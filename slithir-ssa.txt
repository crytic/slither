'npx hardhat clean' running (wd: /home/marce/Work/data-flow/protocols/fusion-protocol)
'npx hardhat clean --global' running (wd: /home/marce/Work/data-flow/protocols/fusion-protocol)
Problem executing hardhat: You are using a version of Node.js that is not supported by Hardhat, and it may work incorrectly, or not work at all.

Please, make sure you are using a supported version of Node.js.

To learn more about which versions of Node.js are supported go to https://hardhat.org/nodejs-versions

'npx hardhat compile --force' running (wd: /home/marce/Work/data-flow/protocols/fusion-protocol)
INFO:Printers:Contract DelegatedShare
	Function ERC20Pods.constructor(uint256,uint256)
		IRs:
			_guard_1(ReentrancyGuardLib.Data) := ϕ(['_guard_0', '_guard_7', '_guard_5', '_guard_3'])
		Expression: podsLimit_ == 0
		IRs:
			TMP_0(bool) = podsLimit__1 == 0
			CONDITION TMP_0
		Expression: revert ZeroPodsLimit()()
		IRs:
			TMP_1(None) = SOLIDITY_CALL revert ZeroPodsLimit()()
		Expression: podsLimit = podsLimit_
		IRs:
			podsLimit_1(uint256) := podsLimit__1(uint256)
		Expression: podCallGasLimit = podCallGasLimit_
		IRs:
			podCallGasLimit_1(uint256) := podCallGasLimit__1(uint256)
		Expression: _guard.init()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.init(ReentrancyGuardLib.Data), arguments:['_guard_1'] 
	Function ERC20Pods.hasPod(address,address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			pod_1(address) := ϕ(['pod_1', 'farm_1'])
			_pods_1(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_9', '_pods_6', '_pods_2', '_pods_0', '_pods_3', '_pods_1'])
		Expression: _pods[account].contains(pod)
		IRs:
			REF_1(AddressSet.Data) -> _pods_1[account_1]
			TMP_3(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.contains(AddressSet.Data,address), arguments:['REF_1', 'pod_1'] 
			RETURN TMP_3
	Function ERC20Pods.podsCount(address)
		IRs:
			_pods_2(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_9', '_pods_6', '_pods_2', '_pods_0', '_pods_3', '_pods_1'])
		Expression: _pods[account].length()
		IRs:
			REF_3(AddressSet.Data) -> _pods_2[account_1]
			TMP_4(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_3'] 
			RETURN TMP_4
	Function ERC20Pods.podAt(address,uint256)
		IRs:
			_pods_3(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_9', '_pods_6', '_pods_2', '_pods_0', '_pods_3', '_pods_1'])
		Expression: _pods[account].at(index)
		IRs:
			REF_5(AddressSet.Data) -> _pods_3[account_1]
			TMP_5(address) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.at(AddressSet.Data,uint256), arguments:['REF_5', 'index_1'] 
			RETURN TMP_5
	Function ERC20Pods.pods(address)
		IRs:
			_pods_4(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_9', '_pods_6', '_pods_2', '_pods_0', '_pods_3', '_pods_1'])
		Expression: _pods[account].items.get()
		IRs:
			REF_7(AddressSet.Data) -> _pods_4[account_1]
			REF_8(AddressArray.Data) -> REF_7.items
			TMP_6(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_8'] 
			RETURN TMP_6
	Function ERC20Pods.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1', 'account_1'])
			_guard_2(ReentrancyGuardLib.Data) := ϕ(['_guard_0', '_guard_7', '_guard_5', '_guard_3'])
		Expression: super.balanceOf(account)
		IRs:
			TMP_7(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_7
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_2)
	Function ERC20Pods.podBalanceOf(address,address)
		IRs:
			_guard_4(ReentrancyGuardLib.Data) := ϕ(['_guard_0', '_guard_7', '_guard_5', '_guard_3'])
		Expression: hasPod(account,pod)
		IRs:
			TMP_9(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,pod_1)
			CONDITION TMP_9
		Expression: super.balanceOf(account)
		IRs:
			TMP_10(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_10
		Expression: 0
		IRs:
			RETURN 0
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_4)
	Function ERC20Pods.addPod(address)
		Expression: _addPod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removePod(address)
		Expression: _removePod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._removePod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removeAllPods()
		Expression: _removeAllPods(msg.sender)
		IRs:
			INTERNAL_CALL, ERC20Pods._removeAllPods(address)(msg.sender)
	Function ERC20Pods._addPod(address,address)
		IRs:
			account_1(address) := ϕ(['account_1', 'msg.sender'])
			pod_1(address) := ϕ(['farm_1', 'pod_1'])
			podsLimit_2(uint256) := ϕ(['podsLimit_0', 'podsLimit_1', 'podsLimit_3'])
			_pods_5(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_9', '_pods_6', '_pods_2', '_pods_0', '_pods_3', '_pods_1'])
		Expression: pod == address(0)
		IRs:
			TMP_15 = CONVERT 0 to address
			TMP_16(bool) = pod_1 == TMP_15
			CONDITION TMP_16
		Expression: revert InvalidPodAddress()()
		IRs:
			TMP_17(None) = SOLIDITY_CALL revert InvalidPodAddress()()
		Expression: IPod(pod).token() != IERC20Pods(address(this))
		IRs:
			TMP_18 = CONVERT pod_1 to IPod
			TMP_19(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_18(IPod), function:token, arguments:[]  
			podsLimit_3(uint256) := ϕ(['podsLimit_2', 'podsLimit_1', 'podsLimit_3'])
			_pods_6(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_9', '_pods_6', '_pods_2', '_pods_5', '_pods_3', '_pods_1'])
			TMP_20 = CONVERT this to address
			TMP_21 = CONVERT TMP_20 to IERC20Pods
			TMP_22(bool) = TMP_19 != TMP_21
			CONDITION TMP_22
		Expression: revert InvalidTokenInPod()()
		IRs:
			TMP_23(None) = SOLIDITY_CALL revert InvalidTokenInPod()()
		Expression: ! _pods[account].add(pod)
		IRs:
			REF_11(AddressSet.Data) -> _pods_6[account_1]
			TMP_24(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.add(AddressSet.Data,address), arguments:['REF_11', 'pod_1'] 
			TMP_25 = UnaryType.BANG TMP_24 
			CONDITION TMP_25
		Expression: revert PodAlreadyAdded()()
		IRs:
			TMP_26(None) = SOLIDITY_CALL revert PodAlreadyAdded()()
		Expression: _pods[account].length() > podsLimit
		IRs:
			REF_13(AddressSet.Data) -> _pods_6[account_1]
			TMP_27(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_13'] 
			TMP_28(bool) = TMP_27 > podsLimit_3
			CONDITION TMP_28
		Expression: revert PodsLimitReachedForAccount()()
		IRs:
			TMP_29(None) = SOLIDITY_CALL revert PodsLimitReachedForAccount()()
		Expression: PodAdded(account,pod)
		IRs:
			Emit PodAdded(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_31(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_31(uint256)
		Expression: balance > 0
		IRs:
			TMP_32(bool) = balance_1 > 0
			CONDITION TMP_32
		Expression: _updateBalances(pod,address(0),account,balance)
		IRs:
			TMP_33 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,TMP_33,account_1,balance_1)
	Function ERC20Pods._removePod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			pod_1(address) := ϕ(['pod_1'])
			_pods_7(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_9', '_pods_6', '_pods_2', '_pods_0', '_pods_3', '_pods_1'])
		Expression: ! _pods[account].remove(pod)
		IRs:
			REF_15(AddressSet.Data) -> _pods_7[account_1]
			TMP_35(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_15', 'pod_1'] 
			TMP_36 = UnaryType.BANG TMP_35 
			CONDITION TMP_36
		Expression: revert PodNotFound()()
		IRs:
			TMP_37(None) = SOLIDITY_CALL revert PodNotFound()()
		Expression: PodRemoved(account,pod)
		IRs:
			Emit PodRemoved(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_39(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_39(uint256)
		Expression: balance > 0
		IRs:
			TMP_40(bool) = balance_1 > 0
			CONDITION TMP_40
		Expression: _updateBalances(pod,account,address(0),balance)
		IRs:
			TMP_41 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,account_1,TMP_41,balance_1)
	Function ERC20Pods._removeAllPods(address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			_pods_8(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_9', '_pods_6', '_pods_2', '_pods_0', '_pods_3', '_pods_1'])
		Expression: items = _pods[account].items.get()
		IRs:
			REF_17(AddressSet.Data) -> _pods_8[account_1]
			REF_18(AddressArray.Data) -> REF_17.items
			TMP_43(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_18'] 
			items_1(address[]) = ['TMP_43(address[])']
		Expression: balance = balanceOf(account)
		IRs:
			TMP_44(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_44(uint256)
		Expression: i = items.length
		IRs:
			REF_20 -> LENGTH items_1
			i_1(uint256) := REF_20(uint256)
		Expression: i > 0
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_45(bool) = i_2 > 0
			CONDITION TMP_45
		Expression: _pods[account].remove(items[i - 1])
		IRs:
			REF_21(AddressSet.Data) -> _pods_9[account_1]
			TMP_46(uint256) = i_2 - 1
			REF_23(address) -> items_1[TMP_46]
			TMP_47(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_21', 'REF_23'] 
		Expression: PodRemoved(account,items[i - 1])
		IRs:
			TMP_48(uint256) = i_2 - 1
			REF_24(address) -> items_1[TMP_48]
			Emit PodRemoved(account_1,REF_24)
		Expression: balance > 0
		IRs:
			TMP_50(bool) = balance_1 > 0
			CONDITION TMP_50
		Expression: _updateBalances(items[i - 1],account,address(0),balance)
		IRs:
			TMP_51(uint256) = i_2 - 1
			REF_25(address) -> items_1[TMP_51]
			TMP_52 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(REF_25,account_1,TMP_52,balance_1)
		Expression: i --
		IRs:
			TMP_54(uint256) := i_2(uint256)
			i_3(uint256) = i_2 - 1
	Function ERC20Pods._updateBalances(address,address,address,uint256)
		IRs:
			pod_1(address) := ϕ(['REF_25', 'pod_1', 'pod_1', 'pod_1', 'pod_scope_1_1'])
			from_1(address) := ϕ(['from_1', 'account_1', 'TMP_33', 'account_1', 'TMP_90'])
			to_1(address) := ϕ(['account_1', 'TMP_84', 'to_1', 'TMP_41', 'TMP_52'])
			amount_1(uint256) := ϕ(['balance_1', 'balance_1', 'balance_1', 'amount_1'])
			podCallGasLimit_2(uint256) := ϕ(['podCallGasLimit_1', 'podCallGasLimit_0'])
		Expression: selector = IPod.updateBalances.selector
		IRs:
			REF_27(bytes4) (->None) := 2048858793(bytes4)
			selector_1(bytes4) := REF_27(bytes4)
		Expression: exception = revert InsufficientGas().selector
		IRs:
			REF_28(bytes4) (->None) := 472281420(bytes4)
			exception_1(bytes4) := REF_28(bytes4)
		Expression: gasLimit = podCallGasLimit
		IRs:
			gasLimit_1(uint256) := podCallGasLimit_2(uint256)
		Expression: ptr__updateBalances_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_55(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr__updateBalances_asm_0_1(uint256) := TMP_55(uint256)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0,selector)
		IRs:
			TMP_56(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr__updateBalances_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x04,from)
		IRs:
			TMP_57(uint256) = ptr__updateBalances_asm_0_1 + 4
			TMP_58(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_57,from_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x24,to)
		IRs:
			TMP_59(uint256) = ptr__updateBalances_asm_0_1 + 36
			TMP_60(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_59,to_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x44,amount)
		IRs:
			TMP_61(uint256) = ptr__updateBalances_asm_0_1 + 68
			TMP_62(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_61,amount_1)
		Expression: gas()() * 63 / 64 < gasLimit
		IRs:
			TMP_63(uint256) = SOLIDITY_CALL gas()()
			TMP_64(uint256) = TMP_63 * 63
			TMP_65(uint256) = TMP_64 / 64
			TMP_66(bool) = TMP_65 < gasLimit_1
			CONDITION TMP_66
		Expression: mstore(uint256,uint256)(0,exception)
		IRs:
			TMP_67(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,exception_1)
		Expression: revert(uint256,uint256)(0,4)
		IRs:
			TMP_68(None) = SOLIDITY_CALL revert(uint256,uint256)(0,4)
		Expression: pop(uint256)(call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit,pod,0,ptr__updateBalances_asm_0,0x64,0,0))
		IRs:
			TMP_69(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit_1,pod_1,0,ptr__updateBalances_asm_0_1,100,0,0)
			TMP_70(None) = SOLIDITY_CALL pop(uint256)(TMP_69)
	Function ERC20Pods._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'TMP_130', 'account_1'])
			to_1(address) := ϕ(['TMP_142', 'to_1', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_guard_6(ReentrancyGuardLib.Data) := ϕ(['_guard_0', '_guard_7', '_guard_5', '_guard_3'])
			_pods_11(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_9', '_pods_6', '_pods_2', '_pods_0', '_pods_3', '_pods_1'])
		Expression: super._afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: amount > 0 && from != to
		IRs:
			TMP_72(bool) = amount_1 > 0
			TMP_73(bool) = from_1 != to_1
			TMP_74(bool) = TMP_72 && TMP_73
			CONDITION TMP_74
		Expression: a = _pods[from].items.get()
		IRs:
			REF_29(AddressSet.Data) -> _pods_13[from_1]
			REF_30(AddressArray.Data) -> REF_29.items
			TMP_75(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_30'] 
			a_1(address[]) = ['TMP_75(address[])']
		Expression: b = _pods[to].items.get()
		IRs:
			REF_32(AddressSet.Data) -> _pods_13[to_1]
			REF_33(AddressArray.Data) -> REF_32.items
			TMP_76(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_33'] 
			b_1(address[]) = ['TMP_76(address[])']
		Expression: aLength = a.length
		IRs:
			REF_35 -> LENGTH a_1
			aLength_1(uint256) := REF_35(uint256)
		Expression: bLength = b.length
		IRs:
			REF_36 -> LENGTH b_1
			bLength_1(uint256) := REF_36(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < aLength
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_77(bool) = i_2 < aLength_1
			CONDITION TMP_77
		Expression: pod = a[i]
		IRs:
			REF_37(address) -> a_1[i_2]
			pod_1(address) := REF_37(address)
		IRs:
			b_3(address[]) := ϕ(['b_2', 'b_1'])
		Expression: j = 0
		IRs:
			j_1(uint256) := 0(uint256)
		Expression: j < bLength
		IRs:
			j_2(uint256) := ϕ(['j_3', 'j_1'])
			TMP_78(bool) = j_2 < bLength_1
			CONDITION TMP_78
		Expression: pod == b[j]
		IRs:
			REF_38(address) -> b_1[j_2]
			TMP_79(bool) = pod_1 == REF_38
			CONDITION TMP_79
		Expression: _updateBalances(pod,from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,to_1,amount_1)
		Expression: b[j] = address(0)
		IRs:
			REF_39(address) -> b_1[j_2]
			TMP_81 = CONVERT 0 to address
			b_2(address[]) := ϕ(['b_1'])
			REF_39(address) (->b_2) := TMP_81(address)
		Expression: j ++
		IRs:
			TMP_82(uint256) := j_2(uint256)
			j_3(uint256) = j_2 + 1
		Expression: j == bLength
		IRs:
			TMP_83(bool) = j_2 == bLength_1
			CONDITION TMP_83
		Expression: _updateBalances(pod,from,address(0),amount)
		IRs:
			TMP_84 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,TMP_84,amount_1)
		Expression: i ++
		IRs:
			TMP_86(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		Expression: j_scope_0 = 0
		IRs:
			j_scope_0_1(uint256) := 0(uint256)
		Expression: j_scope_0 < bLength
		IRs:
			j_scope_0_2(uint256) := ϕ(['j_scope_0_3', 'j_scope_0_1'])
			TMP_87(bool) = j_scope_0_2 < bLength_1
			CONDITION TMP_87
		Expression: pod_scope_1 = b[j_scope_0]
		IRs:
			REF_40(address) -> b_1[j_scope_0_2]
			pod_scope_1_1(address) := REF_40(address)
		Expression: pod_scope_1 != address(0)
		IRs:
			TMP_88 = CONVERT 0 to address
			TMP_89(bool) = pod_scope_1_1 != TMP_88
			CONDITION TMP_89
		Expression: _updateBalances(pod_scope_1,address(0),to,amount)
		IRs:
			TMP_90 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_scope_1_1,TMP_90,to_1,amount_1)
		Expression: j_scope_0 ++
		IRs:
			TMP_92(uint256) := j_scope_0_2(uint256)
			j_scope_0_3(uint256) = j_scope_0_2 + 1
		Expression: nonReentrant(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)(_guard_6)
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_0', '_balances_1', '_balances_11', '_balances_5'])
		Expression: _balances[account]
		IRs:
			REF_41(uint256) -> _balances_1[account_1]
			RETURN REF_41
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_94(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_94(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_1', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_42(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_43(uint256) -> REF_42[spender_1]
			RETURN REF_43
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_96(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_96(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_98(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_98(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_101(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_101(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_102(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_103(uint256) = TMP_102 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_103)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_105(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_105(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_106(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_106(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_107(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_108(None) = SOLIDITY_CALL require(bool,string)(TMP_107,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_109(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_109)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_0', '_balances_1', '_balances_11', '_balances_5'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_111 = CONVERT 0 to address
			TMP_112(bool) = from_1 != TMP_111
			TMP_113(None) = SOLIDITY_CALL require(bool,string)(TMP_112,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_114 = CONVERT 0 to address
			TMP_115(bool) = to_1 != TMP_114
			TMP_116(None) = SOLIDITY_CALL require(bool,string)(TMP_115,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_44(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_44(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_118(bool) = fromBalance_1 >= amount_1
			TMP_119(None) = SOLIDITY_CALL require(bool,string)(TMP_118,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_45(uint256) -> _balances_3[from_1]
			TMP_120(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_45(uint256) (->_balances_4) := TMP_120(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_46(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_46(-> _balances_5) = REF_46 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_0', '_balances_1', '_balances_11', '_balances_5'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_123 = CONVERT 0 to address
			TMP_124(bool) = account_1 != TMP_123
			TMP_125(None) = SOLIDITY_CALL require(bool,string)(TMP_124,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_126 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_126,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_47(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_47(-> _balances_8) = REF_47 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_128 = CONVERT 0 to address
			Emit Transfer(TMP_128,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_130 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(TMP_130,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_0', '_balances_1', '_balances_11', '_balances_5'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_132 = CONVERT 0 to address
			TMP_133(bool) = account_1 != TMP_132
			TMP_134(None) = SOLIDITY_CALL require(bool,string)(TMP_133,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_135 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_135,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_48(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_48(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_137(bool) = accountBalance_1 >= amount_1
			TMP_138(None) = SOLIDITY_CALL require(bool,string)(TMP_137,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_49(uint256) -> _balances_10[account_1]
			TMP_139(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_49(uint256) (->_balances_11) := TMP_139(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_140 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_140,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_142 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(account_1,TMP_142,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_109', 'amount_1', 'TMP_157', 'TMP_103'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_144 = CONVERT 0 to address
			TMP_145(bool) = owner_1 != TMP_144
			TMP_146(None) = SOLIDITY_CALL require(bool,string)(TMP_145,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_147 = CONVERT 0 to address
			TMP_148(bool) = spender_1 != TMP_147
			TMP_149(None) = SOLIDITY_CALL require(bool,string)(TMP_148,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_50(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_51(uint256) -> REF_50[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_51(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_151(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_151(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_153(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_154(bool) = currentAllowance_1 != TMP_153
			CONDITION TMP_154
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_155(bool) = currentAllowance_1 >= amount_1
			TMP_156(None) = SOLIDITY_CALL require(bool,string)(TMP_155,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_157(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_157)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'TMP_126', 'account_1'])
			to_1(address) := ϕ(['TMP_135', 'to_1', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function IDelegatedShare.addDefaultFarmIfNeeded(address,address)
	Function IDelegatedShare.mint(address,uint256)
	Function IDelegatedShare.burn(address,uint256)
	Function DelegatedShare.constructor(string,string,uint256,uint256)
		Expression: _owner = msg.sender
		IRs:
			_owner_1(address) := msg.sender(address)
		Expression: ERC20(name,symbol)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name_1,symbol_1)
		Expression: ERC20Pods(maxUserPods,podCallGasLimit)
		IRs:
			INTERNAL_CALL, ERC20Pods.constructor(uint256,uint256)(maxUserPods_1,podCallGasLimit_1)
	Function DelegatedShare.addDefaultFarmIfNeeded(address,address)
		Expression: ! hasPod(account,farm)
		IRs:
			TMP_161(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,farm_1)
			TMP_162 = UnaryType.BANG TMP_161 
			CONDITION TMP_162
		Expression: _addPod(account,farm)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(account_1,farm_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, DelegatedShare.onlyOwner()()
	Function DelegatedShare.mint(address,uint256)
		Expression: _mint(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, DelegatedShare.onlyOwner()()
	Function DelegatedShare.burn(address,uint256)
		Expression: _burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, DelegatedShare.onlyOwner()()
	Function DelegatedShare.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_169(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegatedShare.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_170(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegatedShare.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_171(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegatedShare.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_172(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegatedShare.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_173(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Modifier ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_6'])
EXPRESSION self.enter()
		Expression: self.enter()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.enter(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
_
EXPRESSION self.exit()
		Expression: self.exit()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.exit(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
	Modifier ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard', '_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_2', '_guard_4'])
IF self.check()
		Expression: self.check()
		IRs:
			TMP_176(bool) = LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.check(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard', '_guard'])"] 
			CONDITION TMP_176
EXPRESSION ReentrancyGuardLib.ReentrantCall()
		Expression: ReentrancyGuardLib.ReentrantCall()
		IRs:
			TMP_177(None) = SOLIDITY_CALL revert ReentrantCall()()
END_IF
_
	Modifier DelegatedShare.onlyOwner()
ENTRY_POINT
		IRs:
			_owner_2(address) := ϕ(['_owner_1', '_owner_0'])
IF msg.sender != _owner
		Expression: msg.sender != _owner
		IRs:
			TMP_178(bool) = msg.sender != _owner_2
			CONDITION TMP_178
EXPRESSION revert NotOwner()()
		Expression: revert NotOwner()()
		IRs:
			TMP_179(None) = SOLIDITY_CALL revert NotOwner()()
END_IF
_
Contract DelegationPod
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_7', '_totalSupply_4', '_totalSupply_0'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_11', '_balances_8', '_balances_0', '_balances_5'])
		Expression: _balances[account]
		IRs:
			REF_55(uint256) -> _balances_1[account_1]
			RETURN REF_55
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_180(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_180(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_1', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_56(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_57(uint256) -> REF_56[spender_1]
			RETURN REF_57
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_182(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_182(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_184(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_184(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_187(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_187(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_188(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_189(uint256) = TMP_188 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_189)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_191(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_191(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_192(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_192(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_193(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_194(None) = SOLIDITY_CALL require(bool,string)(TMP_193,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_195(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_195)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['fromDelegatee_1', 'owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'toDelegatee_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_11', '_balances_8', '_balances_0', '_balances_5'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_197 = CONVERT 0 to address
			TMP_198(bool) = from_1 != TMP_197
			TMP_199(None) = SOLIDITY_CALL require(bool,string)(TMP_198,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_200 = CONVERT 0 to address
			TMP_201(bool) = to_1 != TMP_200
			TMP_202(None) = SOLIDITY_CALL require(bool,string)(TMP_201,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_58(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_58(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_204(bool) = fromBalance_1 >= amount_1
			TMP_205(None) = SOLIDITY_CALL require(bool,string)(TMP_204,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_59(uint256) -> _balances_3[from_1]
			TMP_206(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_59(uint256) (->_balances_4) := TMP_206(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_60(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_60(-> _balances_5) = REF_60 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_11', '_balances_8', '_balances_0', '_balances_5'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_7', '_totalSupply_4', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_209 = CONVERT 0 to address
			TMP_210(bool) = account_1 != TMP_209
			TMP_211(None) = SOLIDITY_CALL require(bool,string)(TMP_210,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_212 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_212,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_61(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_61(-> _balances_8) = REF_61 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_214 = CONVERT 0 to address
			Emit Transfer(TMP_214,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_216 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_216,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['fromDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_11', '_balances_8', '_balances_0', '_balances_5'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_7', '_totalSupply_4', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_218 = CONVERT 0 to address
			TMP_219(bool) = account_1 != TMP_218
			TMP_220(None) = SOLIDITY_CALL require(bool,string)(TMP_219,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_221 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_221,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_62(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_62(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_223(bool) = accountBalance_1 >= amount_1
			TMP_224(None) = SOLIDITY_CALL require(bool,string)(TMP_223,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_63(uint256) -> _balances_10[account_1]
			TMP_225(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_63(uint256) (->_balances_11) := TMP_225(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_226 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_226,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_228 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_228,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_243', 'amount_1', 'TMP_195', 'TMP_189'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_230 = CONVERT 0 to address
			TMP_231(bool) = owner_1 != TMP_230
			TMP_232(None) = SOLIDITY_CALL require(bool,string)(TMP_231,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_233 = CONVERT 0 to address
			TMP_234(bool) = spender_1 != TMP_233
			TMP_235(None) = SOLIDITY_CALL require(bool,string)(TMP_234,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_64(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_65(uint256) -> REF_64[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_65(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_237(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_237(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_239(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_240(bool) = currentAllowance_1 != TMP_239
			CONDITION TMP_240
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_241(bool) = currentAllowance_1 >= amount_1
			TMP_242(None) = SOLIDITY_CALL require(bool,string)(TMP_241,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_243(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_243)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'TMP_212', 'account_1'])
			to_1(address) := ϕ(['to_1', 'TMP_221', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'account_1', 'TMP_216'])
			to_1(address) := ϕ(['to_1', 'account_1', 'TMP_228'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_1(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function DelegationPod.constructor(string,string,IERC20Pods)
		IRs:
			name__1(string) := ϕ(['name__1', 'name__1', 'name__1'])
			symbol__1(string) := ϕ(['symbol__1', 'symbol__1', 'symbol__1'])
			token__1(IERC20Pods) := ϕ(['token__1', 'token__1', 'token__1'])
		Expression: ERC20(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name__1,symbol__1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function DelegationPod.delegate(address)
		IRs:
			token_2(IERC20Pods) := ϕ(['token_3', 'token_0', 'token_1'])
			delegated_1(mapping(address => address)) := ϕ(['delegated_1', 'delegated_0', 'delegated_2', 'delegated_4'])
		Expression: prevDelegatee = delegated[msg.sender]
		IRs:
			REF_66(address) -> delegated_1[msg.sender]
			prevDelegatee_1(address) := REF_66(address)
		Expression: prevDelegatee != delegatee
		IRs:
			TMP_249(bool) = prevDelegatee_1 != delegatee_1
			CONDITION TMP_249
		Expression: delegated[msg.sender] = delegatee
		IRs:
			REF_67(address) -> delegated_1[msg.sender]
			delegated_2(mapping(address => address)) := ϕ(['delegated_1'])
			REF_67(address) (->delegated_2) := delegatee_1(address)
		Expression: Delegated(msg.sender,delegatee)
		IRs:
			Emit Delegated(msg.sender,delegatee_1)
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_251 = CONVERT token_2 to IERC20Pods
			TMP_252 = CONVERT this to address
			TMP_253(uint256) = HIGH_LEVEL_CALL, dest:TMP_251(IERC20Pods), function:podBalanceOf, arguments:['TMP_252', 'msg.sender']  
			token_3(IERC20Pods) := ϕ(['token_3', 'token_1', 'token_2'])
			balance_1(uint256) := TMP_253(uint256)
		Expression: balance > 0
		IRs:
			TMP_254(bool) = balance_1 > 0
			CONDITION TMP_254
		Expression: _updateBalances(msg.sender,msg.sender,prevDelegatee,delegatee,balance)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(msg.sender,msg.sender,prevDelegatee_1,delegatee_1,balance_1)
	Function DelegationPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			delegated_3(mapping(address => address)) := ϕ(['delegated_1', 'delegated_0', 'delegated_2', 'delegated_4'])
		Expression: to == address(0)
		IRs:
			TMP_256 = CONVERT 0 to address
			TMP_257(bool) = to_1 == TMP_256
			CONDITION TMP_257
		Expression: _updateBalances(from,to,address(0),address(0),amount)
		IRs:
			TMP_258 = CONVERT 0 to address
			TMP_259 = CONVERT 0 to address
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,TMP_258,TMP_259,amount_1)
		Expression: _updateBalances(from,to,delegated[from],delegated[to],amount)
		IRs:
			REF_69(address) -> delegated_3[from_1]
			REF_70(address) -> delegated_3[to_1]
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,REF_69,REF_70,amount_1)
	Function DelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			fromDelegatee_1(address) := ϕ(['TMP_258', 'prevDelegatee_1', 'REF_69'])
			toDelegatee_1(address) := ϕ(['delegatee_1', 'REF_70', 'TMP_259'])
			amount_1(uint256) := ϕ(['balance_1', 'amount_1'])
		Expression: fromDelegatee != toDelegatee && amount > 0
		IRs:
			TMP_262(bool) = fromDelegatee_1 != toDelegatee_1
			TMP_263(bool) = amount_1 > 0
			TMP_264(bool) = TMP_262 && TMP_263
			CONDITION TMP_264
		Expression: fromDelegatee == address(0)
		IRs:
			TMP_265 = CONVERT 0 to address
			TMP_266(bool) = fromDelegatee_1 == TMP_265
			CONDITION TMP_266
		Expression: _mint(toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(toDelegatee_1,amount_1)
		Expression: toDelegatee == address(0)
		IRs:
			TMP_268 = CONVERT 0 to address
			TMP_269(bool) = toDelegatee_1 == TMP_268
			CONDITION TMP_269
		Expression: _burn(fromDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(fromDelegatee_1,amount_1)
		Expression: _transfer(fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(fromDelegatee_1,toDelegatee_1,amount_1)
	Function DelegationPod.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_272(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_273(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_274(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_275(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_276(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_4(IERC20Pods) := ϕ(['token_3', 'token_0', 'token_1'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_277 = CONVERT token_4 to address
			TMP_278(bool) = msg.sender != TMP_277
			CONDITION TMP_278
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_279(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract FarmingDelegationPod
	Function TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		Expression: maxSharePods = maxSharePods_
		IRs:
			maxSharePods_1(uint256) := maxSharePods__1(uint256)
		Expression: sharePodGasLimit = sharePodGasLimit_
		IRs:
			sharePodGasLimit_1(uint256) := sharePodGasLimit__1(uint256)
		Expression: DelegationPod(name_,symbol_,token_)
		IRs:
			INTERNAL_CALL, DelegationPod.constructor(string,string,IERC20Pods)(name__1,symbol__1,token__1)
	Function TokenizedDelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			registration_1(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
		Expression: delegatee != address(0) && address(registration[delegatee]) == address(0)
		IRs:
			TMP_281 = CONVERT 0 to address
			TMP_282(bool) = delegatee_1 != TMP_281
			REF_71(IDelegatedShare) -> registration_1[delegatee_1]
			TMP_283 = CONVERT REF_71 to address
			TMP_284 = CONVERT 0 to address
			TMP_285(bool) = TMP_283 == TMP_284
			TMP_286(bool) = TMP_282 && TMP_285
			CONDITION TMP_286
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_287(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, DelegationPod.delegate(address)(delegatee_1)
	Function TokenizedDelegationPod.register(string,string)
		IRs:
			name_1(string) := ϕ(['name_1'])
			symbol_1(string) := ϕ(['symbol_1'])
			maxSharePods_2(uint256) := ϕ(['maxSharePods_1', 'maxSharePods_0', 'maxSharePods_3'])
			sharePodGasLimit_2(uint256) := ϕ(['sharePodGasLimit_3', 'sharePodGasLimit_1', 'sharePodGasLimit_0'])
		Expression: shareToken = new DelegatedShare(name,symbol,maxSharePods,sharePodGasLimit)
		IRs:
			TMP_290(DelegatedShare) = new DelegatedShare(name_1,symbol_1,maxSharePods_3,sharePodGasLimit_3) 
			shareToken_1(IDelegatedShare) := TMP_290(DelegatedShare)
		Expression: registration[msg.sender] = shareToken
		IRs:
			REF_72(IDelegatedShare) -> registration_1[msg.sender]
			registration_2(mapping(address => IDelegatedShare)) := ϕ(['registration_1'])
			REF_72(IDelegatedShare) (->registration_2) := shareToken_1(IDelegatedShare)
		Expression: RegisterDelegatee(msg.sender)
		IRs:
			Emit RegisterDelegatee(msg.sender)
		Expression: onlyNotRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyNotRegistered()()
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'msg.sender'])
			to_1(address) := ϕ(['to_1', 'msg.sender'])
			fromDelegatee_1(address) := ϕ(['prevDelegatee_1', 'REF_80', 'TMP_311'])
			toDelegatee_1(address) := ϕ(['REF_81', 'TMP_312', 'delegatee_1'])
			amount_1(uint256) := ϕ(['balance_1', 'amount_1'])
			registration_3(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
		Expression: super._updateBalances(from,to,fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,fromDelegatee_1,toDelegatee_1,amount_1)
		Expression: fromDelegatee != address(0)
		IRs:
			TMP_294 = CONVERT 0 to address
			TMP_295(bool) = fromDelegatee_1 != TMP_294
			CONDITION TMP_295
		Expression: registration[fromDelegatee].burn(from,amount)
		IRs:
			REF_73(IDelegatedShare) -> registration_4[fromDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_73(IDelegatedShare), function:burn, arguments:['from_1', 'amount_1']  
			registration_5(mapping(address => IDelegatedShare)) := ϕ(['registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
		Expression: toDelegatee != address(0)
		IRs:
			TMP_297 = CONVERT 0 to address
			TMP_298(bool) = toDelegatee_1 != TMP_297
			CONDITION TMP_298
		Expression: registration[toDelegatee].mint(to,amount)
		IRs:
			REF_75(IDelegatedShare) -> registration_5[toDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_75(IDelegatedShare), function:mint, arguments:['to_1', 'amount_1']  
			registration_6(mapping(address => IDelegatedShare)) := ϕ(['registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
	Function DelegationPod.constructor(string,string,IERC20Pods)
		Expression: ERC20(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name__1,symbol__1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function DelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			delegated_1(mapping(address => address)) := ϕ(['delegated_4', 'delegated_2', 'delegated_0', 'delegated_1'])
			token_1(IERC20Pods) := ϕ(['token_2', 'token_3', 'token_0'])
		Expression: prevDelegatee = delegated[msg.sender]
		IRs:
			REF_77(address) -> delegated_1[msg.sender]
			prevDelegatee_1(address) := REF_77(address)
		Expression: prevDelegatee != delegatee
		IRs:
			TMP_302(bool) = prevDelegatee_1 != delegatee_1
			CONDITION TMP_302
		Expression: delegated[msg.sender] = delegatee
		IRs:
			REF_78(address) -> delegated_1[msg.sender]
			delegated_2(mapping(address => address)) := ϕ(['delegated_1'])
			REF_78(address) (->delegated_2) := delegatee_1(address)
		Expression: Delegated(msg.sender,delegatee)
		IRs:
			Emit Delegated(msg.sender,delegatee_1)
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_304 = CONVERT token_1 to IERC20Pods
			TMP_305 = CONVERT this to address
			TMP_306(uint256) = HIGH_LEVEL_CALL, dest:TMP_304(IERC20Pods), function:podBalanceOf, arguments:['TMP_305', 'msg.sender']  
			token_2(IERC20Pods) := ϕ(['token_1', 'token_2', 'token_3'])
			balance_1(uint256) := TMP_306(uint256)
		Expression: balance > 0
		IRs:
			TMP_307(bool) = balance_1 > 0
			CONDITION TMP_307
		Expression: _updateBalances(msg.sender,msg.sender,prevDelegatee,delegatee,balance)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(msg.sender,msg.sender,prevDelegatee_1,delegatee_1,balance_1)
	Function DelegationPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			delegated_3(mapping(address => address)) := ϕ(['delegated_4', 'delegated_2', 'delegated_0', 'delegated_1'])
		Expression: to == address(0)
		IRs:
			TMP_309 = CONVERT 0 to address
			TMP_310(bool) = to_1 == TMP_309
			CONDITION TMP_310
		Expression: _updateBalances(from,to,address(0),address(0),amount)
		IRs:
			TMP_311 = CONVERT 0 to address
			TMP_312 = CONVERT 0 to address
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,TMP_311,TMP_312,amount_1)
		Expression: _updateBalances(from,to,delegated[from],delegated[to],amount)
		IRs:
			REF_80(address) -> delegated_3[from_1]
			REF_81(address) -> delegated_3[to_1]
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,REF_80,REF_81,amount_1)
	Function DelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			fromDelegatee_1(address) := ϕ(['fromDelegatee_1'])
			toDelegatee_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: fromDelegatee != toDelegatee && amount > 0
		IRs:
			TMP_315(bool) = fromDelegatee_1 != toDelegatee_1
			TMP_316(bool) = amount_1 > 0
			TMP_317(bool) = TMP_315 && TMP_316
			CONDITION TMP_317
		Expression: fromDelegatee == address(0)
		IRs:
			TMP_318 = CONVERT 0 to address
			TMP_319(bool) = fromDelegatee_1 == TMP_318
			CONDITION TMP_319
		Expression: _mint(toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(toDelegatee_1,amount_1)
		Expression: toDelegatee == address(0)
		IRs:
			TMP_321 = CONVERT 0 to address
			TMP_322(bool) = toDelegatee_1 == TMP_321
			CONDITION TMP_322
		Expression: _burn(fromDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(fromDelegatee_1,amount_1)
		Expression: _transfer(fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(fromDelegatee_1,toDelegatee_1,amount_1)
	Function DelegationPod.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_325(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_326(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_327(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_328(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_329(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_0', '_balances_1', '_balances_8', '_balances_11'])
		Expression: _balances[account]
		IRs:
			REF_82(uint256) -> _balances_1[account_1]
			RETURN REF_82
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_330(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_330(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_0', '_allowances_1'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_83(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_84(uint256) -> REF_83[spender_1]
			RETURN REF_84
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_332(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_332(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_334(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_334(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_337(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_337(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_338(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_339(uint256) = TMP_338 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_339)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_341(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_341(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_342(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_342(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_343(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_344(None) = SOLIDITY_CALL require(bool,string)(TMP_343,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_345(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_345)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'fromDelegatee_1', 'from_1'])
			to_1(address) := ϕ(['toDelegatee_1', 'to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_0', '_balances_1', '_balances_8', '_balances_11'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_347 = CONVERT 0 to address
			TMP_348(bool) = from_1 != TMP_347
			TMP_349(None) = SOLIDITY_CALL require(bool,string)(TMP_348,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_350 = CONVERT 0 to address
			TMP_351(bool) = to_1 != TMP_350
			TMP_352(None) = SOLIDITY_CALL require(bool,string)(TMP_351,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_85(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_85(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_354(bool) = fromBalance_1 >= amount_1
			TMP_355(None) = SOLIDITY_CALL require(bool,string)(TMP_354,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_86(uint256) -> _balances_3[from_1]
			TMP_356(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_86(uint256) (->_balances_4) := TMP_356(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_87(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_87(-> _balances_5) = REF_87 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_0', '_balances_1', '_balances_8', '_balances_11'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_359 = CONVERT 0 to address
			TMP_360(bool) = account_1 != TMP_359
			TMP_361(None) = SOLIDITY_CALL require(bool,string)(TMP_360,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_362 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_362,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_88(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_88(-> _balances_8) = REF_88 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_364 = CONVERT 0 to address
			Emit Transfer(TMP_364,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_366 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_366,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['fromDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_0', '_balances_1', '_balances_8', '_balances_11'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_368 = CONVERT 0 to address
			TMP_369(bool) = account_1 != TMP_368
			TMP_370(None) = SOLIDITY_CALL require(bool,string)(TMP_369,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_371 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_371,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_89(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_89(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_373(bool) = accountBalance_1 >= amount_1
			TMP_374(None) = SOLIDITY_CALL require(bool,string)(TMP_373,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_90(uint256) -> _balances_10[account_1]
			TMP_375(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_90(uint256) (->_balances_11) := TMP_375(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_376 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_376,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_378 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_378,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_345', 'TMP_393', 'amount_1', 'TMP_339'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_380 = CONVERT 0 to address
			TMP_381(bool) = owner_1 != TMP_380
			TMP_382(None) = SOLIDITY_CALL require(bool,string)(TMP_381,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_383 = CONVERT 0 to address
			TMP_384(bool) = spender_1 != TMP_383
			TMP_385(None) = SOLIDITY_CALL require(bool,string)(TMP_384,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_91(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_92(uint256) -> REF_91[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_92(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_387(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_387(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_389(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_390(bool) = currentAllowance_1 != TMP_389
			CONDITION TMP_390
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_391(bool) = currentAllowance_1 >= amount_1
			TMP_392(None) = SOLIDITY_CALL require(bool,string)(TMP_391,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_393(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_393)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_362', 'account_1', 'from_1'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_371'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_366'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_378'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_3(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
	Function IFarmingDelegationPod.setDefaultFarm(address)
	Function FarmingDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		IRs:
			name__1(string) := ϕ(['name__1'])
			symbol__1(string) := ϕ(['symbol__1'])
			token__1(IERC20Pods) := ϕ(['st1inch_1'])
			maxSharePods__1(uint256) := ϕ(['_MAX_SHARE_PODS_1'])
			sharePodGasLimit__1(uint256) := ϕ(['_SHARE_POD_GAS_LIMIT_1'])
		Expression: TokenizedDelegationPod(name_,symbol_,token_,maxSharePods_,sharePodGasLimit_)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)(name__1,symbol__1,token__1,maxSharePods__1,sharePodGasLimit__1)
	Function FarmingDelegationPod.register(string,string)
		IRs:
			_MAX_FARM_REWARDS_1(uint256) := ϕ(['_MAX_FARM_REWARDS_2', '_MAX_FARM_REWARDS_0'])
		Expression: shareToken = super.register(name,symbol)
		IRs:
			TMP_398(IDelegatedShare) = INTERNAL_CALL, TokenizedDelegationPod.register(string,string)(name_1,symbol_1)
			shareToken_1(IDelegatedShare) := TMP_398(IDelegatedShare)
		Expression: farm = new MultiFarmingPod(shareToken,_MAX_FARM_REWARDS)
		IRs:
			TMP_400(MultiFarmingPod) = new MultiFarmingPod(shareToken_1,_MAX_FARM_REWARDS_2) 
			farm_1(MultiFarmingPod) := TMP_400(MultiFarmingPod)
		Expression: farm.transferOwnership(msg.sender)
		IRs:
			HIGH_LEVEL_CALL, dest:farm_1(MultiFarmingPod), function:transferOwnership, arguments:['msg.sender']  
		Expression: defaultFarms[msg.sender] = address(farm)
		IRs:
			REF_94(address) -> defaultFarms_0[msg.sender]
			TMP_402 = CONVERT farm_1 to address
			defaultFarms_1(mapping(address => address)) := ϕ(['defaultFarms_0'])
			REF_94(address) (->defaultFarms_1) := TMP_402(address)
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function FarmingDelegationPod.delegate(address)
		IRs:
			registration_7(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
			defaultFarms_2(mapping(address => address)) := ϕ(['defaultFarms_1', 'defaultFarms_3', 'defaultFarms_0', 'defaultFarms_4'])
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.delegate(address)(delegatee_1)
			registration_8(mapping(address => IDelegatedShare)) := ϕ(['registration_1'])
		Expression: defaultFarm = defaultFarms[delegatee]
		IRs:
			REF_95(address) -> defaultFarms_3[delegatee_1]
			defaultFarm_1(address) := REF_95(address)
		Expression: defaultFarm != address(0)
		IRs:
			TMP_404 = CONVERT 0 to address
			TMP_405(bool) = defaultFarm_1 != TMP_404
			CONDITION TMP_405
		Expression: registration[delegatee].addDefaultFarmIfNeeded(msg.sender,defaultFarm)
		IRs:
			REF_96(IDelegatedShare) -> registration_8[delegatee_1]
			HIGH_LEVEL_CALL, dest:REF_96(IDelegatedShare), function:addDefaultFarmIfNeeded, arguments:['msg.sender', 'defaultFarm_1']  
			registration_9(mapping(address => IDelegatedShare)) := ϕ(['registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
	Function FarmingDelegationPod.setDefaultFarm(address)
		IRs:
			registration_10(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
		Expression: farm != address(0) && Pod(farm).token() != registration[msg.sender]
		IRs:
			TMP_407 = CONVERT 0 to address
			TMP_408(bool) = farm_1 != TMP_407
			TMP_409 = CONVERT farm_1 to Pod
			TMP_410(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_409(Pod), function:token, arguments:[]  
			registration_12(mapping(address => IDelegatedShare)) := ϕ(['registration_13', 'registration_6', 'registration_11', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
			REF_99(IDelegatedShare) -> registration_12[msg.sender]
			TMP_411(bool) = TMP_410 != REF_99
			TMP_412(bool) = TMP_408 && TMP_411
			CONDITION TMP_412
		Expression: revert DefaultFarmTokenMismatch()()
		IRs:
			TMP_413(None) = SOLIDITY_CALL revert DefaultFarmTokenMismatch()()
		Expression: defaultFarms[msg.sender] = farm
		IRs:
			REF_100(address) -> defaultFarms_3[msg.sender]
			defaultFarms_4(mapping(address => address)) := ϕ(['defaultFarms_3'])
			REF_100(address) (->defaultFarms_4) := farm_1(address)
		Expression: DefaultFarmSet(farm)
		IRs:
			Emit DefaultFarmSet(farm_1)
		Expression: onlyRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyRegistered()()
			registration_11(mapping(address => IDelegatedShare)) := ϕ(['registration_13'])
	Function FarmingDelegationPod.slitherConstructorConstantVariables()
		Expression: _MAX_FARM_REWARDS = 3
	Modifier TokenizedDelegationPod.onlyRegistered()
ENTRY_POINT
		IRs:
			registration_13(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
IF address(registration[msg.sender]) == address(0)
		Expression: address(registration[msg.sender]) == address(0)
		IRs:
			REF_101(IDelegatedShare) -> registration_13[msg.sender]
			TMP_416 = CONVERT REF_101 to address
			TMP_417 = CONVERT 0 to address
			TMP_418(bool) = TMP_416 == TMP_417
			CONDITION TMP_418
EXPRESSION revert NotRegisteredDelegatee()()
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_419(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
END_IF
_
	Modifier TokenizedDelegationPod.onlyNotRegistered()
ENTRY_POINT
		IRs:
			registration_14(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_8', 'registration_1', 'registration_2', 'registration_5', 'registration_12', 'registration_14'])
IF address(registration[msg.sender]) != address(0)
		Expression: address(registration[msg.sender]) != address(0)
		IRs:
			REF_102(IDelegatedShare) -> registration_14[msg.sender]
			TMP_420 = CONVERT REF_102 to address
			TMP_421 = CONVERT 0 to address
			TMP_422(bool) = TMP_420 != TMP_421
			CONDITION TMP_422
EXPRESSION revert AlreadyRegistered()()
		Expression: revert AlreadyRegistered()()
		IRs:
			TMP_423(None) = SOLIDITY_CALL revert AlreadyRegistered()()
END_IF
_
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_4(IERC20Pods) := ϕ(['token_2', 'token_3', 'token_0'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_424 = CONVERT token_4 to address
			TMP_425(bool) = msg.sender != TMP_424
			CONDITION TMP_425
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_426(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract TokenizedDelegationPod
	Function DelegationPod.constructor(string,string,IERC20Pods)
		Expression: ERC20(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name__1,symbol__1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function DelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			delegated_1(mapping(address => address)) := ϕ(['delegated_0', 'delegated_1', 'delegated_4', 'delegated_2'])
			token_1(IERC20Pods) := ϕ(['token_0', 'token_3', 'token_2'])
		Expression: prevDelegatee = delegated[msg.sender]
		IRs:
			REF_103(address) -> delegated_1[msg.sender]
			prevDelegatee_1(address) := REF_103(address)
		Expression: prevDelegatee != delegatee
		IRs:
			TMP_429(bool) = prevDelegatee_1 != delegatee_1
			CONDITION TMP_429
		Expression: delegated[msg.sender] = delegatee
		IRs:
			REF_104(address) -> delegated_1[msg.sender]
			delegated_2(mapping(address => address)) := ϕ(['delegated_1'])
			REF_104(address) (->delegated_2) := delegatee_1(address)
		Expression: Delegated(msg.sender,delegatee)
		IRs:
			Emit Delegated(msg.sender,delegatee_1)
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_431 = CONVERT token_1 to IERC20Pods
			TMP_432 = CONVERT this to address
			TMP_433(uint256) = HIGH_LEVEL_CALL, dest:TMP_431(IERC20Pods), function:podBalanceOf, arguments:['TMP_432', 'msg.sender']  
			token_2(IERC20Pods) := ϕ(['token_3', 'token_1', 'token_2'])
			balance_1(uint256) := TMP_433(uint256)
		Expression: balance > 0
		IRs:
			TMP_434(bool) = balance_1 > 0
			CONDITION TMP_434
		Expression: _updateBalances(msg.sender,msg.sender,prevDelegatee,delegatee,balance)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(msg.sender,msg.sender,prevDelegatee_1,delegatee_1,balance_1)
	Function DelegationPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			delegated_3(mapping(address => address)) := ϕ(['delegated_0', 'delegated_1', 'delegated_4', 'delegated_2'])
		Expression: to == address(0)
		IRs:
			TMP_436 = CONVERT 0 to address
			TMP_437(bool) = to_1 == TMP_436
			CONDITION TMP_437
		Expression: _updateBalances(from,to,address(0),address(0),amount)
		IRs:
			TMP_438 = CONVERT 0 to address
			TMP_439 = CONVERT 0 to address
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,TMP_438,TMP_439,amount_1)
		Expression: _updateBalances(from,to,delegated[from],delegated[to],amount)
		IRs:
			REF_106(address) -> delegated_3[from_1]
			REF_107(address) -> delegated_3[to_1]
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,REF_106,REF_107,amount_1)
	Function DelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			fromDelegatee_1(address) := ϕ(['fromDelegatee_1'])
			toDelegatee_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: fromDelegatee != toDelegatee && amount > 0
		IRs:
			TMP_442(bool) = fromDelegatee_1 != toDelegatee_1
			TMP_443(bool) = amount_1 > 0
			TMP_444(bool) = TMP_442 && TMP_443
			CONDITION TMP_444
		Expression: fromDelegatee == address(0)
		IRs:
			TMP_445 = CONVERT 0 to address
			TMP_446(bool) = fromDelegatee_1 == TMP_445
			CONDITION TMP_446
		Expression: _mint(toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(toDelegatee_1,amount_1)
		Expression: toDelegatee == address(0)
		IRs:
			TMP_448 = CONVERT 0 to address
			TMP_449(bool) = toDelegatee_1 == TMP_448
			CONDITION TMP_449
		Expression: _burn(fromDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(fromDelegatee_1,amount_1)
		Expression: _transfer(fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(fromDelegatee_1,toDelegatee_1,amount_1)
	Function DelegationPod.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_452(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_453(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_454(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_455(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_456(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_0', '_balances_1', '_balances_8'])
		Expression: _balances[account]
		IRs:
			REF_108(uint256) -> _balances_1[account_1]
			RETURN REF_108
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_457(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_457(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_0', '_allowances_2', '_allowances_1'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_109(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_110(uint256) -> REF_109[spender_1]
			RETURN REF_110
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_459(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_459(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_461(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_461(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_464(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_464(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_465(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_466(uint256) = TMP_465 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_466)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_468(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_468(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_469(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_469(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_470(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_471(None) = SOLIDITY_CALL require(bool,string)(TMP_470,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_472(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_472)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['fromDelegatee_1', 'owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'toDelegatee_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_0', '_balances_1', '_balances_8'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_474 = CONVERT 0 to address
			TMP_475(bool) = from_1 != TMP_474
			TMP_476(None) = SOLIDITY_CALL require(bool,string)(TMP_475,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_477 = CONVERT 0 to address
			TMP_478(bool) = to_1 != TMP_477
			TMP_479(None) = SOLIDITY_CALL require(bool,string)(TMP_478,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_111(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_111(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_481(bool) = fromBalance_1 >= amount_1
			TMP_482(None) = SOLIDITY_CALL require(bool,string)(TMP_481,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_112(uint256) -> _balances_3[from_1]
			TMP_483(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_112(uint256) (->_balances_4) := TMP_483(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_113(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_113(-> _balances_5) = REF_113 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_0', '_balances_1', '_balances_8'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_486 = CONVERT 0 to address
			TMP_487(bool) = account_1 != TMP_486
			TMP_488(None) = SOLIDITY_CALL require(bool,string)(TMP_487,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_489 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_489,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_114(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_114(-> _balances_8) = REF_114 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_491 = CONVERT 0 to address
			Emit Transfer(TMP_491,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_493 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_493,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['fromDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_0', '_balances_1', '_balances_8'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_495 = CONVERT 0 to address
			TMP_496(bool) = account_1 != TMP_495
			TMP_497(None) = SOLIDITY_CALL require(bool,string)(TMP_496,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_498 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_498,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_115(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_115(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_500(bool) = accountBalance_1 >= amount_1
			TMP_501(None) = SOLIDITY_CALL require(bool,string)(TMP_500,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_116(uint256) -> _balances_10[account_1]
			TMP_502(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_116(uint256) (->_balances_11) := TMP_502(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_503 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_503,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_505 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_505,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_520', 'TMP_466', 'TMP_472', 'amount_1'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_507 = CONVERT 0 to address
			TMP_508(bool) = owner_1 != TMP_507
			TMP_509(None) = SOLIDITY_CALL require(bool,string)(TMP_508,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_510 = CONVERT 0 to address
			TMP_511(bool) = spender_1 != TMP_510
			TMP_512(None) = SOLIDITY_CALL require(bool,string)(TMP_511,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_117(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_118(uint256) -> REF_117[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_118(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_514(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_514(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_516(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_517(bool) = currentAllowance_1 != TMP_516
			CONDITION TMP_517
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_518(bool) = currentAllowance_1 >= amount_1
			TMP_519(None) = SOLIDITY_CALL require(bool,string)(TMP_518,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_520(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_520)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'TMP_489', 'from_1'])
			to_1(address) := ϕ(['TMP_498', 'account_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'TMP_493', 'from_1'])
			to_1(address) := ϕ(['TMP_505', 'account_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_3(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
	Function TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		IRs:
			name__1(string) := ϕ(['name__1', 'name__1'])
			symbol__1(string) := ϕ(['symbol__1', 'symbol__1'])
			token__1(IERC20Pods) := ϕ(['token__1', 'token__1'])
			maxSharePods__1(uint256) := ϕ(['maxSharePods__1', 'maxSharePods__1'])
			sharePodGasLimit__1(uint256) := ϕ(['sharePodGasLimit__1', 'sharePodGasLimit__1'])
		Expression: maxSharePods = maxSharePods_
		IRs:
			maxSharePods_1(uint256) := maxSharePods__1(uint256)
		Expression: sharePodGasLimit = sharePodGasLimit_
		IRs:
			sharePodGasLimit_1(uint256) := sharePodGasLimit__1(uint256)
		Expression: DelegationPod(name_,symbol_,token_)
		IRs:
			INTERNAL_CALL, DelegationPod.constructor(string,string,IERC20Pods)(name__1,symbol__1,token__1)
	Function TokenizedDelegationPod.delegate(address)
		IRs:
			registration_1(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_0', 'registration_1', 'registration_4', 'registration_2', 'registration_7', 'registration_5'])
		Expression: delegatee != address(0) && address(registration[delegatee]) == address(0)
		IRs:
			TMP_525 = CONVERT 0 to address
			TMP_526(bool) = delegatee_1 != TMP_525
			REF_119(IDelegatedShare) -> registration_1[delegatee_1]
			TMP_527 = CONVERT REF_119 to address
			TMP_528 = CONVERT 0 to address
			TMP_529(bool) = TMP_527 == TMP_528
			TMP_530(bool) = TMP_526 && TMP_529
			CONDITION TMP_530
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_531(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, DelegationPod.delegate(address)(delegatee_1)
	Function TokenizedDelegationPod.register(string,string)
		IRs:
			maxSharePods_2(uint256) := ϕ(['maxSharePods_1', 'maxSharePods_3', 'maxSharePods_0'])
			sharePodGasLimit_2(uint256) := ϕ(['sharePodGasLimit_1', 'sharePodGasLimit_3', 'sharePodGasLimit_0'])
		Expression: shareToken = new DelegatedShare(name,symbol,maxSharePods,sharePodGasLimit)
		IRs:
			TMP_534(DelegatedShare) = new DelegatedShare(name_1,symbol_1,maxSharePods_3,sharePodGasLimit_3) 
			shareToken_1(IDelegatedShare) := TMP_534(DelegatedShare)
		Expression: registration[msg.sender] = shareToken
		IRs:
			REF_120(IDelegatedShare) -> registration_1[msg.sender]
			registration_2(mapping(address => IDelegatedShare)) := ϕ(['registration_1'])
			REF_120(IDelegatedShare) (->registration_2) := shareToken_1(IDelegatedShare)
		Expression: RegisterDelegatee(msg.sender)
		IRs:
			Emit RegisterDelegatee(msg.sender)
		Expression: onlyNotRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyNotRegistered()()
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'msg.sender'])
			to_1(address) := ϕ(['to_1', 'msg.sender'])
			fromDelegatee_1(address) := ϕ(['TMP_438', 'prevDelegatee_1', 'REF_106'])
			toDelegatee_1(address) := ϕ(['delegatee_1', 'REF_107', 'TMP_439'])
			amount_1(uint256) := ϕ(['amount_1', 'balance_1'])
			registration_3(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_0', 'registration_1', 'registration_4', 'registration_2', 'registration_7', 'registration_5'])
		Expression: super._updateBalances(from,to,fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,fromDelegatee_1,toDelegatee_1,amount_1)
		Expression: fromDelegatee != address(0)
		IRs:
			TMP_538 = CONVERT 0 to address
			TMP_539(bool) = fromDelegatee_1 != TMP_538
			CONDITION TMP_539
		Expression: registration[fromDelegatee].burn(from,amount)
		IRs:
			REF_121(IDelegatedShare) -> registration_4[fromDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_121(IDelegatedShare), function:burn, arguments:['from_1', 'amount_1']  
			registration_5(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_1', 'registration_4', 'registration_2', 'registration_7', 'registration_5'])
		Expression: toDelegatee != address(0)
		IRs:
			TMP_541 = CONVERT 0 to address
			TMP_542(bool) = toDelegatee_1 != TMP_541
			CONDITION TMP_542
		Expression: registration[toDelegatee].mint(to,amount)
		IRs:
			REF_123(IDelegatedShare) -> registration_5[toDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_123(IDelegatedShare), function:mint, arguments:['to_1', 'amount_1']  
			registration_6(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_1', 'registration_4', 'registration_2', 'registration_7', 'registration_5'])
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_4(IERC20Pods) := ϕ(['token_0', 'token_3', 'token_2'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_544 = CONVERT token_4 to address
			TMP_545(bool) = msg.sender != TMP_544
			CONDITION TMP_545
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_546(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
	Modifier TokenizedDelegationPod.onlyRegistered()
ENTRY_POINT
		IRs:
			registration_7(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_0', 'registration_1', 'registration_4', 'registration_2', 'registration_7', 'registration_5'])
IF address(registration[msg.sender]) == address(0)
		Expression: address(registration[msg.sender]) == address(0)
		IRs:
			REF_125(IDelegatedShare) -> registration_7[msg.sender]
			TMP_547 = CONVERT REF_125 to address
			TMP_548 = CONVERT 0 to address
			TMP_549(bool) = TMP_547 == TMP_548
			CONDITION TMP_549
EXPRESSION revert NotRegisteredDelegatee()()
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_550(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
END_IF
_
	Modifier TokenizedDelegationPod.onlyNotRegistered()
ENTRY_POINT
		IRs:
			registration_8(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_0', 'registration_1', 'registration_4', 'registration_2', 'registration_7', 'registration_5'])
IF address(registration[msg.sender]) != address(0)
		Expression: address(registration[msg.sender]) != address(0)
		IRs:
			REF_126(IDelegatedShare) -> registration_8[msg.sender]
			TMP_551 = CONVERT REF_126 to address
			TMP_552 = CONVERT 0 to address
			TMP_553(bool) = TMP_551 != TMP_552
			CONDITION TMP_553
EXPRESSION revert AlreadyRegistered()()
		Expression: revert AlreadyRegistered()()
		IRs:
			TMP_554(None) = SOLIDITY_CALL revert AlreadyRegistered()()
END_IF
_
Contract IDelegatedShare
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IDelegatedShare.addDefaultFarmIfNeeded(address,address)
	Function IDelegatedShare.mint(address,uint256)
	Function IDelegatedShare.burn(address,uint256)
Contract IDelegationPod
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
Contract IFarmingDelegationPod
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IFarmingDelegationPod.setDefaultFarm(address)
Contract ITokenizedDelegationPod
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
Contract ERC20Pods
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: _balances[account]
		IRs:
			REF_127(uint256) -> _balances_1[account_1]
			RETURN REF_127
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_555(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_555(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1', '_allowances_0', '_allowances_2'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_128(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_129(uint256) -> REF_128[spender_1]
			RETURN REF_129
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_557(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_557(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_559(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_559(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_562(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_562(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_563(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_564(uint256) = TMP_563 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_564)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_566(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_566(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_567(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_567(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_568(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_569(None) = SOLIDITY_CALL require(bool,string)(TMP_568,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_570(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_570)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_572 = CONVERT 0 to address
			TMP_573(bool) = from_1 != TMP_572
			TMP_574(None) = SOLIDITY_CALL require(bool,string)(TMP_573,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_575 = CONVERT 0 to address
			TMP_576(bool) = to_1 != TMP_575
			TMP_577(None) = SOLIDITY_CALL require(bool,string)(TMP_576,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_130(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_130(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_579(bool) = fromBalance_1 >= amount_1
			TMP_580(None) = SOLIDITY_CALL require(bool,string)(TMP_579,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_131(uint256) -> _balances_3[from_1]
			TMP_581(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_131(uint256) (->_balances_4) := TMP_581(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_132(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_132(-> _balances_5) = REF_132 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_584 = CONVERT 0 to address
			TMP_585(bool) = account_1 != TMP_584
			TMP_586(None) = SOLIDITY_CALL require(bool,string)(TMP_585,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_587 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_587,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_133(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_133(-> _balances_8) = REF_133 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_589 = CONVERT 0 to address
			Emit Transfer(TMP_589,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_591 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(TMP_591,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_593 = CONVERT 0 to address
			TMP_594(bool) = account_1 != TMP_593
			TMP_595(None) = SOLIDITY_CALL require(bool,string)(TMP_594,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_596 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_596,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_134(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_134(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_598(bool) = accountBalance_1 >= amount_1
			TMP_599(None) = SOLIDITY_CALL require(bool,string)(TMP_598,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_135(uint256) -> _balances_10[account_1]
			TMP_600(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_135(uint256) (->_balances_11) := TMP_600(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_601 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_601,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_603 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(account_1,TMP_603,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_564', 'amount_1', 'TMP_570', 'TMP_618'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_605 = CONVERT 0 to address
			TMP_606(bool) = owner_1 != TMP_605
			TMP_607(None) = SOLIDITY_CALL require(bool,string)(TMP_606,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_608 = CONVERT 0 to address
			TMP_609(bool) = spender_1 != TMP_608
			TMP_610(None) = SOLIDITY_CALL require(bool,string)(TMP_609,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_136(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_137(uint256) -> REF_136[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_137(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_612(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_612(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_614(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_615(bool) = currentAllowance_1 != TMP_614
			CONDITION TMP_615
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_616(bool) = currentAllowance_1 >= amount_1
			TMP_617(None) = SOLIDITY_CALL require(bool,string)(TMP_616,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_618(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_618)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'TMP_587', 'from_1'])
			to_1(address) := ϕ(['TMP_596', 'account_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20Pods.constructor(uint256,uint256)
		IRs:
			podsLimit__1(uint256) := ϕ(['maxUserPods_1'])
			podCallGasLimit__1(uint256) := ϕ(['podCallGasLimit_1'])
			_guard_1(ReentrancyGuardLib.Data) := ϕ(['_guard_5', '_guard_7', '_guard_3', '_guard_0'])
		Expression: podsLimit_ == 0
		IRs:
			TMP_620(bool) = podsLimit__1 == 0
			CONDITION TMP_620
		Expression: revert ZeroPodsLimit()()
		IRs:
			TMP_621(None) = SOLIDITY_CALL revert ZeroPodsLimit()()
		Expression: podsLimit = podsLimit_
		IRs:
			podsLimit_1(uint256) := podsLimit__1(uint256)
		Expression: podCallGasLimit = podCallGasLimit_
		IRs:
			podCallGasLimit_1(uint256) := podCallGasLimit__1(uint256)
		Expression: _guard.init()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.init(ReentrancyGuardLib.Data), arguments:['_guard_1'] 
	Function ERC20Pods.hasPod(address,address)
		IRs:
			account_1(address) := ϕ(['account_1'])
			pod_1(address) := ϕ(['pod_1'])
			_pods_1(mapping(address => AddressSet.Data)) := ϕ(['_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_3', '_pods_7', '_pods_1', '_pods_0', '_pods_13'])
		Expression: _pods[account].contains(pod)
		IRs:
			REF_139(AddressSet.Data) -> _pods_1[account_1]
			TMP_623(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.contains(AddressSet.Data,address), arguments:['REF_139', 'pod_1'] 
			RETURN TMP_623
	Function ERC20Pods.podsCount(address)
		IRs:
			_pods_2(mapping(address => AddressSet.Data)) := ϕ(['_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_3', '_pods_7', '_pods_1', '_pods_0', '_pods_13'])
		Expression: _pods[account].length()
		IRs:
			REF_141(AddressSet.Data) -> _pods_2[account_1]
			TMP_624(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_141'] 
			RETURN TMP_624
	Function ERC20Pods.podAt(address,uint256)
		IRs:
			_pods_3(mapping(address => AddressSet.Data)) := ϕ(['_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_3', '_pods_7', '_pods_1', '_pods_0', '_pods_13'])
		Expression: _pods[account].at(index)
		IRs:
			REF_143(AddressSet.Data) -> _pods_3[account_1]
			TMP_625(address) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.at(AddressSet.Data,uint256), arguments:['REF_143', 'index_1'] 
			RETURN TMP_625
	Function ERC20Pods.pods(address)
		IRs:
			_pods_4(mapping(address => AddressSet.Data)) := ϕ(['_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_3', '_pods_7', '_pods_1', '_pods_0', '_pods_13'])
		Expression: _pods[account].items.get()
		IRs:
			REF_145(AddressSet.Data) -> _pods_4[account_1]
			REF_146(AddressArray.Data) -> REF_145.items
			TMP_626(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_146'] 
			RETURN TMP_626
	Function ERC20Pods.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1', 'account_1'])
			_guard_2(ReentrancyGuardLib.Data) := ϕ(['_guard_5', '_guard_7', '_guard_3', '_guard_0'])
		Expression: super.balanceOf(account)
		IRs:
			TMP_627(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_627
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_2)
	Function ERC20Pods.podBalanceOf(address,address)
		IRs:
			_guard_4(ReentrancyGuardLib.Data) := ϕ(['_guard_5', '_guard_7', '_guard_3', '_guard_0'])
		Expression: hasPod(account,pod)
		IRs:
			TMP_629(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,pod_1)
			CONDITION TMP_629
		Expression: super.balanceOf(account)
		IRs:
			TMP_630(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_630
		Expression: 0
		IRs:
			RETURN 0
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_4)
	Function ERC20Pods.addPod(address)
		Expression: _addPod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removePod(address)
		Expression: _removePod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._removePod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removeAllPods()
		Expression: _removeAllPods(msg.sender)
		IRs:
			INTERNAL_CALL, ERC20Pods._removeAllPods(address)(msg.sender)
	Function ERC20Pods._addPod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			pod_1(address) := ϕ(['pod_1'])
			podsLimit_2(uint256) := ϕ(['podsLimit_0', 'podsLimit_1', 'podsLimit_3'])
			_pods_5(mapping(address => AddressSet.Data)) := ϕ(['_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_3', '_pods_7', '_pods_1', '_pods_0', '_pods_13'])
		Expression: pod == address(0)
		IRs:
			TMP_635 = CONVERT 0 to address
			TMP_636(bool) = pod_1 == TMP_635
			CONDITION TMP_636
		Expression: revert InvalidPodAddress()()
		IRs:
			TMP_637(None) = SOLIDITY_CALL revert InvalidPodAddress()()
		Expression: IPod(pod).token() != IERC20Pods(address(this))
		IRs:
			TMP_638 = CONVERT pod_1 to IPod
			TMP_639(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_638(IPod), function:token, arguments:[]  
			podsLimit_3(uint256) := ϕ(['podsLimit_1', 'podsLimit_3', 'podsLimit_2'])
			_pods_6(mapping(address => AddressSet.Data)) := ϕ(['_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_5', '_pods_3', '_pods_7', '_pods_1', '_pods_13'])
			TMP_640 = CONVERT this to address
			TMP_641 = CONVERT TMP_640 to IERC20Pods
			TMP_642(bool) = TMP_639 != TMP_641
			CONDITION TMP_642
		Expression: revert InvalidTokenInPod()()
		IRs:
			TMP_643(None) = SOLIDITY_CALL revert InvalidTokenInPod()()
		Expression: ! _pods[account].add(pod)
		IRs:
			REF_149(AddressSet.Data) -> _pods_6[account_1]
			TMP_644(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.add(AddressSet.Data,address), arguments:['REF_149', 'pod_1'] 
			TMP_645 = UnaryType.BANG TMP_644 
			CONDITION TMP_645
		Expression: revert PodAlreadyAdded()()
		IRs:
			TMP_646(None) = SOLIDITY_CALL revert PodAlreadyAdded()()
		Expression: _pods[account].length() > podsLimit
		IRs:
			REF_151(AddressSet.Data) -> _pods_6[account_1]
			TMP_647(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_151'] 
			TMP_648(bool) = TMP_647 > podsLimit_3
			CONDITION TMP_648
		Expression: revert PodsLimitReachedForAccount()()
		IRs:
			TMP_649(None) = SOLIDITY_CALL revert PodsLimitReachedForAccount()()
		Expression: PodAdded(account,pod)
		IRs:
			Emit PodAdded(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_651(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_651(uint256)
		Expression: balance > 0
		IRs:
			TMP_652(bool) = balance_1 > 0
			CONDITION TMP_652
		Expression: _updateBalances(pod,address(0),account,balance)
		IRs:
			TMP_653 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,TMP_653,account_1,balance_1)
	Function ERC20Pods._removePod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			pod_1(address) := ϕ(['pod_1'])
			_pods_7(mapping(address => AddressSet.Data)) := ϕ(['_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_3', '_pods_7', '_pods_1', '_pods_0', '_pods_13'])
		Expression: ! _pods[account].remove(pod)
		IRs:
			REF_153(AddressSet.Data) -> _pods_7[account_1]
			TMP_655(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_153', 'pod_1'] 
			TMP_656 = UnaryType.BANG TMP_655 
			CONDITION TMP_656
		Expression: revert PodNotFound()()
		IRs:
			TMP_657(None) = SOLIDITY_CALL revert PodNotFound()()
		Expression: PodRemoved(account,pod)
		IRs:
			Emit PodRemoved(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_659(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_659(uint256)
		Expression: balance > 0
		IRs:
			TMP_660(bool) = balance_1 > 0
			CONDITION TMP_660
		Expression: _updateBalances(pod,account,address(0),balance)
		IRs:
			TMP_661 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,account_1,TMP_661,balance_1)
	Function ERC20Pods._removeAllPods(address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			_pods_8(mapping(address => AddressSet.Data)) := ϕ(['_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_3', '_pods_7', '_pods_1', '_pods_0', '_pods_13'])
		Expression: items = _pods[account].items.get()
		IRs:
			REF_155(AddressSet.Data) -> _pods_8[account_1]
			REF_156(AddressArray.Data) -> REF_155.items
			TMP_663(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_156'] 
			items_1(address[]) = ['TMP_663(address[])']
		Expression: balance = balanceOf(account)
		IRs:
			TMP_664(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_664(uint256)
		Expression: i = items.length
		IRs:
			REF_158 -> LENGTH items_1
			i_1(uint256) := REF_158(uint256)
		Expression: i > 0
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_665(bool) = i_2 > 0
			CONDITION TMP_665
		Expression: _pods[account].remove(items[i - 1])
		IRs:
			REF_159(AddressSet.Data) -> _pods_9[account_1]
			TMP_666(uint256) = i_2 - 1
			REF_161(address) -> items_1[TMP_666]
			TMP_667(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_159', 'REF_161'] 
		Expression: PodRemoved(account,items[i - 1])
		IRs:
			TMP_668(uint256) = i_2 - 1
			REF_162(address) -> items_1[TMP_668]
			Emit PodRemoved(account_1,REF_162)
		Expression: balance > 0
		IRs:
			TMP_670(bool) = balance_1 > 0
			CONDITION TMP_670
		Expression: _updateBalances(items[i - 1],account,address(0),balance)
		IRs:
			TMP_671(uint256) = i_2 - 1
			REF_163(address) -> items_1[TMP_671]
			TMP_672 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(REF_163,account_1,TMP_672,balance_1)
		Expression: i --
		IRs:
			TMP_674(uint256) := i_2(uint256)
			i_3(uint256) = i_2 - 1
	Function ERC20Pods._updateBalances(address,address,address,uint256)
		IRs:
			pod_1(address) := ϕ(['pod_1', 'pod_1', 'REF_163', 'pod_1', 'pod_scope_1_1'])
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_710', 'account_1', 'TMP_653'])
			to_1(address) := ϕ(['TMP_661', 'to_1', 'TMP_704', 'account_1', 'TMP_672'])
			amount_1(uint256) := ϕ(['balance_1', 'amount_1', 'balance_1', 'balance_1'])
			podCallGasLimit_2(uint256) := ϕ(['podCallGasLimit_0', 'podCallGasLimit_1'])
		Expression: selector = IPod.updateBalances.selector
		IRs:
			REF_165(bytes4) (->None) := 2048858793(bytes4)
			selector_1(bytes4) := REF_165(bytes4)
		Expression: exception = revert InsufficientGas().selector
		IRs:
			REF_166(bytes4) (->None) := 472281420(bytes4)
			exception_1(bytes4) := REF_166(bytes4)
		Expression: gasLimit = podCallGasLimit
		IRs:
			gasLimit_1(uint256) := podCallGasLimit_2(uint256)
		Expression: ptr__updateBalances_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_675(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr__updateBalances_asm_0_1(uint256) := TMP_675(uint256)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0,selector)
		IRs:
			TMP_676(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr__updateBalances_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x04,from)
		IRs:
			TMP_677(uint256) = ptr__updateBalances_asm_0_1 + 4
			TMP_678(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_677,from_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x24,to)
		IRs:
			TMP_679(uint256) = ptr__updateBalances_asm_0_1 + 36
			TMP_680(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_679,to_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x44,amount)
		IRs:
			TMP_681(uint256) = ptr__updateBalances_asm_0_1 + 68
			TMP_682(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_681,amount_1)
		Expression: gas()() * 63 / 64 < gasLimit
		IRs:
			TMP_683(uint256) = SOLIDITY_CALL gas()()
			TMP_684(uint256) = TMP_683 * 63
			TMP_685(uint256) = TMP_684 / 64
			TMP_686(bool) = TMP_685 < gasLimit_1
			CONDITION TMP_686
		Expression: mstore(uint256,uint256)(0,exception)
		IRs:
			TMP_687(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,exception_1)
		Expression: revert(uint256,uint256)(0,4)
		IRs:
			TMP_688(None) = SOLIDITY_CALL revert(uint256,uint256)(0,4)
		Expression: pop(uint256)(call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit,pod,0,ptr__updateBalances_asm_0,0x64,0,0))
		IRs:
			TMP_689(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit_1,pod_1,0,ptr__updateBalances_asm_0_1,100,0,0)
			TMP_690(None) = SOLIDITY_CALL pop(uint256)(TMP_689)
	Function ERC20Pods._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'TMP_591', 'from_1'])
			to_1(address) := ϕ(['account_1', 'TMP_603', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_guard_6(ReentrancyGuardLib.Data) := ϕ(['_guard_5', '_guard_7', '_guard_3', '_guard_0'])
			_pods_11(mapping(address => AddressSet.Data)) := ϕ(['_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_3', '_pods_7', '_pods_1', '_pods_0', '_pods_13'])
		Expression: super._afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: amount > 0 && from != to
		IRs:
			TMP_692(bool) = amount_1 > 0
			TMP_693(bool) = from_1 != to_1
			TMP_694(bool) = TMP_692 && TMP_693
			CONDITION TMP_694
		Expression: a = _pods[from].items.get()
		IRs:
			REF_167(AddressSet.Data) -> _pods_13[from_1]
			REF_168(AddressArray.Data) -> REF_167.items
			TMP_695(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_168'] 
			a_1(address[]) = ['TMP_695(address[])']
		Expression: b = _pods[to].items.get()
		IRs:
			REF_170(AddressSet.Data) -> _pods_13[to_1]
			REF_171(AddressArray.Data) -> REF_170.items
			TMP_696(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_171'] 
			b_1(address[]) = ['TMP_696(address[])']
		Expression: aLength = a.length
		IRs:
			REF_173 -> LENGTH a_1
			aLength_1(uint256) := REF_173(uint256)
		Expression: bLength = b.length
		IRs:
			REF_174 -> LENGTH b_1
			bLength_1(uint256) := REF_174(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < aLength
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_697(bool) = i_2 < aLength_1
			CONDITION TMP_697
		Expression: pod = a[i]
		IRs:
			REF_175(address) -> a_1[i_2]
			pod_1(address) := REF_175(address)
		IRs:
			b_3(address[]) := ϕ(['b_1', 'b_2'])
		Expression: j = 0
		IRs:
			j_1(uint256) := 0(uint256)
		Expression: j < bLength
		IRs:
			j_2(uint256) := ϕ(['j_1', 'j_3'])
			TMP_698(bool) = j_2 < bLength_1
			CONDITION TMP_698
		Expression: pod == b[j]
		IRs:
			REF_176(address) -> b_1[j_2]
			TMP_699(bool) = pod_1 == REF_176
			CONDITION TMP_699
		Expression: _updateBalances(pod,from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,to_1,amount_1)
		Expression: b[j] = address(0)
		IRs:
			REF_177(address) -> b_1[j_2]
			TMP_701 = CONVERT 0 to address
			b_2(address[]) := ϕ(['b_1'])
			REF_177(address) (->b_2) := TMP_701(address)
		Expression: j ++
		IRs:
			TMP_702(uint256) := j_2(uint256)
			j_3(uint256) = j_2 + 1
		Expression: j == bLength
		IRs:
			TMP_703(bool) = j_2 == bLength_1
			CONDITION TMP_703
		Expression: _updateBalances(pod,from,address(0),amount)
		IRs:
			TMP_704 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,TMP_704,amount_1)
		Expression: i ++
		IRs:
			TMP_706(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		Expression: j_scope_0 = 0
		IRs:
			j_scope_0_1(uint256) := 0(uint256)
		Expression: j_scope_0 < bLength
		IRs:
			j_scope_0_2(uint256) := ϕ(['j_scope_0_1', 'j_scope_0_3'])
			TMP_707(bool) = j_scope_0_2 < bLength_1
			CONDITION TMP_707
		Expression: pod_scope_1 = b[j_scope_0]
		IRs:
			REF_178(address) -> b_1[j_scope_0_2]
			pod_scope_1_1(address) := REF_178(address)
		Expression: pod_scope_1 != address(0)
		IRs:
			TMP_708 = CONVERT 0 to address
			TMP_709(bool) = pod_scope_1_1 != TMP_708
			CONDITION TMP_709
		Expression: _updateBalances(pod_scope_1,address(0),to,amount)
		IRs:
			TMP_710 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_scope_1_1,TMP_710,to_1,amount_1)
		Expression: j_scope_0 ++
		IRs:
			TMP_712(uint256) := j_scope_0_2(uint256)
			j_scope_0_3(uint256) = j_scope_0_2 + 1
		Expression: nonReentrant(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)(_guard_6)
	Modifier ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_6'])
EXPRESSION self.enter()
		Expression: self.enter()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.enter(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
_
EXPRESSION self.exit()
		Expression: self.exit()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.exit(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
	Modifier ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard', '_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_2', '_guard_4'])
IF self.check()
		Expression: self.check()
		IRs:
			TMP_716(bool) = LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.check(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard', '_guard'])"] 
			CONDITION TMP_716
EXPRESSION ReentrancyGuardLib.ReentrantCall()
		Expression: ReentrancyGuardLib.ReentrantCall()
		IRs:
			TMP_717(None) = SOLIDITY_CALL revert ReentrantCall()()
END_IF
_
Contract Pod
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function Pod.constructor(IERC20Pods)
		IRs:
			token__1(IERC20Pods) := ϕ(['farmableToken__1', 'token__1', 'token__1', 'token__1', 'token__1'])
		Expression: token = token_
		IRs:
			token_1(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, Pod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_2(IERC20Pods) := ϕ(['token_1', 'token_0'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_720 = CONVERT token_2 to address
			TMP_721(bool) = msg.sender != TMP_720
			CONDITION TMP_721
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_722(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract IERC20Pods
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
Contract IPod
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
Contract ReentrancyGuardLib
	Function ReentrancyGuardLib.init(ReentrancyGuardLib.Data)
		IRs:
			_NOT_ENTERED_1(uint256) := ϕ(['_NOT_ENTERED_0'])
		Expression: self._status = _NOT_ENTERED
		IRs:
			REF_182(uint256) -> self_1 (-> [])._status
			self_2 (-> [])(ReentrancyGuardLib.Data) := ϕ(['self_1 (-> [])'])
			REF_182(uint256) (->self_2 (-> [])) := _NOT_ENTERED_1(uint256)
	Function ReentrancyGuardLib.enter(ReentrancyGuardLib.Data)
		IRs:
			_ENTERED_1(uint256) := ϕ(['_ENTERED_0'])
		Expression: self._status == _ENTERED
		IRs:
			REF_183(uint256) -> self_1 (-> [])._status
			TMP_723(bool) = REF_183 == _ENTERED_1
			CONDITION TMP_723
		Expression: revert ReentrantCall()()
		IRs:
			TMP_724(None) = SOLIDITY_CALL revert ReentrantCall()()
		Expression: self._status = _ENTERED
		IRs:
			REF_184(uint256) -> self_1 (-> [])._status
			self_2 (-> [])(ReentrancyGuardLib.Data) := ϕ(['self_1 (-> [])'])
			REF_184(uint256) (->self_2 (-> [])) := _ENTERED_1(uint256)
	Function ReentrancyGuardLib.exit(ReentrancyGuardLib.Data)
		IRs:
			_NOT_ENTERED_2(uint256) := ϕ(['_NOT_ENTERED_0'])
		Expression: self._status = _NOT_ENTERED
		IRs:
			REF_185(uint256) -> self_1 (-> [])._status
			self_2 (-> [])(ReentrancyGuardLib.Data) := ϕ(['self_1 (-> [])'])
			REF_185(uint256) (->self_2 (-> [])) := _NOT_ENTERED_2(uint256)
	Function ReentrancyGuardLib.check(ReentrancyGuardLib.Data)
		IRs:
			_ENTERED_2(uint256) := ϕ(['_ENTERED_0'])
		Expression: self._status == _ENTERED
		IRs:
			REF_186(uint256) -> self_1 (-> [])._status
			TMP_725(bool) = REF_186 == _ENTERED_2
			RETURN TMP_725
	Function ReentrancyGuardLib.slitherConstructorConstantVariables()
		Expression: _NOT_ENTERED = 1
		Expression: _ENTERED = 2
Contract ReentrancyGuardExt
	Modifier ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)
ENTRY_POINT
EXPRESSION self.enter()
		Expression: self.enter()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.enter(ReentrancyGuardLib.Data), arguments:['self_1 (-> [])'] 
_
EXPRESSION self.exit()
		Expression: self.exit()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.exit(ReentrancyGuardLib.Data), arguments:['self_1 (-> [])'] 
	Modifier ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)
ENTRY_POINT
IF self.check()
		Expression: self.check()
		IRs:
			TMP_728(bool) = LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.check(ReentrancyGuardLib.Data), arguments:['self_1 (-> [])'] 
			CONDITION TMP_728
EXPRESSION ReentrancyGuardLib.ReentrantCall()
		Expression: ReentrancyGuardLib.ReentrantCall()
		IRs:
			TMP_729(None) = SOLIDITY_CALL revert ReentrantCall()()
END_IF
_
Contract FarmingLib
	Function FarmingLib.makeInfo(function() returns(uint256),FarmingLib.Data)
		Expression: info.getTotalSupply = getTotalSupply
		IRs:
			REF_190(function() returns(uint256)) -> info_0.getTotalSupply
			info_1(FarmingLib.Info) := ϕ(['info_0'])
			REF_190(function() returns(uint256)) (->info_1) := getTotalSupply_1(function() returns(uint256))
		Expression: dataSlot = data
		IRs:
			dataSlot_1(bytes32) := data_1 (-> [])(FarmingLib.Data)
		Expression: info.dataSlot = dataSlot
		IRs:
			REF_191(bytes32) -> info_1.dataSlot
			info_2(FarmingLib.Info) := ϕ(['info_1'])
			REF_191(bytes32) (->info_2) := dataSlot_1(bytes32)
		Expression: info
		IRs:
			RETURN info_2
	Function FarmingLib.getData(FarmingLib.Info)
		Expression: dataSlot = self.dataSlot
		IRs:
			REF_192(bytes32) -> self_1.dataSlot
			dataSlot_1(bytes32) := REF_192(bytes32)
		Expression: data = dataSlot
		IRs:
			data_1 (-> ['dataSlot'])(FarmingLib.Data) := dataSlot_1(bytes32)
		Expression: data
		IRs:
			RETURN data_1 (-> ['dataSlot'])
	Function FarmingLib.startFarming(FarmingLib.Info,uint256,uint256)
		Expression: data = self.getData()
		IRs:
			TMP_730(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			data_1 (-> ['TMP_730'])(FarmingLib.Data) := TMP_730(FarmingLib.Data)
		Expression: data.userInfo.updateFarmedPerToken(_farmedPerToken(self))
		IRs:
			REF_194(UserAccounting.Info) -> data_1 (-> ['TMP_730']).userInfo
			TMP_731(uint256) = INTERNAL_CALL, FarmingLib._farmedPerToken(FarmingLib.Info)(self_1)
			LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.updateFarmedPerToken(UserAccounting.Info,uint256), arguments:['REF_194', 'TMP_731'] 
		Expression: reward = data.farmInfo.startFarming(amount,period)
		IRs:
			REF_196(FarmAccounting.Info) -> data_1 (-> ['TMP_730']).farmInfo
			TMP_733(uint256) = LIBRARY_CALL, dest:FarmAccounting, function:FarmAccounting.startFarming(FarmAccounting.Info,uint256,uint256), arguments:['REF_196', 'amount_1', 'period_1'] 
			reward_1(uint256) := TMP_733(uint256)
		Expression: reward
		IRs:
			RETURN reward_1
	Function FarmingLib.farmed(FarmingLib.Info,address,uint256)
		Expression: self.getData().userInfo.farmed(account,balance,_farmedPerToken(self))
		IRs:
			TMP_734(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			REF_199(UserAccounting.Info) -> TMP_734.userInfo
			TMP_735(uint256) = INTERNAL_CALL, FarmingLib._farmedPerToken(FarmingLib.Info)(self_1)
			TMP_736(uint256) = LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.farmed(UserAccounting.Info,address,uint256,uint256), arguments:['REF_199', 'account_1', 'balance_1', 'TMP_735'] 
			RETURN TMP_736
	Function FarmingLib.claim(FarmingLib.Info,address,uint256)
		Expression: data = self.getData()
		IRs:
			TMP_737(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			data_1 (-> ['TMP_737'])(FarmingLib.Data) := TMP_737(FarmingLib.Data)
		Expression: fpt = _farmedPerToken(self)
		IRs:
			TMP_738(uint256) = INTERNAL_CALL, FarmingLib._farmedPerToken(FarmingLib.Info)(self_1)
			fpt_1(uint256) := TMP_738(uint256)
		Expression: amount = data.userInfo.farmed(account,balance,fpt)
		IRs:
			REF_202(UserAccounting.Info) -> data_1 (-> ['TMP_737']).userInfo
			TMP_739(uint256) = LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.farmed(UserAccounting.Info,address,uint256,uint256), arguments:['REF_202', 'account_1', 'balance_1', 'fpt_1'] 
			amount_1(uint256) := TMP_739(uint256)
		Expression: amount > 0
		IRs:
			TMP_740(bool) = amount_1 > 0
			CONDITION TMP_740
		Expression: data.userInfo.eraseFarmed(account,balance,fpt)
		IRs:
			REF_204(UserAccounting.Info) -> data_1 (-> ['TMP_737']).userInfo
			LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.eraseFarmed(UserAccounting.Info,address,uint256,uint256), arguments:['REF_204', 'account_1', 'balance_1', 'fpt_1'] 
		Expression: amount
		IRs:
			RETURN amount_1
	Function FarmingLib.updateBalances(FarmingLib.Info,address,address,uint256)
		Expression: self.getData().userInfo.updateBalances(from,to,amount,_farmedPerToken(self))
		IRs:
			TMP_742(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			REF_207(UserAccounting.Info) -> TMP_742.userInfo
			TMP_743(uint256) = INTERNAL_CALL, FarmingLib._farmedPerToken(FarmingLib.Info)(self_1)
			LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.updateBalances(UserAccounting.Info,address,address,uint256,uint256), arguments:['REF_207', 'from_1', 'to_1', 'amount_1', 'TMP_743'] 
	Function FarmingLib._farmedPerToken(FarmingLib.Info)
		IRs:
			self_1(FarmingLib.Info) := ϕ(['self_1', 'self_1', 'self_1', 'self_1'])
		Expression: self.getData().userInfo.farmedPerToken(_infoToContext(self),_lazyGetSupply,_lazyGetFarmed)
		IRs:
			TMP_745(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			REF_210(UserAccounting.Info) -> TMP_745.userInfo
			TMP_746(bytes32) = INTERNAL_CALL, FarmingLib._infoToContext(FarmingLib.Info)(self_1)
			TMP_747(uint256) = LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.farmedPerToken(UserAccounting.Info,bytes32,function(bytes32) returns(uint256),function(bytes32,uint256) returns(uint256)), arguments:['REF_210', 'TMP_746', '_lazyGetSupply', '_lazyGetFarmed'] 
			RETURN TMP_747
	Function FarmingLib._lazyGetSupply(bytes32)
		Expression: self = _contextToInfo(context)
		IRs:
			TMP_748(FarmingLib.Info) = INTERNAL_CALL, FarmingLib._contextToInfo(bytes32)(context_1)
			self_1(FarmingLib.Info) := TMP_748(FarmingLib.Info)
		Expression: self.getTotalSupply()
		IRs:
			REF_212(function() returns(uint256)) -> self_1.getTotalSupply
			TMP_749(uint256) = INTERNAL_DYNAMIC_CALL REF_212()  
			RETURN TMP_749
	Function FarmingLib._lazyGetFarmed(bytes32,uint256)
		Expression: self = _contextToInfo(context)
		IRs:
			TMP_750(FarmingLib.Info) = INTERNAL_CALL, FarmingLib._contextToInfo(bytes32)(context_1)
			self_1(FarmingLib.Info) := TMP_750(FarmingLib.Info)
		Expression: self.getData().farmInfo.farmedSinceCheckpointScaled(checkpoint)
		IRs:
			TMP_751(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			REF_214(FarmAccounting.Info) -> TMP_751.farmInfo
			TMP_752(uint256) = LIBRARY_CALL, dest:FarmAccounting, function:FarmAccounting.farmedSinceCheckpointScaled(FarmAccounting.Info,uint256), arguments:['REF_214', 'checkpoint_1'] 
			RETURN TMP_752
	Function FarmingLib._contextToInfo(bytes32)
		IRs:
			context_1(bytes32) := ϕ(['context_1', 'context_1'])
		Expression: self = context
		IRs:
			self_1(FarmingLib.Info) := context_1(bytes32)
		Expression: self
		IRs:
			RETURN self_1
	Function FarmingLib._infoToContext(FarmingLib.Info)
		IRs:
			self_1(FarmingLib.Info) := ϕ(['self_1'])
		Expression: context = self
		IRs:
			context_1(bytes32) := self_1(FarmingLib.Info)
		Expression: context
		IRs:
			RETURN context_1
Contract MultiFarmingPod
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_753(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_753)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_755(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_756(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_757(bool) = TMP_755 == TMP_756
			TMP_758(None) = SOLIDITY_CALL require(bool,string)(TMP_757,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_759 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_759)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_762 = CONVERT 0 to address
			TMP_763(bool) = newOwner_1 != TMP_762
			TMP_764(None) = SOLIDITY_CALL require(bool,string)(TMP_763,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['TMP_759', 'TMP_753', 'newOwner_1'])
			_owner_2(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function IMultiFarmingPod.totalSupply()
	Function IMultiFarmingPod.distributor()
	Function IMultiFarmingPod.farmInfo(IERC20)
	Function IMultiFarmingPod.farmed(IERC20,address)
	Function IMultiFarmingPod.claim(IERC20)
	Function IMultiFarmingPod.claim()
	Function IMultiFarmingPod.setDistributor(address)
	Function IMultiFarmingPod.startFarming(IERC20,uint256,uint256)
	Function IMultiFarmingPod.rescueFunds(IERC20,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_1(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, MultiFarmingPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function MultiFarmingPod.constructor(IERC20Pods,uint256)
		Expression: rewardsTokensLimit_ > 5
		IRs:
			TMP_770(bool) = rewardsTokensLimit__1 > 5
			CONDITION TMP_770
		Expression: revert RewardsTokensLimitTooHigh(uint256)(rewardsTokensLimit_)
		IRs:
			TMP_771(None) = SOLIDITY_CALL revert RewardsTokensLimitTooHigh(uint256)(rewardsTokensLimit__1)
		Expression: address(farmableToken_) == address(0)
		IRs:
			TMP_772 = CONVERT farmableToken__1 to address
			TMP_773 = CONVERT 0 to address
			TMP_774(bool) = TMP_772 == TMP_773
			CONDITION TMP_774
		Expression: revert ZeroFarmableTokenAddress()()
		IRs:
			TMP_775(None) = SOLIDITY_CALL revert ZeroFarmableTokenAddress()()
		Expression: rewardsTokensLimit = rewardsTokensLimit_
		IRs:
			rewardsTokensLimit_1(uint256) := rewardsTokensLimit__1(uint256)
		Expression: Pod(farmableToken_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(farmableToken__1)
	Function MultiFarmingPod.rewardsTokens()
		IRs:
			_rewardsTokens_1(AddressSet.Data) := ϕ(['_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0', '_rewardsTokens_5'])
		Expression: _rewardsTokens.items.get()
		IRs:
			REF_216(AddressArray.Data) -> _rewardsTokens_1.items
			TMP_777(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_216'] 
			RETURN TMP_777
	Function MultiFarmingPod.farmInfo(IERC20)
		IRs:
			_farms_1(mapping(IERC20 => FarmingLib.Data)) := ϕ(['_farms_1', '_farms_0', '_farms_2'])
		Expression: _farms[rewardsToken].farmInfo
		IRs:
			REF_218(FarmingLib.Data) -> _farms_1[rewardsToken_1]
			REF_219(FarmAccounting.Info) -> REF_218.farmInfo
			RETURN REF_219
	Function MultiFarmingPod.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_5', '_totalSupply_3'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function MultiFarmingPod.distributor()
		IRs:
			_distributor_1(address) := ϕ(['_distributor_4', '_distributor_6', '_distributor_0'])
		Expression: _distributor
		IRs:
			RETURN _distributor_1
	Function MultiFarmingPod.setDistributor(address)
		IRs:
			_distributor_2(address) := ϕ(['_distributor_4', '_distributor_6', '_distributor_0'])
		Expression: oldDistributor = _distributor
		IRs:
			oldDistributor_1(address) := _distributor_3(address)
		Expression: distributor_ == oldDistributor
		IRs:
			TMP_778(bool) = distributor__1 == oldDistributor_1
			CONDITION TMP_778
		Expression: revert SameDistributor()()
		IRs:
			TMP_779(None) = SOLIDITY_CALL revert SameDistributor()()
		Expression: DistributorChanged(oldDistributor,distributor_)
		IRs:
			Emit DistributorChanged(oldDistributor_1,distributor__1)
		Expression: _distributor = distributor_
		IRs:
			_distributor_4(address) := distributor__1(address)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function MultiFarmingPod.addRewardsToken(address)
		IRs:
			token_2(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_0'])
			rewardsTokensLimit_2(uint256) := ϕ(['rewardsTokensLimit_3', 'rewardsTokensLimit_1', 'rewardsTokensLimit_0'])
			_rewardsTokens_2(AddressSet.Data) := ϕ(['_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0', '_rewardsTokens_5'])
		Expression: _rewardsTokens.length() == rewardsTokensLimit
		IRs:
			TMP_782(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['_rewardsTokens_3'] 
			TMP_783(bool) = TMP_782 == rewardsTokensLimit_3
			CONDITION TMP_783
		Expression: revert RewardsTokensLimitReached()()
		IRs:
			TMP_784(None) = SOLIDITY_CALL revert RewardsTokensLimitReached()()
		Expression: ! _rewardsTokens.add(rewardsToken)
		IRs:
			TMP_785(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.add(AddressSet.Data,address), arguments:['_rewardsTokens_3', 'rewardsToken_1'] 
			TMP_786 = UnaryType.BANG TMP_785 
			CONDITION TMP_786
		Expression: revert RewardsTokenAlreadyAdded()()
		IRs:
			TMP_787(None) = SOLIDITY_CALL revert RewardsTokenAlreadyAdded()()
		Expression: FarmCreated(address(token),rewardsToken)
		IRs:
			TMP_788 = CONVERT token_3 to address
			Emit FarmCreated(TMP_788,rewardsToken_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function MultiFarmingPod.startFarming(IERC20,uint256,uint256)
		IRs:
			_rewardsTokens_4(AddressSet.Data) := ϕ(['_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0', '_rewardsTokens_5'])
		Expression: ! _rewardsTokens.contains(address(rewardsToken))
		IRs:
			TMP_791 = CONVERT rewardsToken_1 to address
			TMP_792(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.contains(AddressSet.Data,address), arguments:['_rewardsTokens_5', 'TMP_791'] 
			TMP_793 = UnaryType.BANG TMP_792 
			CONDITION TMP_793
		Expression: revert RewardsTokenNotFound()()
		IRs:
			TMP_794(None) = SOLIDITY_CALL revert RewardsTokenNotFound()()
		Expression: reward = _makeInfo(rewardsToken).startFarming(amount,period)
		IRs:
			TMP_795(FarmingLib.Info) = INTERNAL_CALL, MultiFarmingPod._makeInfo(IERC20)(rewardsToken_1)
			TMP_796(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.startFarming(FarmingLib.Info,uint256,uint256), arguments:['TMP_795', 'amount_1', 'period_1'] 
			reward_1(uint256) := TMP_796(uint256)
		Expression: RewardAdded(address(rewardsToken),reward,period)
		IRs:
			TMP_797 = CONVERT rewardsToken_1 to address
			Emit RewardAdded(TMP_797,reward_1,period_1)
		Expression: rewardsToken.safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_799 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['rewardsToken_1', 'msg.sender', 'TMP_799', 'amount_1'] 
		Expression: onlyDistributor()
		IRs:
			MODIFIER_CALL, MultiFarmingPod.onlyDistributor()()
	Function MultiFarmingPod.farmed(IERC20,address)
		IRs:
			token_4(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_0'])
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),account)
		IRs:
			TMP_802 = CONVERT token_4 to IERC20Pods
			TMP_803 = CONVERT this to address
			TMP_804(uint256) = HIGH_LEVEL_CALL, dest:TMP_802(IERC20Pods), function:podBalanceOf, arguments:['TMP_803', 'account_1']  
			token_5(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_4'])
			balance_1(uint256) := TMP_804(uint256)
		Expression: _makeInfo(rewardsToken).farmed(account,balance)
		IRs:
			TMP_805(FarmingLib.Info) = INTERNAL_CALL, MultiFarmingPod._makeInfo(IERC20)(rewardsToken_1)
			TMP_806(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.farmed(FarmingLib.Info,address,uint256), arguments:['TMP_805', 'account_1', 'balance_1'] 
			RETURN TMP_806
	Function MultiFarmingPod.claim(IERC20)
		IRs:
			token_6(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_0'])
		Expression: podBalance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_807 = CONVERT token_6 to IERC20Pods
			TMP_808 = CONVERT this to address
			TMP_809(uint256) = HIGH_LEVEL_CALL, dest:TMP_807(IERC20Pods), function:podBalanceOf, arguments:['TMP_808', 'msg.sender']  
			token_7(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_6'])
			podBalance_1(uint256) := TMP_809(uint256)
		Expression: _claim(rewardsToken,msg.sender,podBalance)
		IRs:
			INTERNAL_CALL, MultiFarmingPod._claim(IERC20,address,uint256)(rewardsToken_1,msg.sender,podBalance_1)
	Function MultiFarmingPod.claim()
		IRs:
			token_8(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_0'])
			_rewardsTokens_6(AddressSet.Data) := ϕ(['_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0', '_rewardsTokens_5'])
		Expression: podBalance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_811 = CONVERT token_8 to IERC20Pods
			TMP_812 = CONVERT this to address
			TMP_813(uint256) = HIGH_LEVEL_CALL, dest:TMP_811(IERC20Pods), function:podBalanceOf, arguments:['TMP_812', 'msg.sender']  
			token_9(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_8'])
			_rewardsTokens_7(AddressSet.Data) := ϕ(['_rewardsTokens_8', '_rewardsTokens_3', '_rewardsTokens_7', '_rewardsTokens_1', '_rewardsTokens_6', '_rewardsTokens_5'])
			podBalance_1(uint256) := TMP_813(uint256)
		Expression: tokens = _rewardsTokens.items.get()
		IRs:
			REF_229(AddressArray.Data) -> _rewardsTokens_7.items
			TMP_814(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_229'] 
			tokens_1(address[]) = ['TMP_814(address[])']
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < tokens.length
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			REF_231 -> LENGTH tokens_1
			TMP_815(bool) = i_2 < REF_231
			CONDITION TMP_815
		Expression: _claim(IERC20(tokens[i]),msg.sender,podBalance)
		IRs:
			REF_232(address) -> tokens_1[i_2]
			TMP_816 = CONVERT REF_232 to IERC20
			INTERNAL_CALL, MultiFarmingPod._claim(IERC20,address,uint256)(TMP_816,msg.sender,podBalance_1)
		Expression: i ++
		IRs:
			TMP_818(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
	Function MultiFarmingPod._claim(IERC20,address,uint256)
		IRs:
			rewardsToken_1(IERC20) := ϕ(['rewardsToken_1', 'TMP_816'])
			account_1(address) := ϕ(['msg.sender'])
			podBalance_1(uint256) := ϕ(['podBalance_1', 'podBalance_1'])
		Expression: amount = _makeInfo(rewardsToken).claim(account,podBalance)
		IRs:
			TMP_819(FarmingLib.Info) = INTERNAL_CALL, MultiFarmingPod._makeInfo(IERC20)(rewardsToken_1)
			TMP_820(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.claim(FarmingLib.Info,address,uint256), arguments:['TMP_819', 'account_1', 'podBalance_1'] 
			amount_1(uint256) := TMP_820(uint256)
		Expression: amount > 0
		IRs:
			TMP_821(bool) = amount_1 > 0
			CONDITION TMP_821
		Expression: _transferReward(rewardsToken,account,amount)
		IRs:
			INTERNAL_CALL, MultiFarmingPod._transferReward(IERC20,address,uint256)(rewardsToken_1,account_1,amount_1)
	Function MultiFarmingPod._transferReward(IERC20,address,uint256)
		IRs:
			reward_1(IERC20) := ϕ(['rewardsToken_1'])
			to_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: reward.safeTransfer(to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['reward_1', 'to_1', 'amount_1'] 
	Function MultiFarmingPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_5', '_totalSupply_3'])
			_rewardsTokens_8(AddressSet.Data) := ϕ(['_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0', '_rewardsTokens_5'])
		Expression: tokens = _rewardsTokens.items.get()
		IRs:
			REF_235(AddressArray.Data) -> _rewardsTokens_8.items
			TMP_824(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_235'] 
			tokens_1(address[]) = ['TMP_824(address[])']
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < tokens.length
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			REF_237 -> LENGTH tokens_1
			TMP_825(bool) = i_2 < REF_237
			CONDITION TMP_825
		Expression: _makeInfo(IERC20(tokens[i])).updateBalances(from,to,amount)
		IRs:
			REF_238(address) -> tokens_1[i_2]
			TMP_826 = CONVERT REF_238 to IERC20
			TMP_827(FarmingLib.Info) = INTERNAL_CALL, MultiFarmingPod._makeInfo(IERC20)(TMP_826)
			LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.updateBalances(FarmingLib.Info,address,address,uint256), arguments:['TMP_827', 'from_1', 'to_1', 'amount_1'] 
		Expression: i ++
		IRs:
			TMP_829(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		Expression: from == address(0)
		IRs:
			TMP_830 = CONVERT 0 to address
			TMP_831(bool) = from_1 == TMP_830
			CONDITION TMP_831
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_2 (c)+ amount_1
		Expression: to == address(0)
		IRs:
			TMP_832 = CONVERT 0 to address
			TMP_833(bool) = to_1 == TMP_832
			CONDITION TMP_833
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_5(uint256) = _totalSupply_4 (c)- amount_1
	Function MultiFarmingPod.rescueFunds(IERC20,uint256)
		IRs:
			_distributor_5(address) := ϕ(['_distributor_4', '_distributor_6', '_distributor_0'])
		Expression: token == IERC20(address(0))
		IRs:
			TMP_834 = CONVERT 0 to address
			TMP_835 = CONVERT TMP_834 to IERC20
			TMP_836(bool) = token_1 == TMP_835
			CONDITION TMP_836
		Expression: address(_distributor).sendValue(amount)
		IRs:
			TMP_837 = CONVERT _distributor_6 to address
			LIBRARY_CALL, dest:Address, function:Address.sendValue(address,uint256), arguments:['TMP_837', 'amount_1'] 
		Expression: token.safeTransfer(_distributor,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['token_1', '_distributor_6', 'amount_1'] 
		Expression: onlyDistributor()
		IRs:
			MODIFIER_CALL, MultiFarmingPod.onlyDistributor()()
	Function MultiFarmingPod._makeInfo(IERC20)
		IRs:
			rewardsToken_1(IERC20) := ϕ(['TMP_826', 'rewardsToken_1', 'rewardsToken_1', 'rewardsToken_1'])
			_farms_2(mapping(IERC20 => FarmingLib.Data)) := ϕ(['_farms_1', '_farms_0', '_farms_2'])
		Expression: FarmingLib.makeInfo(totalSupply,_farms[rewardsToken])
		IRs:
			REF_243(FarmingLib.Data) -> _farms_2[rewardsToken_1]
			TMP_841(FarmingLib.Info) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.makeInfo(function() returns(uint256),FarmingLib.Data), arguments:['totalSupply', 'REF_243'] 
			RETURN TMP_841
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_10(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_0'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_843 = CONVERT token_10 to address
			TMP_844(bool) = msg.sender != TMP_843
			CONDITION TMP_844
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_845(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
	Modifier MultiFarmingPod.onlyDistributor()
ENTRY_POINT
		IRs:
			_distributor_7(address) := ϕ(['_distributor_4', '_distributor_6', '_distributor_0'])
IF msg.sender != _distributor
		Expression: msg.sender != _distributor
		IRs:
			TMP_846(bool) = msg.sender != _distributor_7
			CONDITION TMP_846
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_847(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract FarmAccounting
	Function FarmAccounting.farmedSinceCheckpointScaled(FarmAccounting.Info,uint256)
		IRs:
			info_1(FarmAccounting.Info) := ϕ(['prev_1'])
			checkpoint_1(uint256) := ϕ(['TMP_864'])
			_SCALE_1(uint256) := ϕ(['_SCALE_0', '_SCALE_3'])
		Expression: info.duration > 0
		IRs:
			REF_244(uint32) -> info_1.duration
			TMP_848(bool) = REF_244 > 0
			CONDITION TMP_848
		Expression: elapsed = Math.min(block.timestamp,info.finished) - Math.min(checkpoint,info.finished)
		IRs:
			REF_246(uint40) -> info_1.finished
			TMP_849(uint256) = LIBRARY_CALL, dest:Math, function:Math.min(uint256,uint256), arguments:['block.timestamp', 'REF_246'] 
			REF_248(uint40) -> info_1.finished
			TMP_850(uint256) = LIBRARY_CALL, dest:Math, function:Math.min(uint256,uint256), arguments:['checkpoint_1', 'REF_248'] 
			TMP_851(uint256) = TMP_849 - TMP_850
			elapsed_1(uint256) := TMP_851(uint256)
		Expression: elapsed * info.reward * _SCALE / info.duration
		IRs:
			REF_249(uint184) -> info_1.reward
			TMP_852(uint256) = elapsed_1 * REF_249
			TMP_853(uint256) = TMP_852 * _SCALE_1
			REF_250(uint32) -> info_1.duration
			TMP_854(uint256) = TMP_853 / REF_250
			RETURN TMP_854
		Expression: amount
		IRs:
			RETURN amount_0
	Function FarmAccounting.startFarming(FarmAccounting.Info,uint256,uint256)
		IRs:
			_MAX_REWARD_AMOUNT_1(uint256) := ϕ(['_MAX_REWARD_AMOUNT_0'])
			_SCALE_2(uint256) := ϕ(['_SCALE_0', '_SCALE_3'])
		Expression: period == 0
		IRs:
			TMP_855(bool) = period_1 == 0
			CONDITION TMP_855
		Expression: revert ZeroDuration()()
		IRs:
			TMP_856(None) = SOLIDITY_CALL revert ZeroDuration()()
		Expression: period > type()(uint32).max
		IRs:
			TMP_858(uint32) := 4294967295(uint32)
			TMP_859(bool) = period_1 > TMP_858
			CONDITION TMP_859
		Expression: revert DurationTooLarge()()
		IRs:
			TMP_860(None) = SOLIDITY_CALL revert DurationTooLarge()()
		Expression: amount > _MAX_REWARD_AMOUNT
		IRs:
			TMP_861(bool) = amount_1 > _MAX_REWARD_AMOUNT_1
			CONDITION TMP_861
		Expression: revert AmountTooLarge()()
		IRs:
			TMP_862(None) = SOLIDITY_CALL revert AmountTooLarge()()
		Expression: prev = info
		IRs:
			prev_1(FarmAccounting.Info) := info_1 (-> [])(FarmAccounting.Info)
		Expression: block.timestamp < prev.finished
		IRs:
			REF_251(uint40) -> prev_1.finished
			TMP_863(bool) = block.timestamp < REF_251
			CONDITION TMP_863
		Expression: amount += prev.reward - farmedSinceCheckpointScaled(prev,prev.finished - prev.duration) / _SCALE
		IRs:
			REF_252(uint184) -> prev_1.reward
			REF_253(uint40) -> prev_1.finished
			REF_254(uint32) -> prev_1.duration
			TMP_864(uint40) = REF_253 (c)- REF_254
			TMP_865(uint256) = INTERNAL_CALL, FarmAccounting.farmedSinceCheckpointScaled(FarmAccounting.Info,uint256)(prev_1,TMP_864)
			TMP_866(uint256) = TMP_865 (c)/ _SCALE_3
			TMP_867(uint184) = REF_252 (c)- TMP_866
			amount_2(uint256) = amount_1 (c)+ TMP_867
		IRs:
			amount_3(uint256) := ϕ(['amount_1', 'amount_2'])
		Expression: (info.finished,info.duration,info.reward) = (uint40(block.timestamp + period),uint32(period),uint184(amount))
		IRs:
			REF_255(uint40) -> info_1 (-> []).finished
			REF_256(uint32) -> info_1 (-> []).duration
			REF_257(uint184) -> info_1 (-> []).reward
			TMP_868(uint256) = block.timestamp (c)+ period_1
			TMP_869 = CONVERT TMP_868 to uint40
			TMP_870 = CONVERT period_1 to uint32
			TMP_871 = CONVERT amount_3 to uint184
			info_2 (-> [])(FarmAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_255(uint40) (->info_2 (-> [])) := TMP_869(uint40)
			info_3 (-> [])(FarmAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_256(uint32) (->info_3 (-> [])) := TMP_870(uint32)
			info_4 (-> [])(FarmAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_257(uint184) (->info_4 (-> [])) := TMP_871(uint184)
		Expression: amount
		IRs:
			RETURN amount_3
	Function FarmAccounting.slitherConstructorConstantVariables()
		Expression: _MAX_REWARD_AMOUNT = 1e32
		Expression: _SCALE = 1e18
Contract UserAccounting
	Function UserAccounting.farmedPerToken(UserAccounting.Info,bytes32,function(bytes32) returns(uint256),function(bytes32,uint256) returns(uint256))
		Expression: checkpoint = info.checkpoint
		IRs:
			REF_258(uint40) -> info_1 (-> []).checkpoint
			checkpoint_1(uint256) := REF_258(uint40)
		Expression: fpt = info.farmedPerTokenStored
		IRs:
			REF_259(uint216) -> info_1 (-> []).farmedPerTokenStored
			fpt_1(uint256) := REF_259(uint216)
		Expression: block.timestamp != checkpoint
		IRs:
			TMP_872(bool) = block.timestamp != checkpoint_1
			CONDITION TMP_872
		Expression: supply = lazyGetSupply(context)
		IRs:
			TMP_873(uint256) = INTERNAL_DYNAMIC_CALL lazyGetSupply(context_1)  
			supply_1(uint256) := TMP_873(uint256)
		Expression: supply > 0
		IRs:
			TMP_874(bool) = supply_1 > 0
			CONDITION TMP_874
		Expression: fpt += lazyGetFarmed(context,checkpoint) / supply
		IRs:
			TMP_875(uint256) = INTERNAL_DYNAMIC_CALL lazyGetFarmed(context_1,checkpoint_1)  
			TMP_876(uint256) = TMP_875 / supply_1
			fpt_2(uint256) = fpt_1 + TMP_876
		IRs:
			fpt_3(uint256) := ϕ(['fpt_1', 'fpt_2'])
		Expression: fpt
		IRs:
			RETURN fpt_3
	Function UserAccounting.farmed(UserAccounting.Info,address,uint256,uint256)
		Expression: uint256(int256(balance * fpt) - info.corrections[account]) / FarmAccounting._SCALE
		IRs:
			TMP_877(uint256) = balance_1 (c)* fpt_1
			TMP_878 = CONVERT TMP_877 to int256
			REF_260(mapping(address => int256)) -> info_1 (-> []).corrections
			REF_261(int256) -> REF_260[account_1]
			TMP_879(int256) = TMP_878 (c)- REF_261
			TMP_880 = CONVERT TMP_879 to uint256
			REF_262(uint256) -> FarmAccounting._SCALE
			TMP_881(uint256) = TMP_880 (c)/ REF_262
			RETURN TMP_881
	Function UserAccounting.eraseFarmed(UserAccounting.Info,address,uint256,uint256)
		Expression: info.corrections[account] = int256(balance * fpt)
		IRs:
			REF_263(mapping(address => int256)) -> info_1 (-> []).corrections
			REF_264(int256) -> REF_263[account_1]
			TMP_882(uint256) = balance_1 (c)* fpt_1
			TMP_883 = CONVERT TMP_882 to int256
			info_2 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_264(int256) (->info_2 (-> [])) := TMP_883(int256)
	Function UserAccounting.updateFarmedPerToken(UserAccounting.Info,uint256)
		IRs:
			info_1 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			fpt_1(uint256) := ϕ(['fpt_1'])
		Expression: (info.checkpoint,info.farmedPerTokenStored) = (uint40(block.timestamp),uint216(fpt))
		IRs:
			REF_265(uint40) -> info_1 (-> []).checkpoint
			REF_266(uint216) -> info_1 (-> []).farmedPerTokenStored
			TMP_884 = CONVERT block.timestamp to uint40
			TMP_885 = CONVERT fpt_1 to uint216
			info_2 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_265(uint40) (->info_2 (-> [])) := TMP_884(uint40)
			info_3 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_266(uint216) (->info_3 (-> [])) := TMP_885(uint216)
	Function UserAccounting.updateBalances(UserAccounting.Info,address,address,uint256,uint256)
		Expression: fromZero = (from == address(0))
		IRs:
			TMP_886 = CONVERT 0 to address
			TMP_887(bool) = from_1 == TMP_886
			fromZero_1(bool) := TMP_887(bool)
		Expression: toZero = (to == address(0))
		IRs:
			TMP_888 = CONVERT 0 to address
			TMP_889(bool) = to_1 == TMP_888
			toZero_1(bool) := TMP_889(bool)
		Expression: amount > 0 && from != to
		IRs:
			TMP_890(bool) = amount_1 > 0
			TMP_891(bool) = from_1 != to_1
			TMP_892(bool) = TMP_890 && TMP_891
			CONDITION TMP_892
		Expression: fromZero || toZero
		IRs:
			TMP_893(bool) = fromZero_1 || toZero_1
			CONDITION TMP_893
		Expression: updateFarmedPerToken(info,fpt)
		IRs:
			INTERNAL_CALL, UserAccounting.updateFarmedPerToken(UserAccounting.Info,uint256)(info_1 (-> []),fpt_1)
		Expression: diff = int256(amount * fpt)
		IRs:
			TMP_895(uint256) = amount_1 (c)* fpt_1
			TMP_896 = CONVERT TMP_895 to int256
			diff_1(int256) := TMP_896(int256)
		Expression: ! fromZero
		IRs:
			TMP_897 = UnaryType.BANG fromZero_1 
			CONDITION TMP_897
		Expression: info.corrections[from] -= diff
		IRs:
			REF_267(mapping(address => int256)) -> info_1 (-> []).corrections
			REF_268(int256) -> REF_267[from_1]
			info_2 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_268(-> info_2 (-> [])) = REF_268 (c)- diff_1
		IRs:
			info_3 (-> [])(UserAccounting.Info) := ϕ(['info_2 (-> [])', 'info_1 (-> [])'])
		Expression: ! toZero
		IRs:
			TMP_898 = UnaryType.BANG toZero_1 
			CONDITION TMP_898
		Expression: info.corrections[to] += diff
		IRs:
			REF_269(mapping(address => int256)) -> info_3 (-> []).corrections
			REF_270(int256) -> REF_269[to_1]
			info_4 (-> [])(UserAccounting.Info) := ϕ(['info_3 (-> [])'])
			REF_270(-> info_4 (-> [])) = REF_270 (c)+ diff_1
Contract IMultiFarmingPod
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IMultiFarmingPod.totalSupply()
	Function IMultiFarmingPod.distributor()
	Function IMultiFarmingPod.farmInfo(IERC20)
	Function IMultiFarmingPod.farmed(IERC20,address)
	Function IMultiFarmingPod.claim(IERC20)
	Function IMultiFarmingPod.claim()
	Function IMultiFarmingPod.setDistributor(address)
	Function IMultiFarmingPod.startFarming(IERC20,uint256,uint256)
	Function IMultiFarmingPod.rescueFunds(IERC20,uint256)
Contract IDaiLikePermit
	Function IDaiLikePermit.permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)
Contract AddressArray
	Function AddressArray.length(AddressArray.Data)
		IRs:
			self_1 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
		Expression: self._raw[0] >> 160
		IRs:
			REF_271(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_272(uint256) -> REF_271[0]
			TMP_899(uint256) = REF_272 >> 160
			RETURN TMP_899
	Function AddressArray.at(AddressArray.Data,uint256)
		Expression: address(uint160(self._raw[i]))
		IRs:
			REF_273(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_274(uint256) -> REF_273[i_1]
			TMP_900 = CONVERT REF_274 to uint160
			TMP_901 = CONVERT TMP_900 to address
			RETURN TMP_901
	Function AddressArray.get(AddressArray.Data)
		Expression: lengthAndFirst = self._raw[0]
		IRs:
			REF_275(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_276(uint256) -> REF_275[0]
			lengthAndFirst_1(uint256) := REF_276(uint256)
		Expression: arr = new address[](lengthAndFirst >> 160)
		IRs:
			TMP_903(uint256) = lengthAndFirst_1 >> 160
			TMP_904(address[])  = new address[](TMP_903)
			arr_1(address[]) = ['TMP_904(address[])']
		Expression: _get(self,arr,lengthAndFirst)
		IRs:
			TMP_905(address[]) = INTERNAL_CALL, AddressArray._get(AddressArray.Data,address[],uint256)(self_1 (-> []),arr_1,lengthAndFirst_1)
		Expression: arr
		IRs:
			RETURN arr_1
	Function AddressArray.get(AddressArray.Data,address[])
		Expression: _get(self,output,self._raw[0])
		IRs:
			REF_277(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_278(uint256) -> REF_277[0]
			TMP_906(address[]) = INTERNAL_CALL, AddressArray._get(AddressArray.Data,address[],uint256)(self_1 (-> []),output_1,REF_278)
			RETURN TMP_906
	Function AddressArray._get(AddressArray.Data,address[],uint256)
		IRs:
			self_1 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])', 'self_1 (-> [])'])
			output_1(address[]) := ϕ(['output_1', 'arr_1'])
			lengthAndFirst_1(uint256) := ϕ(['REF_278', 'lengthAndFirst_1'])
		Expression: len = lengthAndFirst >> 160
		IRs:
			TMP_907(uint256) = lengthAndFirst_1 >> 160
			len_1(uint256) := TMP_907(uint256)
		Expression: len > output.length
		IRs:
			REF_279 -> LENGTH output_1
			TMP_908(bool) = len_1 > REF_279
			CONDITION TMP_908
		Expression: revert OutputArrayTooSmall()()
		IRs:
			TMP_909(None) = SOLIDITY_CALL revert OutputArrayTooSmall()()
		Expression: len > 0
		IRs:
			TMP_910(bool) = len_1 > 0
			CONDITION TMP_910
		Expression: output[0] = address(uint160(lengthAndFirst))
		IRs:
			REF_280(address) -> output_1[0]
			TMP_911 = CONVERT lengthAndFirst_1 to uint160
			TMP_912 = CONVERT TMP_911 to address
			output_2(address[]) := ϕ(['output_1'])
			REF_280(address) (->output_2) := TMP_912(address)
		Expression: i = 1
		IRs:
			i_1(uint256) := 1(uint256)
		Expression: i < len
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_913(bool) = i_2 < len_1
			CONDITION TMP_913
		Expression: output[i] = address(uint160(self._raw[i]))
		IRs:
			REF_281(address) -> output_2[i_2]
			REF_282(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_283(uint256) -> REF_282[i_2]
			TMP_914 = CONVERT REF_283 to uint160
			TMP_915 = CONVERT TMP_914 to address
			output_3(address[]) := ϕ(['output_2'])
			REF_281(address) (->output_3) := TMP_915(address)
		Expression: i ++
		IRs:
			TMP_916(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		IRs:
			output_4(address[]) := ϕ(['output_2', 'output_1'])
		Expression: output
		IRs:
			RETURN output_4
	Function AddressArray.push(AddressArray.Data,address)
		Expression: lengthAndFirst = self._raw[0]
		IRs:
			REF_284(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_285(uint256) -> REF_284[0]
			lengthAndFirst_1(uint256) := REF_285(uint256)
		Expression: len = lengthAndFirst >> 160
		IRs:
			TMP_917(uint256) = lengthAndFirst_1 >> 160
			len_1(uint256) := TMP_917(uint256)
		Expression: len == 0
		IRs:
			TMP_918(bool) = len_1 == 0
			CONDITION TMP_918
		Expression: self._raw[0] = (1 << 160) + uint160(account)
		IRs:
			REF_286(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_287(uint256) -> REF_286[0]
			TMP_919(uint256) = 1 << 160
			TMP_920 = CONVERT account_1 to uint160
			TMP_921(uint256) = TMP_919 + TMP_920
			self_4 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_287(uint256) (->self_4 (-> [])) := TMP_921(uint256)
		Expression: self._raw[0] = lengthAndFirst + (1 << 160)
		IRs:
			REF_288(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_289(uint256) -> REF_288[0]
			TMP_922(uint256) = 1 << 160
			TMP_923(uint256) = lengthAndFirst_1 + TMP_922
			self_2 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_289(uint256) (->self_2 (-> [])) := TMP_923(uint256)
		Expression: self._raw[len] = uint160(account)
		IRs:
			REF_290(mapping(uint256 => uint256)) -> self_2 (-> [])._raw
			REF_291(uint256) -> REF_290[len_1]
			TMP_924 = CONVERT account_1 to uint160
			self_3 (-> [])(AddressArray.Data) := ϕ(['self_2 (-> [])'])
			REF_291(uint256) (->self_3 (-> [])) := TMP_924(uint160)
		Expression: len + 1
		IRs:
			TMP_925(uint256) = len_1 + 1
			RETURN TMP_925
	Function AddressArray.pop(AddressArray.Data)
		Expression: lengthAndFirst = self._raw[0]
		IRs:
			REF_292(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_293(uint256) -> REF_292[0]
			lengthAndFirst_1(uint256) := REF_293(uint256)
		Expression: len = lengthAndFirst >> 160
		IRs:
			TMP_926(uint256) = lengthAndFirst_1 >> 160
			len_1(uint256) := TMP_926(uint256)
		Expression: len == 0
		IRs:
			TMP_927(bool) = len_1 == 0
			CONDITION TMP_927
		Expression: revert PopFromEmptyArray()()
		IRs:
			TMP_928(None) = SOLIDITY_CALL revert PopFromEmptyArray()()
		Expression: self._raw[len - 1] = 0
		IRs:
			REF_294(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			TMP_929(uint256) = len_1 - 1
			REF_295(uint256) -> REF_294[TMP_929]
			self_2 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_295(uint256) (->self_2 (-> [])) := 0(uint256)
		Expression: len > 1
		IRs:
			TMP_930(bool) = len_1 > 1
			CONDITION TMP_930
		Expression: self._raw[0] = lengthAndFirst - (1 << 160)
		IRs:
			REF_296(mapping(uint256 => uint256)) -> self_2 (-> [])._raw
			REF_297(uint256) -> REF_296[0]
			TMP_931(uint256) = 1 << 160
			TMP_932(uint256) = lengthAndFirst_1 - TMP_931
			self_3 (-> [])(AddressArray.Data) := ϕ(['self_2 (-> [])'])
			REF_297(uint256) (->self_3 (-> [])) := TMP_932(uint256)
	Function AddressArray.set(AddressArray.Data,uint256,address)
		Expression: len = length(self)
		IRs:
			TMP_933(uint256) = INTERNAL_CALL, AddressArray.length(AddressArray.Data)(self_1 (-> []))
			len_1(uint256) := TMP_933(uint256)
		Expression: index >= len
		IRs:
			TMP_934(bool) = index_1 >= len_1
			CONDITION TMP_934
		Expression: revert IndexOutOfBounds()()
		IRs:
			TMP_935(None) = SOLIDITY_CALL revert IndexOutOfBounds()()
		Expression: index == 0
		IRs:
			TMP_936(bool) = index_1 == 0
			CONDITION TMP_936
		Expression: self._raw[0] = (len << 160) | uint160(account)
		IRs:
			REF_298(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_299(uint256) -> REF_298[0]
			TMP_937(uint256) = len_1 << 160
			TMP_938 = CONVERT account_1 to uint160
			TMP_939(uint256) = TMP_937 | TMP_938
			self_3 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_299(uint256) (->self_3 (-> [])) := TMP_939(uint256)
		Expression: self._raw[index] = uint160(account)
		IRs:
			REF_300(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_301(uint256) -> REF_300[index_1]
			TMP_940 = CONVERT account_1 to uint160
			self_2 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_301(uint256) (->self_2 (-> [])) := TMP_940(uint160)
Contract AddressSet
	Function AddressSet.length(AddressSet.Data)
		Expression: s.items.length()
		IRs:
			REF_302(AddressArray.Data) -> s_1 (-> []).items
			TMP_941(uint256) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.length(AddressArray.Data), arguments:['REF_302'] 
			RETURN TMP_941
	Function AddressSet.at(AddressSet.Data,uint256)
		Expression: s.items.at(index)
		IRs:
			REF_304(AddressArray.Data) -> s_1 (-> []).items
			TMP_942(address) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.at(AddressArray.Data,uint256), arguments:['REF_304', 'index_1'] 
			RETURN TMP_942
	Function AddressSet.contains(AddressSet.Data,address)
		Expression: s.lookup[item] != 0
		IRs:
			REF_306(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_307(uint256) -> REF_306[item_1]
			TMP_943(bool) = REF_307 != 0
			RETURN TMP_943
	Function AddressSet.add(AddressSet.Data,address)
		Expression: s.lookup[item] > 0
		IRs:
			REF_308(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_309(uint256) -> REF_308[item_1]
			TMP_944(bool) = REF_309 > 0
			CONDITION TMP_944
		Expression: false
		IRs:
			RETURN False
		Expression: s.lookup[item] = s.items.push(item)
		IRs:
			REF_310(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_311(uint256) -> REF_310[item_1]
			REF_312(AddressArray.Data) -> s_1 (-> []).items
			TMP_945(uint256) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.push(AddressArray.Data,address), arguments:['REF_312', 'item_1'] 
			s_2 (-> [])(AddressSet.Data) := ϕ(['s_1 (-> [])'])
			REF_311(uint256) (->s_2 (-> [])) := TMP_945(uint256)
		Expression: true
		IRs:
			RETURN True
	Function AddressSet.remove(AddressSet.Data,address)
		Expression: index = s.lookup[item]
		IRs:
			REF_314(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_315(uint256) -> REF_314[item_1]
			index_1(uint256) := REF_315(uint256)
		Expression: index == 0
		IRs:
			TMP_946(bool) = index_1 == 0
			CONDITION TMP_946
		Expression: false
		IRs:
			RETURN False
		Expression: index < s.items.length()
		IRs:
			REF_316(AddressArray.Data) -> s_1 (-> []).items
			TMP_947(uint256) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.length(AddressArray.Data), arguments:['REF_316'] 
			TMP_948(bool) = index_1 < TMP_947
			CONDITION TMP_948
		Expression: lastItem = s.items.at(s.items.length() - 1)
		IRs:
			REF_318(AddressArray.Data) -> s_1 (-> []).items
			REF_320(AddressArray.Data) -> s_1 (-> []).items
			TMP_949(uint256) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.length(AddressArray.Data), arguments:['REF_320'] 
			TMP_950(uint256) = TMP_949 - 1
			TMP_951(address) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.at(AddressArray.Data,uint256), arguments:['REF_318', 'TMP_950'] 
			lastItem_1(address) := TMP_951(address)
		Expression: s.items.set(index - 1,lastItem)
		IRs:
			REF_322(AddressArray.Data) -> s_1 (-> []).items
			TMP_952(uint256) = index_1 - 1
			LIBRARY_CALL, dest:AddressArray, function:AddressArray.set(AddressArray.Data,uint256,address), arguments:['REF_322', 'TMP_952', 'lastItem_1'] 
		Expression: s.lookup[lastItem] = index
		IRs:
			REF_324(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_325(uint256) -> REF_324[lastItem_1]
			s_2 (-> [])(AddressSet.Data) := ϕ(['s_1 (-> [])'])
			REF_325(uint256) (->s_2 (-> [])) := index_1(uint256)
		IRs:
			s_3 (-> [])(AddressSet.Data) := ϕ(['s_1 (-> [])', 's_2 (-> [])'])
		Expression: s.items.pop()
		IRs:
			REF_326(AddressArray.Data) -> s_3 (-> []).items
			LIBRARY_CALL, dest:AddressArray, function:AddressArray.pop(AddressArray.Data), arguments:['REF_326'] 
		Expression: delete s.lookup[item]
		IRs:
			REF_328(mapping(address => uint256)) -> s_3 (-> []).lookup
			REF_329(uint256) -> REF_328[item_1]
			REF_328 = delete REF_329 
		Expression: true
		IRs:
			RETURN True
Contract RevertReasonForwarder
	Function RevertReasonForwarder.reRevert()
		Expression: ptr_reRevert_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_955(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_reRevert_asm_0_1(uint256) := TMP_955(uint256)
		Expression: returndatacopy(uint256,uint256,uint256)(ptr_reRevert_asm_0,0,returndatasize()())
		IRs:
			TMP_956(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_957(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(ptr_reRevert_asm_0_1,0,TMP_956)
		Expression: revert(uint256,uint256)(ptr_reRevert_asm_0,returndatasize()())
		IRs:
			TMP_958(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_959(None) = SOLIDITY_CALL revert(uint256,uint256)(ptr_reRevert_asm_0_1,TMP_958)
Contract SafeERC20
	Function SafeERC20.safeTransferFrom(IERC20,address,address,uint256)
		Expression: selector = token.transferFrom.selector
		IRs:
			REF_331(bytes4) (->None) := 599290589(bytes4)
			selector_1(bytes4) := REF_331(bytes4)
		Expression: data_safeTransferFrom_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_960(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data_safeTransferFrom_asm_0_1(uint256) := TMP_960(uint256)
		Expression: mstore(uint256,uint256)(data_safeTransferFrom_asm_0,selector)
		IRs:
			TMP_961(None) = SOLIDITY_CALL mstore(uint256,uint256)(data_safeTransferFrom_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(data_safeTransferFrom_asm_0 + 0x04,from)
		IRs:
			TMP_962(uint256) = data_safeTransferFrom_asm_0_1 + 4
			TMP_963(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_962,from_1)
		Expression: mstore(uint256,uint256)(data_safeTransferFrom_asm_0 + 0x24,to)
		IRs:
			TMP_964(uint256) = data_safeTransferFrom_asm_0_1 + 36
			TMP_965(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_964,to_1)
		Expression: mstore(uint256,uint256)(data_safeTransferFrom_asm_0 + 0x44,amount)
		IRs:
			TMP_966(uint256) = data_safeTransferFrom_asm_0_1 + 68
			TMP_967(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_966,amount_1)
		Expression: success = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data_safeTransferFrom_asm_0,100,0x0,0x20)
		IRs:
			TMP_968(uint256) = SOLIDITY_CALL gas()()
			TMP_969(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_968,token_1,0,data_safeTransferFrom_asm_0_1,100,0,32)
			success_1(bool) := TMP_969(uint256)
		Expression: success
		IRs:
			CONDITION success_1
		Expression: switch_expr_1336_245_22_safeTransferFrom_asm_0 = returndatasize()()
		IRs:
			TMP_970(uint256) = SOLIDITY_CALL returndatasize()()
			switch_expr_1336_245_22_safeTransferFrom_asm_0_1(uint256) := TMP_970(uint256)
		Expression: switch_expr_1336_245_22_safeTransferFrom_asm_0 == 0
		IRs:
			TMP_971(bool) = switch_expr_1336_245_22_safeTransferFrom_asm_0_1 == 0
			CONDITION TMP_971
		IRs:
			success_4(bool) := ϕ(['success_2', 'success_3'])
		Expression: success = extcodesize(uint256)(token) > 0
		IRs:
			REF_332(None) -> token_1.codesize
			TMP_972(bool) = REF_332 > 0
			success_2(bool) := TMP_972(bool)
		Expression: success = returndatasize()() > 31 & mload(uint256)(0) == 1
		IRs:
			TMP_973(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_974(bool) = TMP_973 > 31
			TMP_975(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_976(bool) = TMP_975 == 1
			TMP_977(bool) = TMP_974 & TMP_976
			success_3(bool) := TMP_977(bool)
		Expression: ! success
		IRs:
			TMP_978 = UnaryType.BANG success_4 
			CONDITION TMP_978
		Expression: revert SafeTransferFromFailed()()
		IRs:
			TMP_979(None) = SOLIDITY_CALL revert SafeTransferFromFailed()()
	Function SafeERC20.safeTransfer(IERC20,address,uint256)
		Expression: ! _makeCall(token,token.transfer.selector,to,value)
		IRs:
			REF_334(bytes4) (->None) := 2835717307(bytes4)
			TMP_980(bool) = INTERNAL_CALL, SafeERC20._makeCall(IERC20,bytes4,address,uint256)(token_1,REF_334,to_1,value_1)
			TMP_981 = UnaryType.BANG TMP_980 
			CONDITION TMP_981
		Expression: revert SafeTransferFailed()()
		IRs:
			TMP_982(None) = SOLIDITY_CALL revert SafeTransferFailed()()
	Function SafeERC20.forceApprove(IERC20,address,uint256)
		IRs:
			token_1(IERC20) := ϕ(['token_1', 'token_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1'])
			value_1(uint256) := ϕ(['TMP_1004', 'TMP_998'])
		Expression: ! _makeCall(token,token.approve.selector,spender,value)
		IRs:
			REF_336(bytes4) (->None) := 157198259(bytes4)
			TMP_983(bool) = INTERNAL_CALL, SafeERC20._makeCall(IERC20,bytes4,address,uint256)(token_1,REF_336,spender_1,value_1)
			TMP_984 = UnaryType.BANG TMP_983 
			CONDITION TMP_984
		Expression: ! _makeCall(token,token.approve.selector,spender,0) || ! _makeCall(token,token.approve.selector,spender,value)
		IRs:
			REF_338(bytes4) (->None) := 157198259(bytes4)
			TMP_985(bool) = INTERNAL_CALL, SafeERC20._makeCall(IERC20,bytes4,address,uint256)(token_1,REF_338,spender_1,0)
			TMP_986 = UnaryType.BANG TMP_985 
			REF_340(bytes4) (->None) := 157198259(bytes4)
			TMP_987(bool) = INTERNAL_CALL, SafeERC20._makeCall(IERC20,bytes4,address,uint256)(token_1,REF_340,spender_1,value_1)
			TMP_988 = UnaryType.BANG TMP_987 
			TMP_989(bool) = TMP_986 || TMP_988
			CONDITION TMP_989
		Expression: revert ForceApproveFailed()()
		IRs:
			TMP_990(None) = SOLIDITY_CALL revert ForceApproveFailed()()
	Function SafeERC20.safeIncreaseAllowance(IERC20,address,uint256)
		Expression: allowance = token.allowance(address(this),spender)
		IRs:
			TMP_991 = CONVERT this to address
			TMP_992(uint256) = HIGH_LEVEL_CALL, dest:token_1(IERC20), function:allowance, arguments:['TMP_991', 'spender_1']  
			allowance_1(uint256) := TMP_992(uint256)
		Expression: value > type()(uint256).max - allowance
		IRs:
			TMP_994(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_995(uint256) = TMP_994 (c)- allowance_1
			TMP_996(bool) = value_1 > TMP_995
			CONDITION TMP_996
		Expression: revert SafeIncreaseAllowanceFailed()()
		IRs:
			TMP_997(None) = SOLIDITY_CALL revert SafeIncreaseAllowanceFailed()()
		Expression: forceApprove(token,spender,allowance + value)
		IRs:
			TMP_998(uint256) = allowance_1 (c)+ value_1
			INTERNAL_CALL, SafeERC20.forceApprove(IERC20,address,uint256)(token_1,spender_1,TMP_998)
	Function SafeERC20.safeDecreaseAllowance(IERC20,address,uint256)
		Expression: allowance = token.allowance(address(this),spender)
		IRs:
			TMP_1000 = CONVERT this to address
			TMP_1001(uint256) = HIGH_LEVEL_CALL, dest:token_1(IERC20), function:allowance, arguments:['TMP_1000', 'spender_1']  
			allowance_1(uint256) := TMP_1001(uint256)
		Expression: value > allowance
		IRs:
			TMP_1002(bool) = value_1 > allowance_1
			CONDITION TMP_1002
		Expression: revert SafeDecreaseAllowanceFailed()()
		IRs:
			TMP_1003(None) = SOLIDITY_CALL revert SafeDecreaseAllowanceFailed()()
		Expression: forceApprove(token,spender,allowance - value)
		IRs:
			TMP_1004(uint256) = allowance_1 (c)- value_1
			INTERNAL_CALL, SafeERC20.forceApprove(IERC20,address,uint256)(token_1,spender_1,TMP_1004)
	Function SafeERC20.safePermit(IERC20,bytes)
		Expression: ! tryPermit(token,permit)
		IRs:
			TMP_1006(bool) = INTERNAL_CALL, SafeERC20.tryPermit(IERC20,bytes)(token_1,permit_1)
			TMP_1007 = UnaryType.BANG TMP_1006 
			CONDITION TMP_1007
		Expression: RevertReasonForwarder.reRevert()
		IRs:
			LIBRARY_CALL, dest:RevertReasonForwarder, function:RevertReasonForwarder.reRevert(), arguments:[] 
	Function SafeERC20.tryPermit(IERC20,bytes)
		IRs:
			token_1(IERC20) := ϕ(['token_1'])
			permit_1(bytes) := ϕ(['permit_1'])
		Expression: permit.length == 32 * 7
		IRs:
			REF_344 -> LENGTH permit_1
			TMP_1009(uint256) = 32 (c)* 7
			TMP_1010(bool) = REF_344 == TMP_1009
			CONDITION TMP_1010
		Expression: _makeCalldataCall(token,IERC20Permit.permit.selector,permit)
		IRs:
			REF_346(bytes4) (->None) := 3573918927(bytes4)
			TMP_1011(bool) = INTERNAL_CALL, SafeERC20._makeCalldataCall(IERC20,bytes4,bytes)(token_1,REF_346,permit_1)
			RETURN TMP_1011
		Expression: permit.length == 32 * 8
		IRs:
			REF_347 -> LENGTH permit_1
			TMP_1012(uint256) = 32 (c)* 8
			TMP_1013(bool) = REF_347 == TMP_1012
			CONDITION TMP_1013
		Expression: _makeCalldataCall(token,IDaiLikePermit.permit.selector,permit)
		IRs:
			REF_349(bytes4) (->None) := 2412490508(bytes4)
			TMP_1014(bool) = INTERNAL_CALL, SafeERC20._makeCalldataCall(IERC20,bytes4,bytes)(token_1,REF_349,permit_1)
			RETURN TMP_1014
		Expression: revert SafePermitBadLength()()
		IRs:
			TMP_1015(None) = SOLIDITY_CALL revert SafePermitBadLength()()
	Function SafeERC20._makeCall(IERC20,bytes4,address,uint256)
		IRs:
			token_1(IERC20) := ϕ(['token_1', 'token_1'])
			selector_1(bytes4) := ϕ(['REF_338', 'REF_340', 'REF_336', 'REF_334'])
			to_1(address) := ϕ(['spender_1', 'to_1'])
			amount_1(uint256) := ϕ(['value_1', 'value_1'])
		Expression: data__makeCall_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_1016(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data__makeCall_asm_0_1(uint256) := TMP_1016(uint256)
		Expression: mstore(uint256,uint256)(data__makeCall_asm_0,selector)
		IRs:
			TMP_1017(None) = SOLIDITY_CALL mstore(uint256,uint256)(data__makeCall_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(data__makeCall_asm_0 + 0x04,to)
		IRs:
			TMP_1018(uint256) = data__makeCall_asm_0_1 + 4
			TMP_1019(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_1018,to_1)
		Expression: mstore(uint256,uint256)(data__makeCall_asm_0 + 0x24,amount)
		IRs:
			TMP_1020(uint256) = data__makeCall_asm_0_1 + 36
			TMP_1021(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_1020,amount_1)
		Expression: success = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data__makeCall_asm_0,0x44,0x0,0x20)
		IRs:
			TMP_1022(uint256) = SOLIDITY_CALL gas()()
			TMP_1023(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_1022,token_1,0,data__makeCall_asm_0_1,68,0,32)
			success_1(bool) := TMP_1023(uint256)
		Expression: success
		IRs:
			CONDITION success_1
		Expression: switch_expr_4503_245_22__makeCall_asm_0 = returndatasize()()
		IRs:
			TMP_1024(uint256) = SOLIDITY_CALL returndatasize()()
			switch_expr_4503_245_22__makeCall_asm_0_1(uint256) := TMP_1024(uint256)
		Expression: switch_expr_4503_245_22__makeCall_asm_0 == 0
		IRs:
			TMP_1025(bool) = switch_expr_4503_245_22__makeCall_asm_0_1 == 0
			CONDITION TMP_1025
		IRs:
			success_4(bool) := ϕ(['success_2', 'success_3'])
		Expression: success = extcodesize(uint256)(token) > 0
		IRs:
			REF_350(None) -> token_1.codesize
			TMP_1026(bool) = REF_350 > 0
			success_2(bool) := TMP_1026(bool)
		Expression: success = returndatasize()() > 31 & mload(uint256)(0) == 1
		IRs:
			TMP_1027(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_1028(bool) = TMP_1027 > 31
			TMP_1029(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_1030(bool) = TMP_1029 == 1
			TMP_1031(bool) = TMP_1028 & TMP_1030
			success_3(bool) := TMP_1031(bool)
		Expression: success
		IRs:
			RETURN success_4
	Function SafeERC20._makeCalldataCall(IERC20,bytes4,bytes)
		IRs:
			token_1(IERC20) := ϕ(['token_1'])
			selector_1(bytes4) := ϕ(['REF_346', 'REF_349'])
			args_1(bytes) := ϕ(['permit_1'])
		Expression: len__makeCalldataCall_asm_0 = 4 + args
		IRs:
			TMP_1032(uint256) = 4 + args_1
			len__makeCalldataCall_asm_0_1(uint256) := TMP_1032(uint256)
		Expression: data__makeCalldataCall_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_1033(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data__makeCalldataCall_asm_0_1(uint256) := TMP_1033(uint256)
		Expression: mstore(uint256,uint256)(data__makeCalldataCall_asm_0,selector)
		IRs:
			TMP_1034(None) = SOLIDITY_CALL mstore(uint256,uint256)(data__makeCalldataCall_asm_0_1,selector_1)
		Expression: calldatacopy(uint256,uint256,uint256)(data__makeCalldataCall_asm_0 + 0x04,args,args)
		IRs:
			TMP_1035(uint256) = data__makeCalldataCall_asm_0_1 + 4
			TMP_1036(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_1035,args_1,args_1)
		Expression: success = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data__makeCalldataCall_asm_0,len__makeCalldataCall_asm_0,0x0,0x20)
		IRs:
			TMP_1037(uint256) = SOLIDITY_CALL gas()()
			TMP_1038(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_1037,token_1,0,data__makeCalldataCall_asm_0_1,len__makeCalldataCall_asm_0_1,0,32)
			success_1(bool) := TMP_1038(uint256)
		Expression: success
		IRs:
			CONDITION success_1
		Expression: switch_expr_5322_245_22__makeCalldataCall_asm_0 = returndatasize()()
		IRs:
			TMP_1039(uint256) = SOLIDITY_CALL returndatasize()()
			switch_expr_5322_245_22__makeCalldataCall_asm_0_1(uint256) := TMP_1039(uint256)
		Expression: switch_expr_5322_245_22__makeCalldataCall_asm_0 == 0
		IRs:
			TMP_1040(bool) = switch_expr_5322_245_22__makeCalldataCall_asm_0_1 == 0
			CONDITION TMP_1040
		IRs:
			success_4(bool) := ϕ(['success_2', 'success_3'])
		Expression: success = extcodesize(uint256)(token) > 0
		IRs:
			REF_351(None) -> token_1.codesize
			TMP_1041(bool) = REF_351 > 0
			success_3(bool) := TMP_1041(bool)
		Expression: success = returndatasize()() > 31 & mload(uint256)(0) == 1
		IRs:
			TMP_1042(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_1043(bool) = TMP_1042 > 31
			TMP_1044(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_1045(bool) = TMP_1044 == 1
			TMP_1046(bool) = TMP_1043 & TMP_1045
			success_2(bool) := TMP_1046(bool)
		Expression: success
		IRs:
			RETURN success_4
Contract Ownable
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_1047(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_1047)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_1049(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_1050(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_1051(bool) = TMP_1049 == TMP_1050
			TMP_1052(None) = SOLIDITY_CALL require(bool,string)(TMP_1051,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_1053 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_1053)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_1056 = CONVERT 0 to address
			TMP_1057(bool) = newOwner_1 != TMP_1056
			TMP_1058(None) = SOLIDITY_CALL require(bool,string)(TMP_1057,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['TMP_1047', 'newOwner_1', 'TMP_1053'])
			_owner_2(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
Contract ERC20
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20.constructor(string,string)
		IRs:
			name__1(string) := ϕ(['name_1', 'name__1', 'name__1', 'name__1', 'name__1'])
			symbol__1(string) := ϕ(['symbol_1', 'symbol__1', 'symbol__1', 'symbol__1', 'symbol__1'])
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_7', '_totalSupply_0', '_totalSupply_4'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_0', '_balances_5', '_balances_1', '_balances_8'])
		Expression: _balances[account]
		IRs:
			REF_352(uint256) -> _balances_1[account_1]
			RETURN REF_352
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_1063(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_1063(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_1', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_353(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_354(uint256) -> REF_353[spender_1]
			RETURN REF_354
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_1065(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_1065(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_1067(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_1067(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_1070(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_1070(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_1071(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_1072(uint256) = TMP_1071 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_1072)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_1074(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_1074(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_1075(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_1075(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_1076(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_1077(None) = SOLIDITY_CALL require(bool,string)(TMP_1076,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_1078(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_1078)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'owner_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_0', '_balances_5', '_balances_1', '_balances_8'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_1080 = CONVERT 0 to address
			TMP_1081(bool) = from_1 != TMP_1080
			TMP_1082(None) = SOLIDITY_CALL require(bool,string)(TMP_1081,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_1083 = CONVERT 0 to address
			TMP_1084(bool) = to_1 != TMP_1083
			TMP_1085(None) = SOLIDITY_CALL require(bool,string)(TMP_1084,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_355(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_355(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_1087(bool) = fromBalance_1 >= amount_1
			TMP_1088(None) = SOLIDITY_CALL require(bool,string)(TMP_1087,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_356(uint256) -> _balances_3[from_1]
			TMP_1089(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_356(uint256) (->_balances_4) := TMP_1089(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_357(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_357(-> _balances_5) = REF_357 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_0', '_balances_5', '_balances_1', '_balances_8'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_7', '_totalSupply_0', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_1092 = CONVERT 0 to address
			TMP_1093(bool) = account_1 != TMP_1092
			TMP_1094(None) = SOLIDITY_CALL require(bool,string)(TMP_1093,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_1095 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_1095,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_358(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_358(-> _balances_8) = REF_358 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_1097 = CONVERT 0 to address
			Emit Transfer(TMP_1097,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_1099 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_1099,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_0', '_balances_5', '_balances_1', '_balances_8'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_7', '_totalSupply_0', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_1101 = CONVERT 0 to address
			TMP_1102(bool) = account_1 != TMP_1101
			TMP_1103(None) = SOLIDITY_CALL require(bool,string)(TMP_1102,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_1104 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_1104,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_359(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_359(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_1106(bool) = accountBalance_1 >= amount_1
			TMP_1107(None) = SOLIDITY_CALL require(bool,string)(TMP_1106,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_360(uint256) -> _balances_10[account_1]
			TMP_1108(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_360(uint256) (->_balances_11) := TMP_1108(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_1109 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_1109,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_1111 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_1111,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_1126', 'amount_1', 'TMP_1072', 'TMP_1078'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_1113 = CONVERT 0 to address
			TMP_1114(bool) = owner_1 != TMP_1113
			TMP_1115(None) = SOLIDITY_CALL require(bool,string)(TMP_1114,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_1116 = CONVERT 0 to address
			TMP_1117(bool) = spender_1 != TMP_1116
			TMP_1118(None) = SOLIDITY_CALL require(bool,string)(TMP_1117,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_361(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_362(uint256) -> REF_361[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_362(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_1120(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_1120(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_1122(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_1123(bool) = currentAllowance_1 != TMP_1122
			CONDITION TMP_1123
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_1124(bool) = currentAllowance_1 >= amount_1
			TMP_1125(None) = SOLIDITY_CALL require(bool,string)(TMP_1124,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_1126(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_1126)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_1095', 'from_1', 'account_1'])
			to_1(address) := ϕ(['to_1', 'account_1', 'TMP_1104'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'TMP_1099', 'account_1'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_1111'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
Contract IERC20
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
Contract IERC20Metadata
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
Contract IERC20Permit
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32)
	Function IERC20Permit.nonces(address)
	Function IERC20Permit.DOMAIN_SEPARATOR()
Contract Address
	Function Address.isContract(address)
		IRs:
			account_1(address) := ϕ(['target_1'])
		Expression: account.code.length > 0
		IRs:
			TMP_1128(bytes) = SOLIDITY_CALL code(address)(account_1)
			REF_363 -> LENGTH TMP_1128
			TMP_1129(bool) = REF_363 > 0
			RETURN TMP_1129
	Function Address.sendValue(address,uint256)
		Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)
		IRs:
			TMP_1130 = CONVERT this to address
			TMP_1131(uint256) = SOLIDITY_CALL balance(address)(TMP_1130)
			TMP_1132(bool) = TMP_1131 >= amount_1
			TMP_1133(None) = SOLIDITY_CALL require(bool,string)(TMP_1132,Address: insufficient balance)
		Expression: (success,None) = recipient.call{value: amount}()
		IRs:
			TUPLE_0(bool,bytes) = LOW_LEVEL_CALL, dest:recipient_1, function:call, arguments:[''] value:amount_1 
			success_1(bool)= UNPACK TUPLE_0 index: 0 
		Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)
		IRs:
			TMP_1134(None) = SOLIDITY_CALL require(bool,string)(success_1,Address: unable to send value, recipient may have reverted)
	Function Address.functionCall(address,bytes)
		Expression: functionCallWithValue(target,data,0,Address: low-level call failed)
		IRs:
			TMP_1135(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target_1,data_1,0,Address: low-level call failed)
			RETURN TMP_1135
	Function Address.functionCall(address,bytes,string)
		Expression: functionCallWithValue(target,data,0,errorMessage)
		IRs:
			TMP_1136(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target_1,data_1,0,errorMessage_1)
			RETURN TMP_1136
	Function Address.functionCallWithValue(address,bytes,uint256)
		Expression: functionCallWithValue(target,data,value,Address: low-level call with value failed)
		IRs:
			TMP_1137(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target_1,data_1,value_1,Address: low-level call with value failed)
			RETURN TMP_1137
	Function Address.functionCallWithValue(address,bytes,uint256,string)
		IRs:
			target_1(address) := ϕ(['target_1', 'target_1', 'target_1'])
			data_1(bytes) := ϕ(['data_1', 'data_1', 'data_1'])
			value_1(uint256) := ϕ(['value_1'])
			errorMessage_1(string) := ϕ(['errorMessage_1'])
		Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)
		IRs:
			TMP_1138 = CONVERT this to address
			TMP_1139(uint256) = SOLIDITY_CALL balance(address)(TMP_1138)
			TMP_1140(bool) = TMP_1139 >= value_1
			TMP_1141(None) = SOLIDITY_CALL require(bool,string)(TMP_1140,Address: insufficient balance for call)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_1(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:call, arguments:['data_1'] value:value_1 
			success_1(bool)= UNPACK TUPLE_1 index: 0 
			returndata_1(bytes)= UNPACK TUPLE_1 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_1142(bytes) = INTERNAL_CALL, Address.verifyCallResultFromTarget(address,bool,bytes,string)(target_1,success_1,returndata_1,errorMessage_1)
			RETURN TMP_1142
	Function Address.functionStaticCall(address,bytes)
		Expression: functionStaticCall(target,data,Address: low-level static call failed)
		IRs:
			TMP_1143(bytes) = INTERNAL_CALL, Address.functionStaticCall(address,bytes,string)(target_1,data_1,Address: low-level static call failed)
			RETURN TMP_1143
	Function Address.functionStaticCall(address,bytes,string)
		IRs:
			target_1(address) := ϕ(['target_1'])
			data_1(bytes) := ϕ(['data_1'])
		Expression: (success,returndata) = target.staticcall(data)
		IRs:
			TUPLE_2(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:staticcall, arguments:['data_1']  
			success_1(bool)= UNPACK TUPLE_2 index: 0 
			returndata_1(bytes)= UNPACK TUPLE_2 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_1144(bytes) = INTERNAL_CALL, Address.verifyCallResultFromTarget(address,bool,bytes,string)(target_1,success_1,returndata_1,errorMessage_1)
			RETURN TMP_1144
	Function Address.functionDelegateCall(address,bytes)
		Expression: functionDelegateCall(target,data,Address: low-level delegate call failed)
		IRs:
			TMP_1145(bytes) = INTERNAL_CALL, Address.functionDelegateCall(address,bytes,string)(target_1,data_1,Address: low-level delegate call failed)
			RETURN TMP_1145
	Function Address.functionDelegateCall(address,bytes,string)
		IRs:
			target_1(address) := ϕ(['target_1'])
			data_1(bytes) := ϕ(['data_1'])
		Expression: (success,returndata) = target.delegatecall(data)
		IRs:
			TUPLE_3(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:delegatecall, arguments:['data_1']  
			success_1(bool)= UNPACK TUPLE_3 index: 0 
			returndata_1(bytes)= UNPACK TUPLE_3 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_1146(bytes) = INTERNAL_CALL, Address.verifyCallResultFromTarget(address,bool,bytes,string)(target_1,success_1,returndata_1,errorMessage_1)
			RETURN TMP_1146
	Function Address.verifyCallResultFromTarget(address,bool,bytes,string)
		IRs:
			target_1(address) := ϕ(['target_1', 'target_1', 'target_1'])
			success_1(bool) := ϕ(['success_1', 'success_1', 'success_1'])
			returndata_1(bytes) := ϕ(['returndata_1', 'returndata_1', 'returndata_1'])
			errorMessage_1(string) := ϕ(['errorMessage_1', 'errorMessage_1', 'errorMessage_1'])
		Expression: success
		IRs:
			CONDITION success_1
		Expression: returndata.length == 0
		IRs:
			REF_368 -> LENGTH returndata_1
			TMP_1147(bool) = REF_368 == 0
			CONDITION TMP_1147
		Expression: require(bool,string)(isContract(target),Address: call to non-contract)
		IRs:
			TMP_1148(bool) = INTERNAL_CALL, Address.isContract(address)(target_1)
			TMP_1149(None) = SOLIDITY_CALL require(bool,string)(TMP_1148,Address: call to non-contract)
		Expression: returndata
		IRs:
			RETURN returndata_1
		Expression: _revert(returndata,errorMessage)
		IRs:
			INTERNAL_CALL, Address._revert(bytes,string)(returndata_1,errorMessage_1)
	Function Address.verifyCallResult(bool,bytes,string)
		Expression: success
		IRs:
			CONDITION success_1
		Expression: returndata
		IRs:
			RETURN returndata_1
		Expression: _revert(returndata,errorMessage)
		IRs:
			INTERNAL_CALL, Address._revert(bytes,string)(returndata_1,errorMessage_1)
	Function Address._revert(bytes,string)
		IRs:
			returndata_1(bytes) := ϕ(['returndata_1', 'returndata_1'])
			errorMessage_1(string) := ϕ(['errorMessage_1', 'errorMessage_1'])
		Expression: returndata.length > 0
		IRs:
			REF_369 -> LENGTH returndata_1
			TMP_1152(bool) = REF_369 > 0
			CONDITION TMP_1152
		Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)
		IRs:
			TMP_1153(uint256) = SOLIDITY_CALL mload(uint256)(returndata_1)
			returndata_size__revert_asm_0_1(uint256) := TMP_1153(uint256)
		Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)
		IRs:
			TMP_1154(uint256) = 32 + returndata_1
			TMP_1155(None) = SOLIDITY_CALL revert(uint256,uint256)(TMP_1154,returndata_size__revert_asm_0_1)
		Expression: revert(string)(errorMessage)
		IRs:
			TMP_1156(None) = SOLIDITY_CALL revert(string)(errorMessage_1)
Contract Context
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
Contract Math
	Function Math.max(uint256,uint256)
		Expression: a > b
		IRs:
			TMP_1157(bool) = a_1 > b_1
			CONDITION TMP_1157
		Expression: a
		IRs:
			RETURN a_1
		Expression: b
		IRs:
			RETURN b_1
	Function Math.min(uint256,uint256)
		IRs:
			a_1(uint256) := ϕ(['result_8'])
			b_1(uint256) := ϕ(['TMP_1235'])
		Expression: a < b
		IRs:
			TMP_1158(bool) = a_1 < b_1
			CONDITION TMP_1158
		Expression: a
		IRs:
			RETURN a_1
		Expression: b
		IRs:
			RETURN b_1
	Function Math.average(uint256,uint256)
		Expression: (a & b) + (a ^ b) / 2
		IRs:
			TMP_1159(uint256) = a_1 & b_1
			TMP_1160(uint256) = a_1 ^ b_1
			TMP_1161(uint256) = TMP_1160 (c)/ 2
			TMP_1162(uint256) = TMP_1159 (c)+ TMP_1161
			RETURN TMP_1162
	Function Math.ceilDiv(uint256,uint256)
		Expression: a == 0
		IRs:
			TMP_1163(bool) = a_1 == 0
			CONDITION TMP_1163
		Expression: 0
		IRs:
			RETURN 0
		Expression: (a - 1) / b + 1
		IRs:
			TMP_1164(uint256) = a_1 (c)- 1
			TMP_1165(uint256) = TMP_1164 (c)/ b_1
			TMP_1166(uint256) = TMP_1165 (c)+ 1
			RETURN TMP_1166
	Function Math.mulDiv(uint256,uint256,uint256)
		IRs:
			x_1(uint256) := ϕ(['x_1'])
			y_1(uint256) := ϕ(['y_1'])
			denominator_1(uint256) := ϕ(['denominator_1'])
		Expression: mm_mulDiv_asm_0 = mulmod(uint256,uint256,uint256)(x,y,~ 0)
		IRs:
			TMP_1167 = UnaryType.TILD 0 
			TMP_1168(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x_1,y_1,TMP_1167)
			mm_mulDiv_asm_0_1(uint256) := TMP_1168(uint256)
		Expression: prod0 = x * y
		IRs:
			TMP_1169(uint256) = x_1 * y_1
			prod0_1(uint256) := TMP_1169(uint256)
		Expression: prod1 = mm_mulDiv_asm_0 - prod0 - mm_mulDiv_asm_0 < prod0
		IRs:
			TMP_1170(uint256) = mm_mulDiv_asm_0_1 - prod0_1
			TMP_1171(bool) = mm_mulDiv_asm_0_1 < prod0_1
			TMP_1172(uint256) = TMP_1170 - TMP_1171
			prod1_1(uint256) := TMP_1172(uint256)
		Expression: prod1 == 0
		IRs:
			TMP_1173(bool) = prod1_1 == 0
			CONDITION TMP_1173
		Expression: prod0 / denominator
		IRs:
			TMP_1174(uint256) = prod0_1 / denominator_1
			RETURN TMP_1174
		Expression: require(bool)(denominator > prod1)
		IRs:
			TMP_1175(bool) = denominator_1 > prod1_1
			TMP_1176(None) = SOLIDITY_CALL require(bool)(TMP_1175)
		Expression: remainder = mulmod(uint256,uint256,uint256)(x,y,denominator)
		IRs:
			TMP_1177(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x_1,y_1,denominator_1)
			remainder_1(uint256) := TMP_1177(uint256)
		Expression: prod1 = prod1 - remainder > prod0
		IRs:
			TMP_1178(bool) = remainder_1 > prod0_1
			TMP_1179(uint256) = prod1_1 - TMP_1178
			prod1_2(uint256) := TMP_1179(uint256)
		Expression: prod0 = prod0 - remainder
		IRs:
			TMP_1180(uint256) = prod0_1 - remainder_1
			prod0_2(uint256) := TMP_1180(uint256)
		Expression: twos = denominator & (~ denominator + 1)
		IRs:
			TMP_1181 = UnaryType.TILD denominator_1 
			TMP_1182(uint256) = TMP_1181 + 1
			TMP_1183(uint256) = denominator_1 & TMP_1182
			twos_1(uint256) := TMP_1183(uint256)
		Expression: denominator = denominator / twos
		IRs:
			TMP_1184(uint256) = denominator_1 / twos_1
			denominator_2(uint256) := TMP_1184(uint256)
		Expression: prod0 = prod0 / twos
		IRs:
			TMP_1185(uint256) = prod0_2 / twos_1
			prod0_3(uint256) := TMP_1185(uint256)
		Expression: twos = 0 - twos / twos + 1
		IRs:
			TMP_1186(uint256) = 0 - twos_1
			TMP_1187(uint256) = TMP_1186 / twos_1
			TMP_1188(uint256) = TMP_1187 + 1
			twos_2(uint256) := TMP_1188(uint256)
		Expression: prod0 |= prod1 * twos
		IRs:
			TMP_1189(uint256) = prod1_2 * twos_2
			prod0_4(uint256) = prod0_3 | TMP_1189
		Expression: inverse = (3 * denominator) ^ 2
		IRs:
			TMP_1190(uint256) = 3 * denominator_2
			TMP_1191(uint256) = TMP_1190 ^ 2
			inverse_1(uint256) := TMP_1191(uint256)
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1192(uint256) = denominator_2 * inverse_1
			TMP_1193(uint256) = 2 - TMP_1192
			inverse_2(uint256) = inverse_1 * TMP_1193
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1194(uint256) = denominator_2 * inverse_2
			TMP_1195(uint256) = 2 - TMP_1194
			inverse_3(uint256) = inverse_2 * TMP_1195
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1196(uint256) = denominator_2 * inverse_3
			TMP_1197(uint256) = 2 - TMP_1196
			inverse_4(uint256) = inverse_3 * TMP_1197
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1198(uint256) = denominator_2 * inverse_4
			TMP_1199(uint256) = 2 - TMP_1198
			inverse_5(uint256) = inverse_4 * TMP_1199
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1200(uint256) = denominator_2 * inverse_5
			TMP_1201(uint256) = 2 - TMP_1200
			inverse_6(uint256) = inverse_5 * TMP_1201
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1202(uint256) = denominator_2 * inverse_6
			TMP_1203(uint256) = 2 - TMP_1202
			inverse_7(uint256) = inverse_6 * TMP_1203
		Expression: result = prod0 * inverse
		IRs:
			TMP_1204(uint256) = prod0_4 * inverse_7
			result_1(uint256) := TMP_1204(uint256)
		Expression: result
		IRs:
			RETURN result_1
		Expression: result
	Function Math.mulDiv(uint256,uint256,uint256,Math.Rounding)
		Expression: result = mulDiv(x,y,denominator)
		IRs:
			TMP_1205(uint256) = INTERNAL_CALL, Math.mulDiv(uint256,uint256,uint256)(x_1,y_1,denominator_1)
			result_1(uint256) := TMP_1205(uint256)
		Expression: rounding == Rounding.Up && mulmod(uint256,uint256,uint256)(x,y,denominator) > 0
		IRs:
			REF_370(Math.Rounding) -> Rounding.Up
			TMP_1206(bool) = rounding_1 == REF_370
			TMP_1207(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x_1,y_1,denominator_1)
			TMP_1208(bool) = TMP_1207 > 0
			TMP_1209(bool) = TMP_1206 && TMP_1208
			CONDITION TMP_1209
		Expression: result += 1
		IRs:
			result_2(uint256) = result_1 (c)+ 1
		IRs:
			result_3(uint256) := ϕ(['result_2', 'result_1'])
		Expression: result
		IRs:
			RETURN result_3
	Function Math.sqrt(uint256)
		IRs:
			a_1(uint256) := ϕ(['a_1'])
		Expression: a == 0
		IRs:
			TMP_1210(bool) = a_1 == 0
			CONDITION TMP_1210
		Expression: 0
		IRs:
			RETURN 0
		Expression: result = 1 << (log2(a) >> 1)
		IRs:
			TMP_1211(uint256) = INTERNAL_CALL, Math.log2(uint256)(a_1)
			TMP_1212(uint256) = TMP_1211 >> 1
			TMP_1213(uint256) = 1 << TMP_1212
			result_1(uint256) := TMP_1213(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1214(uint256) = a_1 / result_1
			TMP_1215(uint256) = result_1 + TMP_1214
			TMP_1216(uint256) = TMP_1215 >> 1
			result_2(uint256) := TMP_1216(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1217(uint256) = a_1 / result_2
			TMP_1218(uint256) = result_2 + TMP_1217
			TMP_1219(uint256) = TMP_1218 >> 1
			result_3(uint256) := TMP_1219(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1220(uint256) = a_1 / result_3
			TMP_1221(uint256) = result_3 + TMP_1220
			TMP_1222(uint256) = TMP_1221 >> 1
			result_4(uint256) := TMP_1222(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1223(uint256) = a_1 / result_4
			TMP_1224(uint256) = result_4 + TMP_1223
			TMP_1225(uint256) = TMP_1224 >> 1
			result_5(uint256) := TMP_1225(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1226(uint256) = a_1 / result_5
			TMP_1227(uint256) = result_5 + TMP_1226
			TMP_1228(uint256) = TMP_1227 >> 1
			result_6(uint256) := TMP_1228(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1229(uint256) = a_1 / result_6
			TMP_1230(uint256) = result_6 + TMP_1229
			TMP_1231(uint256) = TMP_1230 >> 1
			result_7(uint256) := TMP_1231(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1232(uint256) = a_1 / result_7
			TMP_1233(uint256) = result_7 + TMP_1232
			TMP_1234(uint256) = TMP_1233 >> 1
			result_8(uint256) := TMP_1234(uint256)
		Expression: min(result,a / result)
		IRs:
			TMP_1235(uint256) = a_1 / result_8
			TMP_1236(uint256) = INTERNAL_CALL, Math.min(uint256,uint256)(result_8,TMP_1235)
			RETURN TMP_1236
	Function Math.sqrt(uint256,Math.Rounding)
		Expression: result = sqrt(a)
		IRs:
			TMP_1237(uint256) = INTERNAL_CALL, Math.sqrt(uint256)(a_1)
			result_1(uint256) := TMP_1237(uint256)
		Expression: rounding == Rounding.Up && result * result < a
		IRs:
			REF_371(Math.Rounding) -> Rounding.Up
			TMP_1238(bool) = rounding_1 == REF_371
			TMP_1239(uint256) = result_1 * result_1
			TMP_1240(bool) = TMP_1239 < a_1
			TMP_1241(bool) = TMP_1238 && TMP_1240
			CONDITION TMP_1241
		Expression: result + 1
		IRs:
			TMP_1242(uint256) = result_1 + 1
			RETURN TMP_1242
		Expression: result + 0
		IRs:
			TMP_1243(uint256) = result_1 + 0
			RETURN TMP_1243
	Function Math.log2(uint256)
		IRs:
			value_1(uint256) := ϕ(['value_1', 'a_1'])
		Expression: result = 0
		IRs:
			result_1(uint256) := 0(uint256)
		Expression: value >> 128 > 0
		IRs:
			TMP_1244(uint256) = value_1 >> 128
			TMP_1245(bool) = TMP_1244 > 0
			CONDITION TMP_1245
		Expression: value >>= 128
		IRs:
			value_2(uint256) = value_1 >> 128
		Expression: result += 128
		IRs:
			result_2(uint256) = result_1 + 128
		IRs:
			value_3(uint256) := ϕ(['value_2', 'value_1'])
			result_3(uint256) := ϕ(['result_2', 'result_1'])
		Expression: value >> 64 > 0
		IRs:
			TMP_1246(uint256) = value_3 >> 64
			TMP_1247(bool) = TMP_1246 > 0
			CONDITION TMP_1247
		Expression: value >>= 64
		IRs:
			value_4(uint256) = value_3 >> 64
		Expression: result += 64
		IRs:
			result_4(uint256) = result_3 + 64
		IRs:
			value_5(uint256) := ϕ(['value_1', 'value_4'])
			result_5(uint256) := ϕ(['result_4', 'result_1'])
		Expression: value >> 32 > 0
		IRs:
			TMP_1248(uint256) = value_5 >> 32
			TMP_1249(bool) = TMP_1248 > 0
			CONDITION TMP_1249
		Expression: value >>= 32
		IRs:
			value_6(uint256) = value_5 >> 32
		Expression: result += 32
		IRs:
			result_6(uint256) = result_5 + 32
		IRs:
			value_7(uint256) := ϕ(['value_6', 'value_1'])
			result_7(uint256) := ϕ(['result_6', 'result_1'])
		Expression: value >> 16 > 0
		IRs:
			TMP_1250(uint256) = value_7 >> 16
			TMP_1251(bool) = TMP_1250 > 0
			CONDITION TMP_1251
		Expression: value >>= 16
		IRs:
			value_8(uint256) = value_7 >> 16
		Expression: result += 16
		IRs:
			result_8(uint256) = result_7 + 16
		IRs:
			value_9(uint256) := ϕ(['value_1', 'value_8'])
			result_9(uint256) := ϕ(['result_8', 'result_1'])
		Expression: value >> 8 > 0
		IRs:
			TMP_1252(uint256) = value_9 >> 8
			TMP_1253(bool) = TMP_1252 > 0
			CONDITION TMP_1253
		Expression: value >>= 8
		IRs:
			value_10(uint256) = value_9 >> 8
		Expression: result += 8
		IRs:
			result_10(uint256) = result_9 + 8
		IRs:
			value_11(uint256) := ϕ(['value_10', 'value_1'])
			result_11(uint256) := ϕ(['result_10', 'result_1'])
		Expression: value >> 4 > 0
		IRs:
			TMP_1254(uint256) = value_11 >> 4
			TMP_1255(bool) = TMP_1254 > 0
			CONDITION TMP_1255
		Expression: value >>= 4
		IRs:
			value_12(uint256) = value_11 >> 4
		Expression: result += 4
		IRs:
			result_12(uint256) = result_11 + 4
		IRs:
			value_13(uint256) := ϕ(['value_1', 'value_12'])
			result_13(uint256) := ϕ(['result_12', 'result_1'])
		Expression: value >> 2 > 0
		IRs:
			TMP_1256(uint256) = value_13 >> 2
			TMP_1257(bool) = TMP_1256 > 0
			CONDITION TMP_1257
		Expression: value >>= 2
		IRs:
			value_14(uint256) = value_13 >> 2
		Expression: result += 2
		IRs:
			result_14(uint256) = result_13 + 2
		IRs:
			value_15(uint256) := ϕ(['value_14', 'value_1'])
			result_15(uint256) := ϕ(['result_14', 'result_1'])
		Expression: value >> 1 > 0
		IRs:
			TMP_1258(uint256) = value_15 >> 1
			TMP_1259(bool) = TMP_1258 > 0
			CONDITION TMP_1259
		Expression: result += 1
		IRs:
			result_16(uint256) = result_15 + 1
		IRs:
			result_17(uint256) := ϕ(['result_16', 'result_1'])
		Expression: result
		IRs:
			RETURN result_17
	Function Math.log2(uint256,Math.Rounding)
		Expression: result = log2(value)
		IRs:
			TMP_1260(uint256) = INTERNAL_CALL, Math.log2(uint256)(value_1)
			result_1(uint256) := TMP_1260(uint256)
		Expression: rounding == Rounding.Up && 1 << result < value
		IRs:
			REF_372(Math.Rounding) -> Rounding.Up
			TMP_1261(bool) = rounding_1 == REF_372
			TMP_1262(uint256) = 1 << result_1
			TMP_1263(bool) = TMP_1262 < value_1
			TMP_1264(bool) = TMP_1261 && TMP_1263
			CONDITION TMP_1264
		Expression: result + 1
		IRs:
			TMP_1265(uint256) = result_1 + 1
			RETURN TMP_1265
		Expression: result + 0
		IRs:
			TMP_1266(uint256) = result_1 + 0
			RETURN TMP_1266
	Function Math.log10(uint256)
		IRs:
			value_1(uint256) := ϕ(['value_1'])
		Expression: result = 0
		IRs:
			result_1(uint256) := 0(uint256)
		Expression: value >= 10 ** 64
		IRs:
			TMP_1267(uint256) = 10 ** 64
			TMP_1268(bool) = value_1 >= TMP_1267
			CONDITION TMP_1268
		Expression: value /= 10 ** 64
		IRs:
			TMP_1269(uint256) = 10 ** 64
			value_2(uint256) = value_1 / TMP_1269
		Expression: result += 64
		IRs:
			result_2(uint256) = result_1 + 64
		IRs:
			value_3(uint256) := ϕ(['value_2', 'value_1'])
			result_3(uint256) := ϕ(['result_2', 'result_1'])
		Expression: value >= 10 ** 32
		IRs:
			TMP_1270(uint256) = 10 ** 32
			TMP_1271(bool) = value_3 >= TMP_1270
			CONDITION TMP_1271
		Expression: value /= 10 ** 32
		IRs:
			TMP_1272(uint256) = 10 ** 32
			value_4(uint256) = value_3 / TMP_1272
		Expression: result += 32
		IRs:
			result_4(uint256) = result_3 + 32
		IRs:
			value_5(uint256) := ϕ(['value_4', 'value_1'])
			result_5(uint256) := ϕ(['result_1', 'result_4'])
		Expression: value >= 10 ** 16
		IRs:
			TMP_1273(uint256) = 10 ** 16
			TMP_1274(bool) = value_5 >= TMP_1273
			CONDITION TMP_1274
		Expression: value /= 10 ** 16
		IRs:
			TMP_1275(uint256) = 10 ** 16
			value_6(uint256) = value_5 / TMP_1275
		Expression: result += 16
		IRs:
			result_6(uint256) = result_5 + 16
		IRs:
			value_7(uint256) := ϕ(['value_6', 'value_1'])
			result_7(uint256) := ϕ(['result_6', 'result_1'])
		Expression: value >= 10 ** 8
		IRs:
			TMP_1276(uint256) = 10 ** 8
			TMP_1277(bool) = value_7 >= TMP_1276
			CONDITION TMP_1277
		Expression: value /= 10 ** 8
		IRs:
			TMP_1278(uint256) = 10 ** 8
			value_8(uint256) = value_7 / TMP_1278
		Expression: result += 8
		IRs:
			result_8(uint256) = result_7 + 8
		IRs:
			value_9(uint256) := ϕ(['value_8', 'value_1'])
			result_9(uint256) := ϕ(['result_1', 'result_8'])
		Expression: value >= 10 ** 4
		IRs:
			TMP_1279(uint256) = 10 ** 4
			TMP_1280(bool) = value_9 >= TMP_1279
			CONDITION TMP_1280
		Expression: value /= 10 ** 4
		IRs:
			TMP_1281(uint256) = 10 ** 4
			value_10(uint256) = value_9 / TMP_1281
		Expression: result += 4
		IRs:
			result_10(uint256) = result_9 + 4
		IRs:
			value_11(uint256) := ϕ(['value_10', 'value_1'])
			result_11(uint256) := ϕ(['result_10', 'result_1'])
		Expression: value >= 10 ** 2
		IRs:
			TMP_1282(uint256) = 10 ** 2
			TMP_1283(bool) = value_11 >= TMP_1282
			CONDITION TMP_1283
		Expression: value /= 10 ** 2
		IRs:
			TMP_1284(uint256) = 10 ** 2
			value_12(uint256) = value_11 / TMP_1284
		Expression: result += 2
		IRs:
			result_12(uint256) = result_11 + 2
		IRs:
			value_13(uint256) := ϕ(['value_12', 'value_1'])
			result_13(uint256) := ϕ(['result_1', 'result_12'])
		Expression: value >= 10 ** 1
		IRs:
			TMP_1285(uint256) = 10 ** 1
			TMP_1286(bool) = value_13 >= TMP_1285
			CONDITION TMP_1286
		Expression: result += 1
		IRs:
			result_14(uint256) = result_13 + 1
		IRs:
			result_15(uint256) := ϕ(['result_1', 'result_14'])
		Expression: result
		IRs:
			RETURN result_15
	Function Math.log10(uint256,Math.Rounding)
		Expression: result = log10(value)
		IRs:
			TMP_1287(uint256) = INTERNAL_CALL, Math.log10(uint256)(value_1)
			result_1(uint256) := TMP_1287(uint256)
		Expression: rounding == Rounding.Up && 10 ** result < value
		IRs:
			REF_373(Math.Rounding) -> Rounding.Up
			TMP_1288(bool) = rounding_1 == REF_373
			TMP_1289(uint256) = 10 ** result_1
			TMP_1290(bool) = TMP_1289 < value_1
			TMP_1291(bool) = TMP_1288 && TMP_1290
			CONDITION TMP_1291
		Expression: result + 1
		IRs:
			TMP_1292(uint256) = result_1 + 1
			RETURN TMP_1292
		Expression: result + 0
		IRs:
			TMP_1293(uint256) = result_1 + 0
			RETURN TMP_1293
	Function Math.log256(uint256)
		IRs:
			value_1(uint256) := ϕ(['value_1'])
		Expression: result = 0
		IRs:
			result_1(uint256) := 0(uint256)
		Expression: value >> 128 > 0
		IRs:
			TMP_1294(uint256) = value_1 >> 128
			TMP_1295(bool) = TMP_1294 > 0
			CONDITION TMP_1295
		Expression: value >>= 128
		IRs:
			value_2(uint256) = value_1 >> 128
		Expression: result += 16
		IRs:
			result_2(uint256) = result_1 + 16
		IRs:
			value_3(uint256) := ϕ(['value_2', 'value_1'])
			result_3(uint256) := ϕ(['result_2', 'result_1'])
		Expression: value >> 64 > 0
		IRs:
			TMP_1296(uint256) = value_3 >> 64
			TMP_1297(bool) = TMP_1296 > 0
			CONDITION TMP_1297
		Expression: value >>= 64
		IRs:
			value_4(uint256) = value_3 >> 64
		Expression: result += 8
		IRs:
			result_4(uint256) = result_3 + 8
		IRs:
			value_5(uint256) := ϕ(['value_1', 'value_4'])
			result_5(uint256) := ϕ(['result_1', 'result_4'])
		Expression: value >> 32 > 0
		IRs:
			TMP_1298(uint256) = value_5 >> 32
			TMP_1299(bool) = TMP_1298 > 0
			CONDITION TMP_1299
		Expression: value >>= 32
		IRs:
			value_6(uint256) = value_5 >> 32
		Expression: result += 4
		IRs:
			result_6(uint256) = result_5 + 4
		IRs:
			value_7(uint256) := ϕ(['value_6', 'value_1'])
			result_7(uint256) := ϕ(['result_6', 'result_1'])
		Expression: value >> 16 > 0
		IRs:
			TMP_1300(uint256) = value_7 >> 16
			TMP_1301(bool) = TMP_1300 > 0
			CONDITION TMP_1301
		Expression: value >>= 16
		IRs:
			value_8(uint256) = value_7 >> 16
		Expression: result += 2
		IRs:
			result_8(uint256) = result_7 + 2
		IRs:
			value_9(uint256) := ϕ(['value_1', 'value_8'])
			result_9(uint256) := ϕ(['result_1', 'result_8'])
		Expression: value >> 8 > 0
		IRs:
			TMP_1302(uint256) = value_9 >> 8
			TMP_1303(bool) = TMP_1302 > 0
			CONDITION TMP_1303
		Expression: result += 1
		IRs:
			result_10(uint256) = result_9 + 1
		IRs:
			result_11(uint256) := ϕ(['result_1', 'result_10'])
		Expression: result
		IRs:
			RETURN result_11
	Function Math.log256(uint256,Math.Rounding)
		Expression: result = log256(value)
		IRs:
			TMP_1304(uint256) = INTERNAL_CALL, Math.log256(uint256)(value_1)
			result_1(uint256) := TMP_1304(uint256)
		Expression: rounding == Rounding.Up && 1 << (result * 8) < value
		IRs:
			REF_374(Math.Rounding) -> Rounding.Up
			TMP_1305(bool) = rounding_1 == REF_374
			TMP_1306(uint256) = result_1 * 8
			TMP_1307(uint256) = 1 << TMP_1306
			TMP_1308(bool) = TMP_1307 < value_1
			TMP_1309(bool) = TMP_1305 && TMP_1308
			CONDITION TMP_1309
		Expression: result + 1
		IRs:
			TMP_1310(uint256) = result_1 + 1
			RETURN TMP_1310
		Expression: result + 0
		IRs:
			TMP_1311(uint256) = result_1 + 0
			RETURN TMP_1311
Contract PowerPod
	Function IVotable.votingPowerOf(address)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function VotingPowerCalculator.constructor(uint256,uint256)
		IRs:
			_ONE_E18_1(uint256) := ϕ(['_ONE_E18_0'])
		Expression: origin_ > block.timestamp
		IRs:
			TMP_1312(bool) = origin__1 > block.timestamp
			CONDITION TMP_1312
		Expression: revert OriginInTheFuture()()
		IRs:
			TMP_1313(None) = SOLIDITY_CALL revert OriginInTheFuture()()
		Expression: origin = origin_
		IRs:
			origin_1(uint256) := origin__1(uint256)
		Expression: expBase = expBase_
		IRs:
			expBase_1(uint256) := expBase__1(uint256)
		Expression: _expTable0 = expBase_
		IRs:
			_expTable0_1(uint256) := expBase__1(uint256)
		Expression: _expTable1 = (_expTable0 * _expTable0) / _ONE_E18
		IRs:
			TMP_1314(uint256) = _expTable0_1 (c)* _expTable0_1
			TMP_1315(uint256) = TMP_1314 (c)/ _ONE_E18_1
			_expTable1_1(uint256) := TMP_1315(uint256)
		Expression: _expTable2 = (_expTable1 * _expTable1) / _ONE_E18
		IRs:
			TMP_1316(uint256) = _expTable1_1 (c)* _expTable1_1
			TMP_1317(uint256) = TMP_1316 (c)/ _ONE_E18_1
			_expTable2_1(uint256) := TMP_1317(uint256)
		Expression: _expTable3 = (_expTable2 * _expTable2) / _ONE_E18
		IRs:
			TMP_1318(uint256) = _expTable2_1 (c)* _expTable2_1
			TMP_1319(uint256) = TMP_1318 (c)/ _ONE_E18_1
			_expTable3_1(uint256) := TMP_1319(uint256)
		Expression: _expTable4 = (_expTable3 * _expTable3) / _ONE_E18
		IRs:
			TMP_1320(uint256) = _expTable3_1 (c)* _expTable3_1
			TMP_1321(uint256) = TMP_1320 (c)/ _ONE_E18_1
			_expTable4_1(uint256) := TMP_1321(uint256)
		Expression: _expTable5 = (_expTable4 * _expTable4) / _ONE_E18
		IRs:
			TMP_1322(uint256) = _expTable4_1 (c)* _expTable4_1
			TMP_1323(uint256) = TMP_1322 (c)/ _ONE_E18_1
			_expTable5_1(uint256) := TMP_1323(uint256)
		Expression: _expTable6 = (_expTable5 * _expTable5) / _ONE_E18
		IRs:
			TMP_1324(uint256) = _expTable5_1 (c)* _expTable5_1
			TMP_1325(uint256) = TMP_1324 (c)/ _ONE_E18_1
			_expTable6_1(uint256) := TMP_1325(uint256)
		Expression: _expTable7 = (_expTable6 * _expTable6) / _ONE_E18
		IRs:
			TMP_1326(uint256) = _expTable6_1 (c)* _expTable6_1
			TMP_1327(uint256) = TMP_1326 (c)/ _ONE_E18_1
			_expTable7_1(uint256) := TMP_1327(uint256)
		Expression: _expTable8 = (_expTable7 * _expTable7) / _ONE_E18
		IRs:
			TMP_1328(uint256) = _expTable7_1 (c)* _expTable7_1
			TMP_1329(uint256) = TMP_1328 (c)/ _ONE_E18_1
			_expTable8_1(uint256) := TMP_1329(uint256)
		Expression: _expTable9 = (_expTable8 * _expTable8) / _ONE_E18
		IRs:
			TMP_1330(uint256) = _expTable8_1 (c)* _expTable8_1
			TMP_1331(uint256) = TMP_1330 (c)/ _ONE_E18_1
			_expTable9_1(uint256) := TMP_1331(uint256)
		Expression: _expTable10 = (_expTable9 * _expTable9) / _ONE_E18
		IRs:
			TMP_1332(uint256) = _expTable9_1 (c)* _expTable9_1
			TMP_1333(uint256) = TMP_1332 (c)/ _ONE_E18_1
			_expTable10_1(uint256) := TMP_1333(uint256)
		Expression: _expTable11 = (_expTable10 * _expTable10) / _ONE_E18
		IRs:
			TMP_1334(uint256) = _expTable10_1 (c)* _expTable10_1
			TMP_1335(uint256) = TMP_1334 (c)/ _ONE_E18_1
			_expTable11_1(uint256) := TMP_1335(uint256)
		Expression: _expTable12 = (_expTable11 * _expTable11) / _ONE_E18
		IRs:
			TMP_1336(uint256) = _expTable11_1 (c)* _expTable11_1
			TMP_1337(uint256) = TMP_1336 (c)/ _ONE_E18_1
			_expTable12_1(uint256) := TMP_1337(uint256)
		Expression: _expTable13 = (_expTable12 * _expTable12) / _ONE_E18
		IRs:
			TMP_1338(uint256) = _expTable12_1 (c)* _expTable12_1
			TMP_1339(uint256) = TMP_1338 (c)/ _ONE_E18_1
			_expTable13_1(uint256) := TMP_1339(uint256)
		Expression: _expTable14 = (_expTable13 * _expTable13) / _ONE_E18
		IRs:
			TMP_1340(uint256) = _expTable13_1 (c)* _expTable13_1
			TMP_1341(uint256) = TMP_1340 (c)/ _ONE_E18_1
			_expTable14_1(uint256) := TMP_1341(uint256)
		Expression: _expTable15 = (_expTable14 * _expTable14) / _ONE_E18
		IRs:
			TMP_1342(uint256) = _expTable14_1 (c)* _expTable14_1
			TMP_1343(uint256) = TMP_1342 (c)/ _ONE_E18_1
			_expTable15_1(uint256) := TMP_1343(uint256)
		Expression: _expTable16 = (_expTable15 * _expTable15) / _ONE_E18
		IRs:
			TMP_1344(uint256) = _expTable15_1 (c)* _expTable15_1
			TMP_1345(uint256) = TMP_1344 (c)/ _ONE_E18_1
			_expTable16_1(uint256) := TMP_1345(uint256)
		Expression: _expTable17 = (_expTable16 * _expTable16) / _ONE_E18
		IRs:
			TMP_1346(uint256) = _expTable16_1 (c)* _expTable16_1
			TMP_1347(uint256) = TMP_1346 (c)/ _ONE_E18_1
			_expTable17_1(uint256) := TMP_1347(uint256)
		Expression: _expTable18 = (_expTable17 * _expTable17) / _ONE_E18
		IRs:
			TMP_1348(uint256) = _expTable17_1 (c)* _expTable17_1
			TMP_1349(uint256) = TMP_1348 (c)/ _ONE_E18_1
			_expTable18_1(uint256) := TMP_1349(uint256)
		Expression: _expTable19 = (_expTable18 * _expTable18) / _ONE_E18
		IRs:
			TMP_1350(uint256) = _expTable18_1 (c)* _expTable18_1
			TMP_1351(uint256) = TMP_1350 (c)/ _ONE_E18_1
			_expTable19_1(uint256) := TMP_1351(uint256)
		Expression: _expTable20 = (_expTable19 * _expTable19) / _ONE_E18
		IRs:
			TMP_1352(uint256) = _expTable19_1 (c)* _expTable19_1
			TMP_1353(uint256) = TMP_1352 (c)/ _ONE_E18_1
			_expTable20_1(uint256) := TMP_1353(uint256)
		Expression: _expTable21 = (_expTable20 * _expTable20) / _ONE_E18
		IRs:
			TMP_1354(uint256) = _expTable20_1 (c)* _expTable20_1
			TMP_1355(uint256) = TMP_1354 (c)/ _ONE_E18_1
			_expTable21_1(uint256) := TMP_1355(uint256)
		Expression: _expTable22 = (_expTable21 * _expTable21) / _ONE_E18
		IRs:
			TMP_1356(uint256) = _expTable21_1 (c)* _expTable21_1
			TMP_1357(uint256) = TMP_1356 (c)/ _ONE_E18_1
			_expTable22_1(uint256) := TMP_1357(uint256)
		Expression: _expTable23 = (_expTable22 * _expTable22) / _ONE_E18
		IRs:
			TMP_1358(uint256) = _expTable22_1 (c)* _expTable22_1
			TMP_1359(uint256) = TMP_1358 (c)/ _ONE_E18_1
			_expTable23_1(uint256) := TMP_1359(uint256)
		Expression: _expTable24 = (_expTable23 * _expTable23) / _ONE_E18
		IRs:
			TMP_1360(uint256) = _expTable23_1 (c)* _expTable23_1
			TMP_1361(uint256) = TMP_1360 (c)/ _ONE_E18_1
			_expTable24_1(uint256) := TMP_1361(uint256)
		Expression: _expTable25 = (_expTable24 * _expTable24) / _ONE_E18
		IRs:
			TMP_1362(uint256) = _expTable24_1 (c)* _expTable24_1
			TMP_1363(uint256) = TMP_1362 (c)/ _ONE_E18_1
			_expTable25_1(uint256) := TMP_1363(uint256)
		Expression: _expTable26 = (_expTable25 * _expTable25) / _ONE_E18
		IRs:
			TMP_1364(uint256) = _expTable25_1 (c)* _expTable25_1
			TMP_1365(uint256) = TMP_1364 (c)/ _ONE_E18_1
			_expTable26_1(uint256) := TMP_1365(uint256)
		Expression: _expTable27 = (_expTable26 * _expTable26) / _ONE_E18
		IRs:
			TMP_1366(uint256) = _expTable26_1 (c)* _expTable26_1
			TMP_1367(uint256) = TMP_1366 (c)/ _ONE_E18_1
			_expTable27_1(uint256) := TMP_1367(uint256)
		Expression: _expTable28 = (_expTable27 * _expTable27) / _ONE_E18
		IRs:
			TMP_1368(uint256) = _expTable27_1 (c)* _expTable27_1
			TMP_1369(uint256) = TMP_1368 (c)/ _ONE_E18_1
			_expTable28_1(uint256) := TMP_1369(uint256)
		Expression: _expTable29 = (_expTable28 * _expTable28) / _ONE_E18
		IRs:
			TMP_1370(uint256) = _expTable28_1 (c)* _expTable28_1
			TMP_1371(uint256) = TMP_1370 (c)/ _ONE_E18_1
			_expTable29_1(uint256) := TMP_1371(uint256)
	Function VotingPowerCalculator._votingPowerAt(uint256,uint256)
		IRs:
			balance_1(uint256) := ϕ(['TMP_1756'])
			timestamp_1(uint256) := ϕ(['block.timestamp'])
			_ONE_E18_2(uint256) := ϕ(['_ONE_E18_0'])
			origin_2(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_2(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_2(uint256) := ϕ(['_expTable1_0', '_expTable1_1'])
			_expTable2_2(uint256) := ϕ(['_expTable2_0', '_expTable2_1'])
			_expTable3_2(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_2(uint256) := ϕ(['_expTable4_0', '_expTable4_1'])
			_expTable5_2(uint256) := ϕ(['_expTable5_1', '_expTable5_0'])
			_expTable6_2(uint256) := ϕ(['_expTable6_0', '_expTable6_1'])
			_expTable7_2(uint256) := ϕ(['_expTable7_0', '_expTable7_1'])
			_expTable8_2(uint256) := ϕ(['_expTable8_0', '_expTable8_1'])
			_expTable9_2(uint256) := ϕ(['_expTable9_0', '_expTable9_1'])
			_expTable10_2(uint256) := ϕ(['_expTable10_0', '_expTable10_1'])
			_expTable11_2(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_2(uint256) := ϕ(['_expTable12_0', '_expTable12_1'])
			_expTable13_2(uint256) := ϕ(['_expTable13_1', '_expTable13_0'])
			_expTable14_2(uint256) := ϕ(['_expTable14_0', '_expTable14_1'])
			_expTable15_2(uint256) := ϕ(['_expTable15_0', '_expTable15_1'])
			_expTable16_2(uint256) := ϕ(['_expTable16_0', '_expTable16_1'])
			_expTable17_2(uint256) := ϕ(['_expTable17_0', '_expTable17_1'])
			_expTable18_2(uint256) := ϕ(['_expTable18_0', '_expTable18_1'])
			_expTable19_2(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_2(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_2(uint256) := ϕ(['_expTable21_1', '_expTable21_0'])
			_expTable22_2(uint256) := ϕ(['_expTable22_0', '_expTable22_1'])
			_expTable23_2(uint256) := ϕ(['_expTable23_0', '_expTable23_1'])
			_expTable24_2(uint256) := ϕ(['_expTable24_0', '_expTable24_1'])
			_expTable25_2(uint256) := ϕ(['_expTable25_0', '_expTable25_1'])
			_expTable26_2(uint256) := ϕ(['_expTable26_0', '_expTable26_1'])
			_expTable27_2(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_2(uint256) := ϕ(['_expTable28_0', '_expTable28_1'])
			_expTable29_2(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_1372(uint256) = timestamp_4 - origin_2
			t_1(uint256) := TMP_1372(uint256)
		Expression: votingPower = balance
		IRs:
			votingPower_1(uint256) := balance_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_1373(uint256) = t_1 & 1
			TMP_1374(bool) = TMP_1373 != 0
			CONDITION TMP_1374
		Expression: votingPower = (votingPower * _expTable0) / _ONE_E18
		IRs:
			TMP_1375(uint256) = votingPower_1 * _expTable0_2
			TMP_1376(uint256) = TMP_1375 / _ONE_E18_2
			votingPower_2(uint256) := TMP_1376(uint256)
		IRs:
			votingPower_3(uint256) := ϕ(['votingPower_2', 'votingPower_1'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_1377(uint256) = t_1 & 2
			TMP_1378(bool) = TMP_1377 != 0
			CONDITION TMP_1378
		Expression: votingPower = (votingPower * _expTable1) / _ONE_E18
		IRs:
			TMP_1379(uint256) = votingPower_3 * _expTable1_2
			TMP_1380(uint256) = TMP_1379 / _ONE_E18_2
			votingPower_4(uint256) := TMP_1380(uint256)
		IRs:
			votingPower_5(uint256) := ϕ(['votingPower_4', 'votingPower_1'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_1381(uint256) = t_1 & 4
			TMP_1382(bool) = TMP_1381 != 0
			CONDITION TMP_1382
		Expression: votingPower = (votingPower * _expTable2) / _ONE_E18
		IRs:
			TMP_1383(uint256) = votingPower_5 * _expTable2_2
			TMP_1384(uint256) = TMP_1383 / _ONE_E18_2
			votingPower_6(uint256) := TMP_1384(uint256)
		IRs:
			votingPower_7(uint256) := ϕ(['votingPower_6', 'votingPower_1'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_1385(uint256) = t_1 & 8
			TMP_1386(bool) = TMP_1385 != 0
			CONDITION TMP_1386
		Expression: votingPower = (votingPower * _expTable3) / _ONE_E18
		IRs:
			TMP_1387(uint256) = votingPower_7 * _expTable3_2
			TMP_1388(uint256) = TMP_1387 / _ONE_E18_2
			votingPower_8(uint256) := TMP_1388(uint256)
		IRs:
			votingPower_9(uint256) := ϕ(['votingPower_8', 'votingPower_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_1389(uint256) = t_1 & 16
			TMP_1390(bool) = TMP_1389 != 0
			CONDITION TMP_1390
		Expression: votingPower = (votingPower * _expTable4) / _ONE_E18
		IRs:
			TMP_1391(uint256) = votingPower_9 * _expTable4_2
			TMP_1392(uint256) = TMP_1391 / _ONE_E18_2
			votingPower_10(uint256) := TMP_1392(uint256)
		IRs:
			votingPower_11(uint256) := ϕ(['votingPower_10', 'votingPower_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_1393(uint256) = t_1 & 32
			TMP_1394(bool) = TMP_1393 != 0
			CONDITION TMP_1394
		Expression: votingPower = (votingPower * _expTable5) / _ONE_E18
		IRs:
			TMP_1395(uint256) = votingPower_11 * _expTable5_2
			TMP_1396(uint256) = TMP_1395 / _ONE_E18_2
			votingPower_12(uint256) := TMP_1396(uint256)
		IRs:
			votingPower_13(uint256) := ϕ(['votingPower_12', 'votingPower_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_1397(uint256) = t_1 & 64
			TMP_1398(bool) = TMP_1397 != 0
			CONDITION TMP_1398
		Expression: votingPower = (votingPower * _expTable6) / _ONE_E18
		IRs:
			TMP_1399(uint256) = votingPower_13 * _expTable6_2
			TMP_1400(uint256) = TMP_1399 / _ONE_E18_2
			votingPower_14(uint256) := TMP_1400(uint256)
		IRs:
			votingPower_15(uint256) := ϕ(['votingPower_14', 'votingPower_1'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_1401(uint256) = t_1 & 128
			TMP_1402(bool) = TMP_1401 != 0
			CONDITION TMP_1402
		Expression: votingPower = (votingPower * _expTable7) / _ONE_E18
		IRs:
			TMP_1403(uint256) = votingPower_15 * _expTable7_2
			TMP_1404(uint256) = TMP_1403 / _ONE_E18_2
			votingPower_16(uint256) := TMP_1404(uint256)
		IRs:
			votingPower_17(uint256) := ϕ(['votingPower_16', 'votingPower_1'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_1405(uint256) = t_1 & 256
			TMP_1406(bool) = TMP_1405 != 0
			CONDITION TMP_1406
		Expression: votingPower = (votingPower * _expTable8) / _ONE_E18
		IRs:
			TMP_1407(uint256) = votingPower_17 * _expTable8_2
			TMP_1408(uint256) = TMP_1407 / _ONE_E18_2
			votingPower_18(uint256) := TMP_1408(uint256)
		IRs:
			votingPower_19(uint256) := ϕ(['votingPower_18', 'votingPower_1'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_1409(uint256) = t_1 & 512
			TMP_1410(bool) = TMP_1409 != 0
			CONDITION TMP_1410
		Expression: votingPower = (votingPower * _expTable9) / _ONE_E18
		IRs:
			TMP_1411(uint256) = votingPower_19 * _expTable9_2
			TMP_1412(uint256) = TMP_1411 / _ONE_E18_2
			votingPower_20(uint256) := TMP_1412(uint256)
		IRs:
			votingPower_21(uint256) := ϕ(['votingPower_20', 'votingPower_1'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_1413(uint256) = t_1 & 1024
			TMP_1414(bool) = TMP_1413 != 0
			CONDITION TMP_1414
		Expression: votingPower = (votingPower * _expTable10) / _ONE_E18
		IRs:
			TMP_1415(uint256) = votingPower_21 * _expTable10_2
			TMP_1416(uint256) = TMP_1415 / _ONE_E18_2
			votingPower_22(uint256) := TMP_1416(uint256)
		IRs:
			votingPower_23(uint256) := ϕ(['votingPower_22', 'votingPower_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_1417(uint256) = t_1 & 2048
			TMP_1418(bool) = TMP_1417 != 0
			CONDITION TMP_1418
		Expression: votingPower = (votingPower * _expTable11) / _ONE_E18
		IRs:
			TMP_1419(uint256) = votingPower_23 * _expTable11_2
			TMP_1420(uint256) = TMP_1419 / _ONE_E18_2
			votingPower_24(uint256) := TMP_1420(uint256)
		IRs:
			votingPower_25(uint256) := ϕ(['votingPower_24', 'votingPower_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_1421(uint256) = t_1 & 4096
			TMP_1422(bool) = TMP_1421 != 0
			CONDITION TMP_1422
		Expression: votingPower = (votingPower * _expTable12) / _ONE_E18
		IRs:
			TMP_1423(uint256) = votingPower_25 * _expTable12_2
			TMP_1424(uint256) = TMP_1423 / _ONE_E18_2
			votingPower_26(uint256) := TMP_1424(uint256)
		IRs:
			votingPower_27(uint256) := ϕ(['votingPower_26', 'votingPower_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_1425(uint256) = t_1 & 8192
			TMP_1426(bool) = TMP_1425 != 0
			CONDITION TMP_1426
		Expression: votingPower = (votingPower * _expTable13) / _ONE_E18
		IRs:
			TMP_1427(uint256) = votingPower_27 * _expTable13_2
			TMP_1428(uint256) = TMP_1427 / _ONE_E18_2
			votingPower_28(uint256) := TMP_1428(uint256)
		IRs:
			votingPower_29(uint256) := ϕ(['votingPower_28', 'votingPower_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_1429(uint256) = t_1 & 16384
			TMP_1430(bool) = TMP_1429 != 0
			CONDITION TMP_1430
		Expression: votingPower = (votingPower * _expTable14) / _ONE_E18
		IRs:
			TMP_1431(uint256) = votingPower_29 * _expTable14_2
			TMP_1432(uint256) = TMP_1431 / _ONE_E18_2
			votingPower_30(uint256) := TMP_1432(uint256)
		IRs:
			votingPower_31(uint256) := ϕ(['votingPower_30', 'votingPower_1'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_1433(uint256) = t_1 & 32768
			TMP_1434(bool) = TMP_1433 != 0
			CONDITION TMP_1434
		Expression: votingPower = (votingPower * _expTable15) / _ONE_E18
		IRs:
			TMP_1435(uint256) = votingPower_31 * _expTable15_2
			TMP_1436(uint256) = TMP_1435 / _ONE_E18_2
			votingPower_32(uint256) := TMP_1436(uint256)
		IRs:
			votingPower_33(uint256) := ϕ(['votingPower_32', 'votingPower_1'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_1437(uint256) = t_1 & 65536
			TMP_1438(bool) = TMP_1437 != 0
			CONDITION TMP_1438
		Expression: votingPower = (votingPower * _expTable16) / _ONE_E18
		IRs:
			TMP_1439(uint256) = votingPower_33 * _expTable16_2
			TMP_1440(uint256) = TMP_1439 / _ONE_E18_2
			votingPower_34(uint256) := TMP_1440(uint256)
		IRs:
			votingPower_35(uint256) := ϕ(['votingPower_34', 'votingPower_1'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_1441(uint256) = t_1 & 131072
			TMP_1442(bool) = TMP_1441 != 0
			CONDITION TMP_1442
		Expression: votingPower = (votingPower * _expTable17) / _ONE_E18
		IRs:
			TMP_1443(uint256) = votingPower_35 * _expTable17_2
			TMP_1444(uint256) = TMP_1443 / _ONE_E18_2
			votingPower_36(uint256) := TMP_1444(uint256)
		IRs:
			votingPower_37(uint256) := ϕ(['votingPower_36', 'votingPower_1'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_1445(uint256) = t_1 & 262144
			TMP_1446(bool) = TMP_1445 != 0
			CONDITION TMP_1446
		Expression: votingPower = (votingPower * _expTable18) / _ONE_E18
		IRs:
			TMP_1447(uint256) = votingPower_37 * _expTable18_2
			TMP_1448(uint256) = TMP_1447 / _ONE_E18_2
			votingPower_38(uint256) := TMP_1448(uint256)
		IRs:
			votingPower_39(uint256) := ϕ(['votingPower_38', 'votingPower_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_1449(uint256) = t_1 & 524288
			TMP_1450(bool) = TMP_1449 != 0
			CONDITION TMP_1450
		Expression: votingPower = (votingPower * _expTable19) / _ONE_E18
		IRs:
			TMP_1451(uint256) = votingPower_39 * _expTable19_2
			TMP_1452(uint256) = TMP_1451 / _ONE_E18_2
			votingPower_40(uint256) := TMP_1452(uint256)
		IRs:
			votingPower_41(uint256) := ϕ(['votingPower_40', 'votingPower_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_1453(uint256) = t_1 & 1048576
			TMP_1454(bool) = TMP_1453 != 0
			CONDITION TMP_1454
		Expression: votingPower = (votingPower * _expTable20) / _ONE_E18
		IRs:
			TMP_1455(uint256) = votingPower_41 * _expTable20_2
			TMP_1456(uint256) = TMP_1455 / _ONE_E18_2
			votingPower_42(uint256) := TMP_1456(uint256)
		IRs:
			votingPower_43(uint256) := ϕ(['votingPower_42', 'votingPower_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_1457(uint256) = t_1 & 2097152
			TMP_1458(bool) = TMP_1457 != 0
			CONDITION TMP_1458
		Expression: votingPower = (votingPower * _expTable21) / _ONE_E18
		IRs:
			TMP_1459(uint256) = votingPower_43 * _expTable21_2
			TMP_1460(uint256) = TMP_1459 / _ONE_E18_2
			votingPower_44(uint256) := TMP_1460(uint256)
		IRs:
			votingPower_45(uint256) := ϕ(['votingPower_44', 'votingPower_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_1461(uint256) = t_1 & 4194304
			TMP_1462(bool) = TMP_1461 != 0
			CONDITION TMP_1462
		Expression: votingPower = (votingPower * _expTable22) / _ONE_E18
		IRs:
			TMP_1463(uint256) = votingPower_45 * _expTable22_2
			TMP_1464(uint256) = TMP_1463 / _ONE_E18_2
			votingPower_46(uint256) := TMP_1464(uint256)
		IRs:
			votingPower_47(uint256) := ϕ(['votingPower_46', 'votingPower_1'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_1465(uint256) = t_1 & 8388608
			TMP_1466(bool) = TMP_1465 != 0
			CONDITION TMP_1466
		Expression: votingPower = (votingPower * _expTable23) / _ONE_E18
		IRs:
			TMP_1467(uint256) = votingPower_47 * _expTable23_2
			TMP_1468(uint256) = TMP_1467 / _ONE_E18_2
			votingPower_48(uint256) := TMP_1468(uint256)
		IRs:
			votingPower_49(uint256) := ϕ(['votingPower_48', 'votingPower_1'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_1469(uint256) = t_1 & 16777216
			TMP_1470(bool) = TMP_1469 != 0
			CONDITION TMP_1470
		Expression: votingPower = (votingPower * _expTable24) / _ONE_E18
		IRs:
			TMP_1471(uint256) = votingPower_49 * _expTable24_2
			TMP_1472(uint256) = TMP_1471 / _ONE_E18_2
			votingPower_50(uint256) := TMP_1472(uint256)
		IRs:
			votingPower_51(uint256) := ϕ(['votingPower_50', 'votingPower_1'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_1473(uint256) = t_1 & 33554432
			TMP_1474(bool) = TMP_1473 != 0
			CONDITION TMP_1474
		Expression: votingPower = (votingPower * _expTable25) / _ONE_E18
		IRs:
			TMP_1475(uint256) = votingPower_51 * _expTable25_2
			TMP_1476(uint256) = TMP_1475 / _ONE_E18_2
			votingPower_52(uint256) := TMP_1476(uint256)
		IRs:
			votingPower_53(uint256) := ϕ(['votingPower_52', 'votingPower_1'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_1477(uint256) = t_1 & 67108864
			TMP_1478(bool) = TMP_1477 != 0
			CONDITION TMP_1478
		Expression: votingPower = (votingPower * _expTable26) / _ONE_E18
		IRs:
			TMP_1479(uint256) = votingPower_53 * _expTable26_2
			TMP_1480(uint256) = TMP_1479 / _ONE_E18_2
			votingPower_54(uint256) := TMP_1480(uint256)
		IRs:
			votingPower_55(uint256) := ϕ(['votingPower_54', 'votingPower_1'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_1481(uint256) = t_1 & 134217728
			TMP_1482(bool) = TMP_1481 != 0
			CONDITION TMP_1482
		Expression: votingPower = (votingPower * _expTable27) / _ONE_E18
		IRs:
			TMP_1483(uint256) = votingPower_55 * _expTable27_2
			TMP_1484(uint256) = TMP_1483 / _ONE_E18_2
			votingPower_56(uint256) := TMP_1484(uint256)
		IRs:
			votingPower_57(uint256) := ϕ(['votingPower_56', 'votingPower_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_1485(uint256) = t_1 & 268435456
			TMP_1486(bool) = TMP_1485 != 0
			CONDITION TMP_1486
		Expression: votingPower = (votingPower * _expTable28) / _ONE_E18
		IRs:
			TMP_1487(uint256) = votingPower_57 * _expTable28_2
			TMP_1488(uint256) = TMP_1487 / _ONE_E18_2
			votingPower_58(uint256) := TMP_1488(uint256)
		IRs:
			votingPower_59(uint256) := ϕ(['votingPower_58', 'votingPower_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_1489(uint256) = t_1 & 536870912
			TMP_1490(bool) = TMP_1489 != 0
			CONDITION TMP_1490
		Expression: votingPower = (votingPower * _expTable29) / _ONE_E18
		IRs:
			TMP_1491(uint256) = votingPower_59 * _expTable29_2
			TMP_1492(uint256) = TMP_1491 / _ONE_E18_2
			votingPower_60(uint256) := TMP_1492(uint256)
		IRs:
			votingPower_61(uint256) := ϕ(['votingPower_60', 'votingPower_1'])
		Expression: votingPower
		IRs:
			RETURN votingPower_61
		Expression: timestamp < origin
		IRs:
			TMP_1493(bool) = timestamp_1 < origin_2
			CONDITION TMP_1493
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_2(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: votingPower
	Function VotingPowerCalculator._balanceAt(uint256,uint256)
		IRs:
			_ONE_E18_3(uint256) := ϕ(['_ONE_E18_0'])
			origin_3(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_3(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_3(uint256) := ϕ(['_expTable1_0', '_expTable1_1'])
			_expTable2_3(uint256) := ϕ(['_expTable2_0', '_expTable2_1'])
			_expTable3_3(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_3(uint256) := ϕ(['_expTable4_0', '_expTable4_1'])
			_expTable5_3(uint256) := ϕ(['_expTable5_1', '_expTable5_0'])
			_expTable6_3(uint256) := ϕ(['_expTable6_0', '_expTable6_1'])
			_expTable7_3(uint256) := ϕ(['_expTable7_0', '_expTable7_1'])
			_expTable8_3(uint256) := ϕ(['_expTable8_0', '_expTable8_1'])
			_expTable9_3(uint256) := ϕ(['_expTable9_0', '_expTable9_1'])
			_expTable10_3(uint256) := ϕ(['_expTable10_0', '_expTable10_1'])
			_expTable11_3(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_3(uint256) := ϕ(['_expTable12_0', '_expTable12_1'])
			_expTable13_3(uint256) := ϕ(['_expTable13_1', '_expTable13_0'])
			_expTable14_3(uint256) := ϕ(['_expTable14_0', '_expTable14_1'])
			_expTable15_3(uint256) := ϕ(['_expTable15_0', '_expTable15_1'])
			_expTable16_3(uint256) := ϕ(['_expTable16_0', '_expTable16_1'])
			_expTable17_3(uint256) := ϕ(['_expTable17_0', '_expTable17_1'])
			_expTable18_3(uint256) := ϕ(['_expTable18_0', '_expTable18_1'])
			_expTable19_3(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_3(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_3(uint256) := ϕ(['_expTable21_1', '_expTable21_0'])
			_expTable22_3(uint256) := ϕ(['_expTable22_0', '_expTable22_1'])
			_expTable23_3(uint256) := ϕ(['_expTable23_0', '_expTable23_1'])
			_expTable24_3(uint256) := ϕ(['_expTable24_0', '_expTable24_1'])
			_expTable25_3(uint256) := ϕ(['_expTable25_0', '_expTable25_1'])
			_expTable26_3(uint256) := ϕ(['_expTable26_0', '_expTable26_1'])
			_expTable27_3(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_3(uint256) := ϕ(['_expTable28_0', '_expTable28_1'])
			_expTable29_3(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_1494(uint256) = timestamp_4 - origin_3
			t_1(uint256) := TMP_1494(uint256)
		Expression: balance = votingPower
		IRs:
			balance_1(uint256) := votingPower_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_1495(uint256) = t_1 & 1
			TMP_1496(bool) = TMP_1495 != 0
			CONDITION TMP_1496
		Expression: balance = (balance * _ONE_E18) / _expTable0
		IRs:
			TMP_1497(uint256) = balance_1 * _ONE_E18_3
			TMP_1498(uint256) = TMP_1497 / _expTable0_3
			balance_2(uint256) := TMP_1498(uint256)
		IRs:
			balance_3(uint256) := ϕ(['balance_2', 'balance_1'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_1499(uint256) = t_1 & 2
			TMP_1500(bool) = TMP_1499 != 0
			CONDITION TMP_1500
		Expression: balance = (balance * _ONE_E18) / _expTable1
		IRs:
			TMP_1501(uint256) = balance_3 * _ONE_E18_3
			TMP_1502(uint256) = TMP_1501 / _expTable1_3
			balance_4(uint256) := TMP_1502(uint256)
		IRs:
			balance_5(uint256) := ϕ(['balance_1', 'balance_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_1503(uint256) = t_1 & 4
			TMP_1504(bool) = TMP_1503 != 0
			CONDITION TMP_1504
		Expression: balance = (balance * _ONE_E18) / _expTable2
		IRs:
			TMP_1505(uint256) = balance_5 * _ONE_E18_3
			TMP_1506(uint256) = TMP_1505 / _expTable2_3
			balance_6(uint256) := TMP_1506(uint256)
		IRs:
			balance_7(uint256) := ϕ(['balance_6', 'balance_1'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_1507(uint256) = t_1 & 8
			TMP_1508(bool) = TMP_1507 != 0
			CONDITION TMP_1508
		Expression: balance = (balance * _ONE_E18) / _expTable3
		IRs:
			TMP_1509(uint256) = balance_7 * _ONE_E18_3
			TMP_1510(uint256) = TMP_1509 / _expTable3_3
			balance_8(uint256) := TMP_1510(uint256)
		IRs:
			balance_9(uint256) := ϕ(['balance_8', 'balance_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_1511(uint256) = t_1 & 16
			TMP_1512(bool) = TMP_1511 != 0
			CONDITION TMP_1512
		Expression: balance = (balance * _ONE_E18) / _expTable4
		IRs:
			TMP_1513(uint256) = balance_9 * _ONE_E18_3
			TMP_1514(uint256) = TMP_1513 / _expTable4_3
			balance_10(uint256) := TMP_1514(uint256)
		IRs:
			balance_11(uint256) := ϕ(['balance_10', 'balance_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_1515(uint256) = t_1 & 32
			TMP_1516(bool) = TMP_1515 != 0
			CONDITION TMP_1516
		Expression: balance = (balance * _ONE_E18) / _expTable5
		IRs:
			TMP_1517(uint256) = balance_11 * _ONE_E18_3
			TMP_1518(uint256) = TMP_1517 / _expTable5_3
			balance_12(uint256) := TMP_1518(uint256)
		IRs:
			balance_13(uint256) := ϕ(['balance_12', 'balance_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_1519(uint256) = t_1 & 64
			TMP_1520(bool) = TMP_1519 != 0
			CONDITION TMP_1520
		Expression: balance = (balance * _ONE_E18) / _expTable6
		IRs:
			TMP_1521(uint256) = balance_13 * _ONE_E18_3
			TMP_1522(uint256) = TMP_1521 / _expTable6_3
			balance_14(uint256) := TMP_1522(uint256)
		IRs:
			balance_15(uint256) := ϕ(['balance_14', 'balance_1'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_1523(uint256) = t_1 & 128
			TMP_1524(bool) = TMP_1523 != 0
			CONDITION TMP_1524
		Expression: balance = (balance * _ONE_E18) / _expTable7
		IRs:
			TMP_1525(uint256) = balance_15 * _ONE_E18_3
			TMP_1526(uint256) = TMP_1525 / _expTable7_3
			balance_16(uint256) := TMP_1526(uint256)
		IRs:
			balance_17(uint256) := ϕ(['balance_16', 'balance_1'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_1527(uint256) = t_1 & 256
			TMP_1528(bool) = TMP_1527 != 0
			CONDITION TMP_1528
		Expression: balance = (balance * _ONE_E18) / _expTable8
		IRs:
			TMP_1529(uint256) = balance_17 * _ONE_E18_3
			TMP_1530(uint256) = TMP_1529 / _expTable8_3
			balance_18(uint256) := TMP_1530(uint256)
		IRs:
			balance_19(uint256) := ϕ(['balance_18', 'balance_1'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_1531(uint256) = t_1 & 512
			TMP_1532(bool) = TMP_1531 != 0
			CONDITION TMP_1532
		Expression: balance = (balance * _ONE_E18) / _expTable9
		IRs:
			TMP_1533(uint256) = balance_19 * _ONE_E18_3
			TMP_1534(uint256) = TMP_1533 / _expTable9_3
			balance_20(uint256) := TMP_1534(uint256)
		IRs:
			balance_21(uint256) := ϕ(['balance_1', 'balance_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_1535(uint256) = t_1 & 1024
			TMP_1536(bool) = TMP_1535 != 0
			CONDITION TMP_1536
		Expression: balance = (balance * _ONE_E18) / _expTable10
		IRs:
			TMP_1537(uint256) = balance_21 * _ONE_E18_3
			TMP_1538(uint256) = TMP_1537 / _expTable10_3
			balance_22(uint256) := TMP_1538(uint256)
		IRs:
			balance_23(uint256) := ϕ(['balance_22', 'balance_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_1539(uint256) = t_1 & 2048
			TMP_1540(bool) = TMP_1539 != 0
			CONDITION TMP_1540
		Expression: balance = (balance * _ONE_E18) / _expTable11
		IRs:
			TMP_1541(uint256) = balance_23 * _ONE_E18_3
			TMP_1542(uint256) = TMP_1541 / _expTable11_3
			balance_24(uint256) := TMP_1542(uint256)
		IRs:
			balance_25(uint256) := ϕ(['balance_24', 'balance_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_1543(uint256) = t_1 & 4096
			TMP_1544(bool) = TMP_1543 != 0
			CONDITION TMP_1544
		Expression: balance = (balance * _ONE_E18) / _expTable12
		IRs:
			TMP_1545(uint256) = balance_25 * _ONE_E18_3
			TMP_1546(uint256) = TMP_1545 / _expTable12_3
			balance_26(uint256) := TMP_1546(uint256)
		IRs:
			balance_27(uint256) := ϕ(['balance_26', 'balance_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_1547(uint256) = t_1 & 8192
			TMP_1548(bool) = TMP_1547 != 0
			CONDITION TMP_1548
		Expression: balance = (balance * _ONE_E18) / _expTable13
		IRs:
			TMP_1549(uint256) = balance_27 * _ONE_E18_3
			TMP_1550(uint256) = TMP_1549 / _expTable13_3
			balance_28(uint256) := TMP_1550(uint256)
		IRs:
			balance_29(uint256) := ϕ(['balance_28', 'balance_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_1551(uint256) = t_1 & 16384
			TMP_1552(bool) = TMP_1551 != 0
			CONDITION TMP_1552
		Expression: balance = (balance * _ONE_E18) / _expTable14
		IRs:
			TMP_1553(uint256) = balance_29 * _ONE_E18_3
			TMP_1554(uint256) = TMP_1553 / _expTable14_3
			balance_30(uint256) := TMP_1554(uint256)
		IRs:
			balance_31(uint256) := ϕ(['balance_30', 'balance_1'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_1555(uint256) = t_1 & 32768
			TMP_1556(bool) = TMP_1555 != 0
			CONDITION TMP_1556
		Expression: balance = (balance * _ONE_E18) / _expTable15
		IRs:
			TMP_1557(uint256) = balance_31 * _ONE_E18_3
			TMP_1558(uint256) = TMP_1557 / _expTable15_3
			balance_32(uint256) := TMP_1558(uint256)
		IRs:
			balance_33(uint256) := ϕ(['balance_32', 'balance_1'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_1559(uint256) = t_1 & 65536
			TMP_1560(bool) = TMP_1559 != 0
			CONDITION TMP_1560
		Expression: balance = (balance * _ONE_E18) / _expTable16
		IRs:
			TMP_1561(uint256) = balance_33 * _ONE_E18_3
			TMP_1562(uint256) = TMP_1561 / _expTable16_3
			balance_34(uint256) := TMP_1562(uint256)
		IRs:
			balance_35(uint256) := ϕ(['balance_34', 'balance_1'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_1563(uint256) = t_1 & 131072
			TMP_1564(bool) = TMP_1563 != 0
			CONDITION TMP_1564
		Expression: balance = (balance * _ONE_E18) / _expTable17
		IRs:
			TMP_1565(uint256) = balance_35 * _ONE_E18_3
			TMP_1566(uint256) = TMP_1565 / _expTable17_3
			balance_36(uint256) := TMP_1566(uint256)
		IRs:
			balance_37(uint256) := ϕ(['balance_1', 'balance_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_1567(uint256) = t_1 & 262144
			TMP_1568(bool) = TMP_1567 != 0
			CONDITION TMP_1568
		Expression: balance = (balance * _ONE_E18) / _expTable18
		IRs:
			TMP_1569(uint256) = balance_37 * _ONE_E18_3
			TMP_1570(uint256) = TMP_1569 / _expTable18_3
			balance_38(uint256) := TMP_1570(uint256)
		IRs:
			balance_39(uint256) := ϕ(['balance_38', 'balance_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_1571(uint256) = t_1 & 524288
			TMP_1572(bool) = TMP_1571 != 0
			CONDITION TMP_1572
		Expression: balance = (balance * _ONE_E18) / _expTable19
		IRs:
			TMP_1573(uint256) = balance_39 * _ONE_E18_3
			TMP_1574(uint256) = TMP_1573 / _expTable19_3
			balance_40(uint256) := TMP_1574(uint256)
		IRs:
			balance_41(uint256) := ϕ(['balance_40', 'balance_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_1575(uint256) = t_1 & 1048576
			TMP_1576(bool) = TMP_1575 != 0
			CONDITION TMP_1576
		Expression: balance = (balance * _ONE_E18) / _expTable20
		IRs:
			TMP_1577(uint256) = balance_41 * _ONE_E18_3
			TMP_1578(uint256) = TMP_1577 / _expTable20_3
			balance_42(uint256) := TMP_1578(uint256)
		IRs:
			balance_43(uint256) := ϕ(['balance_42', 'balance_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_1579(uint256) = t_1 & 2097152
			TMP_1580(bool) = TMP_1579 != 0
			CONDITION TMP_1580
		Expression: balance = (balance * _ONE_E18) / _expTable21
		IRs:
			TMP_1581(uint256) = balance_43 * _ONE_E18_3
			TMP_1582(uint256) = TMP_1581 / _expTable21_3
			balance_44(uint256) := TMP_1582(uint256)
		IRs:
			balance_45(uint256) := ϕ(['balance_44', 'balance_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_1583(uint256) = t_1 & 4194304
			TMP_1584(bool) = TMP_1583 != 0
			CONDITION TMP_1584
		Expression: balance = (balance * _ONE_E18) / _expTable22
		IRs:
			TMP_1585(uint256) = balance_45 * _ONE_E18_3
			TMP_1586(uint256) = TMP_1585 / _expTable22_3
			balance_46(uint256) := TMP_1586(uint256)
		IRs:
			balance_47(uint256) := ϕ(['balance_46', 'balance_1'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_1587(uint256) = t_1 & 8388608
			TMP_1588(bool) = TMP_1587 != 0
			CONDITION TMP_1588
		Expression: balance = (balance * _ONE_E18) / _expTable23
		IRs:
			TMP_1589(uint256) = balance_47 * _ONE_E18_3
			TMP_1590(uint256) = TMP_1589 / _expTable23_3
			balance_48(uint256) := TMP_1590(uint256)
		IRs:
			balance_49(uint256) := ϕ(['balance_48', 'balance_1'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_1591(uint256) = t_1 & 16777216
			TMP_1592(bool) = TMP_1591 != 0
			CONDITION TMP_1592
		Expression: balance = (balance * _ONE_E18) / _expTable24
		IRs:
			TMP_1593(uint256) = balance_49 * _ONE_E18_3
			TMP_1594(uint256) = TMP_1593 / _expTable24_3
			balance_50(uint256) := TMP_1594(uint256)
		IRs:
			balance_51(uint256) := ϕ(['balance_50', 'balance_1'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_1595(uint256) = t_1 & 33554432
			TMP_1596(bool) = TMP_1595 != 0
			CONDITION TMP_1596
		Expression: balance = (balance * _ONE_E18) / _expTable25
		IRs:
			TMP_1597(uint256) = balance_51 * _ONE_E18_3
			TMP_1598(uint256) = TMP_1597 / _expTable25_3
			balance_52(uint256) := TMP_1598(uint256)
		IRs:
			balance_53(uint256) := ϕ(['balance_1', 'balance_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_1599(uint256) = t_1 & 67108864
			TMP_1600(bool) = TMP_1599 != 0
			CONDITION TMP_1600
		Expression: balance = (balance * _ONE_E18) / _expTable26
		IRs:
			TMP_1601(uint256) = balance_53 * _ONE_E18_3
			TMP_1602(uint256) = TMP_1601 / _expTable26_3
			balance_54(uint256) := TMP_1602(uint256)
		IRs:
			balance_55(uint256) := ϕ(['balance_54', 'balance_1'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_1603(uint256) = t_1 & 134217728
			TMP_1604(bool) = TMP_1603 != 0
			CONDITION TMP_1604
		Expression: balance = (balance * _ONE_E18) / _expTable27
		IRs:
			TMP_1605(uint256) = balance_55 * _ONE_E18_3
			TMP_1606(uint256) = TMP_1605 / _expTable27_3
			balance_56(uint256) := TMP_1606(uint256)
		IRs:
			balance_57(uint256) := ϕ(['balance_56', 'balance_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_1607(uint256) = t_1 & 268435456
			TMP_1608(bool) = TMP_1607 != 0
			CONDITION TMP_1608
		Expression: balance = (balance * _ONE_E18) / _expTable28
		IRs:
			TMP_1609(uint256) = balance_57 * _ONE_E18_3
			TMP_1610(uint256) = TMP_1609 / _expTable28_3
			balance_58(uint256) := TMP_1610(uint256)
		IRs:
			balance_59(uint256) := ϕ(['balance_58', 'balance_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_1611(uint256) = t_1 & 536870912
			TMP_1612(bool) = TMP_1611 != 0
			CONDITION TMP_1612
		Expression: balance = (balance * _ONE_E18) / _expTable29
		IRs:
			TMP_1613(uint256) = balance_59 * _ONE_E18_3
			TMP_1614(uint256) = TMP_1613 / _expTable29_3
			balance_60(uint256) := TMP_1614(uint256)
		IRs:
			balance_61(uint256) := ϕ(['balance_60', 'balance_1'])
		Expression: balance
		IRs:
			RETURN balance_61
		Expression: timestamp < origin
		IRs:
			TMP_1615(bool) = timestamp_1 < origin_3
			CONDITION TMP_1615
		Expression: timestamp = origin
		IRs:
			timestamp_3(uint256) := origin_3(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_2(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: balance
	Function FarmingDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		Expression: TokenizedDelegationPod(name_,symbol_,token_,maxSharePods_,sharePodGasLimit_)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)(name__1,symbol__1,token__1,maxSharePods__1,sharePodGasLimit__1)
	Function FarmingDelegationPod.register(string,string)
		IRs:
			_MAX_FARM_REWARDS_1(uint256) := ϕ(['_MAX_FARM_REWARDS_2', '_MAX_FARM_REWARDS_0'])
		Expression: shareToken = super.register(name,symbol)
		IRs:
			TMP_1617(IDelegatedShare) = INTERNAL_CALL, TokenizedDelegationPod.register(string,string)(name_1,symbol_1)
			shareToken_1(IDelegatedShare) := TMP_1617(IDelegatedShare)
		Expression: farm = new MultiFarmingPod(shareToken,_MAX_FARM_REWARDS)
		IRs:
			TMP_1619(MultiFarmingPod) = new MultiFarmingPod(shareToken_1,_MAX_FARM_REWARDS_2) 
			farm_1(MultiFarmingPod) := TMP_1619(MultiFarmingPod)
		Expression: farm.transferOwnership(msg.sender)
		IRs:
			HIGH_LEVEL_CALL, dest:farm_1(MultiFarmingPod), function:transferOwnership, arguments:['msg.sender']  
		Expression: defaultFarms[msg.sender] = address(farm)
		IRs:
			REF_376(address) -> defaultFarms_0[msg.sender]
			TMP_1621 = CONVERT farm_1 to address
			defaultFarms_1(mapping(address => address)) := ϕ(['defaultFarms_0'])
			REF_376(address) (->defaultFarms_1) := TMP_1621(address)
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function FarmingDelegationPod.delegate(address)
		IRs:
			defaultFarms_2(mapping(address => address)) := ϕ(['defaultFarms_1', 'defaultFarms_4', 'defaultFarms_0', 'defaultFarms_3'])
			registration_1(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.delegate(address)(delegatee_1)
			registration_2(mapping(address => IDelegatedShare)) := ϕ(['registration_7'])
		Expression: defaultFarm = defaultFarms[delegatee]
		IRs:
			REF_377(address) -> defaultFarms_3[delegatee_1]
			defaultFarm_1(address) := REF_377(address)
		Expression: defaultFarm != address(0)
		IRs:
			TMP_1623 = CONVERT 0 to address
			TMP_1624(bool) = defaultFarm_1 != TMP_1623
			CONDITION TMP_1624
		Expression: registration[delegatee].addDefaultFarmIfNeeded(msg.sender,defaultFarm)
		IRs:
			REF_378(IDelegatedShare) -> registration_2[delegatee_1]
			HIGH_LEVEL_CALL, dest:REF_378(IDelegatedShare), function:addDefaultFarmIfNeeded, arguments:['msg.sender', 'defaultFarm_1']  
			registration_3(mapping(address => IDelegatedShare)) := ϕ(['registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
	Function FarmingDelegationPod.setDefaultFarm(address)
		IRs:
			registration_4(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
		Expression: farm != address(0) && Pod(farm).token() != registration[msg.sender]
		IRs:
			TMP_1626 = CONVERT 0 to address
			TMP_1627(bool) = farm_1 != TMP_1626
			TMP_1628 = CONVERT farm_1 to Pod
			TMP_1629(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_1628(Pod), function:token, arguments:[]  
			registration_6(mapping(address => IDelegatedShare)) := ϕ(['registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_5', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
			REF_381(IDelegatedShare) -> registration_6[msg.sender]
			TMP_1630(bool) = TMP_1629 != REF_381
			TMP_1631(bool) = TMP_1627 && TMP_1630
			CONDITION TMP_1631
		Expression: revert DefaultFarmTokenMismatch()()
		IRs:
			TMP_1632(None) = SOLIDITY_CALL revert DefaultFarmTokenMismatch()()
		Expression: defaultFarms[msg.sender] = farm
		IRs:
			REF_382(address) -> defaultFarms_3[msg.sender]
			defaultFarms_4(mapping(address => address)) := ϕ(['defaultFarms_3'])
			REF_382(address) (->defaultFarms_4) := farm_1(address)
		Expression: DefaultFarmSet(farm)
		IRs:
			Emit DefaultFarmSet(farm_1)
		Expression: onlyRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyRegistered()()
			registration_5(mapping(address => IDelegatedShare)) := ϕ(['registration_13'])
	Function TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		Expression: maxSharePods = maxSharePods_
		IRs:
			maxSharePods_1(uint256) := maxSharePods__1(uint256)
		Expression: sharePodGasLimit = sharePodGasLimit_
		IRs:
			sharePodGasLimit_1(uint256) := sharePodGasLimit__1(uint256)
		Expression: DelegationPod(name_,symbol_,token_)
		IRs:
			INTERNAL_CALL, DelegationPod.constructor(string,string,IERC20Pods)(name__1,symbol__1,token__1)
	Function TokenizedDelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			registration_7(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
		Expression: delegatee != address(0) && address(registration[delegatee]) == address(0)
		IRs:
			TMP_1636 = CONVERT 0 to address
			TMP_1637(bool) = delegatee_1 != TMP_1636
			REF_383(IDelegatedShare) -> registration_7[delegatee_1]
			TMP_1638 = CONVERT REF_383 to address
			TMP_1639 = CONVERT 0 to address
			TMP_1640(bool) = TMP_1638 == TMP_1639
			TMP_1641(bool) = TMP_1637 && TMP_1640
			CONDITION TMP_1641
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_1642(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, DelegationPod.delegate(address)(delegatee_1)
	Function TokenizedDelegationPod.register(string,string)
		IRs:
			name_1(string) := ϕ(['name_1'])
			symbol_1(string) := ϕ(['symbol_1'])
			maxSharePods_2(uint256) := ϕ(['maxSharePods_1', 'maxSharePods_3', 'maxSharePods_0'])
			sharePodGasLimit_2(uint256) := ϕ(['sharePodGasLimit_1', 'sharePodGasLimit_0', 'sharePodGasLimit_3'])
		Expression: shareToken = new DelegatedShare(name,symbol,maxSharePods,sharePodGasLimit)
		IRs:
			TMP_1645(DelegatedShare) = new DelegatedShare(name_1,symbol_1,maxSharePods_3,sharePodGasLimit_3) 
			shareToken_1(IDelegatedShare) := TMP_1645(DelegatedShare)
		Expression: registration[msg.sender] = shareToken
		IRs:
			REF_384(IDelegatedShare) -> registration_7[msg.sender]
			registration_8(mapping(address => IDelegatedShare)) := ϕ(['registration_7'])
			REF_384(IDelegatedShare) (->registration_8) := shareToken_1(IDelegatedShare)
		Expression: RegisterDelegatee(msg.sender)
		IRs:
			Emit RegisterDelegatee(msg.sender)
		Expression: onlyNotRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyNotRegistered()()
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'msg.sender'])
			to_1(address) := ϕ(['to_1', 'msg.sender'])
			fromDelegatee_1(address) := ϕ(['TMP_1666', 'prevDelegatee_1', 'REF_392'])
			toDelegatee_1(address) := ϕ(['delegatee_1', 'REF_393', 'TMP_1667'])
			amount_1(uint256) := ϕ(['amount_1', 'balance_1'])
			registration_9(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
		Expression: super._updateBalances(from,to,fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,fromDelegatee_1,toDelegatee_1,amount_1)
		Expression: fromDelegatee != address(0)
		IRs:
			TMP_1649 = CONVERT 0 to address
			TMP_1650(bool) = fromDelegatee_1 != TMP_1649
			CONDITION TMP_1650
		Expression: registration[fromDelegatee].burn(from,amount)
		IRs:
			REF_385(IDelegatedShare) -> registration_10[fromDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_385(IDelegatedShare), function:burn, arguments:['from_1', 'amount_1']  
			registration_11(mapping(address => IDelegatedShare)) := ϕ(['registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
		Expression: toDelegatee != address(0)
		IRs:
			TMP_1652 = CONVERT 0 to address
			TMP_1653(bool) = toDelegatee_1 != TMP_1652
			CONDITION TMP_1653
		Expression: registration[toDelegatee].mint(to,amount)
		IRs:
			REF_387(IDelegatedShare) -> registration_11[toDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_387(IDelegatedShare), function:mint, arguments:['to_1', 'amount_1']  
			registration_12(mapping(address => IDelegatedShare)) := ϕ(['registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
	Function DelegationPod.constructor(string,string,IERC20Pods)
		Expression: ERC20(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name__1,symbol__1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function DelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			delegated_1(mapping(address => address)) := ϕ(['delegated_2', 'delegated_0', 'delegated_4', 'delegated_1'])
			token_1(IERC20Pods) := ϕ(['token_0', 'token_3', 'token_2'])
		Expression: prevDelegatee = delegated[msg.sender]
		IRs:
			REF_389(address) -> delegated_1[msg.sender]
			prevDelegatee_1(address) := REF_389(address)
		Expression: prevDelegatee != delegatee
		IRs:
			TMP_1657(bool) = prevDelegatee_1 != delegatee_1
			CONDITION TMP_1657
		Expression: delegated[msg.sender] = delegatee
		IRs:
			REF_390(address) -> delegated_1[msg.sender]
			delegated_2(mapping(address => address)) := ϕ(['delegated_1'])
			REF_390(address) (->delegated_2) := delegatee_1(address)
		Expression: Delegated(msg.sender,delegatee)
		IRs:
			Emit Delegated(msg.sender,delegatee_1)
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_1659 = CONVERT token_1 to IERC20Pods
			TMP_1660 = CONVERT this to address
			TMP_1661(uint256) = HIGH_LEVEL_CALL, dest:TMP_1659(IERC20Pods), function:podBalanceOf, arguments:['TMP_1660', 'msg.sender']  
			token_2(IERC20Pods) := ϕ(['token_3', 'token_1', 'token_2'])
			balance_1(uint256) := TMP_1661(uint256)
		Expression: balance > 0
		IRs:
			TMP_1662(bool) = balance_1 > 0
			CONDITION TMP_1662
		Expression: _updateBalances(msg.sender,msg.sender,prevDelegatee,delegatee,balance)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(msg.sender,msg.sender,prevDelegatee_1,delegatee_1,balance_1)
	Function DelegationPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			delegated_3(mapping(address => address)) := ϕ(['delegated_2', 'delegated_0', 'delegated_4', 'delegated_1'])
		Expression: to == address(0)
		IRs:
			TMP_1664 = CONVERT 0 to address
			TMP_1665(bool) = to_1 == TMP_1664
			CONDITION TMP_1665
		Expression: _updateBalances(from,to,address(0),address(0),amount)
		IRs:
			TMP_1666 = CONVERT 0 to address
			TMP_1667 = CONVERT 0 to address
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,TMP_1666,TMP_1667,amount_1)
		Expression: _updateBalances(from,to,delegated[from],delegated[to],amount)
		IRs:
			REF_392(address) -> delegated_3[from_1]
			REF_393(address) -> delegated_3[to_1]
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,REF_392,REF_393,amount_1)
	Function DelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			fromDelegatee_1(address) := ϕ(['fromDelegatee_1'])
			toDelegatee_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: fromDelegatee != toDelegatee && amount > 0
		IRs:
			TMP_1670(bool) = fromDelegatee_1 != toDelegatee_1
			TMP_1671(bool) = amount_1 > 0
			TMP_1672(bool) = TMP_1670 && TMP_1671
			CONDITION TMP_1672
		Expression: fromDelegatee == address(0)
		IRs:
			TMP_1673 = CONVERT 0 to address
			TMP_1674(bool) = fromDelegatee_1 == TMP_1673
			CONDITION TMP_1674
		Expression: _mint(toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(toDelegatee_1,amount_1)
		Expression: toDelegatee == address(0)
		IRs:
			TMP_1676 = CONVERT 0 to address
			TMP_1677(bool) = toDelegatee_1 == TMP_1676
			CONDITION TMP_1677
		Expression: _burn(fromDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(fromDelegatee_1,amount_1)
		Expression: _transfer(fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(fromDelegatee_1,toDelegatee_1,amount_1)
	Function DelegationPod.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_1680(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_1681(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_1682(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_1683(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_1684(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_11', '_balances_5', '_balances_1', '_balances_8'])
		Expression: _balances[account]
		IRs:
			REF_394(uint256) -> _balances_1[account_1]
			RETURN REF_394
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_1685(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_1685(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1', '_allowances_2', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_395(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_396(uint256) -> REF_395[spender_1]
			RETURN REF_396
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_1687(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_1687(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_1689(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_1689(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_1692(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_1692(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_1693(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_1694(uint256) = TMP_1693 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_1694)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_1696(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_1696(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_1697(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_1697(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_1698(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_1699(None) = SOLIDITY_CALL require(bool,string)(TMP_1698,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_1700(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_1700)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['fromDelegatee_1', 'owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'toDelegatee_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_11', '_balances_5', '_balances_1', '_balances_8'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_1702 = CONVERT 0 to address
			TMP_1703(bool) = from_1 != TMP_1702
			TMP_1704(None) = SOLIDITY_CALL require(bool,string)(TMP_1703,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_1705 = CONVERT 0 to address
			TMP_1706(bool) = to_1 != TMP_1705
			TMP_1707(None) = SOLIDITY_CALL require(bool,string)(TMP_1706,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_397(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_397(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_1709(bool) = fromBalance_1 >= amount_1
			TMP_1710(None) = SOLIDITY_CALL require(bool,string)(TMP_1709,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_398(uint256) -> _balances_3[from_1]
			TMP_1711(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_398(uint256) (->_balances_4) := TMP_1711(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_399(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_399(-> _balances_5) = REF_399 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_11', '_balances_5', '_balances_1', '_balances_8'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_1714 = CONVERT 0 to address
			TMP_1715(bool) = account_1 != TMP_1714
			TMP_1716(None) = SOLIDITY_CALL require(bool,string)(TMP_1715,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_1717 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_1717,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_400(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_400(-> _balances_8) = REF_400 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_1719 = CONVERT 0 to address
			Emit Transfer(TMP_1719,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_1721 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_1721,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['fromDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_11', '_balances_5', '_balances_1', '_balances_8'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_1723 = CONVERT 0 to address
			TMP_1724(bool) = account_1 != TMP_1723
			TMP_1725(None) = SOLIDITY_CALL require(bool,string)(TMP_1724,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_1726 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_1726,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_401(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_401(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_1728(bool) = accountBalance_1 >= amount_1
			TMP_1729(None) = SOLIDITY_CALL require(bool,string)(TMP_1728,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_402(uint256) -> _balances_10[account_1]
			TMP_1730(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_402(uint256) (->_balances_11) := TMP_1730(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_1731 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_1731,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_1733 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_1733,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_1748', 'TMP_1700', 'amount_1', 'TMP_1694'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_1735 = CONVERT 0 to address
			TMP_1736(bool) = owner_1 != TMP_1735
			TMP_1737(None) = SOLIDITY_CALL require(bool,string)(TMP_1736,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_1738 = CONVERT 0 to address
			TMP_1739(bool) = spender_1 != TMP_1738
			TMP_1740(None) = SOLIDITY_CALL require(bool,string)(TMP_1739,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_403(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_404(uint256) -> REF_403[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_404(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_1742(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_1742(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_1744(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_1745(bool) = currentAllowance_1 != TMP_1744
			CONDITION TMP_1745
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_1746(bool) = currentAllowance_1 >= amount_1
			TMP_1747(None) = SOLIDITY_CALL require(bool,string)(TMP_1746,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_1748(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_1748)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'TMP_1717', 'account_1'])
			to_1(address) := ϕ(['to_1', 'account_1', 'TMP_1726'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'TMP_1721', 'account_1'])
			to_1(address) := ϕ(['to_1', 'account_1', 'TMP_1733'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_3(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
	Function IFarmingDelegationPod.setDefaultFarm(address)
	Function PowerPod.constructor(string,string,ISt1inch)
		IRs:
			_MAX_SHARE_PODS_1(uint256) := ϕ(['_MAX_SHARE_PODS_0', '_MAX_SHARE_PODS_2'])
			_SHARE_POD_GAS_LIMIT_1(uint256) := ϕ(['_SHARE_POD_GAS_LIMIT_0', '_SHARE_POD_GAS_LIMIT_2'])
		Expression: FarmingDelegationPod(name_,symbol_,st1inch,_MAX_SHARE_PODS,_SHARE_POD_GAS_LIMIT)
		IRs:
			INTERNAL_CALL, FarmingDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)(name__1,symbol__1,st1inch_1,_MAX_SHARE_PODS_1,_SHARE_POD_GAS_LIMIT_1)
		Expression: VotingPowerCalculator(st1inch.expBase(),st1inch.origin())
		IRs:
			TMP_1753(uint256) = HIGH_LEVEL_CALL, dest:st1inch_1(ISt1inch), function:expBase, arguments:[]  
			TMP_1754(uint256) = HIGH_LEVEL_CALL, dest:st1inch_1(ISt1inch), function:origin, arguments:[]  
			INTERNAL_CALL, VotingPowerCalculator.constructor(uint256,uint256)(TMP_1753,TMP_1754)
	Function PowerPod.votingPowerOf(address)
		Expression: _votingPowerAt(balanceOf(account),block.timestamp)
		IRs:
			TMP_1756(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			TMP_1757(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(TMP_1756,block.timestamp)
			RETURN TMP_1757
	Function PowerPod.slitherConstructorConstantVariables()
		Expression: _MAX_SHARE_PODS = 3
		Expression: _SHARE_POD_GAS_LIMIT = 140_000
	Modifier TokenizedDelegationPod.onlyRegistered()
ENTRY_POINT
		IRs:
			registration_13(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
IF address(registration[msg.sender]) == address(0)
		Expression: address(registration[msg.sender]) == address(0)
		IRs:
			REF_407(IDelegatedShare) -> registration_13[msg.sender]
			TMP_1758 = CONVERT REF_407 to address
			TMP_1759 = CONVERT 0 to address
			TMP_1760(bool) = TMP_1758 == TMP_1759
			CONDITION TMP_1760
EXPRESSION revert NotRegisteredDelegatee()()
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_1761(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
END_IF
_
	Modifier TokenizedDelegationPod.onlyNotRegistered()
ENTRY_POINT
		IRs:
			registration_14(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_6', 'registration_13', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_11'])
IF address(registration[msg.sender]) != address(0)
		Expression: address(registration[msg.sender]) != address(0)
		IRs:
			REF_408(IDelegatedShare) -> registration_14[msg.sender]
			TMP_1762 = CONVERT REF_408 to address
			TMP_1763 = CONVERT 0 to address
			TMP_1764(bool) = TMP_1762 != TMP_1763
			CONDITION TMP_1764
EXPRESSION revert AlreadyRegistered()()
		Expression: revert AlreadyRegistered()()
		IRs:
			TMP_1765(None) = SOLIDITY_CALL revert AlreadyRegistered()()
END_IF
_
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_4(IERC20Pods) := ϕ(['token_0', 'token_3', 'token_2'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_1766 = CONVERT token_4 to address
			TMP_1767(bool) = msg.sender != TMP_1766
			CONDITION TMP_1767
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_1768(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract VotingPowerCalculator
	Function VotingPowerCalculator.constructor(uint256,uint256)
		IRs:
			expBase__1(uint256) := ϕ(['TMP_1753'])
			origin__1(uint256) := ϕ(['TMP_1754'])
			_ONE_E18_1(uint256) := ϕ(['_ONE_E18_0'])
		Expression: origin_ > block.timestamp
		IRs:
			TMP_1769(bool) = origin__1 > block.timestamp
			CONDITION TMP_1769
		Expression: revert OriginInTheFuture()()
		IRs:
			TMP_1770(None) = SOLIDITY_CALL revert OriginInTheFuture()()
		Expression: origin = origin_
		IRs:
			origin_1(uint256) := origin__1(uint256)
		Expression: expBase = expBase_
		IRs:
			expBase_1(uint256) := expBase__1(uint256)
		Expression: _expTable0 = expBase_
		IRs:
			_expTable0_1(uint256) := expBase__1(uint256)
		Expression: _expTable1 = (_expTable0 * _expTable0) / _ONE_E18
		IRs:
			TMP_1771(uint256) = _expTable0_1 (c)* _expTable0_1
			TMP_1772(uint256) = TMP_1771 (c)/ _ONE_E18_1
			_expTable1_1(uint256) := TMP_1772(uint256)
		Expression: _expTable2 = (_expTable1 * _expTable1) / _ONE_E18
		IRs:
			TMP_1773(uint256) = _expTable1_1 (c)* _expTable1_1
			TMP_1774(uint256) = TMP_1773 (c)/ _ONE_E18_1
			_expTable2_1(uint256) := TMP_1774(uint256)
		Expression: _expTable3 = (_expTable2 * _expTable2) / _ONE_E18
		IRs:
			TMP_1775(uint256) = _expTable2_1 (c)* _expTable2_1
			TMP_1776(uint256) = TMP_1775 (c)/ _ONE_E18_1
			_expTable3_1(uint256) := TMP_1776(uint256)
		Expression: _expTable4 = (_expTable3 * _expTable3) / _ONE_E18
		IRs:
			TMP_1777(uint256) = _expTable3_1 (c)* _expTable3_1
			TMP_1778(uint256) = TMP_1777 (c)/ _ONE_E18_1
			_expTable4_1(uint256) := TMP_1778(uint256)
		Expression: _expTable5 = (_expTable4 * _expTable4) / _ONE_E18
		IRs:
			TMP_1779(uint256) = _expTable4_1 (c)* _expTable4_1
			TMP_1780(uint256) = TMP_1779 (c)/ _ONE_E18_1
			_expTable5_1(uint256) := TMP_1780(uint256)
		Expression: _expTable6 = (_expTable5 * _expTable5) / _ONE_E18
		IRs:
			TMP_1781(uint256) = _expTable5_1 (c)* _expTable5_1
			TMP_1782(uint256) = TMP_1781 (c)/ _ONE_E18_1
			_expTable6_1(uint256) := TMP_1782(uint256)
		Expression: _expTable7 = (_expTable6 * _expTable6) / _ONE_E18
		IRs:
			TMP_1783(uint256) = _expTable6_1 (c)* _expTable6_1
			TMP_1784(uint256) = TMP_1783 (c)/ _ONE_E18_1
			_expTable7_1(uint256) := TMP_1784(uint256)
		Expression: _expTable8 = (_expTable7 * _expTable7) / _ONE_E18
		IRs:
			TMP_1785(uint256) = _expTable7_1 (c)* _expTable7_1
			TMP_1786(uint256) = TMP_1785 (c)/ _ONE_E18_1
			_expTable8_1(uint256) := TMP_1786(uint256)
		Expression: _expTable9 = (_expTable8 * _expTable8) / _ONE_E18
		IRs:
			TMP_1787(uint256) = _expTable8_1 (c)* _expTable8_1
			TMP_1788(uint256) = TMP_1787 (c)/ _ONE_E18_1
			_expTable9_1(uint256) := TMP_1788(uint256)
		Expression: _expTable10 = (_expTable9 * _expTable9) / _ONE_E18
		IRs:
			TMP_1789(uint256) = _expTable9_1 (c)* _expTable9_1
			TMP_1790(uint256) = TMP_1789 (c)/ _ONE_E18_1
			_expTable10_1(uint256) := TMP_1790(uint256)
		Expression: _expTable11 = (_expTable10 * _expTable10) / _ONE_E18
		IRs:
			TMP_1791(uint256) = _expTable10_1 (c)* _expTable10_1
			TMP_1792(uint256) = TMP_1791 (c)/ _ONE_E18_1
			_expTable11_1(uint256) := TMP_1792(uint256)
		Expression: _expTable12 = (_expTable11 * _expTable11) / _ONE_E18
		IRs:
			TMP_1793(uint256) = _expTable11_1 (c)* _expTable11_1
			TMP_1794(uint256) = TMP_1793 (c)/ _ONE_E18_1
			_expTable12_1(uint256) := TMP_1794(uint256)
		Expression: _expTable13 = (_expTable12 * _expTable12) / _ONE_E18
		IRs:
			TMP_1795(uint256) = _expTable12_1 (c)* _expTable12_1
			TMP_1796(uint256) = TMP_1795 (c)/ _ONE_E18_1
			_expTable13_1(uint256) := TMP_1796(uint256)
		Expression: _expTable14 = (_expTable13 * _expTable13) / _ONE_E18
		IRs:
			TMP_1797(uint256) = _expTable13_1 (c)* _expTable13_1
			TMP_1798(uint256) = TMP_1797 (c)/ _ONE_E18_1
			_expTable14_1(uint256) := TMP_1798(uint256)
		Expression: _expTable15 = (_expTable14 * _expTable14) / _ONE_E18
		IRs:
			TMP_1799(uint256) = _expTable14_1 (c)* _expTable14_1
			TMP_1800(uint256) = TMP_1799 (c)/ _ONE_E18_1
			_expTable15_1(uint256) := TMP_1800(uint256)
		Expression: _expTable16 = (_expTable15 * _expTable15) / _ONE_E18
		IRs:
			TMP_1801(uint256) = _expTable15_1 (c)* _expTable15_1
			TMP_1802(uint256) = TMP_1801 (c)/ _ONE_E18_1
			_expTable16_1(uint256) := TMP_1802(uint256)
		Expression: _expTable17 = (_expTable16 * _expTable16) / _ONE_E18
		IRs:
			TMP_1803(uint256) = _expTable16_1 (c)* _expTable16_1
			TMP_1804(uint256) = TMP_1803 (c)/ _ONE_E18_1
			_expTable17_1(uint256) := TMP_1804(uint256)
		Expression: _expTable18 = (_expTable17 * _expTable17) / _ONE_E18
		IRs:
			TMP_1805(uint256) = _expTable17_1 (c)* _expTable17_1
			TMP_1806(uint256) = TMP_1805 (c)/ _ONE_E18_1
			_expTable18_1(uint256) := TMP_1806(uint256)
		Expression: _expTable19 = (_expTable18 * _expTable18) / _ONE_E18
		IRs:
			TMP_1807(uint256) = _expTable18_1 (c)* _expTable18_1
			TMP_1808(uint256) = TMP_1807 (c)/ _ONE_E18_1
			_expTable19_1(uint256) := TMP_1808(uint256)
		Expression: _expTable20 = (_expTable19 * _expTable19) / _ONE_E18
		IRs:
			TMP_1809(uint256) = _expTable19_1 (c)* _expTable19_1
			TMP_1810(uint256) = TMP_1809 (c)/ _ONE_E18_1
			_expTable20_1(uint256) := TMP_1810(uint256)
		Expression: _expTable21 = (_expTable20 * _expTable20) / _ONE_E18
		IRs:
			TMP_1811(uint256) = _expTable20_1 (c)* _expTable20_1
			TMP_1812(uint256) = TMP_1811 (c)/ _ONE_E18_1
			_expTable21_1(uint256) := TMP_1812(uint256)
		Expression: _expTable22 = (_expTable21 * _expTable21) / _ONE_E18
		IRs:
			TMP_1813(uint256) = _expTable21_1 (c)* _expTable21_1
			TMP_1814(uint256) = TMP_1813 (c)/ _ONE_E18_1
			_expTable22_1(uint256) := TMP_1814(uint256)
		Expression: _expTable23 = (_expTable22 * _expTable22) / _ONE_E18
		IRs:
			TMP_1815(uint256) = _expTable22_1 (c)* _expTable22_1
			TMP_1816(uint256) = TMP_1815 (c)/ _ONE_E18_1
			_expTable23_1(uint256) := TMP_1816(uint256)
		Expression: _expTable24 = (_expTable23 * _expTable23) / _ONE_E18
		IRs:
			TMP_1817(uint256) = _expTable23_1 (c)* _expTable23_1
			TMP_1818(uint256) = TMP_1817 (c)/ _ONE_E18_1
			_expTable24_1(uint256) := TMP_1818(uint256)
		Expression: _expTable25 = (_expTable24 * _expTable24) / _ONE_E18
		IRs:
			TMP_1819(uint256) = _expTable24_1 (c)* _expTable24_1
			TMP_1820(uint256) = TMP_1819 (c)/ _ONE_E18_1
			_expTable25_1(uint256) := TMP_1820(uint256)
		Expression: _expTable26 = (_expTable25 * _expTable25) / _ONE_E18
		IRs:
			TMP_1821(uint256) = _expTable25_1 (c)* _expTable25_1
			TMP_1822(uint256) = TMP_1821 (c)/ _ONE_E18_1
			_expTable26_1(uint256) := TMP_1822(uint256)
		Expression: _expTable27 = (_expTable26 * _expTable26) / _ONE_E18
		IRs:
			TMP_1823(uint256) = _expTable26_1 (c)* _expTable26_1
			TMP_1824(uint256) = TMP_1823 (c)/ _ONE_E18_1
			_expTable27_1(uint256) := TMP_1824(uint256)
		Expression: _expTable28 = (_expTable27 * _expTable27) / _ONE_E18
		IRs:
			TMP_1825(uint256) = _expTable27_1 (c)* _expTable27_1
			TMP_1826(uint256) = TMP_1825 (c)/ _ONE_E18_1
			_expTable28_1(uint256) := TMP_1826(uint256)
		Expression: _expTable29 = (_expTable28 * _expTable28) / _ONE_E18
		IRs:
			TMP_1827(uint256) = _expTable28_1 (c)* _expTable28_1
			TMP_1828(uint256) = TMP_1827 (c)/ _ONE_E18_1
			_expTable29_1(uint256) := TMP_1828(uint256)
	Function VotingPowerCalculator._votingPowerAt(uint256,uint256)
		IRs:
			_ONE_E18_2(uint256) := ϕ(['_ONE_E18_0'])
			origin_2(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_2(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_2(uint256) := ϕ(['_expTable1_1', '_expTable1_0'])
			_expTable2_2(uint256) := ϕ(['_expTable2_1', '_expTable2_0'])
			_expTable3_2(uint256) := ϕ(['_expTable3_1', '_expTable3_0'])
			_expTable4_2(uint256) := ϕ(['_expTable4_0', '_expTable4_1'])
			_expTable5_2(uint256) := ϕ(['_expTable5_0', '_expTable5_1'])
			_expTable6_2(uint256) := ϕ(['_expTable6_0', '_expTable6_1'])
			_expTable7_2(uint256) := ϕ(['_expTable7_0', '_expTable7_1'])
			_expTable8_2(uint256) := ϕ(['_expTable8_0', '_expTable8_1'])
			_expTable9_2(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_2(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_2(uint256) := ϕ(['_expTable11_1', '_expTable11_0'])
			_expTable12_2(uint256) := ϕ(['_expTable12_0', '_expTable12_1'])
			_expTable13_2(uint256) := ϕ(['_expTable13_0', '_expTable13_1'])
			_expTable14_2(uint256) := ϕ(['_expTable14_0', '_expTable14_1'])
			_expTable15_2(uint256) := ϕ(['_expTable15_0', '_expTable15_1'])
			_expTable16_2(uint256) := ϕ(['_expTable16_0', '_expTable16_1'])
			_expTable17_2(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_2(uint256) := ϕ(['_expTable18_1', '_expTable18_0'])
			_expTable19_2(uint256) := ϕ(['_expTable19_1', '_expTable19_0'])
			_expTable20_2(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_2(uint256) := ϕ(['_expTable21_0', '_expTable21_1'])
			_expTable22_2(uint256) := ϕ(['_expTable22_0', '_expTable22_1'])
			_expTable23_2(uint256) := ϕ(['_expTable23_0', '_expTable23_1'])
			_expTable24_2(uint256) := ϕ(['_expTable24_0', '_expTable24_1'])
			_expTable25_2(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_2(uint256) := ϕ(['_expTable26_1', '_expTable26_0'])
			_expTable27_2(uint256) := ϕ(['_expTable27_1', '_expTable27_0'])
			_expTable28_2(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_2(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_1829(uint256) = timestamp_4 - origin_2
			t_1(uint256) := TMP_1829(uint256)
		Expression: votingPower = balance
		IRs:
			votingPower_1(uint256) := balance_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_1830(uint256) = t_1 & 1
			TMP_1831(bool) = TMP_1830 != 0
			CONDITION TMP_1831
		Expression: votingPower = (votingPower * _expTable0) / _ONE_E18
		IRs:
			TMP_1832(uint256) = votingPower_1 * _expTable0_2
			TMP_1833(uint256) = TMP_1832 / _ONE_E18_2
			votingPower_2(uint256) := TMP_1833(uint256)
		IRs:
			votingPower_3(uint256) := ϕ(['votingPower_2', 'votingPower_1'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_1834(uint256) = t_1 & 2
			TMP_1835(bool) = TMP_1834 != 0
			CONDITION TMP_1835
		Expression: votingPower = (votingPower * _expTable1) / _ONE_E18
		IRs:
			TMP_1836(uint256) = votingPower_3 * _expTable1_2
			TMP_1837(uint256) = TMP_1836 / _ONE_E18_2
			votingPower_4(uint256) := TMP_1837(uint256)
		IRs:
			votingPower_5(uint256) := ϕ(['votingPower_4', 'votingPower_1'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_1838(uint256) = t_1 & 4
			TMP_1839(bool) = TMP_1838 != 0
			CONDITION TMP_1839
		Expression: votingPower = (votingPower * _expTable2) / _ONE_E18
		IRs:
			TMP_1840(uint256) = votingPower_5 * _expTable2_2
			TMP_1841(uint256) = TMP_1840 / _ONE_E18_2
			votingPower_6(uint256) := TMP_1841(uint256)
		IRs:
			votingPower_7(uint256) := ϕ(['votingPower_6', 'votingPower_1'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_1842(uint256) = t_1 & 8
			TMP_1843(bool) = TMP_1842 != 0
			CONDITION TMP_1843
		Expression: votingPower = (votingPower * _expTable3) / _ONE_E18
		IRs:
			TMP_1844(uint256) = votingPower_7 * _expTable3_2
			TMP_1845(uint256) = TMP_1844 / _ONE_E18_2
			votingPower_8(uint256) := TMP_1845(uint256)
		IRs:
			votingPower_9(uint256) := ϕ(['votingPower_8', 'votingPower_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_1846(uint256) = t_1 & 16
			TMP_1847(bool) = TMP_1846 != 0
			CONDITION TMP_1847
		Expression: votingPower = (votingPower * _expTable4) / _ONE_E18
		IRs:
			TMP_1848(uint256) = votingPower_9 * _expTable4_2
			TMP_1849(uint256) = TMP_1848 / _ONE_E18_2
			votingPower_10(uint256) := TMP_1849(uint256)
		IRs:
			votingPower_11(uint256) := ϕ(['votingPower_10', 'votingPower_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_1850(uint256) = t_1 & 32
			TMP_1851(bool) = TMP_1850 != 0
			CONDITION TMP_1851
		Expression: votingPower = (votingPower * _expTable5) / _ONE_E18
		IRs:
			TMP_1852(uint256) = votingPower_11 * _expTable5_2
			TMP_1853(uint256) = TMP_1852 / _ONE_E18_2
			votingPower_12(uint256) := TMP_1853(uint256)
		IRs:
			votingPower_13(uint256) := ϕ(['votingPower_12', 'votingPower_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_1854(uint256) = t_1 & 64
			TMP_1855(bool) = TMP_1854 != 0
			CONDITION TMP_1855
		Expression: votingPower = (votingPower * _expTable6) / _ONE_E18
		IRs:
			TMP_1856(uint256) = votingPower_13 * _expTable6_2
			TMP_1857(uint256) = TMP_1856 / _ONE_E18_2
			votingPower_14(uint256) := TMP_1857(uint256)
		IRs:
			votingPower_15(uint256) := ϕ(['votingPower_14', 'votingPower_1'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_1858(uint256) = t_1 & 128
			TMP_1859(bool) = TMP_1858 != 0
			CONDITION TMP_1859
		Expression: votingPower = (votingPower * _expTable7) / _ONE_E18
		IRs:
			TMP_1860(uint256) = votingPower_15 * _expTable7_2
			TMP_1861(uint256) = TMP_1860 / _ONE_E18_2
			votingPower_16(uint256) := TMP_1861(uint256)
		IRs:
			votingPower_17(uint256) := ϕ(['votingPower_16', 'votingPower_1'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_1862(uint256) = t_1 & 256
			TMP_1863(bool) = TMP_1862 != 0
			CONDITION TMP_1863
		Expression: votingPower = (votingPower * _expTable8) / _ONE_E18
		IRs:
			TMP_1864(uint256) = votingPower_17 * _expTable8_2
			TMP_1865(uint256) = TMP_1864 / _ONE_E18_2
			votingPower_18(uint256) := TMP_1865(uint256)
		IRs:
			votingPower_19(uint256) := ϕ(['votingPower_18', 'votingPower_1'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_1866(uint256) = t_1 & 512
			TMP_1867(bool) = TMP_1866 != 0
			CONDITION TMP_1867
		Expression: votingPower = (votingPower * _expTable9) / _ONE_E18
		IRs:
			TMP_1868(uint256) = votingPower_19 * _expTable9_2
			TMP_1869(uint256) = TMP_1868 / _ONE_E18_2
			votingPower_20(uint256) := TMP_1869(uint256)
		IRs:
			votingPower_21(uint256) := ϕ(['votingPower_20', 'votingPower_1'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_1870(uint256) = t_1 & 1024
			TMP_1871(bool) = TMP_1870 != 0
			CONDITION TMP_1871
		Expression: votingPower = (votingPower * _expTable10) / _ONE_E18
		IRs:
			TMP_1872(uint256) = votingPower_21 * _expTable10_2
			TMP_1873(uint256) = TMP_1872 / _ONE_E18_2
			votingPower_22(uint256) := TMP_1873(uint256)
		IRs:
			votingPower_23(uint256) := ϕ(['votingPower_22', 'votingPower_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_1874(uint256) = t_1 & 2048
			TMP_1875(bool) = TMP_1874 != 0
			CONDITION TMP_1875
		Expression: votingPower = (votingPower * _expTable11) / _ONE_E18
		IRs:
			TMP_1876(uint256) = votingPower_23 * _expTable11_2
			TMP_1877(uint256) = TMP_1876 / _ONE_E18_2
			votingPower_24(uint256) := TMP_1877(uint256)
		IRs:
			votingPower_25(uint256) := ϕ(['votingPower_24', 'votingPower_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_1878(uint256) = t_1 & 4096
			TMP_1879(bool) = TMP_1878 != 0
			CONDITION TMP_1879
		Expression: votingPower = (votingPower * _expTable12) / _ONE_E18
		IRs:
			TMP_1880(uint256) = votingPower_25 * _expTable12_2
			TMP_1881(uint256) = TMP_1880 / _ONE_E18_2
			votingPower_26(uint256) := TMP_1881(uint256)
		IRs:
			votingPower_27(uint256) := ϕ(['votingPower_26', 'votingPower_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_1882(uint256) = t_1 & 8192
			TMP_1883(bool) = TMP_1882 != 0
			CONDITION TMP_1883
		Expression: votingPower = (votingPower * _expTable13) / _ONE_E18
		IRs:
			TMP_1884(uint256) = votingPower_27 * _expTable13_2
			TMP_1885(uint256) = TMP_1884 / _ONE_E18_2
			votingPower_28(uint256) := TMP_1885(uint256)
		IRs:
			votingPower_29(uint256) := ϕ(['votingPower_28', 'votingPower_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_1886(uint256) = t_1 & 16384
			TMP_1887(bool) = TMP_1886 != 0
			CONDITION TMP_1887
		Expression: votingPower = (votingPower * _expTable14) / _ONE_E18
		IRs:
			TMP_1888(uint256) = votingPower_29 * _expTable14_2
			TMP_1889(uint256) = TMP_1888 / _ONE_E18_2
			votingPower_30(uint256) := TMP_1889(uint256)
		IRs:
			votingPower_31(uint256) := ϕ(['votingPower_30', 'votingPower_1'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_1890(uint256) = t_1 & 32768
			TMP_1891(bool) = TMP_1890 != 0
			CONDITION TMP_1891
		Expression: votingPower = (votingPower * _expTable15) / _ONE_E18
		IRs:
			TMP_1892(uint256) = votingPower_31 * _expTable15_2
			TMP_1893(uint256) = TMP_1892 / _ONE_E18_2
			votingPower_32(uint256) := TMP_1893(uint256)
		IRs:
			votingPower_33(uint256) := ϕ(['votingPower_32', 'votingPower_1'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_1894(uint256) = t_1 & 65536
			TMP_1895(bool) = TMP_1894 != 0
			CONDITION TMP_1895
		Expression: votingPower = (votingPower * _expTable16) / _ONE_E18
		IRs:
			TMP_1896(uint256) = votingPower_33 * _expTable16_2
			TMP_1897(uint256) = TMP_1896 / _ONE_E18_2
			votingPower_34(uint256) := TMP_1897(uint256)
		IRs:
			votingPower_35(uint256) := ϕ(['votingPower_34', 'votingPower_1'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_1898(uint256) = t_1 & 131072
			TMP_1899(bool) = TMP_1898 != 0
			CONDITION TMP_1899
		Expression: votingPower = (votingPower * _expTable17) / _ONE_E18
		IRs:
			TMP_1900(uint256) = votingPower_35 * _expTable17_2
			TMP_1901(uint256) = TMP_1900 / _ONE_E18_2
			votingPower_36(uint256) := TMP_1901(uint256)
		IRs:
			votingPower_37(uint256) := ϕ(['votingPower_36', 'votingPower_1'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_1902(uint256) = t_1 & 262144
			TMP_1903(bool) = TMP_1902 != 0
			CONDITION TMP_1903
		Expression: votingPower = (votingPower * _expTable18) / _ONE_E18
		IRs:
			TMP_1904(uint256) = votingPower_37 * _expTable18_2
			TMP_1905(uint256) = TMP_1904 / _ONE_E18_2
			votingPower_38(uint256) := TMP_1905(uint256)
		IRs:
			votingPower_39(uint256) := ϕ(['votingPower_38', 'votingPower_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_1906(uint256) = t_1 & 524288
			TMP_1907(bool) = TMP_1906 != 0
			CONDITION TMP_1907
		Expression: votingPower = (votingPower * _expTable19) / _ONE_E18
		IRs:
			TMP_1908(uint256) = votingPower_39 * _expTable19_2
			TMP_1909(uint256) = TMP_1908 / _ONE_E18_2
			votingPower_40(uint256) := TMP_1909(uint256)
		IRs:
			votingPower_41(uint256) := ϕ(['votingPower_40', 'votingPower_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_1910(uint256) = t_1 & 1048576
			TMP_1911(bool) = TMP_1910 != 0
			CONDITION TMP_1911
		Expression: votingPower = (votingPower * _expTable20) / _ONE_E18
		IRs:
			TMP_1912(uint256) = votingPower_41 * _expTable20_2
			TMP_1913(uint256) = TMP_1912 / _ONE_E18_2
			votingPower_42(uint256) := TMP_1913(uint256)
		IRs:
			votingPower_43(uint256) := ϕ(['votingPower_42', 'votingPower_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_1914(uint256) = t_1 & 2097152
			TMP_1915(bool) = TMP_1914 != 0
			CONDITION TMP_1915
		Expression: votingPower = (votingPower * _expTable21) / _ONE_E18
		IRs:
			TMP_1916(uint256) = votingPower_43 * _expTable21_2
			TMP_1917(uint256) = TMP_1916 / _ONE_E18_2
			votingPower_44(uint256) := TMP_1917(uint256)
		IRs:
			votingPower_45(uint256) := ϕ(['votingPower_44', 'votingPower_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_1918(uint256) = t_1 & 4194304
			TMP_1919(bool) = TMP_1918 != 0
			CONDITION TMP_1919
		Expression: votingPower = (votingPower * _expTable22) / _ONE_E18
		IRs:
			TMP_1920(uint256) = votingPower_45 * _expTable22_2
			TMP_1921(uint256) = TMP_1920 / _ONE_E18_2
			votingPower_46(uint256) := TMP_1921(uint256)
		IRs:
			votingPower_47(uint256) := ϕ(['votingPower_46', 'votingPower_1'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_1922(uint256) = t_1 & 8388608
			TMP_1923(bool) = TMP_1922 != 0
			CONDITION TMP_1923
		Expression: votingPower = (votingPower * _expTable23) / _ONE_E18
		IRs:
			TMP_1924(uint256) = votingPower_47 * _expTable23_2
			TMP_1925(uint256) = TMP_1924 / _ONE_E18_2
			votingPower_48(uint256) := TMP_1925(uint256)
		IRs:
			votingPower_49(uint256) := ϕ(['votingPower_48', 'votingPower_1'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_1926(uint256) = t_1 & 16777216
			TMP_1927(bool) = TMP_1926 != 0
			CONDITION TMP_1927
		Expression: votingPower = (votingPower * _expTable24) / _ONE_E18
		IRs:
			TMP_1928(uint256) = votingPower_49 * _expTable24_2
			TMP_1929(uint256) = TMP_1928 / _ONE_E18_2
			votingPower_50(uint256) := TMP_1929(uint256)
		IRs:
			votingPower_51(uint256) := ϕ(['votingPower_50', 'votingPower_1'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_1930(uint256) = t_1 & 33554432
			TMP_1931(bool) = TMP_1930 != 0
			CONDITION TMP_1931
		Expression: votingPower = (votingPower * _expTable25) / _ONE_E18
		IRs:
			TMP_1932(uint256) = votingPower_51 * _expTable25_2
			TMP_1933(uint256) = TMP_1932 / _ONE_E18_2
			votingPower_52(uint256) := TMP_1933(uint256)
		IRs:
			votingPower_53(uint256) := ϕ(['votingPower_52', 'votingPower_1'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_1934(uint256) = t_1 & 67108864
			TMP_1935(bool) = TMP_1934 != 0
			CONDITION TMP_1935
		Expression: votingPower = (votingPower * _expTable26) / _ONE_E18
		IRs:
			TMP_1936(uint256) = votingPower_53 * _expTable26_2
			TMP_1937(uint256) = TMP_1936 / _ONE_E18_2
			votingPower_54(uint256) := TMP_1937(uint256)
		IRs:
			votingPower_55(uint256) := ϕ(['votingPower_54', 'votingPower_1'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_1938(uint256) = t_1 & 134217728
			TMP_1939(bool) = TMP_1938 != 0
			CONDITION TMP_1939
		Expression: votingPower = (votingPower * _expTable27) / _ONE_E18
		IRs:
			TMP_1940(uint256) = votingPower_55 * _expTable27_2
			TMP_1941(uint256) = TMP_1940 / _ONE_E18_2
			votingPower_56(uint256) := TMP_1941(uint256)
		IRs:
			votingPower_57(uint256) := ϕ(['votingPower_56', 'votingPower_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_1942(uint256) = t_1 & 268435456
			TMP_1943(bool) = TMP_1942 != 0
			CONDITION TMP_1943
		Expression: votingPower = (votingPower * _expTable28) / _ONE_E18
		IRs:
			TMP_1944(uint256) = votingPower_57 * _expTable28_2
			TMP_1945(uint256) = TMP_1944 / _ONE_E18_2
			votingPower_58(uint256) := TMP_1945(uint256)
		IRs:
			votingPower_59(uint256) := ϕ(['votingPower_58', 'votingPower_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_1946(uint256) = t_1 & 536870912
			TMP_1947(bool) = TMP_1946 != 0
			CONDITION TMP_1947
		Expression: votingPower = (votingPower * _expTable29) / _ONE_E18
		IRs:
			TMP_1948(uint256) = votingPower_59 * _expTable29_2
			TMP_1949(uint256) = TMP_1948 / _ONE_E18_2
			votingPower_60(uint256) := TMP_1949(uint256)
		IRs:
			votingPower_61(uint256) := ϕ(['votingPower_60', 'votingPower_1'])
		Expression: votingPower
		IRs:
			RETURN votingPower_61
		Expression: timestamp < origin
		IRs:
			TMP_1950(bool) = timestamp_1 < origin_2
			CONDITION TMP_1950
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_2(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: votingPower
	Function VotingPowerCalculator._balanceAt(uint256,uint256)
		IRs:
			_ONE_E18_3(uint256) := ϕ(['_ONE_E18_0'])
			origin_3(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_3(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_3(uint256) := ϕ(['_expTable1_1', '_expTable1_0'])
			_expTable2_3(uint256) := ϕ(['_expTable2_1', '_expTable2_0'])
			_expTable3_3(uint256) := ϕ(['_expTable3_1', '_expTable3_0'])
			_expTable4_3(uint256) := ϕ(['_expTable4_0', '_expTable4_1'])
			_expTable5_3(uint256) := ϕ(['_expTable5_0', '_expTable5_1'])
			_expTable6_3(uint256) := ϕ(['_expTable6_0', '_expTable6_1'])
			_expTable7_3(uint256) := ϕ(['_expTable7_0', '_expTable7_1'])
			_expTable8_3(uint256) := ϕ(['_expTable8_0', '_expTable8_1'])
			_expTable9_3(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_3(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_3(uint256) := ϕ(['_expTable11_1', '_expTable11_0'])
			_expTable12_3(uint256) := ϕ(['_expTable12_0', '_expTable12_1'])
			_expTable13_3(uint256) := ϕ(['_expTable13_0', '_expTable13_1'])
			_expTable14_3(uint256) := ϕ(['_expTable14_0', '_expTable14_1'])
			_expTable15_3(uint256) := ϕ(['_expTable15_0', '_expTable15_1'])
			_expTable16_3(uint256) := ϕ(['_expTable16_0', '_expTable16_1'])
			_expTable17_3(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_3(uint256) := ϕ(['_expTable18_1', '_expTable18_0'])
			_expTable19_3(uint256) := ϕ(['_expTable19_1', '_expTable19_0'])
			_expTable20_3(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_3(uint256) := ϕ(['_expTable21_0', '_expTable21_1'])
			_expTable22_3(uint256) := ϕ(['_expTable22_0', '_expTable22_1'])
			_expTable23_3(uint256) := ϕ(['_expTable23_0', '_expTable23_1'])
			_expTable24_3(uint256) := ϕ(['_expTable24_0', '_expTable24_1'])
			_expTable25_3(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_3(uint256) := ϕ(['_expTable26_1', '_expTable26_0'])
			_expTable27_3(uint256) := ϕ(['_expTable27_1', '_expTable27_0'])
			_expTable28_3(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_3(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_1951(uint256) = timestamp_4 - origin_3
			t_1(uint256) := TMP_1951(uint256)
		Expression: balance = votingPower
		IRs:
			balance_1(uint256) := votingPower_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_1952(uint256) = t_1 & 1
			TMP_1953(bool) = TMP_1952 != 0
			CONDITION TMP_1953
		Expression: balance = (balance * _ONE_E18) / _expTable0
		IRs:
			TMP_1954(uint256) = balance_1 * _ONE_E18_3
			TMP_1955(uint256) = TMP_1954 / _expTable0_3
			balance_2(uint256) := TMP_1955(uint256)
		IRs:
			balance_3(uint256) := ϕ(['balance_2', 'balance_1'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_1956(uint256) = t_1 & 2
			TMP_1957(bool) = TMP_1956 != 0
			CONDITION TMP_1957
		Expression: balance = (balance * _ONE_E18) / _expTable1
		IRs:
			TMP_1958(uint256) = balance_3 * _ONE_E18_3
			TMP_1959(uint256) = TMP_1958 / _expTable1_3
			balance_4(uint256) := TMP_1959(uint256)
		IRs:
			balance_5(uint256) := ϕ(['balance_1', 'balance_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_1960(uint256) = t_1 & 4
			TMP_1961(bool) = TMP_1960 != 0
			CONDITION TMP_1961
		Expression: balance = (balance * _ONE_E18) / _expTable2
		IRs:
			TMP_1962(uint256) = balance_5 * _ONE_E18_3
			TMP_1963(uint256) = TMP_1962 / _expTable2_3
			balance_6(uint256) := TMP_1963(uint256)
		IRs:
			balance_7(uint256) := ϕ(['balance_6', 'balance_1'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_1964(uint256) = t_1 & 8
			TMP_1965(bool) = TMP_1964 != 0
			CONDITION TMP_1965
		Expression: balance = (balance * _ONE_E18) / _expTable3
		IRs:
			TMP_1966(uint256) = balance_7 * _ONE_E18_3
			TMP_1967(uint256) = TMP_1966 / _expTable3_3
			balance_8(uint256) := TMP_1967(uint256)
		IRs:
			balance_9(uint256) := ϕ(['balance_8', 'balance_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_1968(uint256) = t_1 & 16
			TMP_1969(bool) = TMP_1968 != 0
			CONDITION TMP_1969
		Expression: balance = (balance * _ONE_E18) / _expTable4
		IRs:
			TMP_1970(uint256) = balance_9 * _ONE_E18_3
			TMP_1971(uint256) = TMP_1970 / _expTable4_3
			balance_10(uint256) := TMP_1971(uint256)
		IRs:
			balance_11(uint256) := ϕ(['balance_10', 'balance_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_1972(uint256) = t_1 & 32
			TMP_1973(bool) = TMP_1972 != 0
			CONDITION TMP_1973
		Expression: balance = (balance * _ONE_E18) / _expTable5
		IRs:
			TMP_1974(uint256) = balance_11 * _ONE_E18_3
			TMP_1975(uint256) = TMP_1974 / _expTable5_3
			balance_12(uint256) := TMP_1975(uint256)
		IRs:
			balance_13(uint256) := ϕ(['balance_12', 'balance_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_1976(uint256) = t_1 & 64
			TMP_1977(bool) = TMP_1976 != 0
			CONDITION TMP_1977
		Expression: balance = (balance * _ONE_E18) / _expTable6
		IRs:
			TMP_1978(uint256) = balance_13 * _ONE_E18_3
			TMP_1979(uint256) = TMP_1978 / _expTable6_3
			balance_14(uint256) := TMP_1979(uint256)
		IRs:
			balance_15(uint256) := ϕ(['balance_14', 'balance_1'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_1980(uint256) = t_1 & 128
			TMP_1981(bool) = TMP_1980 != 0
			CONDITION TMP_1981
		Expression: balance = (balance * _ONE_E18) / _expTable7
		IRs:
			TMP_1982(uint256) = balance_15 * _ONE_E18_3
			TMP_1983(uint256) = TMP_1982 / _expTable7_3
			balance_16(uint256) := TMP_1983(uint256)
		IRs:
			balance_17(uint256) := ϕ(['balance_16', 'balance_1'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_1984(uint256) = t_1 & 256
			TMP_1985(bool) = TMP_1984 != 0
			CONDITION TMP_1985
		Expression: balance = (balance * _ONE_E18) / _expTable8
		IRs:
			TMP_1986(uint256) = balance_17 * _ONE_E18_3
			TMP_1987(uint256) = TMP_1986 / _expTable8_3
			balance_18(uint256) := TMP_1987(uint256)
		IRs:
			balance_19(uint256) := ϕ(['balance_18', 'balance_1'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_1988(uint256) = t_1 & 512
			TMP_1989(bool) = TMP_1988 != 0
			CONDITION TMP_1989
		Expression: balance = (balance * _ONE_E18) / _expTable9
		IRs:
			TMP_1990(uint256) = balance_19 * _ONE_E18_3
			TMP_1991(uint256) = TMP_1990 / _expTable9_3
			balance_20(uint256) := TMP_1991(uint256)
		IRs:
			balance_21(uint256) := ϕ(['balance_1', 'balance_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_1992(uint256) = t_1 & 1024
			TMP_1993(bool) = TMP_1992 != 0
			CONDITION TMP_1993
		Expression: balance = (balance * _ONE_E18) / _expTable10
		IRs:
			TMP_1994(uint256) = balance_21 * _ONE_E18_3
			TMP_1995(uint256) = TMP_1994 / _expTable10_3
			balance_22(uint256) := TMP_1995(uint256)
		IRs:
			balance_23(uint256) := ϕ(['balance_22', 'balance_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_1996(uint256) = t_1 & 2048
			TMP_1997(bool) = TMP_1996 != 0
			CONDITION TMP_1997
		Expression: balance = (balance * _ONE_E18) / _expTable11
		IRs:
			TMP_1998(uint256) = balance_23 * _ONE_E18_3
			TMP_1999(uint256) = TMP_1998 / _expTable11_3
			balance_24(uint256) := TMP_1999(uint256)
		IRs:
			balance_25(uint256) := ϕ(['balance_24', 'balance_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_2000(uint256) = t_1 & 4096
			TMP_2001(bool) = TMP_2000 != 0
			CONDITION TMP_2001
		Expression: balance = (balance * _ONE_E18) / _expTable12
		IRs:
			TMP_2002(uint256) = balance_25 * _ONE_E18_3
			TMP_2003(uint256) = TMP_2002 / _expTable12_3
			balance_26(uint256) := TMP_2003(uint256)
		IRs:
			balance_27(uint256) := ϕ(['balance_26', 'balance_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_2004(uint256) = t_1 & 8192
			TMP_2005(bool) = TMP_2004 != 0
			CONDITION TMP_2005
		Expression: balance = (balance * _ONE_E18) / _expTable13
		IRs:
			TMP_2006(uint256) = balance_27 * _ONE_E18_3
			TMP_2007(uint256) = TMP_2006 / _expTable13_3
			balance_28(uint256) := TMP_2007(uint256)
		IRs:
			balance_29(uint256) := ϕ(['balance_28', 'balance_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_2008(uint256) = t_1 & 16384
			TMP_2009(bool) = TMP_2008 != 0
			CONDITION TMP_2009
		Expression: balance = (balance * _ONE_E18) / _expTable14
		IRs:
			TMP_2010(uint256) = balance_29 * _ONE_E18_3
			TMP_2011(uint256) = TMP_2010 / _expTable14_3
			balance_30(uint256) := TMP_2011(uint256)
		IRs:
			balance_31(uint256) := ϕ(['balance_30', 'balance_1'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_2012(uint256) = t_1 & 32768
			TMP_2013(bool) = TMP_2012 != 0
			CONDITION TMP_2013
		Expression: balance = (balance * _ONE_E18) / _expTable15
		IRs:
			TMP_2014(uint256) = balance_31 * _ONE_E18_3
			TMP_2015(uint256) = TMP_2014 / _expTable15_3
			balance_32(uint256) := TMP_2015(uint256)
		IRs:
			balance_33(uint256) := ϕ(['balance_32', 'balance_1'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_2016(uint256) = t_1 & 65536
			TMP_2017(bool) = TMP_2016 != 0
			CONDITION TMP_2017
		Expression: balance = (balance * _ONE_E18) / _expTable16
		IRs:
			TMP_2018(uint256) = balance_33 * _ONE_E18_3
			TMP_2019(uint256) = TMP_2018 / _expTable16_3
			balance_34(uint256) := TMP_2019(uint256)
		IRs:
			balance_35(uint256) := ϕ(['balance_34', 'balance_1'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_2020(uint256) = t_1 & 131072
			TMP_2021(bool) = TMP_2020 != 0
			CONDITION TMP_2021
		Expression: balance = (balance * _ONE_E18) / _expTable17
		IRs:
			TMP_2022(uint256) = balance_35 * _ONE_E18_3
			TMP_2023(uint256) = TMP_2022 / _expTable17_3
			balance_36(uint256) := TMP_2023(uint256)
		IRs:
			balance_37(uint256) := ϕ(['balance_1', 'balance_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_2024(uint256) = t_1 & 262144
			TMP_2025(bool) = TMP_2024 != 0
			CONDITION TMP_2025
		Expression: balance = (balance * _ONE_E18) / _expTable18
		IRs:
			TMP_2026(uint256) = balance_37 * _ONE_E18_3
			TMP_2027(uint256) = TMP_2026 / _expTable18_3
			balance_38(uint256) := TMP_2027(uint256)
		IRs:
			balance_39(uint256) := ϕ(['balance_38', 'balance_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_2028(uint256) = t_1 & 524288
			TMP_2029(bool) = TMP_2028 != 0
			CONDITION TMP_2029
		Expression: balance = (balance * _ONE_E18) / _expTable19
		IRs:
			TMP_2030(uint256) = balance_39 * _ONE_E18_3
			TMP_2031(uint256) = TMP_2030 / _expTable19_3
			balance_40(uint256) := TMP_2031(uint256)
		IRs:
			balance_41(uint256) := ϕ(['balance_40', 'balance_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_2032(uint256) = t_1 & 1048576
			TMP_2033(bool) = TMP_2032 != 0
			CONDITION TMP_2033
		Expression: balance = (balance * _ONE_E18) / _expTable20
		IRs:
			TMP_2034(uint256) = balance_41 * _ONE_E18_3
			TMP_2035(uint256) = TMP_2034 / _expTable20_3
			balance_42(uint256) := TMP_2035(uint256)
		IRs:
			balance_43(uint256) := ϕ(['balance_42', 'balance_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_2036(uint256) = t_1 & 2097152
			TMP_2037(bool) = TMP_2036 != 0
			CONDITION TMP_2037
		Expression: balance = (balance * _ONE_E18) / _expTable21
		IRs:
			TMP_2038(uint256) = balance_43 * _ONE_E18_3
			TMP_2039(uint256) = TMP_2038 / _expTable21_3
			balance_44(uint256) := TMP_2039(uint256)
		IRs:
			balance_45(uint256) := ϕ(['balance_44', 'balance_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_2040(uint256) = t_1 & 4194304
			TMP_2041(bool) = TMP_2040 != 0
			CONDITION TMP_2041
		Expression: balance = (balance * _ONE_E18) / _expTable22
		IRs:
			TMP_2042(uint256) = balance_45 * _ONE_E18_3
			TMP_2043(uint256) = TMP_2042 / _expTable22_3
			balance_46(uint256) := TMP_2043(uint256)
		IRs:
			balance_47(uint256) := ϕ(['balance_46', 'balance_1'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_2044(uint256) = t_1 & 8388608
			TMP_2045(bool) = TMP_2044 != 0
			CONDITION TMP_2045
		Expression: balance = (balance * _ONE_E18) / _expTable23
		IRs:
			TMP_2046(uint256) = balance_47 * _ONE_E18_3
			TMP_2047(uint256) = TMP_2046 / _expTable23_3
			balance_48(uint256) := TMP_2047(uint256)
		IRs:
			balance_49(uint256) := ϕ(['balance_48', 'balance_1'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_2048(uint256) = t_1 & 16777216
			TMP_2049(bool) = TMP_2048 != 0
			CONDITION TMP_2049
		Expression: balance = (balance * _ONE_E18) / _expTable24
		IRs:
			TMP_2050(uint256) = balance_49 * _ONE_E18_3
			TMP_2051(uint256) = TMP_2050 / _expTable24_3
			balance_50(uint256) := TMP_2051(uint256)
		IRs:
			balance_51(uint256) := ϕ(['balance_50', 'balance_1'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_2052(uint256) = t_1 & 33554432
			TMP_2053(bool) = TMP_2052 != 0
			CONDITION TMP_2053
		Expression: balance = (balance * _ONE_E18) / _expTable25
		IRs:
			TMP_2054(uint256) = balance_51 * _ONE_E18_3
			TMP_2055(uint256) = TMP_2054 / _expTable25_3
			balance_52(uint256) := TMP_2055(uint256)
		IRs:
			balance_53(uint256) := ϕ(['balance_1', 'balance_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_2056(uint256) = t_1 & 67108864
			TMP_2057(bool) = TMP_2056 != 0
			CONDITION TMP_2057
		Expression: balance = (balance * _ONE_E18) / _expTable26
		IRs:
			TMP_2058(uint256) = balance_53 * _ONE_E18_3
			TMP_2059(uint256) = TMP_2058 / _expTable26_3
			balance_54(uint256) := TMP_2059(uint256)
		IRs:
			balance_55(uint256) := ϕ(['balance_54', 'balance_1'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_2060(uint256) = t_1 & 134217728
			TMP_2061(bool) = TMP_2060 != 0
			CONDITION TMP_2061
		Expression: balance = (balance * _ONE_E18) / _expTable27
		IRs:
			TMP_2062(uint256) = balance_55 * _ONE_E18_3
			TMP_2063(uint256) = TMP_2062 / _expTable27_3
			balance_56(uint256) := TMP_2063(uint256)
		IRs:
			balance_57(uint256) := ϕ(['balance_56', 'balance_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_2064(uint256) = t_1 & 268435456
			TMP_2065(bool) = TMP_2064 != 0
			CONDITION TMP_2065
		Expression: balance = (balance * _ONE_E18) / _expTable28
		IRs:
			TMP_2066(uint256) = balance_57 * _ONE_E18_3
			TMP_2067(uint256) = TMP_2066 / _expTable28_3
			balance_58(uint256) := TMP_2067(uint256)
		IRs:
			balance_59(uint256) := ϕ(['balance_58', 'balance_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_2068(uint256) = t_1 & 536870912
			TMP_2069(bool) = TMP_2068 != 0
			CONDITION TMP_2069
		Expression: balance = (balance * _ONE_E18) / _expTable29
		IRs:
			TMP_2070(uint256) = balance_59 * _ONE_E18_3
			TMP_2071(uint256) = TMP_2070 / _expTable29_3
			balance_60(uint256) := TMP_2071(uint256)
		IRs:
			balance_61(uint256) := ϕ(['balance_60', 'balance_1'])
		Expression: balance
		IRs:
			RETURN balance_61
		Expression: timestamp < origin
		IRs:
			TMP_2072(bool) = timestamp_1 < origin_3
			CONDITION TMP_2072
		Expression: timestamp = origin
		IRs:
			timestamp_3(uint256) := origin_3(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_2(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: balance
	Function VotingPowerCalculator.slitherConstructorConstantVariables()
		Expression: _ONE_E18 = 1e18
Contract ISt1inch
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function ISt1inch.expBase()
	Function ISt1inch.origin()
	Function ISt1inch.oneInch()
	Function ISt1inch.emergencyExit()
	Function ISt1inch.depositFor(address,uint256)
Contract IVotable
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IVotable.votingPowerOf(address)
Contract DelegatedShare
	Function ERC20Pods.constructor(uint256,uint256)
		IRs:
			_guard_1(ReentrancyGuardLib.Data) := ϕ(['_guard_7', '_guard_0', '_guard_3', '_guard_5'])
		Expression: podsLimit_ == 0
		IRs:
			TMP_0(bool) = podsLimit__1 == 0
			CONDITION TMP_0
		Expression: revert ZeroPodsLimit()()
		IRs:
			TMP_1(None) = SOLIDITY_CALL revert ZeroPodsLimit()()
		Expression: podsLimit = podsLimit_
		IRs:
			podsLimit_1(uint256) := podsLimit__1(uint256)
		Expression: podCallGasLimit = podCallGasLimit_
		IRs:
			podCallGasLimit_1(uint256) := podCallGasLimit__1(uint256)
		Expression: _guard.init()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.init(ReentrancyGuardLib.Data), arguments:['_guard_1'] 
	Function ERC20Pods.hasPod(address,address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			pod_1(address) := ϕ(['farm_1', 'pod_1'])
			_pods_1(mapping(address => AddressSet.Data)) := ϕ(['_pods_0', '_pods_1', '_pods_13', '_pods_7', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_3'])
		Expression: _pods[account].contains(pod)
		IRs:
			REF_1(AddressSet.Data) -> _pods_1[account_1]
			TMP_3(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.contains(AddressSet.Data,address), arguments:['REF_1', 'pod_1'] 
			RETURN TMP_3
	Function ERC20Pods.podsCount(address)
		IRs:
			_pods_2(mapping(address => AddressSet.Data)) := ϕ(['_pods_0', '_pods_1', '_pods_13', '_pods_7', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_3'])
		Expression: _pods[account].length()
		IRs:
			REF_3(AddressSet.Data) -> _pods_2[account_1]
			TMP_4(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_3'] 
			RETURN TMP_4
	Function ERC20Pods.podAt(address,uint256)
		IRs:
			_pods_3(mapping(address => AddressSet.Data)) := ϕ(['_pods_0', '_pods_1', '_pods_13', '_pods_7', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_3'])
		Expression: _pods[account].at(index)
		IRs:
			REF_5(AddressSet.Data) -> _pods_3[account_1]
			TMP_5(address) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.at(AddressSet.Data,uint256), arguments:['REF_5', 'index_1'] 
			RETURN TMP_5
	Function ERC20Pods.pods(address)
		IRs:
			_pods_4(mapping(address => AddressSet.Data)) := ϕ(['_pods_0', '_pods_1', '_pods_13', '_pods_7', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_3'])
		Expression: _pods[account].items.get()
		IRs:
			REF_7(AddressSet.Data) -> _pods_4[account_1]
			REF_8(AddressArray.Data) -> REF_7.items
			TMP_6(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_8'] 
			RETURN TMP_6
	Function ERC20Pods.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1', 'account_1'])
			_guard_2(ReentrancyGuardLib.Data) := ϕ(['_guard_7', '_guard_0', '_guard_3', '_guard_5'])
		Expression: super.balanceOf(account)
		IRs:
			TMP_7(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_7
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_2)
	Function ERC20Pods.podBalanceOf(address,address)
		IRs:
			_guard_4(ReentrancyGuardLib.Data) := ϕ(['_guard_7', '_guard_0', '_guard_3', '_guard_5'])
		Expression: hasPod(account,pod)
		IRs:
			TMP_9(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,pod_1)
			CONDITION TMP_9
		Expression: super.balanceOf(account)
		IRs:
			TMP_10(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_10
		Expression: 0
		IRs:
			RETURN 0
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_4)
	Function ERC20Pods.addPod(address)
		Expression: _addPod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removePod(address)
		Expression: _removePod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._removePod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removeAllPods()
		Expression: _removeAllPods(msg.sender)
		IRs:
			INTERNAL_CALL, ERC20Pods._removeAllPods(address)(msg.sender)
	Function ERC20Pods._addPod(address,address)
		IRs:
			account_1(address) := ϕ(['account_1', 'msg.sender'])
			pod_1(address) := ϕ(['farm_1', 'pod_1'])
			podsLimit_2(uint256) := ϕ(['podsLimit_0', 'podsLimit_1', 'podsLimit_3'])
			_pods_5(mapping(address => AddressSet.Data)) := ϕ(['_pods_0', '_pods_1', '_pods_13', '_pods_7', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_3'])
		Expression: pod == address(0)
		IRs:
			TMP_15 = CONVERT 0 to address
			TMP_16(bool) = pod_1 == TMP_15
			CONDITION TMP_16
		Expression: revert InvalidPodAddress()()
		IRs:
			TMP_17(None) = SOLIDITY_CALL revert InvalidPodAddress()()
		Expression: IPod(pod).token() != IERC20Pods(address(this))
		IRs:
			TMP_18 = CONVERT pod_1 to IPod
			TMP_19(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_18(IPod), function:token, arguments:[]  
			podsLimit_3(uint256) := ϕ(['podsLimit_1', 'podsLimit_3', 'podsLimit_2'])
			_pods_6(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_7', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_5', '_pods_3'])
			TMP_20 = CONVERT this to address
			TMP_21 = CONVERT TMP_20 to IERC20Pods
			TMP_22(bool) = TMP_19 != TMP_21
			CONDITION TMP_22
		Expression: revert InvalidTokenInPod()()
		IRs:
			TMP_23(None) = SOLIDITY_CALL revert InvalidTokenInPod()()
		Expression: ! _pods[account].add(pod)
		IRs:
			REF_11(AddressSet.Data) -> _pods_6[account_1]
			TMP_24(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.add(AddressSet.Data,address), arguments:['REF_11', 'pod_1'] 
			TMP_25 = UnaryType.BANG TMP_24 
			CONDITION TMP_25
		Expression: revert PodAlreadyAdded()()
		IRs:
			TMP_26(None) = SOLIDITY_CALL revert PodAlreadyAdded()()
		Expression: _pods[account].length() > podsLimit
		IRs:
			REF_13(AddressSet.Data) -> _pods_6[account_1]
			TMP_27(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_13'] 
			TMP_28(bool) = TMP_27 > podsLimit_3
			CONDITION TMP_28
		Expression: revert PodsLimitReachedForAccount()()
		IRs:
			TMP_29(None) = SOLIDITY_CALL revert PodsLimitReachedForAccount()()
		Expression: PodAdded(account,pod)
		IRs:
			Emit PodAdded(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_31(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_31(uint256)
		Expression: balance > 0
		IRs:
			TMP_32(bool) = balance_1 > 0
			CONDITION TMP_32
		Expression: _updateBalances(pod,address(0),account,balance)
		IRs:
			TMP_33 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,TMP_33,account_1,balance_1)
	Function ERC20Pods._removePod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			pod_1(address) := ϕ(['pod_1'])
			_pods_7(mapping(address => AddressSet.Data)) := ϕ(['_pods_0', '_pods_1', '_pods_13', '_pods_7', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_3'])
		Expression: ! _pods[account].remove(pod)
		IRs:
			REF_15(AddressSet.Data) -> _pods_7[account_1]
			TMP_35(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_15', 'pod_1'] 
			TMP_36 = UnaryType.BANG TMP_35 
			CONDITION TMP_36
		Expression: revert PodNotFound()()
		IRs:
			TMP_37(None) = SOLIDITY_CALL revert PodNotFound()()
		Expression: PodRemoved(account,pod)
		IRs:
			Emit PodRemoved(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_39(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_39(uint256)
		Expression: balance > 0
		IRs:
			TMP_40(bool) = balance_1 > 0
			CONDITION TMP_40
		Expression: _updateBalances(pod,account,address(0),balance)
		IRs:
			TMP_41 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,account_1,TMP_41,balance_1)
	Function ERC20Pods._removeAllPods(address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			_pods_8(mapping(address => AddressSet.Data)) := ϕ(['_pods_0', '_pods_1', '_pods_13', '_pods_7', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_3'])
		Expression: items = _pods[account].items.get()
		IRs:
			REF_17(AddressSet.Data) -> _pods_8[account_1]
			REF_18(AddressArray.Data) -> REF_17.items
			TMP_43(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_18'] 
			items_1(address[]) = ['TMP_43(address[])']
		Expression: balance = balanceOf(account)
		IRs:
			TMP_44(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_44(uint256)
		Expression: i = items.length
		IRs:
			REF_20 -> LENGTH items_1
			i_1(uint256) := REF_20(uint256)
		Expression: i > 0
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_45(bool) = i_2 > 0
			CONDITION TMP_45
		Expression: _pods[account].remove(items[i - 1])
		IRs:
			REF_21(AddressSet.Data) -> _pods_9[account_1]
			TMP_46(uint256) = i_2 - 1
			REF_23(address) -> items_1[TMP_46]
			TMP_47(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_21', 'REF_23'] 
		Expression: PodRemoved(account,items[i - 1])
		IRs:
			TMP_48(uint256) = i_2 - 1
			REF_24(address) -> items_1[TMP_48]
			Emit PodRemoved(account_1,REF_24)
		Expression: balance > 0
		IRs:
			TMP_50(bool) = balance_1 > 0
			CONDITION TMP_50
		Expression: _updateBalances(items[i - 1],account,address(0),balance)
		IRs:
			TMP_51(uint256) = i_2 - 1
			REF_25(address) -> items_1[TMP_51]
			TMP_52 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(REF_25,account_1,TMP_52,balance_1)
		Expression: i --
		IRs:
			TMP_54(uint256) := i_2(uint256)
			i_3(uint256) = i_2 - 1
	Function ERC20Pods._updateBalances(address,address,address,uint256)
		IRs:
			pod_1(address) := ϕ(['pod_scope_1_1', 'pod_1', 'pod_1', 'REF_25', 'pod_1'])
			from_1(address) := ϕ(['account_1', 'account_1', 'from_1', 'TMP_90', 'TMP_33'])
			to_1(address) := ϕ(['account_1', 'TMP_52', 'to_1', 'TMP_84', 'TMP_41'])
			amount_1(uint256) := ϕ(['balance_1', 'balance_1', 'amount_1', 'balance_1'])
			podCallGasLimit_2(uint256) := ϕ(['podCallGasLimit_0', 'podCallGasLimit_1'])
		Expression: selector = IPod.updateBalances.selector
		IRs:
			REF_27(bytes4) (->None) := 2048858793(bytes4)
			selector_1(bytes4) := REF_27(bytes4)
		Expression: exception = revert InsufficientGas().selector
		IRs:
			REF_28(bytes4) (->None) := 472281420(bytes4)
			exception_1(bytes4) := REF_28(bytes4)
		Expression: gasLimit = podCallGasLimit
		IRs:
			gasLimit_1(uint256) := podCallGasLimit_2(uint256)
		Expression: ptr__updateBalances_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_55(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr__updateBalances_asm_0_1(uint256) := TMP_55(uint256)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0,selector)
		IRs:
			TMP_56(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr__updateBalances_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x04,from)
		IRs:
			TMP_57(uint256) = ptr__updateBalances_asm_0_1 + 4
			TMP_58(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_57,from_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x24,to)
		IRs:
			TMP_59(uint256) = ptr__updateBalances_asm_0_1 + 36
			TMP_60(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_59,to_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x44,amount)
		IRs:
			TMP_61(uint256) = ptr__updateBalances_asm_0_1 + 68
			TMP_62(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_61,amount_1)
		Expression: gas()() * 63 / 64 < gasLimit
		IRs:
			TMP_63(uint256) = SOLIDITY_CALL gas()()
			TMP_64(uint256) = TMP_63 * 63
			TMP_65(uint256) = TMP_64 / 64
			TMP_66(bool) = TMP_65 < gasLimit_1
			CONDITION TMP_66
		Expression: mstore(uint256,uint256)(0,exception)
		IRs:
			TMP_67(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,exception_1)
		Expression: revert(uint256,uint256)(0,4)
		IRs:
			TMP_68(None) = SOLIDITY_CALL revert(uint256,uint256)(0,4)
		Expression: pop(uint256)(call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit,pod,0,ptr__updateBalances_asm_0,0x64,0,0))
		IRs:
			TMP_69(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit_1,pod_1,0,ptr__updateBalances_asm_0_1,100,0,0)
			TMP_70(None) = SOLIDITY_CALL pop(uint256)(TMP_69)
	Function ERC20Pods._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_130', 'account_1', 'from_1'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_142'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_guard_6(ReentrancyGuardLib.Data) := ϕ(['_guard_7', '_guard_0', '_guard_3', '_guard_5'])
			_pods_11(mapping(address => AddressSet.Data)) := ϕ(['_pods_0', '_pods_1', '_pods_13', '_pods_7', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_3'])
		Expression: super._afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: amount > 0 && from != to
		IRs:
			TMP_72(bool) = amount_1 > 0
			TMP_73(bool) = from_1 != to_1
			TMP_74(bool) = TMP_72 && TMP_73
			CONDITION TMP_74
		Expression: a = _pods[from].items.get()
		IRs:
			REF_29(AddressSet.Data) -> _pods_13[from_1]
			REF_30(AddressArray.Data) -> REF_29.items
			TMP_75(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_30'] 
			a_1(address[]) = ['TMP_75(address[])']
		Expression: b = _pods[to].items.get()
		IRs:
			REF_32(AddressSet.Data) -> _pods_13[to_1]
			REF_33(AddressArray.Data) -> REF_32.items
			TMP_76(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_33'] 
			b_1(address[]) = ['TMP_76(address[])']
		Expression: aLength = a.length
		IRs:
			REF_35 -> LENGTH a_1
			aLength_1(uint256) := REF_35(uint256)
		Expression: bLength = b.length
		IRs:
			REF_36 -> LENGTH b_1
			bLength_1(uint256) := REF_36(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < aLength
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_77(bool) = i_2 < aLength_1
			CONDITION TMP_77
		Expression: pod = a[i]
		IRs:
			REF_37(address) -> a_1[i_2]
			pod_1(address) := REF_37(address)
		IRs:
			b_3(address[]) := ϕ(['b_1', 'b_2'])
		Expression: j = 0
		IRs:
			j_1(uint256) := 0(uint256)
		Expression: j < bLength
		IRs:
			j_2(uint256) := ϕ(['j_1', 'j_3'])
			TMP_78(bool) = j_2 < bLength_1
			CONDITION TMP_78
		Expression: pod == b[j]
		IRs:
			REF_38(address) -> b_1[j_2]
			TMP_79(bool) = pod_1 == REF_38
			CONDITION TMP_79
		Expression: _updateBalances(pod,from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,to_1,amount_1)
		Expression: b[j] = address(0)
		IRs:
			REF_39(address) -> b_1[j_2]
			TMP_81 = CONVERT 0 to address
			b_2(address[]) := ϕ(['b_1'])
			REF_39(address) (->b_2) := TMP_81(address)
		Expression: j ++
		IRs:
			TMP_82(uint256) := j_2(uint256)
			j_3(uint256) = j_2 + 1
		Expression: j == bLength
		IRs:
			TMP_83(bool) = j_2 == bLength_1
			CONDITION TMP_83
		Expression: _updateBalances(pod,from,address(0),amount)
		IRs:
			TMP_84 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,TMP_84,amount_1)
		Expression: i ++
		IRs:
			TMP_86(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		Expression: j_scope_0 = 0
		IRs:
			j_scope_0_1(uint256) := 0(uint256)
		Expression: j_scope_0 < bLength
		IRs:
			j_scope_0_2(uint256) := ϕ(['j_scope_0_3', 'j_scope_0_1'])
			TMP_87(bool) = j_scope_0_2 < bLength_1
			CONDITION TMP_87
		Expression: pod_scope_1 = b[j_scope_0]
		IRs:
			REF_40(address) -> b_1[j_scope_0_2]
			pod_scope_1_1(address) := REF_40(address)
		Expression: pod_scope_1 != address(0)
		IRs:
			TMP_88 = CONVERT 0 to address
			TMP_89(bool) = pod_scope_1_1 != TMP_88
			CONDITION TMP_89
		Expression: _updateBalances(pod_scope_1,address(0),to,amount)
		IRs:
			TMP_90 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_scope_1_1,TMP_90,to_1,amount_1)
		Expression: j_scope_0 ++
		IRs:
			TMP_92(uint256) := j_scope_0_2(uint256)
			j_scope_0_3(uint256) = j_scope_0_2 + 1
		Expression: nonReentrant(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)(_guard_6)
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_1', '_balances_0', '_balances_8', '_balances_11'])
		Expression: _balances[account]
		IRs:
			REF_41(uint256) -> _balances_1[account_1]
			RETURN REF_41
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_94(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_94(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_0', '_allowances_1', '_allowances_2'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_42(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_43(uint256) -> REF_42[spender_1]
			RETURN REF_43
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_96(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_96(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_98(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_98(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_101(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_101(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_102(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_103(uint256) = TMP_102 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_103)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_105(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_105(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_106(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_106(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_107(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_108(None) = SOLIDITY_CALL require(bool,string)(TMP_107,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_109(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_109)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_1', '_balances_0', '_balances_8', '_balances_11'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_111 = CONVERT 0 to address
			TMP_112(bool) = from_1 != TMP_111
			TMP_113(None) = SOLIDITY_CALL require(bool,string)(TMP_112,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_114 = CONVERT 0 to address
			TMP_115(bool) = to_1 != TMP_114
			TMP_116(None) = SOLIDITY_CALL require(bool,string)(TMP_115,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_44(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_44(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_118(bool) = fromBalance_1 >= amount_1
			TMP_119(None) = SOLIDITY_CALL require(bool,string)(TMP_118,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_45(uint256) -> _balances_3[from_1]
			TMP_120(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_45(uint256) (->_balances_4) := TMP_120(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_46(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_46(-> _balances_5) = REF_46 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_1', '_balances_0', '_balances_8', '_balances_11'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_123 = CONVERT 0 to address
			TMP_124(bool) = account_1 != TMP_123
			TMP_125(None) = SOLIDITY_CALL require(bool,string)(TMP_124,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_126 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_126,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_47(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_47(-> _balances_8) = REF_47 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_128 = CONVERT 0 to address
			Emit Transfer(TMP_128,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_130 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(TMP_130,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_1', '_balances_0', '_balances_8', '_balances_11'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_132 = CONVERT 0 to address
			TMP_133(bool) = account_1 != TMP_132
			TMP_134(None) = SOLIDITY_CALL require(bool,string)(TMP_133,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_135 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_135,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_48(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_48(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_137(bool) = accountBalance_1 >= amount_1
			TMP_138(None) = SOLIDITY_CALL require(bool,string)(TMP_137,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_49(uint256) -> _balances_10[account_1]
			TMP_139(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_49(uint256) (->_balances_11) := TMP_139(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_140 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_140,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_142 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(account_1,TMP_142,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['amount_1', 'TMP_103', 'TMP_109', 'TMP_157'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_144 = CONVERT 0 to address
			TMP_145(bool) = owner_1 != TMP_144
			TMP_146(None) = SOLIDITY_CALL require(bool,string)(TMP_145,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_147 = CONVERT 0 to address
			TMP_148(bool) = spender_1 != TMP_147
			TMP_149(None) = SOLIDITY_CALL require(bool,string)(TMP_148,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_50(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_51(uint256) -> REF_50[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_51(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_151(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_151(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_153(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_154(bool) = currentAllowance_1 != TMP_153
			CONDITION TMP_154
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_155(bool) = currentAllowance_1 >= amount_1
			TMP_156(None) = SOLIDITY_CALL require(bool,string)(TMP_155,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_157(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_157)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_126'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_135'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function IDelegatedShare.addDefaultFarmIfNeeded(address,address)
	Function IDelegatedShare.mint(address,uint256)
	Function IDelegatedShare.burn(address,uint256)
	Function DelegatedShare.constructor(string,string,uint256,uint256)
		Expression: _owner = msg.sender
		IRs:
			_owner_1(address) := msg.sender(address)
		Expression: ERC20(name,symbol)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name_1,symbol_1)
		Expression: ERC20Pods(maxUserPods,podCallGasLimit)
		IRs:
			INTERNAL_CALL, ERC20Pods.constructor(uint256,uint256)(maxUserPods_1,podCallGasLimit_1)
	Function DelegatedShare.addDefaultFarmIfNeeded(address,address)
		Expression: ! hasPod(account,farm)
		IRs:
			TMP_161(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,farm_1)
			TMP_162 = UnaryType.BANG TMP_161 
			CONDITION TMP_162
		Expression: _addPod(account,farm)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(account_1,farm_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, DelegatedShare.onlyOwner()()
	Function DelegatedShare.mint(address,uint256)
		Expression: _mint(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, DelegatedShare.onlyOwner()()
	Function DelegatedShare.burn(address,uint256)
		Expression: _burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, DelegatedShare.onlyOwner()()
	Function DelegatedShare.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_169(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegatedShare.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_170(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegatedShare.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_171(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegatedShare.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_172(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegatedShare.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_173(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Modifier ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_6'])
EXPRESSION self.enter()
		Expression: self.enter()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.enter(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
_
EXPRESSION self.exit()
		Expression: self.exit()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.exit(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
	Modifier ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard', '_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_4', '_guard_2'])
IF self.check()
		Expression: self.check()
		IRs:
			TMP_176(bool) = LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.check(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard', '_guard'])"] 
			CONDITION TMP_176
EXPRESSION ReentrancyGuardLib.ReentrantCall()
		Expression: ReentrancyGuardLib.ReentrantCall()
		IRs:
			TMP_177(None) = SOLIDITY_CALL revert ReentrantCall()()
END_IF
_
	Modifier DelegatedShare.onlyOwner()
ENTRY_POINT
		IRs:
			_owner_2(address) := ϕ(['_owner_0', '_owner_1'])
IF msg.sender != _owner
		Expression: msg.sender != _owner
		IRs:
			TMP_178(bool) = msg.sender != _owner_2
			CONDITION TMP_178
EXPRESSION revert NotOwner()()
		Expression: revert NotOwner()()
		IRs:
			TMP_179(None) = SOLIDITY_CALL revert NotOwner()()
END_IF
_
Contract DelegationPod
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_7', '_totalSupply_0', '_totalSupply_4'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
		Expression: _balances[account]
		IRs:
			REF_55(uint256) -> _balances_1[account_1]
			RETURN REF_55
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_180(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_180(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_0', '_allowances_2', '_allowances_1'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_56(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_57(uint256) -> REF_56[spender_1]
			RETURN REF_57
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_182(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_182(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_184(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_184(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_187(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_187(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_188(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_189(uint256) = TMP_188 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_189)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_191(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_191(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_192(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_192(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_193(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_194(None) = SOLIDITY_CALL require(bool,string)(TMP_193,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_195(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_195)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['fromDelegatee_1', 'owner_1', 'from_1'])
			to_1(address) := ϕ(['toDelegatee_1', 'to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_197 = CONVERT 0 to address
			TMP_198(bool) = from_1 != TMP_197
			TMP_199(None) = SOLIDITY_CALL require(bool,string)(TMP_198,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_200 = CONVERT 0 to address
			TMP_201(bool) = to_1 != TMP_200
			TMP_202(None) = SOLIDITY_CALL require(bool,string)(TMP_201,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_58(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_58(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_204(bool) = fromBalance_1 >= amount_1
			TMP_205(None) = SOLIDITY_CALL require(bool,string)(TMP_204,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_59(uint256) -> _balances_3[from_1]
			TMP_206(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_59(uint256) (->_balances_4) := TMP_206(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_60(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_60(-> _balances_5) = REF_60 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_7', '_totalSupply_0', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_209 = CONVERT 0 to address
			TMP_210(bool) = account_1 != TMP_209
			TMP_211(None) = SOLIDITY_CALL require(bool,string)(TMP_210,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_212 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_212,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_61(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_61(-> _balances_8) = REF_61 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_214 = CONVERT 0 to address
			Emit Transfer(TMP_214,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_216 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_216,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['fromDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_7', '_totalSupply_0', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_218 = CONVERT 0 to address
			TMP_219(bool) = account_1 != TMP_218
			TMP_220(None) = SOLIDITY_CALL require(bool,string)(TMP_219,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_221 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_221,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_62(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_62(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_223(bool) = accountBalance_1 >= amount_1
			TMP_224(None) = SOLIDITY_CALL require(bool,string)(TMP_223,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_63(uint256) -> _balances_10[account_1]
			TMP_225(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_63(uint256) (->_balances_11) := TMP_225(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_226 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_226,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_228 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_228,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_195', 'TMP_189', 'TMP_243', 'amount_1'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_230 = CONVERT 0 to address
			TMP_231(bool) = owner_1 != TMP_230
			TMP_232(None) = SOLIDITY_CALL require(bool,string)(TMP_231,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_233 = CONVERT 0 to address
			TMP_234(bool) = spender_1 != TMP_233
			TMP_235(None) = SOLIDITY_CALL require(bool,string)(TMP_234,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_64(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_65(uint256) -> REF_64[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_65(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_237(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_237(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_239(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_240(bool) = currentAllowance_1 != TMP_239
			CONDITION TMP_240
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_241(bool) = currentAllowance_1 >= amount_1
			TMP_242(None) = SOLIDITY_CALL require(bool,string)(TMP_241,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_243(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_243)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'account_1', 'TMP_212'])
			to_1(address) := ϕ(['account_1', 'TMP_221', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_216', 'account_1', 'from_1'])
			to_1(address) := ϕ(['account_1', 'TMP_228', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_1(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function DelegationPod.constructor(string,string,IERC20Pods)
		IRs:
			name__1(string) := ϕ(['name__1', 'name__1', 'name__1', 'name__1'])
			symbol__1(string) := ϕ(['symbol__1', 'symbol__1', 'symbol__1', 'symbol__1'])
			token__1(IERC20Pods) := ϕ(['token__1', 'token__1', 'token__1', 'token__1'])
		Expression: ERC20(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name__1,symbol__1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function DelegationPod.delegate(address)
		IRs:
			token_2(IERC20Pods) := ϕ(['token_1', 'token_3', 'token_0'])
			delegated_1(mapping(address => address)) := ϕ(['delegated_4', 'delegated_0', 'delegated_2', 'delegated_1'])
		Expression: prevDelegatee = delegated[msg.sender]
		IRs:
			REF_66(address) -> delegated_1[msg.sender]
			prevDelegatee_1(address) := REF_66(address)
		Expression: prevDelegatee != delegatee
		IRs:
			TMP_249(bool) = prevDelegatee_1 != delegatee_1
			CONDITION TMP_249
		Expression: delegated[msg.sender] = delegatee
		IRs:
			REF_67(address) -> delegated_1[msg.sender]
			delegated_2(mapping(address => address)) := ϕ(['delegated_1'])
			REF_67(address) (->delegated_2) := delegatee_1(address)
		Expression: Delegated(msg.sender,delegatee)
		IRs:
			Emit Delegated(msg.sender,delegatee_1)
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_251 = CONVERT token_2 to IERC20Pods
			TMP_252 = CONVERT this to address
			TMP_253(uint256) = HIGH_LEVEL_CALL, dest:TMP_251(IERC20Pods), function:podBalanceOf, arguments:['TMP_252', 'msg.sender']  
			token_3(IERC20Pods) := ϕ(['token_2', 'token_1', 'token_3'])
			balance_1(uint256) := TMP_253(uint256)
		Expression: balance > 0
		IRs:
			TMP_254(bool) = balance_1 > 0
			CONDITION TMP_254
		Expression: _updateBalances(msg.sender,msg.sender,prevDelegatee,delegatee,balance)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(msg.sender,msg.sender,prevDelegatee_1,delegatee_1,balance_1)
	Function DelegationPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			delegated_3(mapping(address => address)) := ϕ(['delegated_4', 'delegated_0', 'delegated_2', 'delegated_1'])
		Expression: to == address(0)
		IRs:
			TMP_256 = CONVERT 0 to address
			TMP_257(bool) = to_1 == TMP_256
			CONDITION TMP_257
		Expression: _updateBalances(from,to,address(0),address(0),amount)
		IRs:
			TMP_258 = CONVERT 0 to address
			TMP_259 = CONVERT 0 to address
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,TMP_258,TMP_259,amount_1)
		Expression: _updateBalances(from,to,delegated[from],delegated[to],amount)
		IRs:
			REF_69(address) -> delegated_3[from_1]
			REF_70(address) -> delegated_3[to_1]
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,REF_69,REF_70,amount_1)
	Function DelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			fromDelegatee_1(address) := ϕ(['prevDelegatee_1', 'REF_69', 'TMP_258'])
			toDelegatee_1(address) := ϕ(['REF_70', 'TMP_259', 'delegatee_1'])
			amount_1(uint256) := ϕ(['amount_1', 'balance_1'])
		Expression: fromDelegatee != toDelegatee && amount > 0
		IRs:
			TMP_262(bool) = fromDelegatee_1 != toDelegatee_1
			TMP_263(bool) = amount_1 > 0
			TMP_264(bool) = TMP_262 && TMP_263
			CONDITION TMP_264
		Expression: fromDelegatee == address(0)
		IRs:
			TMP_265 = CONVERT 0 to address
			TMP_266(bool) = fromDelegatee_1 == TMP_265
			CONDITION TMP_266
		Expression: _mint(toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(toDelegatee_1,amount_1)
		Expression: toDelegatee == address(0)
		IRs:
			TMP_268 = CONVERT 0 to address
			TMP_269(bool) = toDelegatee_1 == TMP_268
			CONDITION TMP_269
		Expression: _burn(fromDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(fromDelegatee_1,amount_1)
		Expression: _transfer(fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(fromDelegatee_1,toDelegatee_1,amount_1)
	Function DelegationPod.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_272(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_273(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_274(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_275(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_276(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_4(IERC20Pods) := ϕ(['token_1', 'token_3', 'token_0'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_277 = CONVERT token_4 to address
			TMP_278(bool) = msg.sender != TMP_277
			CONDITION TMP_278
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_279(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract FarmingDelegationPod
	Function TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		Expression: maxSharePods = maxSharePods_
		IRs:
			maxSharePods_1(uint256) := maxSharePods__1(uint256)
		Expression: sharePodGasLimit = sharePodGasLimit_
		IRs:
			sharePodGasLimit_1(uint256) := sharePodGasLimit__1(uint256)
		Expression: DelegationPod(name_,symbol_,token_)
		IRs:
			INTERNAL_CALL, DelegationPod.constructor(string,string,IERC20Pods)(name__1,symbol__1,token__1)
	Function TokenizedDelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			registration_1(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_0', 'registration_6', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
		Expression: delegatee != address(0) && address(registration[delegatee]) == address(0)
		IRs:
			TMP_281 = CONVERT 0 to address
			TMP_282(bool) = delegatee_1 != TMP_281
			REF_71(IDelegatedShare) -> registration_1[delegatee_1]
			TMP_283 = CONVERT REF_71 to address
			TMP_284 = CONVERT 0 to address
			TMP_285(bool) = TMP_283 == TMP_284
			TMP_286(bool) = TMP_282 && TMP_285
			CONDITION TMP_286
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_287(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, DelegationPod.delegate(address)(delegatee_1)
	Function TokenizedDelegationPod.register(string,string)
		IRs:
			name_1(string) := ϕ(['name_1'])
			symbol_1(string) := ϕ(['symbol_1'])
			maxSharePods_2(uint256) := ϕ(['maxSharePods_3', 'maxSharePods_1', 'maxSharePods_0'])
			sharePodGasLimit_2(uint256) := ϕ(['sharePodGasLimit_1', 'sharePodGasLimit_3', 'sharePodGasLimit_0'])
		Expression: shareToken = new DelegatedShare(name,symbol,maxSharePods,sharePodGasLimit)
		IRs:
			TMP_290(DelegatedShare) = new DelegatedShare(name_1,symbol_1,maxSharePods_3,sharePodGasLimit_3) 
			shareToken_1(IDelegatedShare) := TMP_290(DelegatedShare)
		Expression: registration[msg.sender] = shareToken
		IRs:
			REF_72(IDelegatedShare) -> registration_1[msg.sender]
			registration_2(mapping(address => IDelegatedShare)) := ϕ(['registration_1'])
			REF_72(IDelegatedShare) (->registration_2) := shareToken_1(IDelegatedShare)
		Expression: RegisterDelegatee(msg.sender)
		IRs:
			Emit RegisterDelegatee(msg.sender)
		Expression: onlyNotRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyNotRegistered()()
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'msg.sender'])
			to_1(address) := ϕ(['msg.sender', 'to_1'])
			fromDelegatee_1(address) := ϕ(['prevDelegatee_1', 'REF_80', 'TMP_311'])
			toDelegatee_1(address) := ϕ(['REF_81', 'delegatee_1', 'TMP_312'])
			amount_1(uint256) := ϕ(['balance_1', 'amount_1'])
			registration_3(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_0', 'registration_6', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
		Expression: super._updateBalances(from,to,fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,fromDelegatee_1,toDelegatee_1,amount_1)
		Expression: fromDelegatee != address(0)
		IRs:
			TMP_294 = CONVERT 0 to address
			TMP_295(bool) = fromDelegatee_1 != TMP_294
			CONDITION TMP_295
		Expression: registration[fromDelegatee].burn(from,amount)
		IRs:
			REF_73(IDelegatedShare) -> registration_4[fromDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_73(IDelegatedShare), function:burn, arguments:['from_1', 'amount_1']  
			registration_5(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
		Expression: toDelegatee != address(0)
		IRs:
			TMP_297 = CONVERT 0 to address
			TMP_298(bool) = toDelegatee_1 != TMP_297
			CONDITION TMP_298
		Expression: registration[toDelegatee].mint(to,amount)
		IRs:
			REF_75(IDelegatedShare) -> registration_5[toDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_75(IDelegatedShare), function:mint, arguments:['to_1', 'amount_1']  
			registration_6(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
	Function DelegationPod.constructor(string,string,IERC20Pods)
		Expression: ERC20(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name__1,symbol__1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function DelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			delegated_1(mapping(address => address)) := ϕ(['delegated_4', 'delegated_2', 'delegated_0', 'delegated_1'])
			token_1(IERC20Pods) := ϕ(['token_2', 'token_3', 'token_0'])
		Expression: prevDelegatee = delegated[msg.sender]
		IRs:
			REF_77(address) -> delegated_1[msg.sender]
			prevDelegatee_1(address) := REF_77(address)
		Expression: prevDelegatee != delegatee
		IRs:
			TMP_302(bool) = prevDelegatee_1 != delegatee_1
			CONDITION TMP_302
		Expression: delegated[msg.sender] = delegatee
		IRs:
			REF_78(address) -> delegated_1[msg.sender]
			delegated_2(mapping(address => address)) := ϕ(['delegated_1'])
			REF_78(address) (->delegated_2) := delegatee_1(address)
		Expression: Delegated(msg.sender,delegatee)
		IRs:
			Emit Delegated(msg.sender,delegatee_1)
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_304 = CONVERT token_1 to IERC20Pods
			TMP_305 = CONVERT this to address
			TMP_306(uint256) = HIGH_LEVEL_CALL, dest:TMP_304(IERC20Pods), function:podBalanceOf, arguments:['TMP_305', 'msg.sender']  
			token_2(IERC20Pods) := ϕ(['token_1', 'token_2', 'token_3'])
			balance_1(uint256) := TMP_306(uint256)
		Expression: balance > 0
		IRs:
			TMP_307(bool) = balance_1 > 0
			CONDITION TMP_307
		Expression: _updateBalances(msg.sender,msg.sender,prevDelegatee,delegatee,balance)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(msg.sender,msg.sender,prevDelegatee_1,delegatee_1,balance_1)
	Function DelegationPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			delegated_3(mapping(address => address)) := ϕ(['delegated_4', 'delegated_2', 'delegated_0', 'delegated_1'])
		Expression: to == address(0)
		IRs:
			TMP_309 = CONVERT 0 to address
			TMP_310(bool) = to_1 == TMP_309
			CONDITION TMP_310
		Expression: _updateBalances(from,to,address(0),address(0),amount)
		IRs:
			TMP_311 = CONVERT 0 to address
			TMP_312 = CONVERT 0 to address
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,TMP_311,TMP_312,amount_1)
		Expression: _updateBalances(from,to,delegated[from],delegated[to],amount)
		IRs:
			REF_80(address) -> delegated_3[from_1]
			REF_81(address) -> delegated_3[to_1]
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,REF_80,REF_81,amount_1)
	Function DelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			fromDelegatee_1(address) := ϕ(['fromDelegatee_1'])
			toDelegatee_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: fromDelegatee != toDelegatee && amount > 0
		IRs:
			TMP_315(bool) = fromDelegatee_1 != toDelegatee_1
			TMP_316(bool) = amount_1 > 0
			TMP_317(bool) = TMP_315 && TMP_316
			CONDITION TMP_317
		Expression: fromDelegatee == address(0)
		IRs:
			TMP_318 = CONVERT 0 to address
			TMP_319(bool) = fromDelegatee_1 == TMP_318
			CONDITION TMP_319
		Expression: _mint(toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(toDelegatee_1,amount_1)
		Expression: toDelegatee == address(0)
		IRs:
			TMP_321 = CONVERT 0 to address
			TMP_322(bool) = toDelegatee_1 == TMP_321
			CONDITION TMP_322
		Expression: _burn(fromDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(fromDelegatee_1,amount_1)
		Expression: _transfer(fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(fromDelegatee_1,toDelegatee_1,amount_1)
	Function DelegationPod.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_325(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_326(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_327(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_328(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_329(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_0', '_balances_1', '_balances_8'])
		Expression: _balances[account]
		IRs:
			REF_82(uint256) -> _balances_1[account_1]
			RETURN REF_82
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_330(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_330(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_0', '_allowances_1'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_83(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_84(uint256) -> REF_83[spender_1]
			RETURN REF_84
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_332(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_332(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_334(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_334(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_337(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_337(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_338(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_339(uint256) = TMP_338 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_339)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_341(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_341(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_342(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_342(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_343(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_344(None) = SOLIDITY_CALL require(bool,string)(TMP_343,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_345(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_345)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'owner_1', 'fromDelegatee_1'])
			to_1(address) := ϕ(['to_1', 'to_1', 'toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_0', '_balances_1', '_balances_8'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_347 = CONVERT 0 to address
			TMP_348(bool) = from_1 != TMP_347
			TMP_349(None) = SOLIDITY_CALL require(bool,string)(TMP_348,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_350 = CONVERT 0 to address
			TMP_351(bool) = to_1 != TMP_350
			TMP_352(None) = SOLIDITY_CALL require(bool,string)(TMP_351,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_85(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_85(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_354(bool) = fromBalance_1 >= amount_1
			TMP_355(None) = SOLIDITY_CALL require(bool,string)(TMP_354,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_86(uint256) -> _balances_3[from_1]
			TMP_356(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_86(uint256) (->_balances_4) := TMP_356(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_87(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_87(-> _balances_5) = REF_87 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_0', '_balances_1', '_balances_8'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_359 = CONVERT 0 to address
			TMP_360(bool) = account_1 != TMP_359
			TMP_361(None) = SOLIDITY_CALL require(bool,string)(TMP_360,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_362 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_362,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_88(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_88(-> _balances_8) = REF_88 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_364 = CONVERT 0 to address
			Emit Transfer(TMP_364,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_366 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_366,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['fromDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_0', '_balances_1', '_balances_8'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_368 = CONVERT 0 to address
			TMP_369(bool) = account_1 != TMP_368
			TMP_370(None) = SOLIDITY_CALL require(bool,string)(TMP_369,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_371 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_371,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_89(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_89(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_373(bool) = accountBalance_1 >= amount_1
			TMP_374(None) = SOLIDITY_CALL require(bool,string)(TMP_373,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_90(uint256) -> _balances_10[account_1]
			TMP_375(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_90(uint256) (->_balances_11) := TMP_375(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_376 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_376,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_378 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_378,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_339', 'TMP_393', 'TMP_345', 'amount_1'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_380 = CONVERT 0 to address
			TMP_381(bool) = owner_1 != TMP_380
			TMP_382(None) = SOLIDITY_CALL require(bool,string)(TMP_381,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_383 = CONVERT 0 to address
			TMP_384(bool) = spender_1 != TMP_383
			TMP_385(None) = SOLIDITY_CALL require(bool,string)(TMP_384,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_91(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_92(uint256) -> REF_91[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_92(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_387(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_387(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_389(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_390(bool) = currentAllowance_1 != TMP_389
			CONDITION TMP_390
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_391(bool) = currentAllowance_1 >= amount_1
			TMP_392(None) = SOLIDITY_CALL require(bool,string)(TMP_391,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_393(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_393)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_362'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_371'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_366', 'from_1', 'account_1'])
			to_1(address) := ϕ(['account_1', 'TMP_378', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_3(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
	Function IFarmingDelegationPod.setDefaultFarm(address)
	Function FarmingDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		IRs:
			name__1(string) := ϕ(['name__1', 'name__1'])
			symbol__1(string) := ϕ(['symbol__1', 'symbol__1'])
			token__1(IERC20Pods) := ϕ(['st1inch_1', 'st1inch_1'])
			maxSharePods__1(uint256) := ϕ(['_MAX_SHARE_PODS_1', '_MAX_SHARE_PODS_1'])
			sharePodGasLimit__1(uint256) := ϕ(['_SHARE_POD_GAS_LIMIT_1', '_SHARE_POD_GAS_LIMIT_1'])
		Expression: TokenizedDelegationPod(name_,symbol_,token_,maxSharePods_,sharePodGasLimit_)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)(name__1,symbol__1,token__1,maxSharePods__1,sharePodGasLimit__1)
	Function FarmingDelegationPod.register(string,string)
		IRs:
			_MAX_FARM_REWARDS_1(uint256) := ϕ(['_MAX_FARM_REWARDS_2', '_MAX_FARM_REWARDS_0'])
		Expression: shareToken = super.register(name,symbol)
		IRs:
			TMP_398(IDelegatedShare) = INTERNAL_CALL, TokenizedDelegationPod.register(string,string)(name_1,symbol_1)
			shareToken_1(IDelegatedShare) := TMP_398(IDelegatedShare)
		Expression: farm = new MultiFarmingPod(shareToken,_MAX_FARM_REWARDS)
		IRs:
			TMP_400(MultiFarmingPod) = new MultiFarmingPod(shareToken_1,_MAX_FARM_REWARDS_2) 
			farm_1(MultiFarmingPod) := TMP_400(MultiFarmingPod)
		Expression: farm.transferOwnership(msg.sender)
		IRs:
			HIGH_LEVEL_CALL, dest:farm_1(MultiFarmingPod), function:transferOwnership, arguments:['msg.sender']  
		Expression: defaultFarms[msg.sender] = address(farm)
		IRs:
			REF_94(address) -> defaultFarms_0[msg.sender]
			TMP_402 = CONVERT farm_1 to address
			defaultFarms_1(mapping(address => address)) := ϕ(['defaultFarms_0'])
			REF_94(address) (->defaultFarms_1) := TMP_402(address)
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function FarmingDelegationPod.delegate(address)
		IRs:
			registration_7(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_0', 'registration_6', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
			defaultFarms_2(mapping(address => address)) := ϕ(['defaultFarms_1', 'defaultFarms_4', 'defaultFarms_0', 'defaultFarms_3'])
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.delegate(address)(delegatee_1)
			registration_8(mapping(address => IDelegatedShare)) := ϕ(['registration_1'])
		Expression: defaultFarm = defaultFarms[delegatee]
		IRs:
			REF_95(address) -> defaultFarms_3[delegatee_1]
			defaultFarm_1(address) := REF_95(address)
		Expression: defaultFarm != address(0)
		IRs:
			TMP_404 = CONVERT 0 to address
			TMP_405(bool) = defaultFarm_1 != TMP_404
			CONDITION TMP_405
		Expression: registration[delegatee].addDefaultFarmIfNeeded(msg.sender,defaultFarm)
		IRs:
			REF_96(IDelegatedShare) -> registration_8[delegatee_1]
			HIGH_LEVEL_CALL, dest:REF_96(IDelegatedShare), function:addDefaultFarmIfNeeded, arguments:['msg.sender', 'defaultFarm_1']  
			registration_9(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_6', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
	Function FarmingDelegationPod.setDefaultFarm(address)
		IRs:
			registration_10(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_0', 'registration_6', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
		Expression: farm != address(0) && Pod(farm).token() != registration[msg.sender]
		IRs:
			TMP_407 = CONVERT 0 to address
			TMP_408(bool) = farm_1 != TMP_407
			TMP_409 = CONVERT farm_1 to Pod
			TMP_410(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_409(Pod), function:token, arguments:[]  
			registration_12(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_6', 'registration_11', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
			REF_99(IDelegatedShare) -> registration_12[msg.sender]
			TMP_411(bool) = TMP_410 != REF_99
			TMP_412(bool) = TMP_408 && TMP_411
			CONDITION TMP_412
		Expression: revert DefaultFarmTokenMismatch()()
		IRs:
			TMP_413(None) = SOLIDITY_CALL revert DefaultFarmTokenMismatch()()
		Expression: defaultFarms[msg.sender] = farm
		IRs:
			REF_100(address) -> defaultFarms_3[msg.sender]
			defaultFarms_4(mapping(address => address)) := ϕ(['defaultFarms_3'])
			REF_100(address) (->defaultFarms_4) := farm_1(address)
		Expression: DefaultFarmSet(farm)
		IRs:
			Emit DefaultFarmSet(farm_1)
		Expression: onlyRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyRegistered()()
			registration_11(mapping(address => IDelegatedShare)) := ϕ(['registration_13'])
	Function FarmingDelegationPod.slitherConstructorConstantVariables()
		Expression: _MAX_FARM_REWARDS = 3
	Modifier TokenizedDelegationPod.onlyRegistered()
ENTRY_POINT
		IRs:
			registration_13(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_0', 'registration_6', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
IF address(registration[msg.sender]) == address(0)
		Expression: address(registration[msg.sender]) == address(0)
		IRs:
			REF_101(IDelegatedShare) -> registration_13[msg.sender]
			TMP_416 = CONVERT REF_101 to address
			TMP_417 = CONVERT 0 to address
			TMP_418(bool) = TMP_416 == TMP_417
			CONDITION TMP_418
EXPRESSION revert NotRegisteredDelegatee()()
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_419(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
END_IF
_
	Modifier TokenizedDelegationPod.onlyNotRegistered()
ENTRY_POINT
		IRs:
			registration_14(mapping(address => IDelegatedShare)) := ϕ(['registration_5', 'registration_14', 'registration_13', 'registration_0', 'registration_6', 'registration_9', 'registration_4', 'registration_1', 'registration_8', 'registration_2', 'registration_12'])
IF address(registration[msg.sender]) != address(0)
		Expression: address(registration[msg.sender]) != address(0)
		IRs:
			REF_102(IDelegatedShare) -> registration_14[msg.sender]
			TMP_420 = CONVERT REF_102 to address
			TMP_421 = CONVERT 0 to address
			TMP_422(bool) = TMP_420 != TMP_421
			CONDITION TMP_422
EXPRESSION revert AlreadyRegistered()()
		Expression: revert AlreadyRegistered()()
		IRs:
			TMP_423(None) = SOLIDITY_CALL revert AlreadyRegistered()()
END_IF
_
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_4(IERC20Pods) := ϕ(['token_2', 'token_3', 'token_0'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_424 = CONVERT token_4 to address
			TMP_425(bool) = msg.sender != TMP_424
			CONDITION TMP_425
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_426(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract TokenizedDelegationPod
	Function DelegationPod.constructor(string,string,IERC20Pods)
		Expression: ERC20(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name__1,symbol__1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function DelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			delegated_1(mapping(address => address)) := ϕ(['delegated_4', 'delegated_1', 'delegated_0', 'delegated_2'])
			token_1(IERC20Pods) := ϕ(['token_3', 'token_0', 'token_2'])
		Expression: prevDelegatee = delegated[msg.sender]
		IRs:
			REF_103(address) -> delegated_1[msg.sender]
			prevDelegatee_1(address) := REF_103(address)
		Expression: prevDelegatee != delegatee
		IRs:
			TMP_429(bool) = prevDelegatee_1 != delegatee_1
			CONDITION TMP_429
		Expression: delegated[msg.sender] = delegatee
		IRs:
			REF_104(address) -> delegated_1[msg.sender]
			delegated_2(mapping(address => address)) := ϕ(['delegated_1'])
			REF_104(address) (->delegated_2) := delegatee_1(address)
		Expression: Delegated(msg.sender,delegatee)
		IRs:
			Emit Delegated(msg.sender,delegatee_1)
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_431 = CONVERT token_1 to IERC20Pods
			TMP_432 = CONVERT this to address
			TMP_433(uint256) = HIGH_LEVEL_CALL, dest:TMP_431(IERC20Pods), function:podBalanceOf, arguments:['TMP_432', 'msg.sender']  
			token_2(IERC20Pods) := ϕ(['token_3', 'token_1', 'token_2'])
			balance_1(uint256) := TMP_433(uint256)
		Expression: balance > 0
		IRs:
			TMP_434(bool) = balance_1 > 0
			CONDITION TMP_434
		Expression: _updateBalances(msg.sender,msg.sender,prevDelegatee,delegatee,balance)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(msg.sender,msg.sender,prevDelegatee_1,delegatee_1,balance_1)
	Function DelegationPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			delegated_3(mapping(address => address)) := ϕ(['delegated_4', 'delegated_1', 'delegated_0', 'delegated_2'])
		Expression: to == address(0)
		IRs:
			TMP_436 = CONVERT 0 to address
			TMP_437(bool) = to_1 == TMP_436
			CONDITION TMP_437
		Expression: _updateBalances(from,to,address(0),address(0),amount)
		IRs:
			TMP_438 = CONVERT 0 to address
			TMP_439 = CONVERT 0 to address
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,TMP_438,TMP_439,amount_1)
		Expression: _updateBalances(from,to,delegated[from],delegated[to],amount)
		IRs:
			REF_106(address) -> delegated_3[from_1]
			REF_107(address) -> delegated_3[to_1]
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,REF_106,REF_107,amount_1)
	Function DelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			fromDelegatee_1(address) := ϕ(['fromDelegatee_1'])
			toDelegatee_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: fromDelegatee != toDelegatee && amount > 0
		IRs:
			TMP_442(bool) = fromDelegatee_1 != toDelegatee_1
			TMP_443(bool) = amount_1 > 0
			TMP_444(bool) = TMP_442 && TMP_443
			CONDITION TMP_444
		Expression: fromDelegatee == address(0)
		IRs:
			TMP_445 = CONVERT 0 to address
			TMP_446(bool) = fromDelegatee_1 == TMP_445
			CONDITION TMP_446
		Expression: _mint(toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(toDelegatee_1,amount_1)
		Expression: toDelegatee == address(0)
		IRs:
			TMP_448 = CONVERT 0 to address
			TMP_449(bool) = toDelegatee_1 == TMP_448
			CONDITION TMP_449
		Expression: _burn(fromDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(fromDelegatee_1,amount_1)
		Expression: _transfer(fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(fromDelegatee_1,toDelegatee_1,amount_1)
	Function DelegationPod.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_452(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_453(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_454(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_455(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_456(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_5', '_balances_0', '_balances_1'])
		Expression: _balances[account]
		IRs:
			REF_108(uint256) -> _balances_1[account_1]
			RETURN REF_108
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_457(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_457(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1', '_allowances_2', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_109(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_110(uint256) -> REF_109[spender_1]
			RETURN REF_110
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_459(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_459(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_461(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_461(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_464(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_464(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_465(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_466(uint256) = TMP_465 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_466)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_468(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_468(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_469(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_469(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_470(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_471(None) = SOLIDITY_CALL require(bool,string)(TMP_470,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_472(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_472)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'fromDelegatee_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'toDelegatee_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_5', '_balances_0', '_balances_1'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_474 = CONVERT 0 to address
			TMP_475(bool) = from_1 != TMP_474
			TMP_476(None) = SOLIDITY_CALL require(bool,string)(TMP_475,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_477 = CONVERT 0 to address
			TMP_478(bool) = to_1 != TMP_477
			TMP_479(None) = SOLIDITY_CALL require(bool,string)(TMP_478,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_111(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_111(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_481(bool) = fromBalance_1 >= amount_1
			TMP_482(None) = SOLIDITY_CALL require(bool,string)(TMP_481,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_112(uint256) -> _balances_3[from_1]
			TMP_483(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_112(uint256) (->_balances_4) := TMP_483(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_113(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_113(-> _balances_5) = REF_113 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_5', '_balances_0', '_balances_1'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_486 = CONVERT 0 to address
			TMP_487(bool) = account_1 != TMP_486
			TMP_488(None) = SOLIDITY_CALL require(bool,string)(TMP_487,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_489 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_489,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_114(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_114(-> _balances_8) = REF_114 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_491 = CONVERT 0 to address
			Emit Transfer(TMP_491,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_493 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_493,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['fromDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_5', '_balances_0', '_balances_1'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_495 = CONVERT 0 to address
			TMP_496(bool) = account_1 != TMP_495
			TMP_497(None) = SOLIDITY_CALL require(bool,string)(TMP_496,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_498 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_498,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_115(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_115(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_500(bool) = accountBalance_1 >= amount_1
			TMP_501(None) = SOLIDITY_CALL require(bool,string)(TMP_500,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_116(uint256) -> _balances_10[account_1]
			TMP_502(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_116(uint256) (->_balances_11) := TMP_502(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_503 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_503,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_505 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_505,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_466', 'TMP_472', 'TMP_520', 'amount_1'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_507 = CONVERT 0 to address
			TMP_508(bool) = owner_1 != TMP_507
			TMP_509(None) = SOLIDITY_CALL require(bool,string)(TMP_508,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_510 = CONVERT 0 to address
			TMP_511(bool) = spender_1 != TMP_510
			TMP_512(None) = SOLIDITY_CALL require(bool,string)(TMP_511,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_117(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_118(uint256) -> REF_117[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_118(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_514(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_514(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_516(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_517(bool) = currentAllowance_1 != TMP_516
			CONDITION TMP_517
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_518(bool) = currentAllowance_1 >= amount_1
			TMP_519(None) = SOLIDITY_CALL require(bool,string)(TMP_518,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_520(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_520)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'TMP_489', 'from_1'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_498'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'TMP_493', 'from_1'])
			to_1(address) := ϕ(['TMP_505', 'account_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_3(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
	Function TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		IRs:
			name__1(string) := ϕ(['name__1', 'name__1', 'name__1'])
			symbol__1(string) := ϕ(['symbol__1', 'symbol__1', 'symbol__1'])
			token__1(IERC20Pods) := ϕ(['token__1', 'token__1', 'token__1'])
			maxSharePods__1(uint256) := ϕ(['maxSharePods__1', 'maxSharePods__1', 'maxSharePods__1'])
			sharePodGasLimit__1(uint256) := ϕ(['sharePodGasLimit__1', 'sharePodGasLimit__1', 'sharePodGasLimit__1'])
		Expression: maxSharePods = maxSharePods_
		IRs:
			maxSharePods_1(uint256) := maxSharePods__1(uint256)
		Expression: sharePodGasLimit = sharePodGasLimit_
		IRs:
			sharePodGasLimit_1(uint256) := sharePodGasLimit__1(uint256)
		Expression: DelegationPod(name_,symbol_,token_)
		IRs:
			INTERNAL_CALL, DelegationPod.constructor(string,string,IERC20Pods)(name__1,symbol__1,token__1)
	Function TokenizedDelegationPod.delegate(address)
		IRs:
			registration_1(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_0', 'registration_4', 'registration_1', 'registration_7', 'registration_2', 'registration_5'])
		Expression: delegatee != address(0) && address(registration[delegatee]) == address(0)
		IRs:
			TMP_525 = CONVERT 0 to address
			TMP_526(bool) = delegatee_1 != TMP_525
			REF_119(IDelegatedShare) -> registration_1[delegatee_1]
			TMP_527 = CONVERT REF_119 to address
			TMP_528 = CONVERT 0 to address
			TMP_529(bool) = TMP_527 == TMP_528
			TMP_530(bool) = TMP_526 && TMP_529
			CONDITION TMP_530
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_531(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, DelegationPod.delegate(address)(delegatee_1)
	Function TokenizedDelegationPod.register(string,string)
		IRs:
			maxSharePods_2(uint256) := ϕ(['maxSharePods_1', 'maxSharePods_0', 'maxSharePods_3'])
			sharePodGasLimit_2(uint256) := ϕ(['sharePodGasLimit_1', 'sharePodGasLimit_3', 'sharePodGasLimit_0'])
		Expression: shareToken = new DelegatedShare(name,symbol,maxSharePods,sharePodGasLimit)
		IRs:
			TMP_534(DelegatedShare) = new DelegatedShare(name_1,symbol_1,maxSharePods_3,sharePodGasLimit_3) 
			shareToken_1(IDelegatedShare) := TMP_534(DelegatedShare)
		Expression: registration[msg.sender] = shareToken
		IRs:
			REF_120(IDelegatedShare) -> registration_1[msg.sender]
			registration_2(mapping(address => IDelegatedShare)) := ϕ(['registration_1'])
			REF_120(IDelegatedShare) (->registration_2) := shareToken_1(IDelegatedShare)
		Expression: RegisterDelegatee(msg.sender)
		IRs:
			Emit RegisterDelegatee(msg.sender)
		Expression: onlyNotRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyNotRegistered()()
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'msg.sender'])
			to_1(address) := ϕ(['to_1', 'msg.sender'])
			fromDelegatee_1(address) := ϕ(['prevDelegatee_1', 'REF_106', 'TMP_438'])
			toDelegatee_1(address) := ϕ(['REF_107', 'TMP_439', 'delegatee_1'])
			amount_1(uint256) := ϕ(['amount_1', 'balance_1'])
			registration_3(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_0', 'registration_4', 'registration_1', 'registration_7', 'registration_2', 'registration_5'])
		Expression: super._updateBalances(from,to,fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,fromDelegatee_1,toDelegatee_1,amount_1)
		Expression: fromDelegatee != address(0)
		IRs:
			TMP_538 = CONVERT 0 to address
			TMP_539(bool) = fromDelegatee_1 != TMP_538
			CONDITION TMP_539
		Expression: registration[fromDelegatee].burn(from,amount)
		IRs:
			REF_121(IDelegatedShare) -> registration_4[fromDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_121(IDelegatedShare), function:burn, arguments:['from_1', 'amount_1']  
			registration_5(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_4', 'registration_1', 'registration_7', 'registration_2', 'registration_5'])
		Expression: toDelegatee != address(0)
		IRs:
			TMP_541 = CONVERT 0 to address
			TMP_542(bool) = toDelegatee_1 != TMP_541
			CONDITION TMP_542
		Expression: registration[toDelegatee].mint(to,amount)
		IRs:
			REF_123(IDelegatedShare) -> registration_5[toDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_123(IDelegatedShare), function:mint, arguments:['to_1', 'amount_1']  
			registration_6(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_4', 'registration_1', 'registration_7', 'registration_2', 'registration_5'])
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_4(IERC20Pods) := ϕ(['token_3', 'token_0', 'token_2'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_544 = CONVERT token_4 to address
			TMP_545(bool) = msg.sender != TMP_544
			CONDITION TMP_545
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_546(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
	Modifier TokenizedDelegationPod.onlyRegistered()
ENTRY_POINT
		IRs:
			registration_7(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_0', 'registration_4', 'registration_1', 'registration_7', 'registration_2', 'registration_5'])
IF address(registration[msg.sender]) == address(0)
		Expression: address(registration[msg.sender]) == address(0)
		IRs:
			REF_125(IDelegatedShare) -> registration_7[msg.sender]
			TMP_547 = CONVERT REF_125 to address
			TMP_548 = CONVERT 0 to address
			TMP_549(bool) = TMP_547 == TMP_548
			CONDITION TMP_549
EXPRESSION revert NotRegisteredDelegatee()()
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_550(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
END_IF
_
	Modifier TokenizedDelegationPod.onlyNotRegistered()
ENTRY_POINT
		IRs:
			registration_8(mapping(address => IDelegatedShare)) := ϕ(['registration_8', 'registration_6', 'registration_0', 'registration_4', 'registration_1', 'registration_7', 'registration_2', 'registration_5'])
IF address(registration[msg.sender]) != address(0)
		Expression: address(registration[msg.sender]) != address(0)
		IRs:
			REF_126(IDelegatedShare) -> registration_8[msg.sender]
			TMP_551 = CONVERT REF_126 to address
			TMP_552 = CONVERT 0 to address
			TMP_553(bool) = TMP_551 != TMP_552
			CONDITION TMP_553
EXPRESSION revert AlreadyRegistered()()
		Expression: revert AlreadyRegistered()()
		IRs:
			TMP_554(None) = SOLIDITY_CALL revert AlreadyRegistered()()
END_IF
_
Contract IDelegatedShare
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IDelegatedShare.addDefaultFarmIfNeeded(address,address)
	Function IDelegatedShare.mint(address,uint256)
	Function IDelegatedShare.burn(address,uint256)
Contract IDelegationPod
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
Contract IFarmingDelegationPod
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IFarmingDelegationPod.setDefaultFarm(address)
Contract ITokenizedDelegationPod
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
Contract ERC20Pods
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: _balances[account]
		IRs:
			REF_127(uint256) -> _balances_1[account_1]
			RETURN REF_127
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_555(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_555(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_0', '_allowances_1', '_allowances_2'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_128(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_129(uint256) -> REF_128[spender_1]
			RETURN REF_129
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_557(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_557(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_559(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_559(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_562(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_562(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_563(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_564(uint256) = TMP_563 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_564)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_566(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_566(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_567(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_567(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_568(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_569(None) = SOLIDITY_CALL require(bool,string)(TMP_568,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_570(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_570)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'owner_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_572 = CONVERT 0 to address
			TMP_573(bool) = from_1 != TMP_572
			TMP_574(None) = SOLIDITY_CALL require(bool,string)(TMP_573,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_575 = CONVERT 0 to address
			TMP_576(bool) = to_1 != TMP_575
			TMP_577(None) = SOLIDITY_CALL require(bool,string)(TMP_576,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_130(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_130(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_579(bool) = fromBalance_1 >= amount_1
			TMP_580(None) = SOLIDITY_CALL require(bool,string)(TMP_579,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_131(uint256) -> _balances_3[from_1]
			TMP_581(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_131(uint256) (->_balances_4) := TMP_581(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_132(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_132(-> _balances_5) = REF_132 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_584 = CONVERT 0 to address
			TMP_585(bool) = account_1 != TMP_584
			TMP_586(None) = SOLIDITY_CALL require(bool,string)(TMP_585,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_587 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_587,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_133(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_133(-> _balances_8) = REF_133 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_589 = CONVERT 0 to address
			Emit Transfer(TMP_589,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_591 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(TMP_591,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_593 = CONVERT 0 to address
			TMP_594(bool) = account_1 != TMP_593
			TMP_595(None) = SOLIDITY_CALL require(bool,string)(TMP_594,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_596 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_596,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_134(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_134(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_598(bool) = accountBalance_1 >= amount_1
			TMP_599(None) = SOLIDITY_CALL require(bool,string)(TMP_598,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_135(uint256) -> _balances_10[account_1]
			TMP_600(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_135(uint256) (->_balances_11) := TMP_600(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_601 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_601,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_603 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(account_1,TMP_603,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['amount_1', 'TMP_564', 'TMP_570', 'TMP_618'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_605 = CONVERT 0 to address
			TMP_606(bool) = owner_1 != TMP_605
			TMP_607(None) = SOLIDITY_CALL require(bool,string)(TMP_606,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_608 = CONVERT 0 to address
			TMP_609(bool) = spender_1 != TMP_608
			TMP_610(None) = SOLIDITY_CALL require(bool,string)(TMP_609,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_136(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_137(uint256) -> REF_136[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_137(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_612(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_612(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_614(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_615(bool) = currentAllowance_1 != TMP_614
			CONDITION TMP_615
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_616(bool) = currentAllowance_1 >= amount_1
			TMP_617(None) = SOLIDITY_CALL require(bool,string)(TMP_616,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_618(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_618)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_587'])
			to_1(address) := ϕ(['to_1', 'account_1', 'TMP_596'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20Pods.constructor(uint256,uint256)
		IRs:
			podsLimit__1(uint256) := ϕ(['_PODS_LIMIT_1', '_PODS_LIMIT_1', 'maxUserPods_1'])
			podCallGasLimit__1(uint256) := ϕ(['_POD_CALL_GAS_LIMIT_1', 'podCallGasLimit_1', '_POD_CALL_GAS_LIMIT_1'])
			_guard_1(ReentrancyGuardLib.Data) := ϕ(['_guard_0', '_guard_3', '_guard_7', '_guard_5'])
		Expression: podsLimit_ == 0
		IRs:
			TMP_620(bool) = podsLimit__1 == 0
			CONDITION TMP_620
		Expression: revert ZeroPodsLimit()()
		IRs:
			TMP_621(None) = SOLIDITY_CALL revert ZeroPodsLimit()()
		Expression: podsLimit = podsLimit_
		IRs:
			podsLimit_1(uint256) := podsLimit__1(uint256)
		Expression: podCallGasLimit = podCallGasLimit_
		IRs:
			podCallGasLimit_1(uint256) := podCallGasLimit__1(uint256)
		Expression: _guard.init()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.init(ReentrancyGuardLib.Data), arguments:['_guard_1'] 
	Function ERC20Pods.hasPod(address,address)
		IRs:
			account_1(address) := ϕ(['account_1'])
			pod_1(address) := ϕ(['pod_1'])
			_pods_1(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_0', '_pods_13', '_pods_4', '_pods_9', '_pods_2', '_pods_6', '_pods_3', '_pods_7'])
		Expression: _pods[account].contains(pod)
		IRs:
			REF_139(AddressSet.Data) -> _pods_1[account_1]
			TMP_623(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.contains(AddressSet.Data,address), arguments:['REF_139', 'pod_1'] 
			RETURN TMP_623
	Function ERC20Pods.podsCount(address)
		IRs:
			_pods_2(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_0', '_pods_13', '_pods_4', '_pods_9', '_pods_2', '_pods_6', '_pods_3', '_pods_7'])
		Expression: _pods[account].length()
		IRs:
			REF_141(AddressSet.Data) -> _pods_2[account_1]
			TMP_624(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_141'] 
			RETURN TMP_624
	Function ERC20Pods.podAt(address,uint256)
		IRs:
			_pods_3(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_0', '_pods_13', '_pods_4', '_pods_9', '_pods_2', '_pods_6', '_pods_3', '_pods_7'])
		Expression: _pods[account].at(index)
		IRs:
			REF_143(AddressSet.Data) -> _pods_3[account_1]
			TMP_625(address) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.at(AddressSet.Data,uint256), arguments:['REF_143', 'index_1'] 
			RETURN TMP_625
	Function ERC20Pods.pods(address)
		IRs:
			_pods_4(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_0', '_pods_13', '_pods_4', '_pods_9', '_pods_2', '_pods_6', '_pods_3', '_pods_7'])
		Expression: _pods[account].items.get()
		IRs:
			REF_145(AddressSet.Data) -> _pods_4[account_1]
			REF_146(AddressArray.Data) -> REF_145.items
			TMP_626(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_146'] 
			RETURN TMP_626
	Function ERC20Pods.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1', 'account_1'])
			_guard_2(ReentrancyGuardLib.Data) := ϕ(['_guard_0', '_guard_3', '_guard_7', '_guard_5'])
		Expression: super.balanceOf(account)
		IRs:
			TMP_627(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_627
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_2)
	Function ERC20Pods.podBalanceOf(address,address)
		IRs:
			_guard_4(ReentrancyGuardLib.Data) := ϕ(['_guard_0', '_guard_3', '_guard_7', '_guard_5'])
		Expression: hasPod(account,pod)
		IRs:
			TMP_629(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,pod_1)
			CONDITION TMP_629
		Expression: super.balanceOf(account)
		IRs:
			TMP_630(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_630
		Expression: 0
		IRs:
			RETURN 0
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_4)
	Function ERC20Pods.addPod(address)
		Expression: _addPod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removePod(address)
		Expression: _removePod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._removePod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removeAllPods()
		Expression: _removeAllPods(msg.sender)
		IRs:
			INTERNAL_CALL, ERC20Pods._removeAllPods(address)(msg.sender)
	Function ERC20Pods._addPod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			pod_1(address) := ϕ(['pod_1'])
			podsLimit_2(uint256) := ϕ(['podsLimit_0', 'podsLimit_3', 'podsLimit_1'])
			_pods_5(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_0', '_pods_13', '_pods_4', '_pods_9', '_pods_2', '_pods_6', '_pods_3', '_pods_7'])
		Expression: pod == address(0)
		IRs:
			TMP_635 = CONVERT 0 to address
			TMP_636(bool) = pod_1 == TMP_635
			CONDITION TMP_636
		Expression: revert InvalidPodAddress()()
		IRs:
			TMP_637(None) = SOLIDITY_CALL revert InvalidPodAddress()()
		Expression: IPod(pod).token() != IERC20Pods(address(this))
		IRs:
			TMP_638 = CONVERT pod_1 to IPod
			TMP_639(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_638(IPod), function:token, arguments:[]  
			podsLimit_3(uint256) := ϕ(['podsLimit_2', 'podsLimit_3', 'podsLimit_1'])
			_pods_6(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_9', '_pods_6', '_pods_2', '_pods_5', '_pods_3', '_pods_7'])
			TMP_640 = CONVERT this to address
			TMP_641 = CONVERT TMP_640 to IERC20Pods
			TMP_642(bool) = TMP_639 != TMP_641
			CONDITION TMP_642
		Expression: revert InvalidTokenInPod()()
		IRs:
			TMP_643(None) = SOLIDITY_CALL revert InvalidTokenInPod()()
		Expression: ! _pods[account].add(pod)
		IRs:
			REF_149(AddressSet.Data) -> _pods_6[account_1]
			TMP_644(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.add(AddressSet.Data,address), arguments:['REF_149', 'pod_1'] 
			TMP_645 = UnaryType.BANG TMP_644 
			CONDITION TMP_645
		Expression: revert PodAlreadyAdded()()
		IRs:
			TMP_646(None) = SOLIDITY_CALL revert PodAlreadyAdded()()
		Expression: _pods[account].length() > podsLimit
		IRs:
			REF_151(AddressSet.Data) -> _pods_6[account_1]
			TMP_647(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_151'] 
			TMP_648(bool) = TMP_647 > podsLimit_3
			CONDITION TMP_648
		Expression: revert PodsLimitReachedForAccount()()
		IRs:
			TMP_649(None) = SOLIDITY_CALL revert PodsLimitReachedForAccount()()
		Expression: PodAdded(account,pod)
		IRs:
			Emit PodAdded(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_651(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_651(uint256)
		Expression: balance > 0
		IRs:
			TMP_652(bool) = balance_1 > 0
			CONDITION TMP_652
		Expression: _updateBalances(pod,address(0),account,balance)
		IRs:
			TMP_653 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,TMP_653,account_1,balance_1)
	Function ERC20Pods._removePod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			pod_1(address) := ϕ(['pod_1'])
			_pods_7(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_0', '_pods_13', '_pods_4', '_pods_9', '_pods_2', '_pods_6', '_pods_3', '_pods_7'])
		Expression: ! _pods[account].remove(pod)
		IRs:
			REF_153(AddressSet.Data) -> _pods_7[account_1]
			TMP_655(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_153', 'pod_1'] 
			TMP_656 = UnaryType.BANG TMP_655 
			CONDITION TMP_656
		Expression: revert PodNotFound()()
		IRs:
			TMP_657(None) = SOLIDITY_CALL revert PodNotFound()()
		Expression: PodRemoved(account,pod)
		IRs:
			Emit PodRemoved(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_659(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_659(uint256)
		Expression: balance > 0
		IRs:
			TMP_660(bool) = balance_1 > 0
			CONDITION TMP_660
		Expression: _updateBalances(pod,account,address(0),balance)
		IRs:
			TMP_661 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,account_1,TMP_661,balance_1)
	Function ERC20Pods._removeAllPods(address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			_pods_8(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_0', '_pods_13', '_pods_4', '_pods_9', '_pods_2', '_pods_6', '_pods_3', '_pods_7'])
		Expression: items = _pods[account].items.get()
		IRs:
			REF_155(AddressSet.Data) -> _pods_8[account_1]
			REF_156(AddressArray.Data) -> REF_155.items
			TMP_663(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_156'] 
			items_1(address[]) = ['TMP_663(address[])']
		Expression: balance = balanceOf(account)
		IRs:
			TMP_664(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_664(uint256)
		Expression: i = items.length
		IRs:
			REF_158 -> LENGTH items_1
			i_1(uint256) := REF_158(uint256)
		Expression: i > 0
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_665(bool) = i_2 > 0
			CONDITION TMP_665
		Expression: _pods[account].remove(items[i - 1])
		IRs:
			REF_159(AddressSet.Data) -> _pods_9[account_1]
			TMP_666(uint256) = i_2 - 1
			REF_161(address) -> items_1[TMP_666]
			TMP_667(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_159', 'REF_161'] 
		Expression: PodRemoved(account,items[i - 1])
		IRs:
			TMP_668(uint256) = i_2 - 1
			REF_162(address) -> items_1[TMP_668]
			Emit PodRemoved(account_1,REF_162)
		Expression: balance > 0
		IRs:
			TMP_670(bool) = balance_1 > 0
			CONDITION TMP_670
		Expression: _updateBalances(items[i - 1],account,address(0),balance)
		IRs:
			TMP_671(uint256) = i_2 - 1
			REF_163(address) -> items_1[TMP_671]
			TMP_672 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(REF_163,account_1,TMP_672,balance_1)
		Expression: i --
		IRs:
			TMP_674(uint256) := i_2(uint256)
			i_3(uint256) = i_2 - 1
	Function ERC20Pods._updateBalances(address,address,address,uint256)
		IRs:
			pod_1(address) := ϕ(['pod_scope_1_1', 'REF_163', 'pod_1', 'pod_1', 'pod_1'])
			from_1(address) := ϕ(['TMP_710', 'account_1', 'from_1', 'TMP_653', 'account_1'])
			to_1(address) := ϕ(['account_1', 'TMP_672', 'to_1', 'TMP_661', 'TMP_704'])
			amount_1(uint256) := ϕ(['amount_1', 'balance_1', 'balance_1', 'balance_1'])
			podCallGasLimit_2(uint256) := ϕ(['podCallGasLimit_1', 'podCallGasLimit_0'])
		Expression: selector = IPod.updateBalances.selector
		IRs:
			REF_165(bytes4) (->None) := 2048858793(bytes4)
			selector_1(bytes4) := REF_165(bytes4)
		Expression: exception = revert InsufficientGas().selector
		IRs:
			REF_166(bytes4) (->None) := 472281420(bytes4)
			exception_1(bytes4) := REF_166(bytes4)
		Expression: gasLimit = podCallGasLimit
		IRs:
			gasLimit_1(uint256) := podCallGasLimit_2(uint256)
		Expression: ptr__updateBalances_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_675(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr__updateBalances_asm_0_1(uint256) := TMP_675(uint256)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0,selector)
		IRs:
			TMP_676(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr__updateBalances_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x04,from)
		IRs:
			TMP_677(uint256) = ptr__updateBalances_asm_0_1 + 4
			TMP_678(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_677,from_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x24,to)
		IRs:
			TMP_679(uint256) = ptr__updateBalances_asm_0_1 + 36
			TMP_680(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_679,to_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x44,amount)
		IRs:
			TMP_681(uint256) = ptr__updateBalances_asm_0_1 + 68
			TMP_682(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_681,amount_1)
		Expression: gas()() * 63 / 64 < gasLimit
		IRs:
			TMP_683(uint256) = SOLIDITY_CALL gas()()
			TMP_684(uint256) = TMP_683 * 63
			TMP_685(uint256) = TMP_684 / 64
			TMP_686(bool) = TMP_685 < gasLimit_1
			CONDITION TMP_686
		Expression: mstore(uint256,uint256)(0,exception)
		IRs:
			TMP_687(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,exception_1)
		Expression: revert(uint256,uint256)(0,4)
		IRs:
			TMP_688(None) = SOLIDITY_CALL revert(uint256,uint256)(0,4)
		Expression: pop(uint256)(call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit,pod,0,ptr__updateBalances_asm_0,0x64,0,0))
		IRs:
			TMP_689(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit_1,pod_1,0,ptr__updateBalances_asm_0_1,100,0,0)
			TMP_690(None) = SOLIDITY_CALL pop(uint256)(TMP_689)
	Function ERC20Pods._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_591'])
			to_1(address) := ϕ(['to_1', 'TMP_603', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_guard_6(ReentrancyGuardLib.Data) := ϕ(['_guard_0', '_guard_3', '_guard_7', '_guard_5'])
			_pods_11(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_0', '_pods_13', '_pods_4', '_pods_9', '_pods_2', '_pods_6', '_pods_3', '_pods_7'])
		Expression: super._afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: amount > 0 && from != to
		IRs:
			TMP_692(bool) = amount_1 > 0
			TMP_693(bool) = from_1 != to_1
			TMP_694(bool) = TMP_692 && TMP_693
			CONDITION TMP_694
		Expression: a = _pods[from].items.get()
		IRs:
			REF_167(AddressSet.Data) -> _pods_13[from_1]
			REF_168(AddressArray.Data) -> REF_167.items
			TMP_695(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_168'] 
			a_1(address[]) = ['TMP_695(address[])']
		Expression: b = _pods[to].items.get()
		IRs:
			REF_170(AddressSet.Data) -> _pods_13[to_1]
			REF_171(AddressArray.Data) -> REF_170.items
			TMP_696(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_171'] 
			b_1(address[]) = ['TMP_696(address[])']
		Expression: aLength = a.length
		IRs:
			REF_173 -> LENGTH a_1
			aLength_1(uint256) := REF_173(uint256)
		Expression: bLength = b.length
		IRs:
			REF_174 -> LENGTH b_1
			bLength_1(uint256) := REF_174(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < aLength
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_697(bool) = i_2 < aLength_1
			CONDITION TMP_697
		Expression: pod = a[i]
		IRs:
			REF_175(address) -> a_1[i_2]
			pod_1(address) := REF_175(address)
		IRs:
			b_3(address[]) := ϕ(['b_2', 'b_1'])
		Expression: j = 0
		IRs:
			j_1(uint256) := 0(uint256)
		Expression: j < bLength
		IRs:
			j_2(uint256) := ϕ(['j_3', 'j_1'])
			TMP_698(bool) = j_2 < bLength_1
			CONDITION TMP_698
		Expression: pod == b[j]
		IRs:
			REF_176(address) -> b_1[j_2]
			TMP_699(bool) = pod_1 == REF_176
			CONDITION TMP_699
		Expression: _updateBalances(pod,from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,to_1,amount_1)
		Expression: b[j] = address(0)
		IRs:
			REF_177(address) -> b_1[j_2]
			TMP_701 = CONVERT 0 to address
			b_2(address[]) := ϕ(['b_1'])
			REF_177(address) (->b_2) := TMP_701(address)
		Expression: j ++
		IRs:
			TMP_702(uint256) := j_2(uint256)
			j_3(uint256) = j_2 + 1
		Expression: j == bLength
		IRs:
			TMP_703(bool) = j_2 == bLength_1
			CONDITION TMP_703
		Expression: _updateBalances(pod,from,address(0),amount)
		IRs:
			TMP_704 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,TMP_704,amount_1)
		Expression: i ++
		IRs:
			TMP_706(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		Expression: j_scope_0 = 0
		IRs:
			j_scope_0_1(uint256) := 0(uint256)
		Expression: j_scope_0 < bLength
		IRs:
			j_scope_0_2(uint256) := ϕ(['j_scope_0_3', 'j_scope_0_1'])
			TMP_707(bool) = j_scope_0_2 < bLength_1
			CONDITION TMP_707
		Expression: pod_scope_1 = b[j_scope_0]
		IRs:
			REF_178(address) -> b_1[j_scope_0_2]
			pod_scope_1_1(address) := REF_178(address)
		Expression: pod_scope_1 != address(0)
		IRs:
			TMP_708 = CONVERT 0 to address
			TMP_709(bool) = pod_scope_1_1 != TMP_708
			CONDITION TMP_709
		Expression: _updateBalances(pod_scope_1,address(0),to,amount)
		IRs:
			TMP_710 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_scope_1_1,TMP_710,to_1,amount_1)
		Expression: j_scope_0 ++
		IRs:
			TMP_712(uint256) := j_scope_0_2(uint256)
			j_scope_0_3(uint256) = j_scope_0_2 + 1
		Expression: nonReentrant(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)(_guard_6)
	Modifier ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_6'])
EXPRESSION self.enter()
		Expression: self.enter()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.enter(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
_
EXPRESSION self.exit()
		Expression: self.exit()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.exit(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
	Modifier ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard', '_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_4', '_guard_2'])
IF self.check()
		Expression: self.check()
		IRs:
			TMP_716(bool) = LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.check(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard', '_guard'])"] 
			CONDITION TMP_716
EXPRESSION ReentrancyGuardLib.ReentrantCall()
		Expression: ReentrancyGuardLib.ReentrantCall()
		IRs:
			TMP_717(None) = SOLIDITY_CALL revert ReentrantCall()()
END_IF
_
Contract Pod
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function Pod.constructor(IERC20Pods)
		IRs:
			token__1(IERC20Pods) := ϕ(['farmableToken__1', 'token__1', 'token__1', 'token__1', 'farmableToken__1', 'token__1', 'token__1', 'farmableToken__1', 'token__1', 'token__1'])
		Expression: token = token_
		IRs:
			token_1(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, Pod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_2(IERC20Pods) := ϕ(['token_0', 'token_1'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_720 = CONVERT token_2 to address
			TMP_721(bool) = msg.sender != TMP_720
			CONDITION TMP_721
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_722(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract IERC20Pods
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
Contract IPod
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
Contract ReentrancyGuardLib
	Function ReentrancyGuardLib.init(ReentrancyGuardLib.Data)
		IRs:
			_NOT_ENTERED_1(uint256) := ϕ(['_NOT_ENTERED_0'])
		Expression: self._status = _NOT_ENTERED
		IRs:
			REF_182(uint256) -> self_1 (-> [])._status
			self_2 (-> [])(ReentrancyGuardLib.Data) := ϕ(['self_1 (-> [])'])
			REF_182(uint256) (->self_2 (-> [])) := _NOT_ENTERED_1(uint256)
	Function ReentrancyGuardLib.enter(ReentrancyGuardLib.Data)
		IRs:
			_ENTERED_1(uint256) := ϕ(['_ENTERED_0'])
		Expression: self._status == _ENTERED
		IRs:
			REF_183(uint256) -> self_1 (-> [])._status
			TMP_723(bool) = REF_183 == _ENTERED_1
			CONDITION TMP_723
		Expression: revert ReentrantCall()()
		IRs:
			TMP_724(None) = SOLIDITY_CALL revert ReentrantCall()()
		Expression: self._status = _ENTERED
		IRs:
			REF_184(uint256) -> self_1 (-> [])._status
			self_2 (-> [])(ReentrancyGuardLib.Data) := ϕ(['self_1 (-> [])'])
			REF_184(uint256) (->self_2 (-> [])) := _ENTERED_1(uint256)
	Function ReentrancyGuardLib.exit(ReentrancyGuardLib.Data)
		IRs:
			_NOT_ENTERED_2(uint256) := ϕ(['_NOT_ENTERED_0'])
		Expression: self._status = _NOT_ENTERED
		IRs:
			REF_185(uint256) -> self_1 (-> [])._status
			self_2 (-> [])(ReentrancyGuardLib.Data) := ϕ(['self_1 (-> [])'])
			REF_185(uint256) (->self_2 (-> [])) := _NOT_ENTERED_2(uint256)
	Function ReentrancyGuardLib.check(ReentrancyGuardLib.Data)
		IRs:
			_ENTERED_2(uint256) := ϕ(['_ENTERED_0'])
		Expression: self._status == _ENTERED
		IRs:
			REF_186(uint256) -> self_1 (-> [])._status
			TMP_725(bool) = REF_186 == _ENTERED_2
			RETURN TMP_725
	Function ReentrancyGuardLib.slitherConstructorConstantVariables()
		Expression: _NOT_ENTERED = 1
		Expression: _ENTERED = 2
Contract ReentrancyGuardExt
	Modifier ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)
ENTRY_POINT
EXPRESSION self.enter()
		Expression: self.enter()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.enter(ReentrancyGuardLib.Data), arguments:['self_1 (-> [])'] 
_
EXPRESSION self.exit()
		Expression: self.exit()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.exit(ReentrancyGuardLib.Data), arguments:['self_1 (-> [])'] 
	Modifier ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)
ENTRY_POINT
IF self.check()
		Expression: self.check()
		IRs:
			TMP_728(bool) = LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.check(ReentrancyGuardLib.Data), arguments:['self_1 (-> [])'] 
			CONDITION TMP_728
EXPRESSION ReentrancyGuardLib.ReentrantCall()
		Expression: ReentrancyGuardLib.ReentrantCall()
		IRs:
			TMP_729(None) = SOLIDITY_CALL revert ReentrantCall()()
END_IF
_
Contract PodMock
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_1(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, PodMock._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
		Expression: _balances[account]
		IRs:
			REF_190(uint256) -> _balances_1[account_1]
			RETURN REF_190
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_732(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_732(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_0', '_allowances_1', '_allowances_2'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_191(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_192(uint256) -> REF_191[spender_1]
			RETURN REF_192
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_734(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_734(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_736(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_736(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_739(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_739(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_740(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_741(uint256) = TMP_740 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_741)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_743(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_743(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_744(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_744(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_745(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_746(None) = SOLIDITY_CALL require(bool,string)(TMP_745,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_747(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_747)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_749 = CONVERT 0 to address
			TMP_750(bool) = from_1 != TMP_749
			TMP_751(None) = SOLIDITY_CALL require(bool,string)(TMP_750,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_752 = CONVERT 0 to address
			TMP_753(bool) = to_1 != TMP_752
			TMP_754(None) = SOLIDITY_CALL require(bool,string)(TMP_753,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_193(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_193(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_756(bool) = fromBalance_1 >= amount_1
			TMP_757(None) = SOLIDITY_CALL require(bool,string)(TMP_756,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_194(uint256) -> _balances_3[from_1]
			TMP_758(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_194(uint256) (->_balances_4) := TMP_758(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_195(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_195(-> _balances_5) = REF_195 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_761 = CONVERT 0 to address
			TMP_762(bool) = account_1 != TMP_761
			TMP_763(None) = SOLIDITY_CALL require(bool,string)(TMP_762,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_764 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_764,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_196(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_196(-> _balances_8) = REF_196 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_766 = CONVERT 0 to address
			Emit Transfer(TMP_766,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_768 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_768,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['from_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_770 = CONVERT 0 to address
			TMP_771(bool) = account_1 != TMP_770
			TMP_772(None) = SOLIDITY_CALL require(bool,string)(TMP_771,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_773 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_773,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_197(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_197(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_775(bool) = accountBalance_1 >= amount_1
			TMP_776(None) = SOLIDITY_CALL require(bool,string)(TMP_775,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_198(uint256) -> _balances_10[account_1]
			TMP_777(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_198(uint256) (->_balances_11) := TMP_777(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_778 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_778,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_780 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_780,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_795', 'TMP_741', 'amount_1', 'TMP_747'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_782 = CONVERT 0 to address
			TMP_783(bool) = owner_1 != TMP_782
			TMP_784(None) = SOLIDITY_CALL require(bool,string)(TMP_783,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_785 = CONVERT 0 to address
			TMP_786(bool) = spender_1 != TMP_785
			TMP_787(None) = SOLIDITY_CALL require(bool,string)(TMP_786,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_199(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_200(uint256) -> REF_199[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_200(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_789(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_789(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_791(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_792(bool) = currentAllowance_1 != TMP_791
			CONDITION TMP_792
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_793(bool) = currentAllowance_1 >= amount_1
			TMP_794(None) = SOLIDITY_CALL require(bool,string)(TMP_793,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_795(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_795)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_764', 'from_1', 'account_1'])
			to_1(address) := ϕ(['account_1', 'TMP_773', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'TMP_768', 'account_1'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_780'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function PodMock.constructor(string,string,IERC20Pods)
		Expression: ERC20(name,symbol)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name_1,symbol_1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function PodMock._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: from == address(0)
		IRs:
			TMP_799 = CONVERT 0 to address
			TMP_800(bool) = from_1 == TMP_799
			CONDITION TMP_800
		Expression: _mint(to,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(to_1,amount_1)
		Expression: to == address(0)
		IRs:
			TMP_802 = CONVERT 0 to address
			TMP_803(bool) = to_1 == TMP_802
			CONDITION TMP_803
		Expression: _burn(from,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(from_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_2(IERC20Pods) := ϕ(['token_1', 'token_0'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_806 = CONVERT token_2 to address
			TMP_807(bool) = msg.sender != TMP_806
			CONDITION TMP_807
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_808(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract WrongPodMock
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_1(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, WrongPodMock._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_0', '_balances_1', '_balances_8', '_balances_11'])
		Expression: _balances[account]
		IRs:
			REF_201(uint256) -> _balances_1[account_1]
			RETURN REF_201
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_811(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_811(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1', '_allowances_2', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_202(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_203(uint256) -> REF_202[spender_1]
			RETURN REF_203
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_813(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_813(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_815(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_815(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_818(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_818(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_819(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_820(uint256) = TMP_819 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_820)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_822(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_822(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_823(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_823(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_824(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_825(None) = SOLIDITY_CALL require(bool,string)(TMP_824,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_826(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_826)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'owner_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_0', '_balances_1', '_balances_8', '_balances_11'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_828 = CONVERT 0 to address
			TMP_829(bool) = from_1 != TMP_828
			TMP_830(None) = SOLIDITY_CALL require(bool,string)(TMP_829,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_831 = CONVERT 0 to address
			TMP_832(bool) = to_1 != TMP_831
			TMP_833(None) = SOLIDITY_CALL require(bool,string)(TMP_832,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_204(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_204(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_835(bool) = fromBalance_1 >= amount_1
			TMP_836(None) = SOLIDITY_CALL require(bool,string)(TMP_835,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_205(uint256) -> _balances_3[from_1]
			TMP_837(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_205(uint256) (->_balances_4) := TMP_837(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_206(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_206(-> _balances_5) = REF_206 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_0', '_balances_1', '_balances_8', '_balances_11'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_840 = CONVERT 0 to address
			TMP_841(bool) = account_1 != TMP_840
			TMP_842(None) = SOLIDITY_CALL require(bool,string)(TMP_841,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_843 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_843,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_207(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_207(-> _balances_8) = REF_207 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_845 = CONVERT 0 to address
			Emit Transfer(TMP_845,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_847 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_847,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_5', '_balances_0', '_balances_1', '_balances_8', '_balances_11'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_849 = CONVERT 0 to address
			TMP_850(bool) = account_1 != TMP_849
			TMP_851(None) = SOLIDITY_CALL require(bool,string)(TMP_850,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_852 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_852,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_208(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_208(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_854(bool) = accountBalance_1 >= amount_1
			TMP_855(None) = SOLIDITY_CALL require(bool,string)(TMP_854,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_209(uint256) -> _balances_10[account_1]
			TMP_856(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_209(uint256) (->_balances_11) := TMP_856(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_857 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_857,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_859 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_859,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['amount_1', 'TMP_826', 'TMP_874', 'TMP_820'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_861 = CONVERT 0 to address
			TMP_862(bool) = owner_1 != TMP_861
			TMP_863(None) = SOLIDITY_CALL require(bool,string)(TMP_862,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_864 = CONVERT 0 to address
			TMP_865(bool) = spender_1 != TMP_864
			TMP_866(None) = SOLIDITY_CALL require(bool,string)(TMP_865,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_210(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_211(uint256) -> REF_210[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_211(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_868(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_868(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_870(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_871(bool) = currentAllowance_1 != TMP_870
			CONDITION TMP_871
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_872(bool) = currentAllowance_1 >= amount_1
			TMP_873(None) = SOLIDITY_CALL require(bool,string)(TMP_872,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_874(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_874)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'TMP_843', 'from_1'])
			to_1(address) := ϕ(['TMP_852', 'account_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_847'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_859'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function WrongPodMock.constructor(string,string,IERC20Pods)
		Expression: ERC20(name,symbol)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name_1,symbol_1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function WrongPodMock._updateBalances(address,address,uint256)
		IRs:
			isRevert_1(bool) := ϕ(['isRevert_0', 'isRevert_2'])
			isOutOfGas_1(bool) := ϕ(['isOutOfGas_2', 'isOutOfGas_0'])
			isReturnGasBomb_1(bool) := ϕ(['isReturnGasBomb_2', 'isReturnGasBomb_0'])
		Expression: isRevert
		IRs:
			CONDITION isRevert_1
		Expression: revert PodsUpdateBalanceRevert()()
		IRs:
			TMP_878(None) = SOLIDITY_CALL revert PodsUpdateBalanceRevert()()
		Expression: isOutOfGas
		IRs:
			CONDITION isOutOfGas_1
		Expression: assert(bool)(false)
		IRs:
			TMP_879(None) = SOLIDITY_CALL assert(bool)(False)
		Expression: isReturnGasBomb
		IRs:
			CONDITION isReturnGasBomb_1
		Expression: return(uint256,uint256)(0,1000000)
		IRs:
			TMP_880(None) = SOLIDITY_CALL return(uint256,uint256)(0,1000000)
	Function WrongPodMock.setIsRevert(bool)
		Expression: isRevert = isRevert_
		IRs:
			isRevert_2(bool) := isRevert__1(bool)
	Function WrongPodMock.setOutOfGas(bool)
		Expression: isOutOfGas = isOutOfGas_
		IRs:
			isOutOfGas_2(bool) := isOutOfGas__1(bool)
	Function WrongPodMock.setReturnGasBomb(bool)
		Expression: isReturnGasBomb = isReturnGasBomb_
		IRs:
			isReturnGasBomb_2(bool) := isReturnGasBomb__1(bool)
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_2(IERC20Pods) := ϕ(['token_0', 'token_1'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_881 = CONVERT token_2 to address
			TMP_882(bool) = msg.sender != TMP_881
			CONDITION TMP_882
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_883(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract FarmingLib
	Function FarmingLib.makeInfo(function() returns(uint256),FarmingLib.Data)
		Expression: info.getTotalSupply = getTotalSupply
		IRs:
			REF_212(function() returns(uint256)) -> info_0.getTotalSupply
			info_1(FarmingLib.Info) := ϕ(['info_0'])
			REF_212(function() returns(uint256)) (->info_1) := getTotalSupply_1(function() returns(uint256))
		Expression: dataSlot = data
		IRs:
			dataSlot_1(bytes32) := data_1 (-> [])(FarmingLib.Data)
		Expression: info.dataSlot = dataSlot
		IRs:
			REF_213(bytes32) -> info_1.dataSlot
			info_2(FarmingLib.Info) := ϕ(['info_1'])
			REF_213(bytes32) (->info_2) := dataSlot_1(bytes32)
		Expression: info
		IRs:
			RETURN info_2
	Function FarmingLib.getData(FarmingLib.Info)
		Expression: dataSlot = self.dataSlot
		IRs:
			REF_214(bytes32) -> self_1.dataSlot
			dataSlot_1(bytes32) := REF_214(bytes32)
		Expression: data = dataSlot
		IRs:
			data_1 (-> ['dataSlot'])(FarmingLib.Data) := dataSlot_1(bytes32)
		Expression: data
		IRs:
			RETURN data_1 (-> ['dataSlot'])
	Function FarmingLib.startFarming(FarmingLib.Info,uint256,uint256)
		Expression: data = self.getData()
		IRs:
			TMP_884(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			data_1 (-> ['TMP_884'])(FarmingLib.Data) := TMP_884(FarmingLib.Data)
		Expression: data.userInfo.updateFarmedPerToken(_farmedPerToken(self))
		IRs:
			REF_216(UserAccounting.Info) -> data_1 (-> ['TMP_884']).userInfo
			TMP_885(uint256) = INTERNAL_CALL, FarmingLib._farmedPerToken(FarmingLib.Info)(self_1)
			LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.updateFarmedPerToken(UserAccounting.Info,uint256), arguments:['REF_216', 'TMP_885'] 
		Expression: reward = data.farmInfo.startFarming(amount,period)
		IRs:
			REF_218(FarmAccounting.Info) -> data_1 (-> ['TMP_884']).farmInfo
			TMP_887(uint256) = LIBRARY_CALL, dest:FarmAccounting, function:FarmAccounting.startFarming(FarmAccounting.Info,uint256,uint256), arguments:['REF_218', 'amount_1', 'period_1'] 
			reward_1(uint256) := TMP_887(uint256)
		Expression: reward
		IRs:
			RETURN reward_1
	Function FarmingLib.farmed(FarmingLib.Info,address,uint256)
		Expression: self.getData().userInfo.farmed(account,balance,_farmedPerToken(self))
		IRs:
			TMP_888(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			REF_221(UserAccounting.Info) -> TMP_888.userInfo
			TMP_889(uint256) = INTERNAL_CALL, FarmingLib._farmedPerToken(FarmingLib.Info)(self_1)
			TMP_890(uint256) = LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.farmed(UserAccounting.Info,address,uint256,uint256), arguments:['REF_221', 'account_1', 'balance_1', 'TMP_889'] 
			RETURN TMP_890
	Function FarmingLib.claim(FarmingLib.Info,address,uint256)
		Expression: data = self.getData()
		IRs:
			TMP_891(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			data_1 (-> ['TMP_891'])(FarmingLib.Data) := TMP_891(FarmingLib.Data)
		Expression: fpt = _farmedPerToken(self)
		IRs:
			TMP_892(uint256) = INTERNAL_CALL, FarmingLib._farmedPerToken(FarmingLib.Info)(self_1)
			fpt_1(uint256) := TMP_892(uint256)
		Expression: amount = data.userInfo.farmed(account,balance,fpt)
		IRs:
			REF_224(UserAccounting.Info) -> data_1 (-> ['TMP_891']).userInfo
			TMP_893(uint256) = LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.farmed(UserAccounting.Info,address,uint256,uint256), arguments:['REF_224', 'account_1', 'balance_1', 'fpt_1'] 
			amount_1(uint256) := TMP_893(uint256)
		Expression: amount > 0
		IRs:
			TMP_894(bool) = amount_1 > 0
			CONDITION TMP_894
		Expression: data.userInfo.eraseFarmed(account,balance,fpt)
		IRs:
			REF_226(UserAccounting.Info) -> data_1 (-> ['TMP_891']).userInfo
			LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.eraseFarmed(UserAccounting.Info,address,uint256,uint256), arguments:['REF_226', 'account_1', 'balance_1', 'fpt_1'] 
		Expression: amount
		IRs:
			RETURN amount_1
	Function FarmingLib.updateBalances(FarmingLib.Info,address,address,uint256)
		Expression: self.getData().userInfo.updateBalances(from,to,amount,_farmedPerToken(self))
		IRs:
			TMP_896(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			REF_229(UserAccounting.Info) -> TMP_896.userInfo
			TMP_897(uint256) = INTERNAL_CALL, FarmingLib._farmedPerToken(FarmingLib.Info)(self_1)
			LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.updateBalances(UserAccounting.Info,address,address,uint256,uint256), arguments:['REF_229', 'from_1', 'to_1', 'amount_1', 'TMP_897'] 
	Function FarmingLib._farmedPerToken(FarmingLib.Info)
		IRs:
			self_1(FarmingLib.Info) := ϕ(['self_1', 'self_1', 'self_1', 'self_1'])
		Expression: self.getData().userInfo.farmedPerToken(_infoToContext(self),_lazyGetSupply,_lazyGetFarmed)
		IRs:
			TMP_899(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			REF_232(UserAccounting.Info) -> TMP_899.userInfo
			TMP_900(bytes32) = INTERNAL_CALL, FarmingLib._infoToContext(FarmingLib.Info)(self_1)
			TMP_901(uint256) = LIBRARY_CALL, dest:UserAccounting, function:UserAccounting.farmedPerToken(UserAccounting.Info,bytes32,function(bytes32) returns(uint256),function(bytes32,uint256) returns(uint256)), arguments:['REF_232', 'TMP_900', '_lazyGetSupply', '_lazyGetFarmed'] 
			RETURN TMP_901
	Function FarmingLib._lazyGetSupply(bytes32)
		Expression: self = _contextToInfo(context)
		IRs:
			TMP_902(FarmingLib.Info) = INTERNAL_CALL, FarmingLib._contextToInfo(bytes32)(context_1)
			self_1(FarmingLib.Info) := TMP_902(FarmingLib.Info)
		Expression: self.getTotalSupply()
		IRs:
			REF_234(function() returns(uint256)) -> self_1.getTotalSupply
			TMP_903(uint256) = INTERNAL_DYNAMIC_CALL REF_234()  
			RETURN TMP_903
	Function FarmingLib._lazyGetFarmed(bytes32,uint256)
		Expression: self = _contextToInfo(context)
		IRs:
			TMP_904(FarmingLib.Info) = INTERNAL_CALL, FarmingLib._contextToInfo(bytes32)(context_1)
			self_1(FarmingLib.Info) := TMP_904(FarmingLib.Info)
		Expression: self.getData().farmInfo.farmedSinceCheckpointScaled(checkpoint)
		IRs:
			TMP_905(FarmingLib.Data) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.getData(FarmingLib.Info), arguments:['self_1'] 
			REF_236(FarmAccounting.Info) -> TMP_905.farmInfo
			TMP_906(uint256) = LIBRARY_CALL, dest:FarmAccounting, function:FarmAccounting.farmedSinceCheckpointScaled(FarmAccounting.Info,uint256), arguments:['REF_236', 'checkpoint_1'] 
			RETURN TMP_906
	Function FarmingLib._contextToInfo(bytes32)
		IRs:
			context_1(bytes32) := ϕ(['context_1', 'context_1'])
		Expression: self = context
		IRs:
			self_1(FarmingLib.Info) := context_1(bytes32)
		Expression: self
		IRs:
			RETURN self_1
	Function FarmingLib._infoToContext(FarmingLib.Info)
		IRs:
			self_1(FarmingLib.Info) := ϕ(['self_1'])
		Expression: context = self
		IRs:
			context_1(bytes32) := self_1(FarmingLib.Info)
		Expression: context
		IRs:
			RETURN context_1
Contract FarmingPod
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_907(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_907)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_909(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_910(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_911(bool) = TMP_909 == TMP_910
			TMP_912(None) = SOLIDITY_CALL require(bool,string)(TMP_911,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_913 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_913)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_916 = CONVERT 0 to address
			TMP_917(bool) = newOwner_1 != TMP_916
			TMP_918(None) = SOLIDITY_CALL require(bool,string)(TMP_917,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['newOwner_1', 'TMP_907', 'TMP_913'])
			_owner_2(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function IFarmingPod.totalSupply()
	Function IFarmingPod.distributor()
	Function IFarmingPod.farmInfo()
	Function IFarmingPod.farmed(address)
	Function IFarmingPod.claim()
	Function IFarmingPod.setDistributor(address)
	Function IFarmingPod.startFarming(uint256,uint256)
	Function IFarmingPod.rescueFunds(IERC20,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_1(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, FarmingPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function FarmingPod.constructor(IERC20Pods,IERC20)
		IRs:
			farmableToken__1(IERC20Pods) := ϕ(['st1inch__1'])
			rewardsToken__1(IERC20) := ϕ(['TMP_4670'])
		Expression: address(farmableToken_) == address(0)
		IRs:
			TMP_924 = CONVERT farmableToken__1 to address
			TMP_925 = CONVERT 0 to address
			TMP_926(bool) = TMP_924 == TMP_925
			CONDITION TMP_926
		Expression: revert ZeroFarmableTokenAddress()()
		IRs:
			TMP_927(None) = SOLIDITY_CALL revert ZeroFarmableTokenAddress()()
		Expression: address(rewardsToken_) == address(0)
		IRs:
			TMP_928 = CONVERT rewardsToken__1 to address
			TMP_929 = CONVERT 0 to address
			TMP_930(bool) = TMP_928 == TMP_929
			CONDITION TMP_930
		Expression: revert ZeroRewardsTokenAddress()()
		IRs:
			TMP_931(None) = SOLIDITY_CALL revert ZeroRewardsTokenAddress()()
		Expression: rewardsToken = rewardsToken_
		IRs:
			rewardsToken_1(IERC20) := rewardsToken__1(IERC20)
		Expression: FarmCreated(address(farmableToken_),address(rewardsToken_))
		IRs:
			TMP_932 = CONVERT farmableToken__1 to address
			TMP_933 = CONVERT rewardsToken__1 to address
			Emit FarmCreated(TMP_932,TMP_933)
		Expression: Pod(farmableToken_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(farmableToken__1)
	Function FarmingPod.farmInfo()
		IRs:
			_farm_1(FarmingLib.Data) := ϕ(['_farm_1', '_farm_0'])
		Expression: _farm.farmInfo
		IRs:
			REF_238(FarmAccounting.Info) -> _farm_1.farmInfo
			RETURN REF_238
	Function FarmingPod.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_5', '_totalSupply_4', '_totalSupply_3'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function FarmingPod.distributor()
		IRs:
			_distributor_1(address) := ϕ(['_distributor_0', '_distributor_6', '_distributor_4'])
		Expression: _distributor
		IRs:
			RETURN _distributor_1
	Function FarmingPod.setDistributor(address)
		IRs:
			_distributor_2(address) := ϕ(['_distributor_0', '_distributor_6', '_distributor_4'])
		Expression: oldDistributor = _distributor
		IRs:
			oldDistributor_1(address) := _distributor_3(address)
		Expression: distributor_ == oldDistributor
		IRs:
			TMP_936(bool) = distributor__1 == oldDistributor_1
			CONDITION TMP_936
		Expression: revert SameDistributor()()
		IRs:
			TMP_937(None) = SOLIDITY_CALL revert SameDistributor()()
		Expression: DistributorChanged(oldDistributor,distributor_)
		IRs:
			Emit DistributorChanged(oldDistributor_1,distributor__1)
		Expression: _distributor = distributor_
		IRs:
			_distributor_4(address) := distributor__1(address)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function FarmingPod.startFarming(uint256,uint256)
		IRs:
			rewardsToken_2(IERC20) := ϕ(['rewardsToken_8', 'rewardsToken_4', 'rewardsToken_7', 'rewardsToken_1', 'rewardsToken_0'])
		Expression: reward = _makeInfo().startFarming(amount,period)
		IRs:
			TMP_940(FarmingLib.Info) = INTERNAL_CALL, FarmingPod._makeInfo()()
			TMP_941(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.startFarming(FarmingLib.Info,uint256,uint256), arguments:['TMP_940', 'amount_1', 'period_1'] 
			reward_1(uint256) := TMP_941(uint256)
		Expression: RewardAdded(reward,period)
		IRs:
			Emit RewardAdded(reward_1,period_1)
		Expression: rewardsToken.safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_943 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['rewardsToken_4', 'msg.sender', 'TMP_943', 'amount_1'] 
		Expression: onlyDistributor()
		IRs:
			MODIFIER_CALL, FarmingPod.onlyDistributor()()
	Function FarmingPod.farmed(address)
		IRs:
			token_2(IERC20Pods) := ϕ(['token_5', 'token_0', 'token_1', 'token_3'])
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),account)
		IRs:
			TMP_946 = CONVERT token_2 to IERC20Pods
			TMP_947 = CONVERT this to address
			TMP_948(uint256) = HIGH_LEVEL_CALL, dest:TMP_946(IERC20Pods), function:podBalanceOf, arguments:['TMP_947', 'account_1']  
			token_3(IERC20Pods) := ϕ(['token_2', 'token_5', 'token_1', 'token_3'])
			balance_1(uint256) := TMP_948(uint256)
		Expression: _makeInfo().farmed(account,balance)
		IRs:
			TMP_949(FarmingLib.Info) = INTERNAL_CALL, FarmingPod._makeInfo()()
			TMP_950(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.farmed(FarmingLib.Info,address,uint256), arguments:['TMP_949', 'account_1', 'balance_1'] 
			RETURN TMP_950
	Function FarmingPod.claim()
		IRs:
			token_4(IERC20Pods) := ϕ(['token_5', 'token_0', 'token_1', 'token_3'])
			rewardsToken_5(IERC20) := ϕ(['rewardsToken_8', 'rewardsToken_4', 'rewardsToken_7', 'rewardsToken_1', 'rewardsToken_0'])
		Expression: podBalance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_951 = CONVERT token_4 to IERC20Pods
			TMP_952 = CONVERT this to address
			TMP_953(uint256) = HIGH_LEVEL_CALL, dest:TMP_951(IERC20Pods), function:podBalanceOf, arguments:['TMP_952', 'msg.sender']  
			token_5(IERC20Pods) := ϕ(['token_5', 'token_1', 'token_4', 'token_3'])
			rewardsToken_6(IERC20) := ϕ(['rewardsToken_5', 'rewardsToken_8', 'rewardsToken_4', 'rewardsToken_7', 'rewardsToken_1'])
			podBalance_1(uint256) := TMP_953(uint256)
		Expression: amount = _makeInfo().claim(msg.sender,podBalance)
		IRs:
			TMP_954(FarmingLib.Info) = INTERNAL_CALL, FarmingPod._makeInfo()()
			TMP_955(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.claim(FarmingLib.Info,address,uint256), arguments:['TMP_954', 'msg.sender', 'podBalance_1'] 
			amount_1(uint256) := TMP_955(uint256)
		Expression: amount > 0
		IRs:
			TMP_956(bool) = amount_1 > 0
			CONDITION TMP_956
		Expression: _transferReward(rewardsToken,msg.sender,amount)
		IRs:
			INTERNAL_CALL, FarmingPod._transferReward(IERC20,address,uint256)(rewardsToken_7,msg.sender,amount_1)
	Function FarmingPod._transferReward(IERC20,address,uint256)
		IRs:
			reward_1(IERC20) := ϕ(['rewardsToken_7'])
			to_1(address) := ϕ(['msg.sender'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: reward.safeTransfer(to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['reward_1', 'to_1', 'amount_1'] 
	Function FarmingPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_5', '_totalSupply_4', '_totalSupply_3'])
		Expression: _makeInfo().updateBalances(from,to,amount)
		IRs:
			TMP_959(FarmingLib.Info) = INTERNAL_CALL, FarmingPod._makeInfo()()
			LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.updateBalances(FarmingLib.Info,address,address,uint256), arguments:['TMP_959', 'from_1', 'to_1', 'amount_1'] 
		Expression: from == address(0)
		IRs:
			TMP_961 = CONVERT 0 to address
			TMP_962(bool) = from_1 == TMP_961
			CONDITION TMP_962
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: to == address(0)
		IRs:
			TMP_963 = CONVERT 0 to address
			TMP_964(bool) = to_1 == TMP_963
			CONDITION TMP_964
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_5(uint256) = _totalSupply_4 (c)- amount_1
	Function FarmingPod.rescueFunds(IERC20,uint256)
		IRs:
			_distributor_5(address) := ϕ(['_distributor_0', '_distributor_6', '_distributor_4'])
		Expression: token == IERC20(address(0))
		IRs:
			TMP_965 = CONVERT 0 to address
			TMP_966 = CONVERT TMP_965 to IERC20
			TMP_967(bool) = token_1 == TMP_966
			CONDITION TMP_967
		Expression: address(_distributor).sendValue(amount)
		IRs:
			TMP_968 = CONVERT _distributor_6 to address
			LIBRARY_CALL, dest:Address, function:Address.sendValue(address,uint256), arguments:['TMP_968', 'amount_1'] 
		Expression: token.safeTransfer(_distributor,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['token_1', '_distributor_6', 'amount_1'] 
		Expression: onlyDistributor()
		IRs:
			MODIFIER_CALL, FarmingPod.onlyDistributor()()
	Function FarmingPod._makeInfo()
		IRs:
			_farm_2(FarmingLib.Data) := ϕ(['_farm_1', '_farm_0'])
		Expression: FarmingLib.makeInfo(totalSupply,_farm)
		IRs:
			TMP_972(FarmingLib.Info) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.makeInfo(function() returns(uint256),FarmingLib.Data), arguments:['totalSupply', '_farm_2'] 
			RETURN TMP_972
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_6(IERC20Pods) := ϕ(['token_5', 'token_0', 'token_1', 'token_3'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_974 = CONVERT token_6 to address
			TMP_975(bool) = msg.sender != TMP_974
			CONDITION TMP_975
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_976(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
	Modifier FarmingPod.onlyDistributor()
ENTRY_POINT
		IRs:
			_distributor_7(address) := ϕ(['_distributor_0', '_distributor_6', '_distributor_4'])
IF msg.sender != _distributor
		Expression: msg.sender != _distributor
		IRs:
			TMP_977(bool) = msg.sender != _distributor_7
			CONDITION TMP_977
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_978(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract MultiFarmingPod
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_979(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_979)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_981(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_982(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_983(bool) = TMP_981 == TMP_982
			TMP_984(None) = SOLIDITY_CALL require(bool,string)(TMP_983,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_985 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_985)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_988 = CONVERT 0 to address
			TMP_989(bool) = newOwner_1 != TMP_988
			TMP_990(None) = SOLIDITY_CALL require(bool,string)(TMP_989,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['newOwner_1', 'TMP_985', 'TMP_979'])
			_owner_2(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function IMultiFarmingPod.totalSupply()
	Function IMultiFarmingPod.distributor()
	Function IMultiFarmingPod.farmInfo(IERC20)
	Function IMultiFarmingPod.farmed(IERC20,address)
	Function IMultiFarmingPod.claim(IERC20)
	Function IMultiFarmingPod.claim()
	Function IMultiFarmingPod.setDistributor(address)
	Function IMultiFarmingPod.startFarming(IERC20,uint256,uint256)
	Function IMultiFarmingPod.rescueFunds(IERC20,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_1(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, MultiFarmingPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function MultiFarmingPod.constructor(IERC20Pods,uint256)
		Expression: rewardsTokensLimit_ > 5
		IRs:
			TMP_996(bool) = rewardsTokensLimit__1 > 5
			CONDITION TMP_996
		Expression: revert RewardsTokensLimitTooHigh(uint256)(rewardsTokensLimit_)
		IRs:
			TMP_997(None) = SOLIDITY_CALL revert RewardsTokensLimitTooHigh(uint256)(rewardsTokensLimit__1)
		Expression: address(farmableToken_) == address(0)
		IRs:
			TMP_998 = CONVERT farmableToken__1 to address
			TMP_999 = CONVERT 0 to address
			TMP_1000(bool) = TMP_998 == TMP_999
			CONDITION TMP_1000
		Expression: revert ZeroFarmableTokenAddress()()
		IRs:
			TMP_1001(None) = SOLIDITY_CALL revert ZeroFarmableTokenAddress()()
		Expression: rewardsTokensLimit = rewardsTokensLimit_
		IRs:
			rewardsTokensLimit_1(uint256) := rewardsTokensLimit__1(uint256)
		Expression: Pod(farmableToken_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(farmableToken__1)
	Function MultiFarmingPod.rewardsTokens()
		IRs:
			_rewardsTokens_1(AddressSet.Data) := ϕ(['_rewardsTokens_5', '_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0'])
		Expression: _rewardsTokens.items.get()
		IRs:
			REF_250(AddressArray.Data) -> _rewardsTokens_1.items
			TMP_1003(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_250'] 
			RETURN TMP_1003
	Function MultiFarmingPod.farmInfo(IERC20)
		IRs:
			_farms_1(mapping(IERC20 => FarmingLib.Data)) := ϕ(['_farms_2', '_farms_0', '_farms_1'])
		Expression: _farms[rewardsToken].farmInfo
		IRs:
			REF_252(FarmingLib.Data) -> _farms_1[rewardsToken_1]
			REF_253(FarmAccounting.Info) -> REF_252.farmInfo
			RETURN REF_253
	Function MultiFarmingPod.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_5', '_totalSupply_3'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function MultiFarmingPod.distributor()
		IRs:
			_distributor_1(address) := ϕ(['_distributor_4', '_distributor_6', '_distributor_0'])
		Expression: _distributor
		IRs:
			RETURN _distributor_1
	Function MultiFarmingPod.setDistributor(address)
		IRs:
			_distributor_2(address) := ϕ(['_distributor_4', '_distributor_6', '_distributor_0'])
		Expression: oldDistributor = _distributor
		IRs:
			oldDistributor_1(address) := _distributor_3(address)
		Expression: distributor_ == oldDistributor
		IRs:
			TMP_1004(bool) = distributor__1 == oldDistributor_1
			CONDITION TMP_1004
		Expression: revert SameDistributor()()
		IRs:
			TMP_1005(None) = SOLIDITY_CALL revert SameDistributor()()
		Expression: DistributorChanged(oldDistributor,distributor_)
		IRs:
			Emit DistributorChanged(oldDistributor_1,distributor__1)
		Expression: _distributor = distributor_
		IRs:
			_distributor_4(address) := distributor__1(address)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function MultiFarmingPod.addRewardsToken(address)
		IRs:
			token_2(IERC20Pods) := ϕ(['token_0', 'token_1', 'token_5', 'token_3', 'token_9', 'token_7'])
			rewardsTokensLimit_2(uint256) := ϕ(['rewardsTokensLimit_1', 'rewardsTokensLimit_3', 'rewardsTokensLimit_0'])
			_rewardsTokens_2(AddressSet.Data) := ϕ(['_rewardsTokens_5', '_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0'])
		Expression: _rewardsTokens.length() == rewardsTokensLimit
		IRs:
			TMP_1008(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['_rewardsTokens_3'] 
			TMP_1009(bool) = TMP_1008 == rewardsTokensLimit_3
			CONDITION TMP_1009
		Expression: revert RewardsTokensLimitReached()()
		IRs:
			TMP_1010(None) = SOLIDITY_CALL revert RewardsTokensLimitReached()()
		Expression: ! _rewardsTokens.add(rewardsToken)
		IRs:
			TMP_1011(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.add(AddressSet.Data,address), arguments:['_rewardsTokens_3', 'rewardsToken_1'] 
			TMP_1012 = UnaryType.BANG TMP_1011 
			CONDITION TMP_1012
		Expression: revert RewardsTokenAlreadyAdded()()
		IRs:
			TMP_1013(None) = SOLIDITY_CALL revert RewardsTokenAlreadyAdded()()
		Expression: FarmCreated(address(token),rewardsToken)
		IRs:
			TMP_1014 = CONVERT token_3 to address
			Emit FarmCreated(TMP_1014,rewardsToken_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function MultiFarmingPod.startFarming(IERC20,uint256,uint256)
		IRs:
			_rewardsTokens_4(AddressSet.Data) := ϕ(['_rewardsTokens_5', '_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0'])
		Expression: ! _rewardsTokens.contains(address(rewardsToken))
		IRs:
			TMP_1017 = CONVERT rewardsToken_1 to address
			TMP_1018(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.contains(AddressSet.Data,address), arguments:['_rewardsTokens_5', 'TMP_1017'] 
			TMP_1019 = UnaryType.BANG TMP_1018 
			CONDITION TMP_1019
		Expression: revert RewardsTokenNotFound()()
		IRs:
			TMP_1020(None) = SOLIDITY_CALL revert RewardsTokenNotFound()()
		Expression: reward = _makeInfo(rewardsToken).startFarming(amount,period)
		IRs:
			TMP_1021(FarmingLib.Info) = INTERNAL_CALL, MultiFarmingPod._makeInfo(IERC20)(rewardsToken_1)
			TMP_1022(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.startFarming(FarmingLib.Info,uint256,uint256), arguments:['TMP_1021', 'amount_1', 'period_1'] 
			reward_1(uint256) := TMP_1022(uint256)
		Expression: RewardAdded(address(rewardsToken),reward,period)
		IRs:
			TMP_1023 = CONVERT rewardsToken_1 to address
			Emit RewardAdded(TMP_1023,reward_1,period_1)
		Expression: rewardsToken.safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_1025 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['rewardsToken_1', 'msg.sender', 'TMP_1025', 'amount_1'] 
		Expression: onlyDistributor()
		IRs:
			MODIFIER_CALL, MultiFarmingPod.onlyDistributor()()
	Function MultiFarmingPod.farmed(IERC20,address)
		IRs:
			token_4(IERC20Pods) := ϕ(['token_0', 'token_1', 'token_5', 'token_3', 'token_9', 'token_7'])
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),account)
		IRs:
			TMP_1028 = CONVERT token_4 to IERC20Pods
			TMP_1029 = CONVERT this to address
			TMP_1030(uint256) = HIGH_LEVEL_CALL, dest:TMP_1028(IERC20Pods), function:podBalanceOf, arguments:['TMP_1029', 'account_1']  
			token_5(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_4'])
			balance_1(uint256) := TMP_1030(uint256)
		Expression: _makeInfo(rewardsToken).farmed(account,balance)
		IRs:
			TMP_1031(FarmingLib.Info) = INTERNAL_CALL, MultiFarmingPod._makeInfo(IERC20)(rewardsToken_1)
			TMP_1032(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.farmed(FarmingLib.Info,address,uint256), arguments:['TMP_1031', 'account_1', 'balance_1'] 
			RETURN TMP_1032
	Function MultiFarmingPod.claim(IERC20)
		IRs:
			token_6(IERC20Pods) := ϕ(['token_0', 'token_1', 'token_5', 'token_3', 'token_9', 'token_7'])
		Expression: podBalance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_1033 = CONVERT token_6 to IERC20Pods
			TMP_1034 = CONVERT this to address
			TMP_1035(uint256) = HIGH_LEVEL_CALL, dest:TMP_1033(IERC20Pods), function:podBalanceOf, arguments:['TMP_1034', 'msg.sender']  
			token_7(IERC20Pods) := ϕ(['token_6', 'token_1', 'token_5', 'token_3', 'token_9', 'token_7'])
			podBalance_1(uint256) := TMP_1035(uint256)
		Expression: _claim(rewardsToken,msg.sender,podBalance)
		IRs:
			INTERNAL_CALL, MultiFarmingPod._claim(IERC20,address,uint256)(rewardsToken_1,msg.sender,podBalance_1)
	Function MultiFarmingPod.claim()
		IRs:
			token_8(IERC20Pods) := ϕ(['token_0', 'token_1', 'token_5', 'token_3', 'token_9', 'token_7'])
			_rewardsTokens_6(AddressSet.Data) := ϕ(['_rewardsTokens_5', '_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0'])
		Expression: podBalance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_1037 = CONVERT token_8 to IERC20Pods
			TMP_1038 = CONVERT this to address
			TMP_1039(uint256) = HIGH_LEVEL_CALL, dest:TMP_1037(IERC20Pods), function:podBalanceOf, arguments:['TMP_1038', 'msg.sender']  
			token_9(IERC20Pods) := ϕ(['token_1', 'token_5', 'token_3', 'token_9', 'token_7', 'token_8'])
			_rewardsTokens_7(AddressSet.Data) := ϕ(['_rewardsTokens_6', '_rewardsTokens_5', '_rewardsTokens_8', '_rewardsTokens_3', '_rewardsTokens_7', '_rewardsTokens_1'])
			podBalance_1(uint256) := TMP_1039(uint256)
		Expression: tokens = _rewardsTokens.items.get()
		IRs:
			REF_263(AddressArray.Data) -> _rewardsTokens_7.items
			TMP_1040(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_263'] 
			tokens_1(address[]) = ['TMP_1040(address[])']
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < tokens.length
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			REF_265 -> LENGTH tokens_1
			TMP_1041(bool) = i_2 < REF_265
			CONDITION TMP_1041
		Expression: _claim(IERC20(tokens[i]),msg.sender,podBalance)
		IRs:
			REF_266(address) -> tokens_1[i_2]
			TMP_1042 = CONVERT REF_266 to IERC20
			INTERNAL_CALL, MultiFarmingPod._claim(IERC20,address,uint256)(TMP_1042,msg.sender,podBalance_1)
		Expression: i ++
		IRs:
			TMP_1044(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
	Function MultiFarmingPod._claim(IERC20,address,uint256)
		IRs:
			rewardsToken_1(IERC20) := ϕ(['rewardsToken_1', 'TMP_1042'])
			account_1(address) := ϕ(['msg.sender'])
			podBalance_1(uint256) := ϕ(['podBalance_1', 'podBalance_1'])
		Expression: amount = _makeInfo(rewardsToken).claim(account,podBalance)
		IRs:
			TMP_1045(FarmingLib.Info) = INTERNAL_CALL, MultiFarmingPod._makeInfo(IERC20)(rewardsToken_1)
			TMP_1046(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.claim(FarmingLib.Info,address,uint256), arguments:['TMP_1045', 'account_1', 'podBalance_1'] 
			amount_1(uint256) := TMP_1046(uint256)
		Expression: amount > 0
		IRs:
			TMP_1047(bool) = amount_1 > 0
			CONDITION TMP_1047
		Expression: _transferReward(rewardsToken,account,amount)
		IRs:
			INTERNAL_CALL, MultiFarmingPod._transferReward(IERC20,address,uint256)(rewardsToken_1,account_1,amount_1)
	Function MultiFarmingPod._transferReward(IERC20,address,uint256)
		IRs:
			reward_1(IERC20) := ϕ(['rewardsToken_1'])
			to_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: reward.safeTransfer(to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['reward_1', 'to_1', 'amount_1'] 
	Function MultiFarmingPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_5', '_totalSupply_3'])
			_rewardsTokens_8(AddressSet.Data) := ϕ(['_rewardsTokens_5', '_rewardsTokens_8', '_rewardsTokens_7', '_rewardsTokens_3', '_rewardsTokens_1', '_rewardsTokens_0'])
		Expression: tokens = _rewardsTokens.items.get()
		IRs:
			REF_269(AddressArray.Data) -> _rewardsTokens_8.items
			TMP_1050(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_269'] 
			tokens_1(address[]) = ['TMP_1050(address[])']
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < tokens.length
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			REF_271 -> LENGTH tokens_1
			TMP_1051(bool) = i_2 < REF_271
			CONDITION TMP_1051
		Expression: _makeInfo(IERC20(tokens[i])).updateBalances(from,to,amount)
		IRs:
			REF_272(address) -> tokens_1[i_2]
			TMP_1052 = CONVERT REF_272 to IERC20
			TMP_1053(FarmingLib.Info) = INTERNAL_CALL, MultiFarmingPod._makeInfo(IERC20)(TMP_1052)
			LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.updateBalances(FarmingLib.Info,address,address,uint256), arguments:['TMP_1053', 'from_1', 'to_1', 'amount_1'] 
		Expression: i ++
		IRs:
			TMP_1055(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		Expression: from == address(0)
		IRs:
			TMP_1056 = CONVERT 0 to address
			TMP_1057(bool) = from_1 == TMP_1056
			CONDITION TMP_1057
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_2 (c)+ amount_1
		Expression: to == address(0)
		IRs:
			TMP_1058 = CONVERT 0 to address
			TMP_1059(bool) = to_1 == TMP_1058
			CONDITION TMP_1059
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_5(uint256) = _totalSupply_4 (c)- amount_1
	Function MultiFarmingPod.rescueFunds(IERC20,uint256)
		IRs:
			_distributor_5(address) := ϕ(['_distributor_4', '_distributor_6', '_distributor_0'])
		Expression: token == IERC20(address(0))
		IRs:
			TMP_1060 = CONVERT 0 to address
			TMP_1061 = CONVERT TMP_1060 to IERC20
			TMP_1062(bool) = token_1 == TMP_1061
			CONDITION TMP_1062
		Expression: address(_distributor).sendValue(amount)
		IRs:
			TMP_1063 = CONVERT _distributor_6 to address
			LIBRARY_CALL, dest:Address, function:Address.sendValue(address,uint256), arguments:['TMP_1063', 'amount_1'] 
		Expression: token.safeTransfer(_distributor,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['token_1', '_distributor_6', 'amount_1'] 
		Expression: onlyDistributor()
		IRs:
			MODIFIER_CALL, MultiFarmingPod.onlyDistributor()()
	Function MultiFarmingPod._makeInfo(IERC20)
		IRs:
			rewardsToken_1(IERC20) := ϕ(['rewardsToken_1', 'rewardsToken_1', 'rewardsToken_1', 'TMP_1052'])
			_farms_2(mapping(IERC20 => FarmingLib.Data)) := ϕ(['_farms_2', '_farms_0', '_farms_1'])
		Expression: FarmingLib.makeInfo(totalSupply,_farms[rewardsToken])
		IRs:
			REF_277(FarmingLib.Data) -> _farms_2[rewardsToken_1]
			TMP_1067(FarmingLib.Info) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.makeInfo(function() returns(uint256),FarmingLib.Data), arguments:['totalSupply', 'REF_277'] 
			RETURN TMP_1067
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_10(IERC20Pods) := ϕ(['token_0', 'token_1', 'token_5', 'token_3', 'token_9', 'token_7'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_1069 = CONVERT token_10 to address
			TMP_1070(bool) = msg.sender != TMP_1069
			CONDITION TMP_1070
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_1071(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
	Modifier MultiFarmingPod.onlyDistributor()
ENTRY_POINT
		IRs:
			_distributor_7(address) := ϕ(['_distributor_4', '_distributor_6', '_distributor_0'])
IF msg.sender != _distributor
		Expression: msg.sender != _distributor
		IRs:
			TMP_1072(bool) = msg.sender != _distributor_7
			CONDITION TMP_1072
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_1073(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract FarmAccounting
	Function FarmAccounting.farmedSinceCheckpointScaled(FarmAccounting.Info,uint256)
		IRs:
			info_1(FarmAccounting.Info) := ϕ(['prev_1'])
			checkpoint_1(uint256) := ϕ(['TMP_1090'])
			_SCALE_1(uint256) := ϕ(['_SCALE_3', '_SCALE_0'])
		Expression: info.duration > 0
		IRs:
			REF_278(uint32) -> info_1.duration
			TMP_1074(bool) = REF_278 > 0
			CONDITION TMP_1074
		Expression: elapsed = Math.min(block.timestamp,info.finished) - Math.min(checkpoint,info.finished)
		IRs:
			REF_280(uint40) -> info_1.finished
			TMP_1075(uint256) = LIBRARY_CALL, dest:Math, function:Math.min(uint256,uint256), arguments:['block.timestamp', 'REF_280'] 
			REF_282(uint40) -> info_1.finished
			TMP_1076(uint256) = LIBRARY_CALL, dest:Math, function:Math.min(uint256,uint256), arguments:['checkpoint_1', 'REF_282'] 
			TMP_1077(uint256) = TMP_1075 - TMP_1076
			elapsed_1(uint256) := TMP_1077(uint256)
		Expression: elapsed * info.reward * _SCALE / info.duration
		IRs:
			REF_283(uint184) -> info_1.reward
			TMP_1078(uint256) = elapsed_1 * REF_283
			TMP_1079(uint256) = TMP_1078 * _SCALE_1
			REF_284(uint32) -> info_1.duration
			TMP_1080(uint256) = TMP_1079 / REF_284
			RETURN TMP_1080
		Expression: amount
		IRs:
			RETURN amount_0
	Function FarmAccounting.startFarming(FarmAccounting.Info,uint256,uint256)
		IRs:
			_MAX_REWARD_AMOUNT_1(uint256) := ϕ(['_MAX_REWARD_AMOUNT_0'])
			_SCALE_2(uint256) := ϕ(['_SCALE_3', '_SCALE_0'])
		Expression: period == 0
		IRs:
			TMP_1081(bool) = period_1 == 0
			CONDITION TMP_1081
		Expression: revert ZeroDuration()()
		IRs:
			TMP_1082(None) = SOLIDITY_CALL revert ZeroDuration()()
		Expression: period > type()(uint32).max
		IRs:
			TMP_1084(uint32) := 4294967295(uint32)
			TMP_1085(bool) = period_1 > TMP_1084
			CONDITION TMP_1085
		Expression: revert DurationTooLarge()()
		IRs:
			TMP_1086(None) = SOLIDITY_CALL revert DurationTooLarge()()
		Expression: amount > _MAX_REWARD_AMOUNT
		IRs:
			TMP_1087(bool) = amount_1 > _MAX_REWARD_AMOUNT_1
			CONDITION TMP_1087
		Expression: revert AmountTooLarge()()
		IRs:
			TMP_1088(None) = SOLIDITY_CALL revert AmountTooLarge()()
		Expression: prev = info
		IRs:
			prev_1(FarmAccounting.Info) := info_1 (-> [])(FarmAccounting.Info)
		Expression: block.timestamp < prev.finished
		IRs:
			REF_285(uint40) -> prev_1.finished
			TMP_1089(bool) = block.timestamp < REF_285
			CONDITION TMP_1089
		Expression: amount += prev.reward - farmedSinceCheckpointScaled(prev,prev.finished - prev.duration) / _SCALE
		IRs:
			REF_286(uint184) -> prev_1.reward
			REF_287(uint40) -> prev_1.finished
			REF_288(uint32) -> prev_1.duration
			TMP_1090(uint40) = REF_287 (c)- REF_288
			TMP_1091(uint256) = INTERNAL_CALL, FarmAccounting.farmedSinceCheckpointScaled(FarmAccounting.Info,uint256)(prev_1,TMP_1090)
			TMP_1092(uint256) = TMP_1091 (c)/ _SCALE_3
			TMP_1093(uint184) = REF_286 (c)- TMP_1092
			amount_2(uint256) = amount_1 (c)+ TMP_1093
		IRs:
			amount_3(uint256) := ϕ(['amount_2', 'amount_1'])
		Expression: (info.finished,info.duration,info.reward) = (uint40(block.timestamp + period),uint32(period),uint184(amount))
		IRs:
			REF_289(uint40) -> info_1 (-> []).finished
			REF_290(uint32) -> info_1 (-> []).duration
			REF_291(uint184) -> info_1 (-> []).reward
			TMP_1094(uint256) = block.timestamp (c)+ period_1
			TMP_1095 = CONVERT TMP_1094 to uint40
			TMP_1096 = CONVERT period_1 to uint32
			TMP_1097 = CONVERT amount_3 to uint184
			info_2 (-> [])(FarmAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_289(uint40) (->info_2 (-> [])) := TMP_1095(uint40)
			info_3 (-> [])(FarmAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_290(uint32) (->info_3 (-> [])) := TMP_1096(uint32)
			info_4 (-> [])(FarmAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_291(uint184) (->info_4 (-> [])) := TMP_1097(uint184)
		Expression: amount
		IRs:
			RETURN amount_3
	Function FarmAccounting.slitherConstructorConstantVariables()
		Expression: _MAX_REWARD_AMOUNT = 1e32
		Expression: _SCALE = 1e18
Contract UserAccounting
	Function UserAccounting.farmedPerToken(UserAccounting.Info,bytes32,function(bytes32) returns(uint256),function(bytes32,uint256) returns(uint256))
		Expression: checkpoint = info.checkpoint
		IRs:
			REF_292(uint40) -> info_1 (-> []).checkpoint
			checkpoint_1(uint256) := REF_292(uint40)
		Expression: fpt = info.farmedPerTokenStored
		IRs:
			REF_293(uint216) -> info_1 (-> []).farmedPerTokenStored
			fpt_1(uint256) := REF_293(uint216)
		Expression: block.timestamp != checkpoint
		IRs:
			TMP_1098(bool) = block.timestamp != checkpoint_1
			CONDITION TMP_1098
		Expression: supply = lazyGetSupply(context)
		IRs:
			TMP_1099(uint256) = INTERNAL_DYNAMIC_CALL lazyGetSupply(context_1)  
			supply_1(uint256) := TMP_1099(uint256)
		Expression: supply > 0
		IRs:
			TMP_1100(bool) = supply_1 > 0
			CONDITION TMP_1100
		Expression: fpt += lazyGetFarmed(context,checkpoint) / supply
		IRs:
			TMP_1101(uint256) = INTERNAL_DYNAMIC_CALL lazyGetFarmed(context_1,checkpoint_1)  
			TMP_1102(uint256) = TMP_1101 / supply_1
			fpt_2(uint256) = fpt_1 + TMP_1102
		IRs:
			fpt_3(uint256) := ϕ(['fpt_2', 'fpt_1'])
		Expression: fpt
		IRs:
			RETURN fpt_3
	Function UserAccounting.farmed(UserAccounting.Info,address,uint256,uint256)
		Expression: uint256(int256(balance * fpt) - info.corrections[account]) / FarmAccounting._SCALE
		IRs:
			TMP_1103(uint256) = balance_1 (c)* fpt_1
			TMP_1104 = CONVERT TMP_1103 to int256
			REF_294(mapping(address => int256)) -> info_1 (-> []).corrections
			REF_295(int256) -> REF_294[account_1]
			TMP_1105(int256) = TMP_1104 (c)- REF_295
			TMP_1106 = CONVERT TMP_1105 to uint256
			REF_296(uint256) -> FarmAccounting._SCALE
			TMP_1107(uint256) = TMP_1106 (c)/ REF_296
			RETURN TMP_1107
	Function UserAccounting.eraseFarmed(UserAccounting.Info,address,uint256,uint256)
		Expression: info.corrections[account] = int256(balance * fpt)
		IRs:
			REF_297(mapping(address => int256)) -> info_1 (-> []).corrections
			REF_298(int256) -> REF_297[account_1]
			TMP_1108(uint256) = balance_1 (c)* fpt_1
			TMP_1109 = CONVERT TMP_1108 to int256
			info_2 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_298(int256) (->info_2 (-> [])) := TMP_1109(int256)
	Function UserAccounting.updateFarmedPerToken(UserAccounting.Info,uint256)
		IRs:
			info_1 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			fpt_1(uint256) := ϕ(['fpt_1'])
		Expression: (info.checkpoint,info.farmedPerTokenStored) = (uint40(block.timestamp),uint216(fpt))
		IRs:
			REF_299(uint40) -> info_1 (-> []).checkpoint
			REF_300(uint216) -> info_1 (-> []).farmedPerTokenStored
			TMP_1110 = CONVERT block.timestamp to uint40
			TMP_1111 = CONVERT fpt_1 to uint216
			info_2 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_299(uint40) (->info_2 (-> [])) := TMP_1110(uint40)
			info_3 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_300(uint216) (->info_3 (-> [])) := TMP_1111(uint216)
	Function UserAccounting.updateBalances(UserAccounting.Info,address,address,uint256,uint256)
		Expression: fromZero = (from == address(0))
		IRs:
			TMP_1112 = CONVERT 0 to address
			TMP_1113(bool) = from_1 == TMP_1112
			fromZero_1(bool) := TMP_1113(bool)
		Expression: toZero = (to == address(0))
		IRs:
			TMP_1114 = CONVERT 0 to address
			TMP_1115(bool) = to_1 == TMP_1114
			toZero_1(bool) := TMP_1115(bool)
		Expression: amount > 0 && from != to
		IRs:
			TMP_1116(bool) = amount_1 > 0
			TMP_1117(bool) = from_1 != to_1
			TMP_1118(bool) = TMP_1116 && TMP_1117
			CONDITION TMP_1118
		Expression: fromZero || toZero
		IRs:
			TMP_1119(bool) = fromZero_1 || toZero_1
			CONDITION TMP_1119
		Expression: updateFarmedPerToken(info,fpt)
		IRs:
			INTERNAL_CALL, UserAccounting.updateFarmedPerToken(UserAccounting.Info,uint256)(info_1 (-> []),fpt_1)
		Expression: diff = int256(amount * fpt)
		IRs:
			TMP_1121(uint256) = amount_1 (c)* fpt_1
			TMP_1122 = CONVERT TMP_1121 to int256
			diff_1(int256) := TMP_1122(int256)
		Expression: ! fromZero
		IRs:
			TMP_1123 = UnaryType.BANG fromZero_1 
			CONDITION TMP_1123
		Expression: info.corrections[from] -= diff
		IRs:
			REF_301(mapping(address => int256)) -> info_1 (-> []).corrections
			REF_302(int256) -> REF_301[from_1]
			info_2 (-> [])(UserAccounting.Info) := ϕ(['info_1 (-> [])'])
			REF_302(-> info_2 (-> [])) = REF_302 (c)- diff_1
		IRs:
			info_3 (-> [])(UserAccounting.Info) := ϕ(['info_2 (-> [])', 'info_1 (-> [])'])
		Expression: ! toZero
		IRs:
			TMP_1124 = UnaryType.BANG toZero_1 
			CONDITION TMP_1124
		Expression: info.corrections[to] += diff
		IRs:
			REF_303(mapping(address => int256)) -> info_3 (-> []).corrections
			REF_304(int256) -> REF_303[to_1]
			info_4 (-> [])(UserAccounting.Info) := ϕ(['info_3 (-> [])'])
			REF_304(-> info_4 (-> [])) = REF_304 (c)+ diff_1
Contract IFarmingPod
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IFarmingPod.totalSupply()
	Function IFarmingPod.distributor()
	Function IFarmingPod.farmInfo()
	Function IFarmingPod.farmed(address)
	Function IFarmingPod.claim()
	Function IFarmingPod.setDistributor(address)
	Function IFarmingPod.startFarming(uint256,uint256)
	Function IFarmingPod.rescueFunds(IERC20,uint256)
Contract IMultiFarmingPod
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IMultiFarmingPod.totalSupply()
	Function IMultiFarmingPod.distributor()
	Function IMultiFarmingPod.farmInfo(IERC20)
	Function IMultiFarmingPod.farmed(IERC20,address)
	Function IMultiFarmingPod.claim(IERC20)
	Function IMultiFarmingPod.claim()
	Function IMultiFarmingPod.setDistributor(address)
	Function IMultiFarmingPod.startFarming(IERC20,uint256,uint256)
	Function IMultiFarmingPod.rescueFunds(IERC20,uint256)
Contract LimitOrderProtocol
	Function OrderRFQMixin.constructor(IWETH)
		Expression: _WETH = weth
		IRs:
			_WETH_1(IWETH) := weth_1(IWETH)
		Expression: OnlyWethReceiver(address(weth))
		IRs:
			TMP_1125 = CONVERT weth_1 to address
			INTERNAL_CALL, OnlyWethReceiver.constructor(address)(TMP_1125)
	Function OrderRFQMixin.invalidatorForOrderRFQ(address,uint256)
		IRs:
			_invalidator_1(mapping(address => mapping(uint256 => uint256))) := ϕ(['_invalidator_0', '_invalidator_1', '_invalidator_3'])
		Expression: _invalidator[maker][slot]
		IRs:
			REF_305(mapping(uint256 => uint256)) -> _invalidator_1[maker_1]
			REF_306(uint256) -> REF_305[slot_1]
			RETURN REF_306
	Function OrderRFQMixin.cancelOrderRFQ(uint256)
		Expression: _invalidateOrder(msg.sender,orderInfo,0)
		IRs:
			INTERNAL_CALL, OrderRFQMixin._invalidateOrder(address,uint256,uint256)(msg.sender,orderInfo_1,0)
	Function OrderRFQMixin.cancelOrderRFQ(uint256,uint256)
		Expression: _invalidateOrder(msg.sender,orderInfo,additionalMask)
		IRs:
			INTERNAL_CALL, OrderRFQMixin._invalidateOrder(address,uint256,uint256)(msg.sender,orderInfo_1,additionalMask_1)
	Function OrderRFQMixin.fillOrderRFQ(OrderRFQLib.OrderRFQ,bytes,uint256)
		Expression: fillOrderRFQTo(order,signature,flagsAndAmount,msg.sender)
		IRs:
			TUPLE_0(uint256,uint256,bytes32) = INTERNAL_CALL, OrderRFQMixin.fillOrderRFQTo(OrderRFQLib.OrderRFQ,bytes,uint256,address)(order_1,signature_1,flagsAndAmount_1,msg.sender)
			RETURN TUPLE_0
	Function OrderRFQMixin.fillOrderRFQCompact(OrderRFQLib.OrderRFQ,bytes32,bytes32,uint256)
		IRs:
			_SIGNER_SMART_CONTRACT_HINT_1(uint256) := ϕ(['_SIGNER_SMART_CONTRACT_HINT_2', '_SIGNER_SMART_CONTRACT_HINT_0', '_SIGNER_SMART_CONTRACT_HINT_4'])
			_IS_VALID_SIGNATURE_65_BYTES_1(uint256) := ϕ(['_IS_VALID_SIGNATURE_65_BYTES_4', '_IS_VALID_SIGNATURE_65_BYTES_0', '_IS_VALID_SIGNATURE_65_BYTES_2'])
		Expression: orderHash = order.hash(_domainSeparatorV4())
		IRs:
			TMP_1129(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1130(bytes32) = LIBRARY_CALL, dest:OrderRFQLib, function:OrderRFQLib.hash(OrderRFQLib.OrderRFQ,bytes32), arguments:['order_1', 'TMP_1129'] 
			orderHash_1(bytes32) := TMP_1130(bytes32)
		Expression: flagsAndAmount & _SIGNER_SMART_CONTRACT_HINT != 0
		IRs:
			TMP_1131(uint256) = flagsAndAmount_1 & _SIGNER_SMART_CONTRACT_HINT_2
			TMP_1132(bool) = TMP_1131 != 0
			CONDITION TMP_1132
		Expression: flagsAndAmount & _IS_VALID_SIGNATURE_65_BYTES != 0
		IRs:
			TMP_1133(uint256) = flagsAndAmount_1 & _IS_VALID_SIGNATURE_65_BYTES_2
			TMP_1134(bool) = TMP_1133 != 0
			CONDITION TMP_1134
		Expression: ! ECDSA.isValidSignature65(order.maker,orderHash,r,vs)
		IRs:
			REF_309(address) -> order_1.maker
			TMP_1135(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.isValidSignature65(address,bytes32,bytes32,bytes32), arguments:['REF_309', 'orderHash_1', 'r_1', 'vs_1'] 
			TMP_1136 = UnaryType.BANG TMP_1135 
			CONDITION TMP_1136
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1137(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: ! ECDSA.isValidSignature(order.maker,orderHash,r,vs)
		IRs:
			REF_311(address) -> order_1.maker
			TMP_1138(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.isValidSignature(address,bytes32,bytes32,bytes32), arguments:['REF_311', 'orderHash_1', 'r_1', 'vs_1'] 
			TMP_1139 = UnaryType.BANG TMP_1138 
			CONDITION TMP_1139
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1140(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: ! ECDSA.recoverOrIsValidSignature(order.maker,orderHash,r,vs)
		IRs:
			REF_313(address) -> order_1.maker
			TMP_1141(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recoverOrIsValidSignature(address,bytes32,bytes32,bytes32), arguments:['REF_313', 'orderHash_1', 'r_1', 'vs_1'] 
			TMP_1142 = UnaryType.BANG TMP_1141 
			CONDITION TMP_1142
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1143(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: (filledMakingAmount,filledTakingAmount) = _fillOrderRFQTo(order,flagsAndAmount,msg.sender)
		IRs:
			TUPLE_1(uint256,uint256) = INTERNAL_CALL, OrderRFQMixin._fillOrderRFQTo(OrderRFQLib.OrderRFQ,uint256,address)(order_1,flagsAndAmount_1,msg.sender)
			filledMakingAmount_1(uint256)= UNPACK TUPLE_1 index: 0 
			filledTakingAmount_1(uint256)= UNPACK TUPLE_1 index: 1 
		Expression: OrderFilledRFQ(orderHash,filledMakingAmount)
		IRs:
			Emit OrderFilledRFQ(orderHash_1,filledMakingAmount_1)
		Expression: (filledMakingAmount,filledTakingAmount,orderHash)
		IRs:
			RETURN filledMakingAmount_1,filledTakingAmount_1,orderHash_1
	Function OrderRFQMixin.fillOrderRFQToWithPermit(OrderRFQLib.OrderRFQ,bytes,uint256,address,bytes)
		Expression: IERC20(order.takerAsset).safePermit(permit)
		IRs:
			REF_314(address) -> order_1.takerAsset
			TMP_1145 = CONVERT REF_314 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['TMP_1145', 'permit_1'] 
		Expression: fillOrderRFQTo(order,signature,flagsAndAmount,target)
		IRs:
			TUPLE_2(uint256,uint256,bytes32) = INTERNAL_CALL, OrderRFQMixin.fillOrderRFQTo(OrderRFQLib.OrderRFQ,bytes,uint256,address)(order_1,signature_1,flagsAndAmount_1,target_1)
			RETURN TUPLE_2
	Function OrderRFQMixin.fillOrderRFQTo(OrderRFQLib.OrderRFQ,bytes,uint256,address)
		IRs:
			order_1(OrderRFQLib.OrderRFQ) := ϕ(['order_1', 'order_1'])
			signature_1(bytes) := ϕ(['signature_1', 'signature_1'])
			flagsAndAmount_1(uint256) := ϕ(['flagsAndAmount_1', 'flagsAndAmount_1'])
			target_1(address) := ϕ(['target_1', 'msg.sender'])
			_SIGNER_SMART_CONTRACT_HINT_3(uint256) := ϕ(['_SIGNER_SMART_CONTRACT_HINT_2', '_SIGNER_SMART_CONTRACT_HINT_0', '_SIGNER_SMART_CONTRACT_HINT_4'])
			_IS_VALID_SIGNATURE_65_BYTES_3(uint256) := ϕ(['_IS_VALID_SIGNATURE_65_BYTES_4', '_IS_VALID_SIGNATURE_65_BYTES_0', '_IS_VALID_SIGNATURE_65_BYTES_2'])
		Expression: orderHash = order.hash(_domainSeparatorV4())
		IRs:
			TMP_1147(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1148(bytes32) = LIBRARY_CALL, dest:OrderRFQLib, function:OrderRFQLib.hash(OrderRFQLib.OrderRFQ,bytes32), arguments:['order_1', 'TMP_1147'] 
			orderHash_1(bytes32) := TMP_1148(bytes32)
		Expression: flagsAndAmount & _SIGNER_SMART_CONTRACT_HINT != 0
		IRs:
			TMP_1149(uint256) = flagsAndAmount_1 & _SIGNER_SMART_CONTRACT_HINT_4
			TMP_1150(bool) = TMP_1149 != 0
			CONDITION TMP_1150
		Expression: flagsAndAmount & _IS_VALID_SIGNATURE_65_BYTES != 0 && signature.length != 65
		IRs:
			TMP_1151(uint256) = flagsAndAmount_1 & _IS_VALID_SIGNATURE_65_BYTES_4
			TMP_1152(bool) = TMP_1151 != 0
			REF_317 -> LENGTH signature_1
			TMP_1153(bool) = REF_317 != 65
			TMP_1154(bool) = TMP_1152 && TMP_1153
			CONDITION TMP_1154
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1155(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: ! ECDSA.isValidSignature(order.maker,orderHash,signature)
		IRs:
			REF_319(address) -> order_1.maker
			TMP_1156(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.isValidSignature(address,bytes32,bytes), arguments:['REF_319', 'orderHash_1', 'signature_1'] 
			TMP_1157 = UnaryType.BANG TMP_1156 
			CONDITION TMP_1157
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1158(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: ! ECDSA.recoverOrIsValidSignature(order.maker,orderHash,signature)
		IRs:
			REF_321(address) -> order_1.maker
			TMP_1159(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recoverOrIsValidSignature(address,bytes32,bytes), arguments:['REF_321', 'orderHash_1', 'signature_1'] 
			TMP_1160 = UnaryType.BANG TMP_1159 
			CONDITION TMP_1160
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1161(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: (filledMakingAmount,filledTakingAmount) = _fillOrderRFQTo(order,flagsAndAmount,target)
		IRs:
			TUPLE_3(uint256,uint256) = INTERNAL_CALL, OrderRFQMixin._fillOrderRFQTo(OrderRFQLib.OrderRFQ,uint256,address)(order_1,flagsAndAmount_1,target_1)
			filledMakingAmount_1(uint256)= UNPACK TUPLE_3 index: 0 
			filledTakingAmount_1(uint256)= UNPACK TUPLE_3 index: 1 
		Expression: OrderFilledRFQ(orderHash,filledMakingAmount)
		IRs:
			Emit OrderFilledRFQ(orderHash_1,filledMakingAmount_1)
		Expression: (filledMakingAmount,filledTakingAmount,orderHash)
		IRs:
			RETURN filledMakingAmount_1,filledTakingAmount_1,orderHash_1
	Function OrderRFQMixin._fillOrderRFQTo(OrderRFQLib.OrderRFQ,uint256,address)
		IRs:
			order_1(OrderRFQLib.OrderRFQ) := ϕ(['order_1', 'order_1'])
			flagsAndAmount_1(uint256) := ϕ(['flagsAndAmount_1', 'flagsAndAmount_1'])
			target_1(address) := ϕ(['target_1', 'msg.sender'])
			_RAW_CALL_GAS_LIMIT_1(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_2', '_RAW_CALL_GAS_LIMIT_0', '_RAW_CALL_GAS_LIMIT_5'])
			_MAKER_AMOUNT_FLAG_1(uint256) := ϕ(['_MAKER_AMOUNT_FLAG_0', '_MAKER_AMOUNT_FLAG_2'])
			_UNWRAP_WETH_FLAG_1(uint256) := ϕ(['_UNWRAP_WETH_FLAG_0', '_UNWRAP_WETH_FLAG_2'])
			_AMOUNT_MASK_1(uint256) := ϕ(['_AMOUNT_MASK_0', '_AMOUNT_MASK_2'])
			_WETH_2(IWETH) := ϕ(['_WETH_3', '_WETH_6', '_WETH_1', '_WETH_0', '_WETH_8'])
		Expression: target == address(0)
		IRs:
			TMP_1163 = CONVERT 0 to address
			TMP_1164(bool) = target_1 == TMP_1163
			CONDITION TMP_1164
		Expression: revert RFQZeroTargetIsForbidden()()
		IRs:
			TMP_1165(None) = SOLIDITY_CALL revert RFQZeroTargetIsForbidden()()
		Expression: maker = order.maker
		IRs:
			REF_322(address) -> order_1.maker
			maker_1(address) := REF_322(address)
		Expression: order.allowedSender != address(0) && order.allowedSender != msg.sender
		IRs:
			REF_323(address) -> order_1.allowedSender
			TMP_1166 = CONVERT 0 to address
			TMP_1167(bool) = REF_323 != TMP_1166
			REF_324(address) -> order_1.allowedSender
			TMP_1168(bool) = REF_324 != msg.sender
			TMP_1169(bool) = TMP_1167 && TMP_1168
			CONDITION TMP_1169
		Expression: revert RFQPrivateOrder()()
		IRs:
			TMP_1170(None) = SOLIDITY_CALL revert RFQPrivateOrder()()
		Expression: info = order.info
		IRs:
			REF_325(uint256) -> order_1.info
			info_1(uint256) := REF_325(uint256)
		Expression: expiration = uint128(info) >> 64
		IRs:
			TMP_1171 = CONVERT info_1 to uint128
			TMP_1172(uint128) = TMP_1171 >> 64
			expiration_1(uint256) := TMP_1172(uint128)
		Expression: expiration != 0 && block.timestamp > expiration
		IRs:
			TMP_1173(bool) = expiration_1 != 0
			TMP_1174(bool) = block.timestamp > expiration_1
			TMP_1175(bool) = TMP_1173 && TMP_1174
			CONDITION TMP_1175
		Expression: revert OrderExpired()()
		IRs:
			TMP_1176(None) = SOLIDITY_CALL revert OrderExpired()()
		Expression: _invalidateOrder(maker,info,0)
		IRs:
			INTERNAL_CALL, OrderRFQMixin._invalidateOrder(address,uint256,uint256)(maker_1,info_1,0)
		Expression: orderMakingAmount = order.makingAmount
		IRs:
			REF_326(uint256) -> order_1.makingAmount
			orderMakingAmount_1(uint256) := REF_326(uint256)
		Expression: orderTakingAmount = order.takingAmount
		IRs:
			REF_327(uint256) -> order_1.takingAmount
			orderTakingAmount_1(uint256) := REF_327(uint256)
		Expression: amount = flagsAndAmount & _AMOUNT_MASK
		IRs:
			TMP_1178(uint256) = flagsAndAmount_1 & _AMOUNT_MASK_2
			amount_1(uint256) := TMP_1178(uint256)
		Expression: amount == 0
		IRs:
			TMP_1179(bool) = amount_1 == 0
			CONDITION TMP_1179
		Expression: makingAmount = orderMakingAmount
		IRs:
			makingAmount_4(uint256) := orderMakingAmount_1(uint256)
		Expression: takingAmount = orderTakingAmount
		IRs:
			takingAmount_4(uint256) := orderTakingAmount_1(uint256)
		Expression: flagsAndAmount & _MAKER_AMOUNT_FLAG != 0
		IRs:
			TMP_1180(uint256) = flagsAndAmount_1 & _MAKER_AMOUNT_FLAG_2
			TMP_1181(bool) = TMP_1180 != 0
			CONDITION TMP_1181
		Expression: amount > orderMakingAmount
		IRs:
			TMP_1182(bool) = amount_1 > orderMakingAmount_1
			CONDITION TMP_1182
		Expression: revert MakingAmountExceeded()()
		IRs:
			TMP_1183(None) = SOLIDITY_CALL revert MakingAmountExceeded()()
		Expression: makingAmount = amount
		IRs:
			makingAmount_1(uint256) := amount_1(uint256)
		Expression: takingAmount = AmountCalculator.getTakingAmount(orderMakingAmount,orderTakingAmount,makingAmount)
		IRs:
			TMP_1184(uint256) = LIBRARY_CALL, dest:AmountCalculator, function:AmountCalculator.getTakingAmount(uint256,uint256,uint256), arguments:['orderMakingAmount_1', 'orderTakingAmount_1', 'makingAmount_1'] 
			takingAmount_1(uint256) := TMP_1184(uint256)
		Expression: amount > orderTakingAmount
		IRs:
			TMP_1185(bool) = amount_1 > orderTakingAmount_1
			CONDITION TMP_1185
		Expression: revert TakingAmountExceeded()()
		IRs:
			TMP_1186(None) = SOLIDITY_CALL revert TakingAmountExceeded()()
		Expression: takingAmount = amount
		IRs:
			takingAmount_2(uint256) := amount_1(uint256)
		Expression: makingAmount = AmountCalculator.getMakingAmount(orderMakingAmount,orderTakingAmount,takingAmount)
		IRs:
			TMP_1187(uint256) = LIBRARY_CALL, dest:AmountCalculator, function:AmountCalculator.getMakingAmount(uint256,uint256,uint256), arguments:['orderMakingAmount_1', 'orderTakingAmount_1', 'takingAmount_2'] 
			makingAmount_2(uint256) := TMP_1187(uint256)
		IRs:
			makingAmount_3(uint256) := ϕ(['makingAmount_2', 'makingAmount_1', 'makingAmount_0'])
			takingAmount_3(uint256) := ϕ(['takingAmount_1', 'takingAmount_0', 'takingAmount_2'])
		IRs:
			makingAmount_5(uint256) := ϕ(['makingAmount_0', 'makingAmount_4'])
			takingAmount_5(uint256) := ϕ(['takingAmount_4', 'takingAmount_0'])
		Expression: makingAmount == 0 || takingAmount == 0
		IRs:
			TMP_1188(bool) = makingAmount_5 == 0
			TMP_1189(bool) = takingAmount_5 == 0
			TMP_1190(bool) = TMP_1188 || TMP_1189
			CONDITION TMP_1190
		Expression: revert RFQSwapWithZeroAmount()()
		IRs:
			TMP_1191(None) = SOLIDITY_CALL revert RFQSwapWithZeroAmount()()
		Expression: order.makerAsset == address(_WETH) && flagsAndAmount & _UNWRAP_WETH_FLAG != 0
		IRs:
			REF_330(address) -> order_1.makerAsset
			TMP_1192 = CONVERT _WETH_3 to address
			TMP_1193(bool) = REF_330 == TMP_1192
			TMP_1194(uint256) = flagsAndAmount_1 & _UNWRAP_WETH_FLAG_2
			TMP_1195(bool) = TMP_1194 != 0
			TMP_1196(bool) = TMP_1193 && TMP_1195
			CONDITION TMP_1196
		Expression: _WETH.transferFrom(maker,address(this),makingAmount)
		IRs:
			TMP_1197 = CONVERT this to address
			TMP_1198(bool) = HIGH_LEVEL_CALL, dest:_WETH_3(IWETH), function:transferFrom, arguments:['maker_1', 'TMP_1197', 'makingAmount_5']  
			_RAW_CALL_GAS_LIMIT_3(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_2', '_RAW_CALL_GAS_LIMIT_5'])
			_WETH_4(IWETH) := ϕ(['_WETH_1', '_WETH_8', '_WETH_3', '_WETH_6'])
		Expression: _WETH.withdraw(makingAmount)
		IRs:
			HIGH_LEVEL_CALL, dest:_WETH_4(IWETH), function:withdraw, arguments:['makingAmount_5']  
			_RAW_CALL_GAS_LIMIT_4(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_2', '_RAW_CALL_GAS_LIMIT_3', '_RAW_CALL_GAS_LIMIT_5'])
			_WETH_5(IWETH) := ϕ(['_WETH_3', '_WETH_6', '_WETH_4', '_WETH_1', '_WETH_8'])
		Expression: (success,None) = target.call{gas: _RAW_CALL_GAS_LIMIT,value: makingAmount}()
		IRs:
			TUPLE_4(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:call, arguments:[''] value:makingAmount_5 gas:_RAW_CALL_GAS_LIMIT_4
			_RAW_CALL_GAS_LIMIT_5(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_2', '_RAW_CALL_GAS_LIMIT_4', '_RAW_CALL_GAS_LIMIT_5'])
			_WETH_6(IWETH) := ϕ(['_WETH_3', '_WETH_6', '_WETH_5', '_WETH_1', '_WETH_8'])
			success_1(bool)= UNPACK TUPLE_4 index: 0 
		Expression: ! success
		IRs:
			TMP_1200 = UnaryType.BANG success_1 
			CONDITION TMP_1200
		Expression: Errors.ETHTransferFailed()
		IRs:
			TMP_1201(None) = SOLIDITY_CALL revert ETHTransferFailed()()
		Expression: IERC20(order.makerAsset).safeTransferFrom(maker,target,makingAmount)
		IRs:
			REF_334(address) -> order_1.makerAsset
			TMP_1202 = CONVERT REF_334 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_1202', 'maker_1', 'target_1', 'makingAmount_5'] 
		Expression: order.takerAsset == address(_WETH) && msg.value > 0
		IRs:
			REF_336(address) -> order_1.takerAsset
			TMP_1204 = CONVERT _WETH_6 to address
			TMP_1205(bool) = REF_336 == TMP_1204
			TMP_1206(bool) = msg.value > 0
			TMP_1207(bool) = TMP_1205 && TMP_1206
			CONDITION TMP_1207
		Expression: msg.value != takingAmount
		IRs:
			TMP_1208(bool) = msg.value != takingAmount_5
			CONDITION TMP_1208
		Expression: Errors.InvalidMsgValue()
		IRs:
			TMP_1209(None) = SOLIDITY_CALL revert InvalidMsgValue()()
		Expression: _WETH.deposit{value: takingAmount}()
		IRs:
			HIGH_LEVEL_CALL, dest:_WETH_6(IWETH), function:deposit, arguments:[] value:takingAmount_5 
			_WETH_7(IWETH) := ϕ(['_WETH_1', '_WETH_8', '_WETH_3', '_WETH_6'])
		Expression: _WETH.transfer(maker,takingAmount)
		IRs:
			TMP_1211(bool) = HIGH_LEVEL_CALL, dest:_WETH_7(IWETH), function:transfer, arguments:['maker_1', 'takingAmount_5']  
			_WETH_8(IWETH) := ϕ(['_WETH_7', '_WETH_3', '_WETH_6', '_WETH_1', '_WETH_8'])
		Expression: msg.value != 0
		IRs:
			TMP_1212(bool) = msg.value != 0
			CONDITION TMP_1212
		Expression: Errors.InvalidMsgValue()
		IRs:
			TMP_1213(None) = SOLIDITY_CALL revert InvalidMsgValue()()
		Expression: IERC20(order.takerAsset).safeTransferFrom(msg.sender,maker,takingAmount)
		IRs:
			REF_339(address) -> order_1.takerAsset
			TMP_1214 = CONVERT REF_339 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_1214', 'msg.sender', 'maker_1', 'takingAmount_5'] 
		Expression: (makingAmount,takingAmount)
		IRs:
			RETURN makingAmount_5,takingAmount_5
	Function OrderRFQMixin._invalidateOrder(address,uint256,uint256)
		IRs:
			maker_1(address) := ϕ(['maker_1', 'msg.sender'])
			orderInfo_1(uint256) := ϕ(['info_1', 'orderInfo_1', 'orderInfo_1'])
			additionalMask_1(uint256) := ϕ(['additionalMask_1'])
			_invalidator_2(mapping(address => mapping(uint256 => uint256))) := ϕ(['_invalidator_0', '_invalidator_1', '_invalidator_3'])
		Expression: invalidatorSlot = uint64(orderInfo) >> 8
		IRs:
			TMP_1216 = CONVERT orderInfo_1 to uint64
			TMP_1217(uint64) = TMP_1216 >> 8
			invalidatorSlot_1(uint256) := TMP_1217(uint64)
		Expression: invalidatorBits = (1 << uint8(orderInfo)) | additionalMask
		IRs:
			TMP_1218 = CONVERT orderInfo_1 to uint8
			TMP_1219(uint256) = 1 << TMP_1218
			TMP_1220(uint256) = TMP_1219 | additionalMask_1
			invalidatorBits_1(uint256) := TMP_1220(uint256)
		Expression: invalidatorStorage = _invalidator[maker]
		IRs:
			REF_341(mapping(uint256 => uint256)) -> _invalidator_2[maker_1]
			invalidatorStorage_1 (-> ['_invalidator'])(mapping(uint256 => uint256)) := REF_341(mapping(uint256 => uint256))
		Expression: invalidator = invalidatorStorage[invalidatorSlot]
		IRs:
			REF_342(uint256) -> invalidatorStorage_1 (-> ['_invalidator'])[invalidatorSlot_1]
			invalidator_1(uint256) := REF_342(uint256)
		Expression: invalidator & invalidatorBits == invalidatorBits
		IRs:
			TMP_1221(uint256) = invalidator_1 & invalidatorBits_1
			TMP_1222(bool) = TMP_1221 == invalidatorBits_1
			CONDITION TMP_1222
		Expression: revert InvalidatedOrder()()
		IRs:
			TMP_1223(None) = SOLIDITY_CALL revert InvalidatedOrder()()
		Expression: invalidatorStorage[invalidatorSlot] = invalidator | invalidatorBits
		IRs:
			REF_343(uint256) -> invalidatorStorage_1 (-> ['_invalidator'])[invalidatorSlot_1]
			TMP_1224(uint256) = invalidator_1 | invalidatorBits_1
			invalidatorStorage_2 (-> ['_invalidator'])(mapping(uint256 => uint256)) := ϕ(["invalidatorStorage_1 (-> ['_invalidator'])"])
			REF_343(uint256) (->invalidatorStorage_2 (-> ['_invalidator'])) := TMP_1224(uint256)
			_invalidator_3(mapping(address => mapping(uint256 => uint256))) := ϕ(["invalidatorStorage_2 (-> ['_invalidator'])"])
	Function OnlyWethReceiver.constructor(address)
		Expression: _WETH = address(weth)
		IRs:
			TMP_1225 = CONVERT weth_1 to address
			_WETH_1(address) := TMP_1225(address)
	Function OnlyWethReceiver._receive()
		IRs:
			_WETH_2(address) := ϕ(['_WETH_0', '_WETH_1'])
		Expression: msg.sender != _WETH
		IRs:
			TMP_1226(bool) = msg.sender != _WETH_2
			CONDITION TMP_1226
		Expression: revert EthDepositRejected()()
		IRs:
			TMP_1227(None) = SOLIDITY_CALL revert EthDepositRejected()()
	Function EthReceiver.receive()
		Expression: _receive()
		IRs:
			INTERNAL_CALL, OnlyWethReceiver._receive()()
	Function EthReceiver._receive()
		Expression: msg.sender == tx.origin
		IRs:
			TMP_1229(bool) = msg.sender == tx.origin
			CONDITION TMP_1229
		Expression: revert EthDepositRejected()()
		IRs:
			TMP_1230(None) = SOLIDITY_CALL revert EthDepositRejected()()
	Function EIP712.constructor(string,string)
		Expression: hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_1231 = CONVERT name_1 to bytes
			TMP_1232(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1231)
			hashedName_1(bytes32) := TMP_1232(bytes32)
		Expression: hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_1233 = CONVERT version_1 to bytes
			TMP_1234(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1233)
			hashedVersion_1(bytes32) := TMP_1234(bytes32)
		Expression: typeHash = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
		IRs:
			TMP_1235(bytes32) = SOLIDITY_CALL keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
			typeHash_1(bytes32) := TMP_1235(bytes32)
		Expression: _HASHED_NAME = hashedName
		IRs:
			_HASHED_NAME_1(bytes32) := hashedName_1(bytes32)
		Expression: _HASHED_VERSION = hashedVersion
		IRs:
			_HASHED_VERSION_1(bytes32) := hashedVersion_1(bytes32)
		Expression: _CACHED_CHAIN_ID = block.chainid
		IRs:
			_CACHED_CHAIN_ID_1(uint256) := block.chainid(uint256)
		Expression: _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash,hashedName,hashedVersion)
		IRs:
			TMP_1236(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(typeHash_1,hashedName_1,hashedVersion_1)
			_CACHED_DOMAIN_SEPARATOR_1(bytes32) := TMP_1236(bytes32)
		Expression: _CACHED_THIS = address(this)
		IRs:
			TMP_1237 = CONVERT this to address
			_CACHED_THIS_1(address) := TMP_1237(address)
		Expression: _TYPE_HASH = typeHash
		IRs:
			_TYPE_HASH_1(bytes32) := typeHash_1(bytes32)
	Function EIP712._domainSeparatorV4()
		IRs:
			_CACHED_DOMAIN_SEPARATOR_2(bytes32) := ϕ(['_CACHED_DOMAIN_SEPARATOR_1', '_CACHED_DOMAIN_SEPARATOR_0'])
			_CACHED_CHAIN_ID_2(uint256) := ϕ(['_CACHED_CHAIN_ID_1', '_CACHED_CHAIN_ID_0'])
			_CACHED_THIS_2(address) := ϕ(['_CACHED_THIS_1', '_CACHED_THIS_0'])
			_HASHED_NAME_2(bytes32) := ϕ(['_HASHED_NAME_3', '_HASHED_NAME_0', '_HASHED_NAME_1'])
			_HASHED_VERSION_2(bytes32) := ϕ(['_HASHED_VERSION_3', '_HASHED_VERSION_0', '_HASHED_VERSION_1'])
			_TYPE_HASH_2(bytes32) := ϕ(['_TYPE_HASH_3', '_TYPE_HASH_0', '_TYPE_HASH_1'])
		Expression: address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID
		IRs:
			TMP_1238 = CONVERT this to address
			TMP_1239(bool) = TMP_1238 == _CACHED_THIS_2
			TMP_1240(bool) = block.chainid == _CACHED_CHAIN_ID_2
			TMP_1241(bool) = TMP_1239 && TMP_1240
			CONDITION TMP_1241
		Expression: _CACHED_DOMAIN_SEPARATOR
		IRs:
			RETURN _CACHED_DOMAIN_SEPARATOR_2
		Expression: _buildDomainSeparator(_TYPE_HASH,_HASHED_NAME,_HASHED_VERSION)
		IRs:
			TMP_1242(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(_TYPE_HASH_2,_HASHED_NAME_2,_HASHED_VERSION_2)
			RETURN TMP_1242
	Function EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)
		IRs:
			typeHash_1(bytes32) := ϕ(['typeHash_1', '_TYPE_HASH_2'])
			nameHash_1(bytes32) := ϕ(['hashedName_1', '_HASHED_NAME_2'])
			versionHash_1(bytes32) := ϕ(['hashedVersion_1', '_HASHED_VERSION_2'])
		Expression: keccak256(bytes)(abi.encode(typeHash,nameHash,versionHash,block.chainid,address(this)))
		IRs:
			TMP_1243 = CONVERT this to address
			TMP_1244(bytes) = SOLIDITY_CALL abi.encode()(typeHash_1,nameHash_1,versionHash_1,block.chainid,TMP_1243)
			TMP_1245(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1244)
			RETURN TMP_1245
	Function EIP712._hashTypedDataV4(bytes32)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_1246(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1247(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_1246', 'structHash_1'] 
			RETURN TMP_1247
	Function OrderMixin.constructor(IWETH)
		Expression: _WETH = weth
		IRs:
			_WETH_1(IWETH) := weth_1(IWETH)
	Function OrderMixin.remaining(bytes32)
		IRs:
			_ORDER_DOES_NOT_EXIST_1(uint256) := ϕ(['_ORDER_DOES_NOT_EXIST_3', '_ORDER_DOES_NOT_EXIST_0'])
			_remaining_1(mapping(bytes32 => uint256)) := ϕ(['_remaining_9', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_0', '_remaining_1'])
		Expression: amount = _remaining[orderHash]
		IRs:
			REF_346(uint256) -> _remaining_1[orderHash_1]
			amount_1(uint256) := REF_346(uint256)
		Expression: amount == _ORDER_DOES_NOT_EXIST
		IRs:
			TMP_1248(bool) = amount_1 == _ORDER_DOES_NOT_EXIST_1
			CONDITION TMP_1248
		Expression: revert UnknownOrder()()
		IRs:
			TMP_1249(None) = SOLIDITY_CALL revert UnknownOrder()()
		Expression: amount - 1
		IRs:
			TMP_1250(uint256) = amount_1 - 1
			RETURN TMP_1250
	Function OrderMixin.remainingRaw(bytes32)
		IRs:
			_remaining_2(mapping(bytes32 => uint256)) := ϕ(['_remaining_9', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_0', '_remaining_1'])
		Expression: _remaining[orderHash]
		IRs:
			REF_347(uint256) -> _remaining_2[orderHash_1]
			RETURN REF_347
	Function OrderMixin.remainingsRaw(bytes32[])
		IRs:
			_remaining_3(mapping(bytes32 => uint256)) := ϕ(['_remaining_9', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_0', '_remaining_1'])
		Expression: results = new uint256[](orderHashes.length)
		IRs:
			REF_348 -> LENGTH orderHashes_1
			TMP_1252(uint256[])  = new uint256[](REF_348)
			results_1(uint256[]) = ['TMP_1252(uint256[])']
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < orderHashes.length
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			REF_349 -> LENGTH orderHashes_1
			TMP_1253(bool) = i_2 < REF_349
			CONDITION TMP_1253
		Expression: results[i] = _remaining[orderHashes[i]]
		IRs:
			REF_350(uint256) -> results_1[i_2]
			REF_351(bytes32) -> orderHashes_1[i_2]
			REF_352(uint256) -> _remaining_3[REF_351]
			results_2(uint256[]) := ϕ(['results_1'])
			REF_350(uint256) (->results_2) := REF_352(uint256)
		Expression: i ++
		IRs:
			TMP_1254(uint256) := i_2(uint256)
			i_3(uint256) = i_2 (c)+ 1
		Expression: results
		IRs:
			RETURN results_1
	Function OrderMixin.simulate(address,bytes)
		Expression: (success,result) = target.delegatecall(data)
		IRs:
			TUPLE_5(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:delegatecall, arguments:['data_1']  
			success_1(bool)= UNPACK TUPLE_5 index: 0 
			result_1(bytes)= UNPACK TUPLE_5 index: 1 
		Expression: revert SimulationResults(bool,bytes)(success,result)
		IRs:
			TMP_1255(None) = SOLIDITY_CALL revert SimulationResults(bool,bytes)(success_1,result_1)
	Function OrderMixin.cancelOrder(OrderLib.Order)
		IRs:
			_ORDER_FILLED_1(uint256) := ϕ(['_ORDER_FILLED_4', '_ORDER_FILLED_0', '_ORDER_FILLED_2'])
			_remaining_4(mapping(bytes32 => uint256)) := ϕ(['_remaining_9', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_0', '_remaining_1'])
		Expression: order.maker != msg.sender
		IRs:
			REF_354(address) -> order_1.maker
			TMP_1256(bool) = REF_354 != msg.sender
			CONDITION TMP_1256
		Expression: revert AccessDenied()()
		IRs:
			TMP_1257(None) = SOLIDITY_CALL revert AccessDenied()()
		Expression: orderHash = hashOrder(order)
		IRs:
			TMP_1258(bytes32) = INTERNAL_CALL, OrderMixin.hashOrder(OrderLib.Order)(order_1)
			orderHash_1(bytes32) := TMP_1258(bytes32)
		Expression: orderRemaining = _remaining[orderHash]
		IRs:
			REF_355(uint256) -> _remaining_5[orderHash_1]
			orderRemaining_1(uint256) := REF_355(uint256)
		Expression: orderRemaining == _ORDER_FILLED
		IRs:
			TMP_1259(bool) = orderRemaining_1 == _ORDER_FILLED_2
			CONDITION TMP_1259
		Expression: revert AlreadyFilled()()
		IRs:
			TMP_1260(None) = SOLIDITY_CALL revert AlreadyFilled()()
		Expression: OrderCanceled(msg.sender,orderHash,orderRemaining)
		IRs:
			Emit OrderCanceled(msg.sender,orderHash_1,orderRemaining_1)
		Expression: _remaining[orderHash] = _ORDER_FILLED
		IRs:
			REF_356(uint256) -> _remaining_5[orderHash_1]
			_remaining_6(mapping(bytes32 => uint256)) := ϕ(['_remaining_5'])
			REF_356(uint256) (->_remaining_6) := _ORDER_FILLED_2(uint256)
		Expression: (orderRemaining,orderHash)
		IRs:
			RETURN orderRemaining_1,orderHash_1
	Function OrderMixin.fillOrder(OrderLib.Order,bytes,bytes,uint256,uint256,uint256)
		Expression: fillOrderTo(order,signature,interaction,makingAmount,takingAmount,skipPermitAndThresholdAmount,msg.sender)
		IRs:
			TUPLE_6(uint256,uint256,bytes32) = INTERNAL_CALL, OrderMixin.fillOrderTo(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address)(order_1,signature_1,interaction_1,makingAmount_1,takingAmount_1,skipPermitAndThresholdAmount_1,msg.sender)
			RETURN TUPLE_6
	Function OrderMixin.fillOrderToWithPermit(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address,bytes)
		Expression: permit.length < 20
		IRs:
			REF_357 -> LENGTH permit_1
			TMP_1262(bool) = REF_357 < 20
			CONDITION TMP_1262
		Expression: revert PermitLengthTooLow()()
		IRs:
			TMP_1263(None) = SOLIDITY_CALL revert PermitLengthTooLow()()
		Expression: (token,permitData) = permit.decodeTargetAndCalldata()
		IRs:
			TUPLE_7(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['permit_1'] 
			token_1(address)= UNPACK TUPLE_7 index: 0 
			permitData_1(bytes)= UNPACK TUPLE_7 index: 1 
		Expression: IERC20(token).safePermit(permitData)
		IRs:
			TMP_1264 = CONVERT token_1 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['TMP_1264', 'permitData_1'] 
		Expression: fillOrderTo(order,signature,interaction,makingAmount,takingAmount,skipPermitAndThresholdAmount,target)
		IRs:
			TUPLE_8(uint256,uint256,bytes32) = INTERNAL_CALL, OrderMixin.fillOrderTo(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address)(order_1,signature_1,interaction_1,makingAmount_1,takingAmount_1,skipPermitAndThresholdAmount_1,target_1)
			RETURN TUPLE_8
	Function OrderMixin.fillOrderTo(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address)
		IRs:
			order__1(OrderLib.Order) := ϕ(['order_1', 'order_1'])
			signature_1(bytes) := ϕ(['signature_1', 'signature_1'])
			interaction_1(bytes) := ϕ(['interaction_1', 'interaction_1'])
			makingAmount_1(uint256) := ϕ(['makingAmount_1', 'makingAmount_1'])
			takingAmount_1(uint256) := ϕ(['takingAmount_1', 'takingAmount_1'])
			skipPermitAndThresholdAmount_1(uint256) := ϕ(['skipPermitAndThresholdAmount_1', 'skipPermitAndThresholdAmount_1'])
			target_1(address) := ϕ(['target_1', 'msg.sender'])
			_RAW_CALL_GAS_LIMIT_1(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_9', '_RAW_CALL_GAS_LIMIT_8', '_RAW_CALL_GAS_LIMIT_10', '_RAW_CALL_GAS_LIMIT_0'])
			_ORDER_DOES_NOT_EXIST_2(uint256) := ϕ(['_ORDER_DOES_NOT_EXIST_3', '_ORDER_DOES_NOT_EXIST_0'])
			_ORDER_FILLED_3(uint256) := ϕ(['_ORDER_FILLED_4', '_ORDER_FILLED_0', '_ORDER_FILLED_2'])
			_SKIP_PERMIT_FLAG_1(uint256) := ϕ(['_SKIP_PERMIT_FLAG_2', '_SKIP_PERMIT_FLAG_0'])
			_THRESHOLD_MASK_1(uint256) := ϕ(['_THRESHOLD_MASK_3', '_THRESHOLD_MASK_4', '_THRESHOLD_MASK_2', '_THRESHOLD_MASK_6', '_THRESHOLD_MASK_5', '_THRESHOLD_MASK_0'])
			_WETH_2(IWETH) := ϕ(['_WETH_13', '_WETH_1', '_WETH_0', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9'])
			_remaining_7(mapping(bytes32 => uint256)) := ϕ(['_remaining_9', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_0', '_remaining_1'])
		Expression: target == address(0)
		IRs:
			TMP_1266 = CONVERT 0 to address
			TMP_1267(bool) = target_1 == TMP_1266
			CONDITION TMP_1267
		Expression: revert ZeroTargetIsForbidden()()
		IRs:
			TMP_1268(None) = SOLIDITY_CALL revert ZeroTargetIsForbidden()()
		Expression: orderHash = hashOrder(order_)
		IRs:
			TMP_1269(bytes32) = INTERNAL_CALL, OrderMixin.hashOrder(OrderLib.Order)(order__1)
			orderHash_1(bytes32) := TMP_1269(bytes32)
		Expression: order = order_
		IRs:
			order_1(OrderLib.Order) := order__1(OrderLib.Order)
		Expression: actualMakingAmount = makingAmount
		IRs:
			actualMakingAmount_1(uint256) := makingAmount_1(uint256)
		Expression: actualTakingAmount = takingAmount
		IRs:
			actualTakingAmount_1(uint256) := takingAmount_1(uint256)
		Expression: remainingMakingAmount = _remaining[orderHash]
		IRs:
			REF_360(uint256) -> _remaining_8[orderHash_1]
			remainingMakingAmount_1(uint256) := REF_360(uint256)
		Expression: remainingMakingAmount == _ORDER_FILLED
		IRs:
			TMP_1270(bool) = remainingMakingAmount_1 == _ORDER_FILLED_4
			CONDITION TMP_1270
		Expression: revert RemainingAmountIsZero()()
		IRs:
			TMP_1271(None) = SOLIDITY_CALL revert RemainingAmountIsZero()()
		Expression: order.allowedSender != address(0) && order.allowedSender != msg.sender
		IRs:
			REF_361(address) -> order_1.allowedSender
			TMP_1272 = CONVERT 0 to address
			TMP_1273(bool) = REF_361 != TMP_1272
			REF_362(address) -> order_1.allowedSender
			TMP_1274(bool) = REF_362 != msg.sender
			TMP_1275(bool) = TMP_1273 && TMP_1274
			CONDITION TMP_1275
		Expression: revert PrivateOrder()()
		IRs:
			TMP_1276(None) = SOLIDITY_CALL revert PrivateOrder()()
		Expression: remainingMakingAmount == _ORDER_DOES_NOT_EXIST
		IRs:
			TMP_1277(bool) = remainingMakingAmount_1 == _ORDER_DOES_NOT_EXIST_3
			CONDITION TMP_1277
		Expression: ! ECDSA.recoverOrIsValidSignature(order.maker,orderHash,signature)
		IRs:
			REF_364(address) -> order_1.maker
			TMP_1278(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recoverOrIsValidSignature(address,bytes32,bytes), arguments:['REF_364', 'orderHash_1', 'signature_1'] 
			TMP_1279 = UnaryType.BANG TMP_1278 
			CONDITION TMP_1279
		Expression: revert BadSignature()()
		IRs:
			TMP_1280(None) = SOLIDITY_CALL revert BadSignature()()
		Expression: remainingMakingAmount = order.makingAmount
		IRs:
			REF_365(uint256) -> order_1.makingAmount
			remainingMakingAmount_3(uint256) := REF_365(uint256)
		Expression: permit = order.permit()
		IRs:
			TMP_1281(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.permit(OrderLib.Order), arguments:['order_1'] 
			permit_1(bytes) := TMP_1281(bytes)
		Expression: skipPermitAndThresholdAmount & _SKIP_PERMIT_FLAG == 0 && permit.length >= 20
		IRs:
			TMP_1282(uint256) = skipPermitAndThresholdAmount_1 & _SKIP_PERMIT_FLAG_2
			TMP_1283(bool) = TMP_1282 == 0
			REF_367 -> LENGTH permit_1
			TMP_1284(bool) = REF_367 >= 20
			TMP_1285(bool) = TMP_1283 && TMP_1284
			CONDITION TMP_1285
		Expression: (token,permitCalldata) = permit.decodeTargetAndCalldata()
		IRs:
			TUPLE_9(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['permit_1'] 
			token_1(address)= UNPACK TUPLE_9 index: 0 
			permitCalldata_1(bytes)= UNPACK TUPLE_9 index: 1 
		Expression: IERC20(token).safePermit(permitCalldata)
		IRs:
			TMP_1286 = CONVERT token_1 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['TMP_1286', 'permitCalldata_1'] 
		Expression: _remaining[orderHash] != _ORDER_DOES_NOT_EXIST
		IRs:
			REF_370(uint256) -> _remaining_8[orderHash_1]
			TMP_1288(bool) = REF_370 != _ORDER_DOES_NOT_EXIST_3
			CONDITION TMP_1288
		Expression: revert ReentrancyDetected()()
		IRs:
			TMP_1289(None) = SOLIDITY_CALL revert ReentrancyDetected()()
		Expression: remainingMakingAmount -= 1
		IRs:
			remainingMakingAmount_2(uint256) = remainingMakingAmount_1 - 1
		IRs:
			remainingMakingAmount_4(uint256) := ϕ(['remainingMakingAmount_2', 'remainingMakingAmount_3', 'remainingMakingAmount_1'])
		Expression: order.predicate().length > 0
		IRs:
			TMP_1290(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.predicate(OrderLib.Order), arguments:['order_1'] 
			REF_372 -> LENGTH TMP_1290
			TMP_1291(bool) = REF_372 > 0
			CONDITION TMP_1291
		Expression: ! checkPredicate(order)
		IRs:
			TMP_1292(bool) = INTERNAL_CALL, OrderMixin.checkPredicate(OrderLib.Order)(order_1)
			TMP_1293 = UnaryType.BANG TMP_1292 
			CONDITION TMP_1293
		Expression: revert PredicateIsNotTrue()()
		IRs:
			TMP_1294(None) = SOLIDITY_CALL revert PredicateIsNotTrue()()
		Expression: (actualTakingAmount == 0) == (actualMakingAmount == 0)
		IRs:
			TMP_1295(bool) = actualTakingAmount_1 == 0
			TMP_1296(bool) = actualMakingAmount_1 == 0
			TMP_1297(bool) = TMP_1295 == TMP_1296
			CONDITION TMP_1297
		Expression: revert OnlyOneAmountShouldBeZero()()
		IRs:
			TMP_1298(None) = SOLIDITY_CALL revert OnlyOneAmountShouldBeZero()()
		Expression: actualTakingAmount == 0
		IRs:
			TMP_1299(bool) = actualTakingAmount_1 == 0
			CONDITION TMP_1299
		Expression: actualMakingAmount > remainingMakingAmount
		IRs:
			TMP_1300(bool) = actualMakingAmount_1 > remainingMakingAmount_4
			CONDITION TMP_1300
		Expression: actualMakingAmount = remainingMakingAmount
		IRs:
			actualMakingAmount_5(uint256) := remainingMakingAmount_4(uint256)
		IRs:
			actualMakingAmount_6(uint256) := ϕ(['actualMakingAmount_5', 'actualMakingAmount_1'])
		Expression: actualTakingAmount = _getTakingAmount(order.getTakingAmount(),order.makingAmount,actualMakingAmount,order.takingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1301(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getTakingAmount(OrderLib.Order), arguments:['order_1'] 
			REF_374(uint256) -> order_1.makingAmount
			REF_375(uint256) -> order_1.takingAmount
			TMP_1302(uint256) = INTERNAL_CALL, OrderMixin._getTakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)(TMP_1301,REF_374,actualMakingAmount_6,REF_375,remainingMakingAmount_4,orderHash_1)
			actualTakingAmount_4(uint256) := TMP_1302(uint256)
		Expression: thresholdAmount = skipPermitAndThresholdAmount & _THRESHOLD_MASK
		IRs:
			TMP_1303(uint256) = skipPermitAndThresholdAmount_1 & _THRESHOLD_MASK_6
			thresholdAmount_1(uint256) := TMP_1303(uint256)
		Expression: actualTakingAmount * makingAmount > thresholdAmount * actualMakingAmount
		IRs:
			TMP_1304(uint256) = actualTakingAmount_4 (c)* makingAmount_1
			TMP_1305(uint256) = thresholdAmount_1 (c)* actualMakingAmount_6
			TMP_1306(bool) = TMP_1304 > TMP_1305
			CONDITION TMP_1306
		Expression: revert TakingAmountTooHigh()()
		IRs:
			TMP_1307(None) = SOLIDITY_CALL revert TakingAmountTooHigh()()
		Expression: actualMakingAmount = _getMakingAmount(order.getMakingAmount(),order.takingAmount,actualTakingAmount,order.makingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1308(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getMakingAmount(OrderLib.Order), arguments:['order_1'] 
			REF_377(uint256) -> order_1.takingAmount
			REF_378(uint256) -> order_1.makingAmount
			TMP_1309(uint256) = INTERNAL_CALL, OrderMixin._getMakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)(TMP_1308,REF_377,actualTakingAmount_1,REF_378,remainingMakingAmount_4,orderHash_1)
			actualMakingAmount_2(uint256) := TMP_1309(uint256)
		Expression: actualMakingAmount > remainingMakingAmount
		IRs:
			TMP_1310(bool) = actualMakingAmount_2 > remainingMakingAmount_4
			CONDITION TMP_1310
		Expression: actualMakingAmount = remainingMakingAmount
		IRs:
			actualMakingAmount_3(uint256) := remainingMakingAmount_4(uint256)
		Expression: actualTakingAmount = _getTakingAmount(order.getTakingAmount(),order.makingAmount,actualMakingAmount,order.takingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1311(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getTakingAmount(OrderLib.Order), arguments:['order_1'] 
			REF_380(uint256) -> order_1.makingAmount
			REF_381(uint256) -> order_1.takingAmount
			TMP_1312(uint256) = INTERNAL_CALL, OrderMixin._getTakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)(TMP_1311,REF_380,actualMakingAmount_3,REF_381,remainingMakingAmount_4,orderHash_1)
			actualTakingAmount_2(uint256) := TMP_1312(uint256)
		Expression: actualTakingAmount > takingAmount
		IRs:
			TMP_1313(bool) = actualTakingAmount_2 > takingAmount_1
			CONDITION TMP_1313
		Expression: revert TakingAmountIncreased()()
		IRs:
			TMP_1314(None) = SOLIDITY_CALL revert TakingAmountIncreased()()
		IRs:
			actualMakingAmount_4(uint256) := ϕ(['actualMakingAmount_2', 'actualMakingAmount_3'])
			actualTakingAmount_3(uint256) := ϕ(['actualTakingAmount_1', 'actualTakingAmount_2'])
		Expression: thresholdAmount_scope_0 = skipPermitAndThresholdAmount & _THRESHOLD_MASK
		IRs:
			TMP_1315(uint256) = skipPermitAndThresholdAmount_1 & _THRESHOLD_MASK_5
			thresholdAmount_scope_0_1(uint256) := TMP_1315(uint256)
		Expression: actualMakingAmount * takingAmount < thresholdAmount_scope_0 * actualTakingAmount
		IRs:
			TMP_1316(uint256) = actualMakingAmount_4 (c)* takingAmount_1
			TMP_1317(uint256) = thresholdAmount_scope_0_1 (c)* actualTakingAmount_3
			TMP_1318(bool) = TMP_1316 < TMP_1317
			CONDITION TMP_1318
		Expression: revert MakingAmountTooLow()()
		IRs:
			TMP_1319(None) = SOLIDITY_CALL revert MakingAmountTooLow()()
		IRs:
			actualMakingAmount_7(uint256) := ϕ(['actualMakingAmount_1', 'actualMakingAmount_2'])
			actualTakingAmount_5(uint256) := ϕ(['actualTakingAmount_1', 'actualTakingAmount_4'])
		Expression: actualMakingAmount == 0 || actualTakingAmount == 0
		IRs:
			TMP_1320(bool) = actualMakingAmount_1 == 0
			TMP_1321(bool) = actualTakingAmount_1 == 0
			TMP_1322(bool) = TMP_1320 || TMP_1321
			CONDITION TMP_1322
		Expression: revert SwapWithZeroAmount()()
		IRs:
			TMP_1323(None) = SOLIDITY_CALL revert SwapWithZeroAmount()()
		Expression: remainingMakingAmount = remainingMakingAmount - actualMakingAmount
		IRs:
			TMP_1324(uint256) = remainingMakingAmount_4 - actualMakingAmount_1
			remainingMakingAmount_5(uint256) := TMP_1324(uint256)
		Expression: _remaining[orderHash] = remainingMakingAmount + 1
		IRs:
			REF_382(uint256) -> _remaining_8[orderHash_1]
			TMP_1325(uint256) = remainingMakingAmount_5 + 1
			_remaining_9(mapping(bytes32 => uint256)) := ϕ(['_remaining_8'])
			REF_382(uint256) (->_remaining_9) := TMP_1325(uint256)
		Expression: OrderFilled(order_.maker,orderHash,remainingMakingAmount)
		IRs:
			REF_383(address) -> order__1.maker
			Emit OrderFilled(REF_383,orderHash_1,remainingMakingAmount_5)
		Expression: order.preInteraction().length >= 20
		IRs:
			TMP_1327(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.preInteraction(OrderLib.Order), arguments:['order_1'] 
			REF_385 -> LENGTH TMP_1327
			TMP_1328(bool) = REF_385 >= 20
			CONDITION TMP_1328
		Expression: (interactionTarget,interactionData) = order.preInteraction().decodeTargetAndCalldata()
		IRs:
			TMP_1329(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.preInteraction(OrderLib.Order), arguments:['order_1'] 
			TUPLE_10(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['TMP_1329'] 
			interactionTarget_1(address)= UNPACK TUPLE_10 index: 0 
			interactionData_1(bytes)= UNPACK TUPLE_10 index: 1 
		Expression: IPreInteractionNotificationReceiver(interactionTarget).fillOrderPreInteraction(orderHash,order.maker,msg.sender,actualMakingAmount,actualTakingAmount,remainingMakingAmount,interactionData)
		IRs:
			TMP_1330 = CONVERT interactionTarget_1 to IPreInteractionNotificationReceiver
			REF_389(address) -> order_1.maker
			HIGH_LEVEL_CALL, dest:TMP_1330(IPreInteractionNotificationReceiver), function:fillOrderPreInteraction, arguments:['orderHash_1', 'REF_389', 'msg.sender', 'actualMakingAmount_1', 'actualTakingAmount_1', 'remainingMakingAmount_5', 'interactionData_1']  
			_RAW_CALL_GAS_LIMIT_7(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_9', '_RAW_CALL_GAS_LIMIT_6', '_RAW_CALL_GAS_LIMIT_10', '_RAW_CALL_GAS_LIMIT_8'])
			_WETH_8(IWETH) := ϕ(['_WETH_13', '_WETH_7', '_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9'])
		Expression: ! _callTransferFrom(order.makerAsset,order.maker,target,actualMakingAmount,order.makerAssetData())
		IRs:
			REF_390(address) -> order_1.makerAsset
			REF_391(address) -> order_1.maker
			TMP_1332(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.makerAssetData(OrderLib.Order), arguments:['order_1'] 
			TMP_1333(bool) = INTERNAL_CALL, OrderMixin._callTransferFrom(address,address,address,uint256,bytes)(REF_390,REF_391,target_1,actualMakingAmount_1,TMP_1332)
			TMP_1334 = UnaryType.BANG TMP_1333 
			CONDITION TMP_1334
		Expression: revert TransferFromMakerToTakerFailed()()
		IRs:
			TMP_1335(None) = SOLIDITY_CALL revert TransferFromMakerToTakerFailed()()
		Expression: interaction.length >= 20
		IRs:
			REF_393 -> LENGTH interaction_1
			TMP_1336(bool) = REF_393 >= 20
			CONDITION TMP_1336
		Expression: (interactionTarget_scope_1,interactionData_scope_2) = interaction.decodeTargetAndCalldata()
		IRs:
			TUPLE_11(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['interaction_1'] 
			interactionTarget_scope_1_1(address)= UNPACK TUPLE_11 index: 0 
			interactionData_scope_2_1(bytes)= UNPACK TUPLE_11 index: 1 
		Expression: offeredTakingAmount = IInteractionNotificationReceiver(interactionTarget_scope_1).fillOrderInteraction(msg.sender,actualMakingAmount,actualTakingAmount,interactionData_scope_2)
		IRs:
			TMP_1337 = CONVERT interactionTarget_scope_1_1 to IInteractionNotificationReceiver
			TMP_1338(uint256) = HIGH_LEVEL_CALL, dest:TMP_1337(IInteractionNotificationReceiver), function:fillOrderInteraction, arguments:['msg.sender', 'actualMakingAmount_1', 'actualTakingAmount_1', 'interactionData_scope_2_1']  
			_RAW_CALL_GAS_LIMIT_9(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_9', '_RAW_CALL_GAS_LIMIT_10', '_RAW_CALL_GAS_LIMIT_8'])
			_WETH_10(IWETH) := ϕ(['_WETH_13', '_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9'])
			offeredTakingAmount_1(uint256) := TMP_1338(uint256)
		Expression: offeredTakingAmount > actualTakingAmount && ! OrderLib.getterIsFrozen(order.getMakingAmount()) && ! OrderLib.getterIsFrozen(order.getTakingAmount())
		IRs:
			TMP_1339(bool) = offeredTakingAmount_1 > actualTakingAmount_1
			TMP_1340(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getMakingAmount(OrderLib.Order), arguments:['order_1'] 
			TMP_1341(bool) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getterIsFrozen(bytes), arguments:['TMP_1340'] 
			TMP_1342 = UnaryType.BANG TMP_1341 
			TMP_1343(bool) = TMP_1339 && TMP_1342
			TMP_1344(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getTakingAmount(OrderLib.Order), arguments:['order_1'] 
			TMP_1345(bool) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getterIsFrozen(bytes), arguments:['TMP_1344'] 
			TMP_1346 = UnaryType.BANG TMP_1345 
			TMP_1347(bool) = TMP_1343 && TMP_1346
			CONDITION TMP_1347
		Expression: actualTakingAmount = offeredTakingAmount
		IRs:
			actualTakingAmount_6(uint256) := offeredTakingAmount_1(uint256)
		IRs:
			actualTakingAmount_7(uint256) := ϕ(['actualTakingAmount_1', 'actualTakingAmount_6'])
		Expression: order.takerAsset == address(_WETH) && msg.value > 0
		IRs:
			REF_400(address) -> order_1.takerAsset
			TMP_1348 = CONVERT _WETH_10 to address
			TMP_1349(bool) = REF_400 == TMP_1348
			TMP_1350(bool) = msg.value > 0
			TMP_1351(bool) = TMP_1349 && TMP_1350
			CONDITION TMP_1351
		Expression: msg.value < actualTakingAmount
		IRs:
			TMP_1352(bool) = msg.value < actualTakingAmount_7
			CONDITION TMP_1352
		Expression: Errors.InvalidMsgValue()
		IRs:
			TMP_1353(None) = SOLIDITY_CALL revert InvalidMsgValue()()
		Expression: msg.value > actualTakingAmount
		IRs:
			TMP_1354(bool) = msg.value > actualTakingAmount_7
			CONDITION TMP_1354
		Expression: (success,None) = msg.sender.call{gas: _RAW_CALL_GAS_LIMIT,value: msg.value - actualTakingAmount}()
		IRs:
			TMP_1355(uint256) = msg.value - actualTakingAmount_7
			TUPLE_12(bool,bytes) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[''] value:TMP_1355 gas:_RAW_CALL_GAS_LIMIT_9
			_RAW_CALL_GAS_LIMIT_10(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_9', '_RAW_CALL_GAS_LIMIT_10', '_RAW_CALL_GAS_LIMIT_8'])
			_WETH_11(IWETH) := ϕ(['_WETH_13', '_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9'])
			success_1(bool)= UNPACK TUPLE_12 index: 0 
		Expression: ! success
		IRs:
			TMP_1356 = UnaryType.BANG success_1 
			CONDITION TMP_1356
		Expression: Errors.ETHTransferFailed()
		IRs:
			TMP_1357(None) = SOLIDITY_CALL revert ETHTransferFailed()()
		Expression: _WETH.deposit{value: actualTakingAmount}()
		IRs:
			HIGH_LEVEL_CALL, dest:_WETH_11(IWETH), function:deposit, arguments:[] value:actualTakingAmount_7 
			_WETH_12(IWETH) := ϕ(['_WETH_13', '_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9'])
		Expression: msg.value != 0
		IRs:
			TMP_1359(bool) = msg.value != 0
			CONDITION TMP_1359
		Expression: Errors.InvalidMsgValue()
		IRs:
			TMP_1360(None) = SOLIDITY_CALL revert InvalidMsgValue()()
		Expression: revert TransferFromTakerToMakerFailed()()
		IRs:
			TMP_1361(None) = SOLIDITY_CALL revert TransferFromTakerToMakerFailed()()
		Expression: order.postInteraction().length >= 20
		IRs:
			TMP_1362(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.postInteraction(OrderLib.Order), arguments:['order_1'] 
			REF_404 -> LENGTH TMP_1362
			TMP_1363(bool) = REF_404 >= 20
			CONDITION TMP_1363
		Expression: (interactionTarget_scope_3,interactionData_scope_4) = order.postInteraction().decodeTargetAndCalldata()
		IRs:
			TMP_1364(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.postInteraction(OrderLib.Order), arguments:['order_1'] 
			TUPLE_13(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['TMP_1364'] 
			interactionTarget_scope_3_1(address)= UNPACK TUPLE_13 index: 0 
			interactionData_scope_4_1(bytes)= UNPACK TUPLE_13 index: 1 
		Expression: IPostInteractionNotificationReceiver(interactionTarget_scope_3).fillOrderPostInteraction(orderHash,order.maker,msg.sender,actualMakingAmount,actualTakingAmount,remainingMakingAmount,interactionData_scope_4)
		IRs:
			TMP_1365 = CONVERT interactionTarget_scope_3_1 to IPostInteractionNotificationReceiver
			REF_408(address) -> order_1.maker
			HIGH_LEVEL_CALL, dest:TMP_1365(IPostInteractionNotificationReceiver), function:fillOrderPostInteraction, arguments:['orderHash_1', 'REF_408', 'msg.sender', 'actualMakingAmount_1', 'actualTakingAmount_7', 'remainingMakingAmount_5', 'interactionData_scope_4_1']  
		Expression: order.receiver == address(0)
		IRs:
			REF_409(address) -> order_1.receiver
			TMP_1367 = CONVERT 0 to address
			TMP_1368(bool) = REF_409 == TMP_1367
			CONDITION TMP_1368
		Expression: _WETH.transfer(order.maker,actualTakingAmount)
		IRs:
			REF_411(address) -> order_1.maker
			TMP_1369(bool) = HIGH_LEVEL_CALL, dest:_WETH_12(IWETH), function:transfer, arguments:['REF_411', 'actualTakingAmount_7']  
			_WETH_13(IWETH) := ϕ(['_WETH_13', '_WETH_1', '_WETH_14', '_WETH_12', '_WETH_11', '_WETH_10', '_WETH_9'])
		Expression: _WETH.transfer(order.receiver,actualTakingAmount)
		IRs:
			REF_413(address) -> order_1.receiver
			TMP_1370(bool) = HIGH_LEVEL_CALL, dest:_WETH_12(IWETH), function:transfer, arguments:['REF_413', 'actualTakingAmount_7']  
			_WETH_14(IWETH) := ϕ(['_WETH_13', '_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9'])
		Expression: order.receiver == address(0)
		IRs:
			REF_414(address) -> order_1.receiver
			TMP_1371 = CONVERT 0 to address
			TMP_1372(bool) = REF_414 == TMP_1371
			CONDITION TMP_1372
		Expression: ! _callTransferFrom(order.takerAsset,msg.sender,order.maker,actualTakingAmount,order.takerAssetData())
		IRs:
			REF_415(address) -> order_1.takerAsset
			REF_416(address) -> order_1.maker
			TMP_1373(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.takerAssetData(OrderLib.Order), arguments:['order_1'] 
			TMP_1374(bool) = INTERNAL_CALL, OrderMixin._callTransferFrom(address,address,address,uint256,bytes)(REF_415,msg.sender,REF_416,actualTakingAmount_7,TMP_1373)
			TMP_1375 = UnaryType.BANG TMP_1374 
		Expression: ! _callTransferFrom(order.takerAsset,msg.sender,order.receiver,actualTakingAmount,order.takerAssetData())
		IRs:
			REF_418(address) -> order_1.takerAsset
			REF_419(address) -> order_1.receiver
			TMP_1376(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.takerAssetData(OrderLib.Order), arguments:['order_1'] 
			TMP_1377(bool) = INTERNAL_CALL, OrderMixin._callTransferFrom(address,address,address,uint256,bytes)(REF_418,msg.sender,REF_419,actualTakingAmount_7,TMP_1376)
			TMP_1378 = UnaryType.BANG TMP_1377 
		Expression: (actualMakingAmount,actualTakingAmount,orderHash)
		IRs:
			RETURN actualMakingAmount_1,actualTakingAmount_7,orderHash_1
	Function OrderMixin.checkPredicate(OrderLib.Order)
		IRs:
			order_1(OrderLib.Order) := ϕ(['order_1'])
		Expression: (success,res) = _selfStaticCall(order.predicate())
		IRs:
			TMP_1379(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.predicate(OrderLib.Order), arguments:['order_1'] 
			TUPLE_14(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(TMP_1379)
			success_1(bool)= UNPACK TUPLE_14 index: 0 
			res_1(uint256)= UNPACK TUPLE_14 index: 1 
		Expression: success && res == 1
		IRs:
			TMP_1380(bool) = res_1 == 1
			TMP_1381(bool) = success_1 && TMP_1380
			RETURN TMP_1381
	Function OrderMixin.hashOrder(OrderLib.Order)
		IRs:
			order_1(OrderLib.Order) := ϕ(['order_1', 'order__1'])
		Expression: order.hash(_domainSeparatorV4())
		IRs:
			TMP_1382(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1383(bytes32) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.hash(OrderLib.Order,bytes32), arguments:['order_1', 'TMP_1382'] 
			RETURN TMP_1383
	Function OrderMixin._callTransferFrom(address,address,address,uint256,bytes)
		IRs:
			asset_1(address) := ϕ(['REF_390', 'REF_418', 'REF_415'])
			from_1(address) := ϕ(['REF_391', 'msg.sender'])
			to_1(address) := ϕ(['target_1', 'REF_419', 'REF_416'])
			amount_1(uint256) := ϕ(['actualMakingAmount_1', 'actualTakingAmount_7'])
			input_1(bytes) := ϕ(['TMP_1376', 'TMP_1373', 'TMP_1332'])
		Expression: selector = IERC20.transferFrom.selector
		IRs:
			REF_424(bytes4) (->None) := 599290589(bytes4)
			selector_1(bytes4) := REF_424(bytes4)
		Expression: data__callTransferFrom_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_1384(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data__callTransferFrom_asm_0_1(uint256) := TMP_1384(uint256)
		Expression: mstore(uint256,uint256)(data__callTransferFrom_asm_0,selector)
		IRs:
			TMP_1385(None) = SOLIDITY_CALL mstore(uint256,uint256)(data__callTransferFrom_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(data__callTransferFrom_asm_0 + 0x04,from)
		IRs:
			TMP_1386(uint256) = data__callTransferFrom_asm_0_1 + 4
			TMP_1387(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_1386,from_1)
		Expression: mstore(uint256,uint256)(data__callTransferFrom_asm_0 + 0x24,to)
		IRs:
			TMP_1388(uint256) = data__callTransferFrom_asm_0_1 + 36
			TMP_1389(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_1388,to_1)
		Expression: mstore(uint256,uint256)(data__callTransferFrom_asm_0 + 0x44,amount)
		IRs:
			TMP_1390(uint256) = data__callTransferFrom_asm_0_1 + 68
			TMP_1391(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_1390,amount_1)
		Expression: calldatacopy(uint256,uint256,uint256)(data__callTransferFrom_asm_0 + 0x64,input,input)
		IRs:
			TMP_1392(uint256) = data__callTransferFrom_asm_0_1 + 100
			TMP_1393(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_1392,input_1,input_1)
		Expression: status__callTransferFrom_asm_0 = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),asset,0,data__callTransferFrom_asm_0,0x64 + input,0x0,0x20)
		IRs:
			TMP_1394(uint256) = SOLIDITY_CALL gas()()
			TMP_1395(uint256) = 100 + input_1
			TMP_1396(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_1394,asset_1,0,data__callTransferFrom_asm_0_1,TMP_1395,0,32)
			status__callTransferFrom_asm_0_1(uint256) := TMP_1396(uint256)
		Expression: success = status__callTransferFrom_asm_0 & ! returndatasize()() | returndatasize()() > 31 & mload(uint256)(0) == 1
		IRs:
			TMP_1397(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_1398 = UnaryType.BANG TMP_1397 
			TMP_1399(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_1400(bool) = TMP_1399 > 31
			TMP_1401(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_1402(bool) = TMP_1401 == 1
			TMP_1403(bool) = TMP_1400 & TMP_1402
			TMP_1404(uint256) = TMP_1398 | TMP_1403
			TMP_1405(uint256) = status__callTransferFrom_asm_0_1 & TMP_1404
			success_1(bool) := TMP_1405(uint256)
		Expression: success
		IRs:
			RETURN success_1
	Function OrderMixin._getMakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)
		IRs:
			getter_1(bytes) := ϕ(['TMP_1308'])
			orderTakingAmount_1(uint256) := ϕ(['REF_377'])
			requestedTakingAmount_1(uint256) := ϕ(['actualTakingAmount_1'])
			orderMakingAmount_1(uint256) := ϕ(['REF_378'])
			remainingMakingAmount_1(uint256) := ϕ(['remainingMakingAmount_4'])
			orderHash_1(bytes32) := ϕ(['orderHash_1'])
		Expression: getter.length == 0
		IRs:
			REF_425 -> LENGTH getter_1
			TMP_1406(bool) = REF_425 == 0
			CONDITION TMP_1406
		Expression: AmountCalculator.getMakingAmount(orderMakingAmount,orderTakingAmount,requestedTakingAmount)
		IRs:
			TMP_1407(uint256) = LIBRARY_CALL, dest:AmountCalculator, function:AmountCalculator.getMakingAmount(uint256,uint256,uint256), arguments:['orderMakingAmount_1', 'orderTakingAmount_1', 'requestedTakingAmount_1'] 
			RETURN TMP_1407
		Expression: _callGetter(getter,orderTakingAmount,requestedTakingAmount,orderMakingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1408(uint256) = INTERNAL_CALL, OrderMixin._callGetter(bytes,uint256,uint256,uint256,uint256,bytes32)(getter_1,orderTakingAmount_1,requestedTakingAmount_1,orderMakingAmount_1,remainingMakingAmount_1,orderHash_1)
			RETURN TMP_1408
	Function OrderMixin._getTakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)
		IRs:
			getter_1(bytes) := ϕ(['TMP_1301', 'TMP_1311'])
			orderMakingAmount_1(uint256) := ϕ(['REF_374', 'REF_380'])
			requestedMakingAmount_1(uint256) := ϕ(['actualMakingAmount_3', 'actualMakingAmount_6'])
			orderTakingAmount_1(uint256) := ϕ(['REF_381', 'REF_375'])
			remainingMakingAmount_1(uint256) := ϕ(['remainingMakingAmount_4'])
			orderHash_1(bytes32) := ϕ(['orderHash_1'])
		Expression: getter.length == 0
		IRs:
			REF_427 -> LENGTH getter_1
			TMP_1409(bool) = REF_427 == 0
			CONDITION TMP_1409
		Expression: AmountCalculator.getTakingAmount(orderMakingAmount,orderTakingAmount,requestedMakingAmount)
		IRs:
			TMP_1410(uint256) = LIBRARY_CALL, dest:AmountCalculator, function:AmountCalculator.getTakingAmount(uint256,uint256,uint256), arguments:['orderMakingAmount_1', 'orderTakingAmount_1', 'requestedMakingAmount_1'] 
			RETURN TMP_1410
		Expression: _callGetter(getter,orderMakingAmount,requestedMakingAmount,orderTakingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1411(uint256) = INTERNAL_CALL, OrderMixin._callGetter(bytes,uint256,uint256,uint256,uint256,bytes32)(getter_1,orderMakingAmount_1,requestedMakingAmount_1,orderTakingAmount_1,remainingMakingAmount_1,orderHash_1)
			RETURN TMP_1411
	Function OrderMixin._callGetter(bytes,uint256,uint256,uint256,uint256,bytes32)
		IRs:
			getter_1(bytes) := ϕ(['getter_1', 'getter_1'])
			orderExpectedAmount_1(uint256) := ϕ(['orderMakingAmount_1', 'orderTakingAmount_1'])
			requestedAmount_1(uint256) := ϕ(['requestedMakingAmount_1', 'requestedTakingAmount_1'])
			orderResultAmount_1(uint256) := ϕ(['orderTakingAmount_1', 'orderMakingAmount_1'])
			remainingMakingAmount_1(uint256) := ϕ(['remainingMakingAmount_1', 'remainingMakingAmount_1'])
			orderHash_1(bytes32) := ϕ(['orderHash_1', 'orderHash_1'])
		Expression: getter.length == 1
		IRs:
			REF_429 -> LENGTH getter_1
			TMP_1412(bool) = REF_429 == 1
			CONDITION TMP_1412
		Expression: OrderLib.getterIsFrozen(getter)
		IRs:
			TMP_1413(bool) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getterIsFrozen(bytes), arguments:['getter_1'] 
			CONDITION TMP_1413
		Expression: requestedAmount != orderExpectedAmount
		IRs:
			TMP_1414(bool) = requestedAmount_1 != orderExpectedAmount_1
			CONDITION TMP_1414
		Expression: revert WrongAmount()()
		IRs:
			TMP_1415(None) = SOLIDITY_CALL revert WrongAmount()()
		Expression: orderResultAmount
		IRs:
			RETURN orderResultAmount_1
		Expression: revert WrongGetter()()
		IRs:
			TMP_1416(None) = SOLIDITY_CALL revert WrongGetter()()
		Expression: (target,data) = getter.decodeTargetAndCalldata()
		IRs:
			TUPLE_15(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['getter_1'] 
			target_1(address)= UNPACK TUPLE_15 index: 0 
			data_1(bytes)= UNPACK TUPLE_15 index: 1 
		Expression: (success,result) = target.staticcall(abi.encodePacked(data,requestedAmount,remainingMakingAmount,orderHash))
		IRs:
			TMP_1417(bytes) = SOLIDITY_CALL abi.encodePacked()(data_1,requestedAmount_1,remainingMakingAmount_1,orderHash_1)
			TUPLE_16(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:staticcall, arguments:['TMP_1417']  
			success_1(bool)= UNPACK TUPLE_16 index: 0 
			result_1(bytes)= UNPACK TUPLE_16 index: 1 
		Expression: ! success || result.length != 32
		IRs:
			TMP_1418 = UnaryType.BANG success_1 
			REF_434 -> LENGTH result_1
			TMP_1419(bool) = REF_434 != 32
			TMP_1420(bool) = TMP_1418 || TMP_1419
			CONDITION TMP_1420
		Expression: revert GetAmountCallFailed()()
		IRs:
			TMP_1421(None) = SOLIDITY_CALL revert GetAmountCallFailed()()
		Expression: abi.decode(result,(uint256))
		IRs:
			TMP_1422(uint256) = SOLIDITY_CALL abi.decode()(result_1,uint256)
			RETURN TMP_1422
	Function PredicateHelper.or(uint256,bytes)
		IRs:
			offsets_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1490'])
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: (current = uint32(offsets >> i)) != 0
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_1423(uint256) = offsets_1 >> i_2
			TMP_1424 = CONVERT TMP_1423 to uint32
			current_1(uint256) := TMP_1424(uint32)
			TMP_1425(bool) = current_1 != 0
			CONDITION TMP_1425
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_17(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_17 index: 0 
			res_1(uint256)= UNPACK TUPLE_17 index: 1 
		Expression: success && res == 1
		IRs:
			TMP_1426(bool) = res_1 == 1
			TMP_1427(bool) = success_1 && TMP_1426
			CONDITION TMP_1427
		Expression: true
		IRs:
			RETURN True
		Expression: previous = current
		IRs:
			previous_1(uint256) := current_1(uint256)
		Expression: i += 32
		IRs:
			i_3(uint256) = i_2 (c)+ 32
		Expression: false
		IRs:
			RETURN False
	Function PredicateHelper.and(uint256,bytes)
		IRs:
			offsets_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1492'])
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: (current = uint32(offsets >> i)) != 0
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_1428(uint256) = offsets_1 >> i_2
			TMP_1429 = CONVERT TMP_1428 to uint32
			current_1(uint256) := TMP_1429(uint32)
			TMP_1430(bool) = current_1 != 0
			CONDITION TMP_1430
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_18(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_18 index: 0 
			res_1(uint256)= UNPACK TUPLE_18 index: 1 
		Expression: ! success || res != 1
		IRs:
			TMP_1431 = UnaryType.BANG success_1 
			TMP_1432(bool) = res_1 != 1
			TMP_1433(bool) = TMP_1431 || TMP_1432
			CONDITION TMP_1433
		Expression: false
		IRs:
			RETURN False
		Expression: previous = current
		IRs:
			previous_1(uint256) := current_1(uint256)
		Expression: i += 32
		IRs:
			i_3(uint256) = i_2 (c)+ 32
		Expression: true
		IRs:
			RETURN True
	Function PredicateHelper.eq(uint256,bytes)
		IRs:
			value_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1488'])
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_19(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_19 index: 0 
			res_1(uint256)= UNPACK TUPLE_19 index: 1 
		Expression: success && res == value
		IRs:
			TMP_1434(bool) = res_1 == value_1
			TMP_1435(bool) = success_1 && TMP_1434
			RETURN TMP_1435
	Function PredicateHelper.lt(uint256,bytes)
		IRs:
			value_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1494'])
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_20(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_20 index: 0 
			res_1(uint256)= UNPACK TUPLE_20 index: 1 
		Expression: success && res < value
		IRs:
			TMP_1436(bool) = res_1 < value_1
			TMP_1437(bool) = success_1 && TMP_1436
			RETURN TMP_1437
	Function PredicateHelper.gt(uint256,bytes)
		IRs:
			value_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1485'])
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_21(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_21 index: 0 
			res_1(uint256)= UNPACK TUPLE_21 index: 1 
		Expression: success && res > value
		IRs:
			TMP_1438(bool) = res_1 > value_1
			TMP_1439(bool) = success_1 && TMP_1438
			RETURN TMP_1439
	Function PredicateHelper.timestampBelow(uint256)
		IRs:
			time_1(uint256) := ϕ(['arg_1', '_time_1'])
		Expression: block.timestamp < time
		IRs:
			TMP_1440(bool) = block.timestamp < time_1
			RETURN TMP_1440
	Function PredicateHelper.arbitraryStaticCall(address,bytes)
		IRs:
			target_1(address) := ϕ(['TMP_1474'])
			data_1(bytes) := ϕ(['TMP_1475'])
		Expression: (success,res) = _staticcallForUint(target,data)
		IRs:
			TUPLE_22(bool,uint256) = INTERNAL_CALL, PredicateHelper._staticcallForUint(address,bytes)(target_1,data_1)
			success_1(bool)= UNPACK TUPLE_22 index: 0 
			res_1(uint256)= UNPACK TUPLE_22 index: 1 
		Expression: ! success
		IRs:
			TMP_1441 = UnaryType.BANG success_1 
			CONDITION TMP_1441
		Expression: revert ArbitraryStaticCallFailed()()
		IRs:
			TMP_1442(None) = SOLIDITY_CALL revert ArbitraryStaticCallFailed()()
		Expression: res
		IRs:
			RETURN res_1
	Function PredicateHelper.timestampBelowAndNonceEquals(uint256)
		IRs:
			timeNonceAccount_1(uint256) := ϕ(['arg_1'])
		Expression: _time = uint48(timeNonceAccount >> 208)
		IRs:
			TMP_1443(uint256) = timeNonceAccount_1 >> 208
			TMP_1444 = CONVERT TMP_1443 to uint48
			_time_1(uint256) := TMP_1444(uint48)
		Expression: _nonce = uint48(timeNonceAccount >> 160)
		IRs:
			TMP_1445(uint256) = timeNonceAccount_1 >> 160
			TMP_1446 = CONVERT TMP_1445 to uint48
			_nonce_1(uint256) := TMP_1446(uint48)
		Expression: _account = address(uint160(timeNonceAccount))
		IRs:
			TMP_1447 = CONVERT timeNonceAccount_1 to uint160
			TMP_1448 = CONVERT TMP_1447 to address
			_account_1(address) := TMP_1448(address)
		Expression: timestampBelow(_time) && nonceEquals(_account,_nonce)
		IRs:
			TMP_1449(bool) = INTERNAL_CALL, PredicateHelper.timestampBelow(uint256)(_time_1)
			TMP_1450(bool) = INTERNAL_CALL, NonceManager.nonceEquals(address,uint256)(_account_1,_nonce_1)
			TMP_1451(bool) = TMP_1449 && TMP_1450
			RETURN TMP_1451
	Function PredicateHelper._selfStaticCall(bytes)
		IRs:
			data_1(bytes) := ϕ(['data_1', 'data_1', 'data_1', 'data_1', 'TMP_1379', 'data_1'])
		Expression: selector = uint32(data.decodeSelector())
		IRs:
			TMP_1452(bytes4) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeSelector(bytes), arguments:['data_1'] 
			TMP_1453 = CONVERT TMP_1452 to uint32
			selector_1(uint256) := TMP_1453(uint32)
		Expression: arg = data.decodeUint256(4)
		IRs:
			TMP_1454(uint256) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeUint256(bytes,uint256), arguments:['data_1', '4'] 
			arg_1(uint256) := TMP_1454(uint256)
		Expression: selector == uint32(this.timestampBelowAndNonceEquals.selector)
		IRs:
			REF_439(bytes4) (->None) := 750946189(bytes4)
			TMP_1455 = CONVERT REF_439 to uint32
			TMP_1456(bool) = selector_1 == TMP_1455
			CONDITION TMP_1456
		Expression: selector < uint32(this.arbitraryStaticCall.selector)
		IRs:
			REF_441(bytes4) (->None) := 3205889240(bytes4)
			TMP_1457 = CONVERT REF_441 to uint32
			TMP_1458(bool) = selector_1 < TMP_1457
			CONDITION TMP_1458
		Expression: selector < uint32(this.eq.selector)
		IRs:
			REF_443(bytes4) (->None) := 1877455034(bytes4)
			TMP_1459 = CONVERT REF_443 to uint32
			TMP_1460(bool) = selector_1 < TMP_1459
			CONDITION TMP_1460
		Expression: selector == uint32(this.gt.selector)
		IRs:
			REF_445(bytes4) (->None) := 1329128120(bytes4)
			TMP_1461 = CONVERT REF_445 to uint32
			TMP_1462(bool) = selector_1 == TMP_1461
			CONDITION TMP_1462
		Expression: selector == uint32(this.timestampBelow.selector)
		IRs:
			REF_447(bytes4) (->None) := 1666788395(bytes4)
			TMP_1463 = CONVERT REF_447 to uint32
			TMP_1464(bool) = selector_1 == TMP_1463
			CONDITION TMP_1464
		Expression: selector == uint32(this.eq.selector)
		IRs:
			REF_449(bytes4) (->None) := 1877455034(bytes4)
			TMP_1465 = CONVERT REF_449 to uint32
			TMP_1466(bool) = selector_1 == TMP_1465
			CONDITION TMP_1466
		Expression: selector == uint32(this.or.selector)
		IRs:
			REF_451(bytes4) (->None) := 1948651845(bytes4)
			TMP_1467 = CONVERT REF_451 to uint32
			TMP_1468(bool) = selector_1 == TMP_1467
			CONDITION TMP_1468
		Expression: selector < uint32(this.lt.selector)
		IRs:
			REF_453(bytes4) (->None) := 3394162210(bytes4)
			TMP_1469 = CONVERT REF_453 to uint32
			TMP_1470(bool) = selector_1 < TMP_1469
			CONDITION TMP_1470
		Expression: selector == uint32(this.arbitraryStaticCall.selector)
		IRs:
			REF_455(bytes4) (->None) := 3205889240(bytes4)
			TMP_1471 = CONVERT REF_455 to uint32
			TMP_1472(bool) = selector_1 == TMP_1471
			CONDITION TMP_1472
		Expression: (true,arbitraryStaticCall(address(uint160(arg)),data.decodeTailCalldata(100)))
		IRs:
			TMP_1473 = CONVERT arg_1 to uint160
			TMP_1474 = CONVERT TMP_1473 to address
			TMP_1475(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1476(uint256) = INTERNAL_CALL, PredicateHelper.arbitraryStaticCall(address,bytes)(TMP_1474,TMP_1475)
			RETURN True,TMP_1476
		Expression: selector == uint32(this.and.selector)
		IRs:
			REF_458(bytes4) (->None) := 3215413571(bytes4)
			TMP_1477 = CONVERT REF_458 to uint32
			TMP_1478(bool) = selector_1 == TMP_1477
			CONDITION TMP_1478
		Expression: selector == uint32(this.lt.selector)
		IRs:
			REF_460(bytes4) (->None) := 3394162210(bytes4)
			TMP_1479 = CONVERT REF_460 to uint32
			TMP_1480(bool) = selector_1 == TMP_1479
			CONDITION TMP_1480
		Expression: selector == uint32(this.nonceEquals.selector)
		IRs:
			REF_462(bytes4) (->None) := 3480209123(bytes4)
			TMP_1481 = CONVERT REF_462 to uint32
			TMP_1482(bool) = selector_1 == TMP_1481
			CONDITION TMP_1482
		Expression: _staticcallForUint(address(this),data)
		IRs:
			TMP_1483 = CONVERT this to address
			TUPLE_23(bool,uint256) = INTERNAL_CALL, PredicateHelper._staticcallForUint(address,bytes)(TMP_1483,data_1)
			RETURN TUPLE_23
		Expression: timestampBelowAndNonceEquals(arg)
		IRs:
			TMP_1484(bool) = INTERNAL_CALL, PredicateHelper.timestampBelowAndNonceEquals(uint256)(arg_1)
			CONDITION TMP_1484
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: gt(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1485(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1486(bool) = INTERNAL_CALL, PredicateHelper.gt(uint256,bytes)(arg_1,TMP_1485)
			CONDITION TMP_1486
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: timestampBelow(arg)
		IRs:
			TMP_1487(bool) = INTERNAL_CALL, PredicateHelper.timestampBelow(uint256)(arg_1)
			CONDITION TMP_1487
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: eq(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1488(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1489(bool) = INTERNAL_CALL, PredicateHelper.eq(uint256,bytes)(arg_1,TMP_1488)
			CONDITION TMP_1489
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: or(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1490(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1491(bool) = INTERNAL_CALL, PredicateHelper.or(uint256,bytes)(arg_1,TMP_1490)
			CONDITION TMP_1491
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: and(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1492(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1493(bool) = INTERNAL_CALL, PredicateHelper.and(uint256,bytes)(arg_1,TMP_1492)
			CONDITION TMP_1493
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: lt(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1494(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1495(bool) = INTERNAL_CALL, PredicateHelper.lt(uint256,bytes)(arg_1,TMP_1494)
			CONDITION TMP_1495
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: nonceEquals(address(uint160(arg)),data.decodeUint256(0x24))
		IRs:
			TMP_1496 = CONVERT arg_1 to uint160
			TMP_1497 = CONVERT TMP_1496 to address
			TMP_1498(uint256) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeUint256(bytes,uint256), arguments:['data_1', '36'] 
			TMP_1499(bool) = INTERNAL_CALL, NonceManager.nonceEquals(address,uint256)(TMP_1497,TMP_1498)
			CONDITION TMP_1499
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
	Function PredicateHelper._staticcallForUint(address,bytes)
		IRs:
			target_1(address) := ϕ(['target_1', 'TMP_1483'])
			input_1(bytes) := ϕ(['data_1', 'data_1'])
		Expression: data__staticcallForUint_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_1500(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data__staticcallForUint_asm_0_1(uint256) := TMP_1500(uint256)
		Expression: calldatacopy(uint256,uint256,uint256)(data__staticcallForUint_asm_0,input,input)
		IRs:
			TMP_1501(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(data__staticcallForUint_asm_0_1,input_1,input_1)
		Expression: success = staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),target,data__staticcallForUint_asm_0,input,0x0,0x20)
		IRs:
			TMP_1502(uint256) = SOLIDITY_CALL gas()()
			TMP_1503(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_1502,target_1,data__staticcallForUint_asm_0_1,input_1,0,32)
			success_1(bool) := TMP_1503(uint256)
		Expression: success = success & returndatasize()() == 32
		IRs:
			TMP_1504(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_1505(bool) = TMP_1504 == 32
			TMP_1506(bool) = success_1 & TMP_1505
			success_2(bool) := TMP_1506(bool)
		Expression: success
		IRs:
			CONDITION success_2
		IRs:
			res_2(uint256) := ϕ(['res_0', 'res_1'])
		Expression: res = mload(uint256)(0)
		IRs:
			TMP_1507(uint256) = SOLIDITY_CALL mload(uint256)(0)
			res_1(uint256) := TMP_1507(uint256)
		Expression: (success,res)
		IRs:
			RETURN success_2,res_2
	Function NonceManager.increaseNonce()
		Expression: advanceNonce(1)
		IRs:
			INTERNAL_CALL, NonceManager.advanceNonce(uint256)(1)
	Function NonceManager.advanceNonce(uint256)
		IRs:
			nonce_1(mapping(address => uint256)) := ϕ(['nonce_0', 'nonce_2', 'nonce_3'])
		Expression: amount == 0 || amount > 255
		IRs:
			TMP_1509(bool) = amount_1 == 0
			TMP_1510(bool) = amount_1 > 255
			TMP_1511(bool) = TMP_1509 || TMP_1510
			CONDITION TMP_1511
		Expression: revert AdvanceNonceFailed()()
		IRs:
			TMP_1512(None) = SOLIDITY_CALL revert AdvanceNonceFailed()()
		Expression: newNonce = nonce[msg.sender] + amount
		IRs:
			REF_469(uint256) -> nonce_1[msg.sender]
			TMP_1513(uint256) = REF_469 + amount_1
			newNonce_1(uint256) := TMP_1513(uint256)
		Expression: nonce[msg.sender] = newNonce
		IRs:
			REF_470(uint256) -> nonce_1[msg.sender]
			nonce_2(mapping(address => uint256)) := ϕ(['nonce_1'])
			REF_470(uint256) (->nonce_2) := newNonce_1(uint256)
		Expression: NonceIncreased(msg.sender,newNonce)
		IRs:
			Emit NonceIncreased(msg.sender,newNonce_1)
	Function NonceManager.nonceEquals(address,uint256)
		IRs:
			makerAddress_1(address) := ϕ(['_account_1', 'TMP_1497'])
			makerNonce_1(uint256) := ϕ(['TMP_1498', '_nonce_1'])
			nonce_3(mapping(address => uint256)) := ϕ(['nonce_0', 'nonce_2', 'nonce_3'])
		Expression: nonce[makerAddress] == makerNonce
		IRs:
			REF_471(uint256) -> nonce_3[makerAddress_1]
			TMP_1515(bool) = REF_471 == makerNonce_1
			RETURN TMP_1515
	Function IOrderMixin.remaining(bytes32)
	Function IOrderMixin.remainingRaw(bytes32)
	Function IOrderMixin.remainingsRaw(bytes32[])
	Function IOrderMixin.checkPredicate(OrderLib.Order)
	Function IOrderMixin.hashOrder(OrderLib.Order)
	Function IOrderMixin.simulate(address,bytes)
	Function IOrderMixin.cancelOrder(OrderLib.Order)
	Function IOrderMixin.fillOrder(OrderLib.Order,bytes,bytes,uint256,uint256,uint256)
	Function IOrderMixin.fillOrderToWithPermit(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address,bytes)
	Function IOrderMixin.fillOrderTo(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address)
	Function LimitOrderProtocol.constructor(IWETH)
		Expression: OrderMixin(_weth)
		IRs:
			INTERNAL_CALL, OrderMixin.constructor(IWETH)(_weth_1)
		Expression: OrderRFQMixin(_weth)
		IRs:
			INTERNAL_CALL, OrderRFQMixin.constructor(IWETH)(_weth_1)
	Function LimitOrderProtocol.DOMAIN_SEPARATOR()
		Expression: _domainSeparatorV4()
		IRs:
			TMP_1518(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			RETURN TMP_1518
Contract OrderLib
	Function OrderLib.getterIsFrozen(bytes)
		Expression: getter.length == 1 && getter[0] == x
		IRs:
			REF_472 -> LENGTH getter_1
			TMP_1519(bool) = REF_472 == 1
			REF_473(None) -> getter_1[0]
			TMP_1520(bool) = REF_473 == x
			TMP_1521(bool) = TMP_1519 && TMP_1520
			RETURN TMP_1521
	Function OrderLib._get(OrderLib.Order,OrderLib.DynamicField)
		IRs:
			order_1(OrderLib.Order) := ϕ(['order_1', 'order_1', 'order_1', 'order_1', 'order_1', 'order_1', 'order_1', 'order_1'])
			field_1(OrderLib.DynamicField) := ϕ(['REF_476', 'REF_479', 'REF_481', 'REF_477', 'REF_482', 'REF_478', 'REF_480', 'REF_475'])
		Expression: bitShift = uint256(field) << 5
		IRs:
			TMP_1522 = CONVERT field_1 to uint256
			TMP_1523(uint256) = TMP_1522 << 5
			bitShift_1(uint256) := TMP_1523(uint256)
		Expression: order.interactions
		IRs:
			REF_474(bytes) -> order_1.interactions
			RETURN REF_474
	Function OrderLib.makerAssetData(OrderLib.Order)
		Expression: _get(order,DynamicField.MakerAssetData)
		IRs:
			REF_475(OrderLib.DynamicField) -> DynamicField.MakerAssetData
			TMP_1524(bytes) = INTERNAL_CALL, OrderLib._get(OrderLib.Order,OrderLib.DynamicField)(order_1,REF_475)
			RETURN TMP_1524
	Function OrderLib.takerAssetData(OrderLib.Order)
		Expression: _get(order,DynamicField.TakerAssetData)
		IRs:
			REF_476(OrderLib.DynamicField) -> DynamicField.TakerAssetData
			TMP_1525(bytes) = INTERNAL_CALL, OrderLib._get(OrderLib.Order,OrderLib.DynamicField)(order_1,REF_476)
			RETURN TMP_1525
	Function OrderLib.getMakingAmount(OrderLib.Order)
		Expression: _get(order,DynamicField.GetMakingAmount)
		IRs:
			REF_477(OrderLib.DynamicField) -> DynamicField.GetMakingAmount
			TMP_1526(bytes) = INTERNAL_CALL, OrderLib._get(OrderLib.Order,OrderLib.DynamicField)(order_1,REF_477)
			RETURN TMP_1526
	Function OrderLib.getTakingAmount(OrderLib.Order)
		Expression: _get(order,DynamicField.GetTakingAmount)
		IRs:
			REF_478(OrderLib.DynamicField) -> DynamicField.GetTakingAmount
			TMP_1527(bytes) = INTERNAL_CALL, OrderLib._get(OrderLib.Order,OrderLib.DynamicField)(order_1,REF_478)
			RETURN TMP_1527
	Function OrderLib.predicate(OrderLib.Order)
		Expression: _get(order,DynamicField.Predicate)
		IRs:
			REF_479(OrderLib.DynamicField) -> DynamicField.Predicate
			TMP_1528(bytes) = INTERNAL_CALL, OrderLib._get(OrderLib.Order,OrderLib.DynamicField)(order_1,REF_479)
			RETURN TMP_1528
	Function OrderLib.permit(OrderLib.Order)
		Expression: _get(order,DynamicField.Permit)
		IRs:
			REF_480(OrderLib.DynamicField) -> DynamicField.Permit
			TMP_1529(bytes) = INTERNAL_CALL, OrderLib._get(OrderLib.Order,OrderLib.DynamicField)(order_1,REF_480)
			RETURN TMP_1529
	Function OrderLib.preInteraction(OrderLib.Order)
		Expression: _get(order,DynamicField.PreInteraction)
		IRs:
			REF_481(OrderLib.DynamicField) -> DynamicField.PreInteraction
			TMP_1530(bytes) = INTERNAL_CALL, OrderLib._get(OrderLib.Order,OrderLib.DynamicField)(order_1,REF_481)
			RETURN TMP_1530
	Function OrderLib.postInteraction(OrderLib.Order)
		Expression: _get(order,DynamicField.PostInteraction)
		IRs:
			REF_482(OrderLib.DynamicField) -> DynamicField.PostInteraction
			TMP_1531(bytes) = INTERNAL_CALL, OrderLib._get(OrderLib.Order,OrderLib.DynamicField)(order_1,REF_482)
			RETURN TMP_1531
	Function OrderLib.hash(OrderLib.Order,bytes32)
		IRs:
			_LIMIT_ORDER_TYPEHASH_1(bytes32) := ϕ(['_LIMIT_ORDER_TYPEHASH_0'])
		Expression: interactions = order.interactions
		IRs:
			REF_483(bytes) -> order_1.interactions
			interactions_1(bytes) := REF_483(bytes)
		Expression: typehash = _LIMIT_ORDER_TYPEHASH
		IRs:
			typehash_1(bytes32) := _LIMIT_ORDER_TYPEHASH_1(bytes32)
		Expression: ptr_hash_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_1532(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_hash_asm_0_1(uint256) := TMP_1532(uint256)
		Expression: calldatacopy(uint256,uint256,uint256)(ptr_hash_asm_0,interactions,interactions)
		IRs:
			TMP_1533(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(ptr_hash_asm_0_1,interactions_1,interactions_1)
		Expression: mstore(uint256,uint256)(ptr_hash_asm_0 + 0x140,keccak256(uint256,uint256)(ptr_hash_asm_0,interactions))
		IRs:
			TMP_1534(uint256) = ptr_hash_asm_0_1 + 320
			TMP_1535(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(ptr_hash_asm_0_1,interactions_1)
			TMP_1536(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_1534,TMP_1535)
		Expression: calldatacopy(uint256,uint256,uint256)(ptr_hash_asm_0 + 0x20,order,0x120)
		IRs:
			TMP_1537(uint256) = ptr_hash_asm_0_1 + 32
			TMP_1538(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_1537,order_1,288)
		Expression: mstore(uint256,uint256)(ptr_hash_asm_0,typehash)
		IRs:
			TMP_1539(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_hash_asm_0_1,typehash_1)
		Expression: result = keccak256(uint256,uint256)(ptr_hash_asm_0,0x160)
		IRs:
			TMP_1540(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(ptr_hash_asm_0_1,352)
			result_1(bytes32) := TMP_1540(uint256)
		Expression: result = ECDSA.toTypedDataHash(domainSeparator,result)
		IRs:
			TMP_1541(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['domainSeparator_1', 'result_1'] 
			result_2(bytes32) := TMP_1541(bytes32)
		Expression: result
		IRs:
			RETURN result_2
	Function OrderLib.slitherConstructorConstantVariables()
		Expression: _LIMIT_ORDER_TYPEHASH = keccak256(bytes)(Order(uint256 salt,address makerAsset,address takerAsset,address maker,address receiver,address allowedSender,uint256 makingAmount,uint256 takingAmount,uint256 offsets,bytes interactions))
Contract OrderMixin
	Function PredicateHelper.or(uint256,bytes)
		IRs:
			offsets_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1610'])
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: (current = uint32(offsets >> i)) != 0
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_1543(uint256) = offsets_1 >> i_2
			TMP_1544 = CONVERT TMP_1543 to uint32
			current_1(uint256) := TMP_1544(uint32)
			TMP_1545(bool) = current_1 != 0
			CONDITION TMP_1545
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_24(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_24 index: 0 
			res_1(uint256)= UNPACK TUPLE_24 index: 1 
		Expression: success && res == 1
		IRs:
			TMP_1546(bool) = res_1 == 1
			TMP_1547(bool) = success_1 && TMP_1546
			CONDITION TMP_1547
		Expression: true
		IRs:
			RETURN True
		Expression: previous = current
		IRs:
			previous_1(uint256) := current_1(uint256)
		Expression: i += 32
		IRs:
			i_3(uint256) = i_2 (c)+ 32
		Expression: false
		IRs:
			RETURN False
	Function PredicateHelper.and(uint256,bytes)
		IRs:
			offsets_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1612'])
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: (current = uint32(offsets >> i)) != 0
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_1548(uint256) = offsets_1 >> i_2
			TMP_1549 = CONVERT TMP_1548 to uint32
			current_1(uint256) := TMP_1549(uint32)
			TMP_1550(bool) = current_1 != 0
			CONDITION TMP_1550
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_25(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_25 index: 0 
			res_1(uint256)= UNPACK TUPLE_25 index: 1 
		Expression: ! success || res != 1
		IRs:
			TMP_1551 = UnaryType.BANG success_1 
			TMP_1552(bool) = res_1 != 1
			TMP_1553(bool) = TMP_1551 || TMP_1552
			CONDITION TMP_1553
		Expression: false
		IRs:
			RETURN False
		Expression: previous = current
		IRs:
			previous_1(uint256) := current_1(uint256)
		Expression: i += 32
		IRs:
			i_3(uint256) = i_2 (c)+ 32
		Expression: true
		IRs:
			RETURN True
	Function PredicateHelper.eq(uint256,bytes)
		IRs:
			value_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1608'])
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_26(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_26 index: 0 
			res_1(uint256)= UNPACK TUPLE_26 index: 1 
		Expression: success && res == value
		IRs:
			TMP_1554(bool) = res_1 == value_1
			TMP_1555(bool) = success_1 && TMP_1554
			RETURN TMP_1555
	Function PredicateHelper.lt(uint256,bytes)
		IRs:
			value_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1614'])
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_27(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_27 index: 0 
			res_1(uint256)= UNPACK TUPLE_27 index: 1 
		Expression: success && res < value
		IRs:
			TMP_1556(bool) = res_1 < value_1
			TMP_1557(bool) = success_1 && TMP_1556
			RETURN TMP_1557
	Function PredicateHelper.gt(uint256,bytes)
		IRs:
			value_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_1605'])
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_28(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_28 index: 0 
			res_1(uint256)= UNPACK TUPLE_28 index: 1 
		Expression: success && res > value
		IRs:
			TMP_1558(bool) = res_1 > value_1
			TMP_1559(bool) = success_1 && TMP_1558
			RETURN TMP_1559
	Function PredicateHelper.timestampBelow(uint256)
		IRs:
			time_1(uint256) := ϕ(['_time_1', 'arg_1'])
		Expression: block.timestamp < time
		IRs:
			TMP_1560(bool) = block.timestamp < time_1
			RETURN TMP_1560
	Function PredicateHelper.arbitraryStaticCall(address,bytes)
		IRs:
			target_1(address) := ϕ(['TMP_1594'])
			data_1(bytes) := ϕ(['TMP_1595'])
		Expression: (success,res) = _staticcallForUint(target,data)
		IRs:
			TUPLE_29(bool,uint256) = INTERNAL_CALL, PredicateHelper._staticcallForUint(address,bytes)(target_1,data_1)
			success_1(bool)= UNPACK TUPLE_29 index: 0 
			res_1(uint256)= UNPACK TUPLE_29 index: 1 
		Expression: ! success
		IRs:
			TMP_1561 = UnaryType.BANG success_1 
			CONDITION TMP_1561
		Expression: revert ArbitraryStaticCallFailed()()
		IRs:
			TMP_1562(None) = SOLIDITY_CALL revert ArbitraryStaticCallFailed()()
		Expression: res
		IRs:
			RETURN res_1
	Function PredicateHelper.timestampBelowAndNonceEquals(uint256)
		IRs:
			timeNonceAccount_1(uint256) := ϕ(['arg_1'])
		Expression: _time = uint48(timeNonceAccount >> 208)
		IRs:
			TMP_1563(uint256) = timeNonceAccount_1 >> 208
			TMP_1564 = CONVERT TMP_1563 to uint48
			_time_1(uint256) := TMP_1564(uint48)
		Expression: _nonce = uint48(timeNonceAccount >> 160)
		IRs:
			TMP_1565(uint256) = timeNonceAccount_1 >> 160
			TMP_1566 = CONVERT TMP_1565 to uint48
			_nonce_1(uint256) := TMP_1566(uint48)
		Expression: _account = address(uint160(timeNonceAccount))
		IRs:
			TMP_1567 = CONVERT timeNonceAccount_1 to uint160
			TMP_1568 = CONVERT TMP_1567 to address
			_account_1(address) := TMP_1568(address)
		Expression: timestampBelow(_time) && nonceEquals(_account,_nonce)
		IRs:
			TMP_1569(bool) = INTERNAL_CALL, PredicateHelper.timestampBelow(uint256)(_time_1)
			TMP_1570(bool) = INTERNAL_CALL, NonceManager.nonceEquals(address,uint256)(_account_1,_nonce_1)
			TMP_1571(bool) = TMP_1569 && TMP_1570
			RETURN TMP_1571
	Function PredicateHelper._selfStaticCall(bytes)
		IRs:
			data_1(bytes) := ϕ(['data_1', 'data_1', 'data_1', 'data_1', 'TMP_1784', 'data_1'])
		Expression: selector = uint32(data.decodeSelector())
		IRs:
			TMP_1572(bytes4) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeSelector(bytes), arguments:['data_1'] 
			TMP_1573 = CONVERT TMP_1572 to uint32
			selector_1(uint256) := TMP_1573(uint32)
		Expression: arg = data.decodeUint256(4)
		IRs:
			TMP_1574(uint256) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeUint256(bytes,uint256), arguments:['data_1', '4'] 
			arg_1(uint256) := TMP_1574(uint256)
		Expression: selector == uint32(this.timestampBelowAndNonceEquals.selector)
		IRs:
			REF_488(bytes4) (->None) := 750946189(bytes4)
			TMP_1575 = CONVERT REF_488 to uint32
			TMP_1576(bool) = selector_1 == TMP_1575
			CONDITION TMP_1576
		Expression: selector < uint32(this.arbitraryStaticCall.selector)
		IRs:
			REF_490(bytes4) (->None) := 3205889240(bytes4)
			TMP_1577 = CONVERT REF_490 to uint32
			TMP_1578(bool) = selector_1 < TMP_1577
			CONDITION TMP_1578
		Expression: selector < uint32(this.eq.selector)
		IRs:
			REF_492(bytes4) (->None) := 1877455034(bytes4)
			TMP_1579 = CONVERT REF_492 to uint32
			TMP_1580(bool) = selector_1 < TMP_1579
			CONDITION TMP_1580
		Expression: selector == uint32(this.gt.selector)
		IRs:
			REF_494(bytes4) (->None) := 1329128120(bytes4)
			TMP_1581 = CONVERT REF_494 to uint32
			TMP_1582(bool) = selector_1 == TMP_1581
			CONDITION TMP_1582
		Expression: selector == uint32(this.timestampBelow.selector)
		IRs:
			REF_496(bytes4) (->None) := 1666788395(bytes4)
			TMP_1583 = CONVERT REF_496 to uint32
			TMP_1584(bool) = selector_1 == TMP_1583
			CONDITION TMP_1584
		Expression: selector == uint32(this.eq.selector)
		IRs:
			REF_498(bytes4) (->None) := 1877455034(bytes4)
			TMP_1585 = CONVERT REF_498 to uint32
			TMP_1586(bool) = selector_1 == TMP_1585
			CONDITION TMP_1586
		Expression: selector == uint32(this.or.selector)
		IRs:
			REF_500(bytes4) (->None) := 1948651845(bytes4)
			TMP_1587 = CONVERT REF_500 to uint32
			TMP_1588(bool) = selector_1 == TMP_1587
			CONDITION TMP_1588
		Expression: selector < uint32(this.lt.selector)
		IRs:
			REF_502(bytes4) (->None) := 3394162210(bytes4)
			TMP_1589 = CONVERT REF_502 to uint32
			TMP_1590(bool) = selector_1 < TMP_1589
			CONDITION TMP_1590
		Expression: selector == uint32(this.arbitraryStaticCall.selector)
		IRs:
			REF_504(bytes4) (->None) := 3205889240(bytes4)
			TMP_1591 = CONVERT REF_504 to uint32
			TMP_1592(bool) = selector_1 == TMP_1591
			CONDITION TMP_1592
		Expression: (true,arbitraryStaticCall(address(uint160(arg)),data.decodeTailCalldata(100)))
		IRs:
			TMP_1593 = CONVERT arg_1 to uint160
			TMP_1594 = CONVERT TMP_1593 to address
			TMP_1595(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1596(uint256) = INTERNAL_CALL, PredicateHelper.arbitraryStaticCall(address,bytes)(TMP_1594,TMP_1595)
			RETURN True,TMP_1596
		Expression: selector == uint32(this.and.selector)
		IRs:
			REF_507(bytes4) (->None) := 3215413571(bytes4)
			TMP_1597 = CONVERT REF_507 to uint32
			TMP_1598(bool) = selector_1 == TMP_1597
			CONDITION TMP_1598
		Expression: selector == uint32(this.lt.selector)
		IRs:
			REF_509(bytes4) (->None) := 3394162210(bytes4)
			TMP_1599 = CONVERT REF_509 to uint32
			TMP_1600(bool) = selector_1 == TMP_1599
			CONDITION TMP_1600
		Expression: selector == uint32(this.nonceEquals.selector)
		IRs:
			REF_511(bytes4) (->None) := 3480209123(bytes4)
			TMP_1601 = CONVERT REF_511 to uint32
			TMP_1602(bool) = selector_1 == TMP_1601
			CONDITION TMP_1602
		Expression: _staticcallForUint(address(this),data)
		IRs:
			TMP_1603 = CONVERT this to address
			TUPLE_30(bool,uint256) = INTERNAL_CALL, PredicateHelper._staticcallForUint(address,bytes)(TMP_1603,data_1)
			RETURN TUPLE_30
		Expression: timestampBelowAndNonceEquals(arg)
		IRs:
			TMP_1604(bool) = INTERNAL_CALL, PredicateHelper.timestampBelowAndNonceEquals(uint256)(arg_1)
			CONDITION TMP_1604
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: gt(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1605(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1606(bool) = INTERNAL_CALL, PredicateHelper.gt(uint256,bytes)(arg_1,TMP_1605)
			CONDITION TMP_1606
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: timestampBelow(arg)
		IRs:
			TMP_1607(bool) = INTERNAL_CALL, PredicateHelper.timestampBelow(uint256)(arg_1)
			CONDITION TMP_1607
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: eq(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1608(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1609(bool) = INTERNAL_CALL, PredicateHelper.eq(uint256,bytes)(arg_1,TMP_1608)
			CONDITION TMP_1609
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: or(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1610(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1611(bool) = INTERNAL_CALL, PredicateHelper.or(uint256,bytes)(arg_1,TMP_1610)
			CONDITION TMP_1611
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: and(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1612(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1613(bool) = INTERNAL_CALL, PredicateHelper.and(uint256,bytes)(arg_1,TMP_1612)
			CONDITION TMP_1613
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: lt(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_1614(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_1615(bool) = INTERNAL_CALL, PredicateHelper.lt(uint256,bytes)(arg_1,TMP_1614)
			CONDITION TMP_1615
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: nonceEquals(address(uint160(arg)),data.decodeUint256(0x24))
		IRs:
			TMP_1616 = CONVERT arg_1 to uint160
			TMP_1617 = CONVERT TMP_1616 to address
			TMP_1618(uint256) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeUint256(bytes,uint256), arguments:['data_1', '36'] 
			TMP_1619(bool) = INTERNAL_CALL, NonceManager.nonceEquals(address,uint256)(TMP_1617,TMP_1618)
			CONDITION TMP_1619
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
	Function PredicateHelper._staticcallForUint(address,bytes)
		IRs:
			target_1(address) := ϕ(['TMP_1603', 'target_1'])
			input_1(bytes) := ϕ(['data_1', 'data_1'])
		Expression: data__staticcallForUint_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_1620(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data__staticcallForUint_asm_0_1(uint256) := TMP_1620(uint256)
		Expression: calldatacopy(uint256,uint256,uint256)(data__staticcallForUint_asm_0,input,input)
		IRs:
			TMP_1621(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(data__staticcallForUint_asm_0_1,input_1,input_1)
		Expression: success = staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),target,data__staticcallForUint_asm_0,input,0x0,0x20)
		IRs:
			TMP_1622(uint256) = SOLIDITY_CALL gas()()
			TMP_1623(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_1622,target_1,data__staticcallForUint_asm_0_1,input_1,0,32)
			success_1(bool) := TMP_1623(uint256)
		Expression: success = success & returndatasize()() == 32
		IRs:
			TMP_1624(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_1625(bool) = TMP_1624 == 32
			TMP_1626(bool) = success_1 & TMP_1625
			success_2(bool) := TMP_1626(bool)
		Expression: success
		IRs:
			CONDITION success_2
		IRs:
			res_2(uint256) := ϕ(['res_1', 'res_0'])
		Expression: res = mload(uint256)(0)
		IRs:
			TMP_1627(uint256) = SOLIDITY_CALL mload(uint256)(0)
			res_1(uint256) := TMP_1627(uint256)
		Expression: (success,res)
		IRs:
			RETURN success_2,res_2
	Function NonceManager.increaseNonce()
		Expression: advanceNonce(1)
		IRs:
			INTERNAL_CALL, NonceManager.advanceNonce(uint256)(1)
	Function NonceManager.advanceNonce(uint256)
		IRs:
			nonce_1(mapping(address => uint256)) := ϕ(['nonce_2', 'nonce_3', 'nonce_0'])
		Expression: amount == 0 || amount > 255
		IRs:
			TMP_1629(bool) = amount_1 == 0
			TMP_1630(bool) = amount_1 > 255
			TMP_1631(bool) = TMP_1629 || TMP_1630
			CONDITION TMP_1631
		Expression: revert AdvanceNonceFailed()()
		IRs:
			TMP_1632(None) = SOLIDITY_CALL revert AdvanceNonceFailed()()
		Expression: newNonce = nonce[msg.sender] + amount
		IRs:
			REF_518(uint256) -> nonce_1[msg.sender]
			TMP_1633(uint256) = REF_518 + amount_1
			newNonce_1(uint256) := TMP_1633(uint256)
		Expression: nonce[msg.sender] = newNonce
		IRs:
			REF_519(uint256) -> nonce_1[msg.sender]
			nonce_2(mapping(address => uint256)) := ϕ(['nonce_1'])
			REF_519(uint256) (->nonce_2) := newNonce_1(uint256)
		Expression: NonceIncreased(msg.sender,newNonce)
		IRs:
			Emit NonceIncreased(msg.sender,newNonce_1)
	Function NonceManager.nonceEquals(address,uint256)
		IRs:
			makerAddress_1(address) := ϕ(['_account_1', 'TMP_1617'])
			makerNonce_1(uint256) := ϕ(['_nonce_1', 'TMP_1618'])
			nonce_3(mapping(address => uint256)) := ϕ(['nonce_2', 'nonce_3', 'nonce_0'])
		Expression: nonce[makerAddress] == makerNonce
		IRs:
			REF_520(uint256) -> nonce_3[makerAddress_1]
			TMP_1635(bool) = REF_520 == makerNonce_1
			RETURN TMP_1635
	Function EIP712.constructor(string,string)
		Expression: hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_1636 = CONVERT name_1 to bytes
			TMP_1637(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1636)
			hashedName_1(bytes32) := TMP_1637(bytes32)
		Expression: hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_1638 = CONVERT version_1 to bytes
			TMP_1639(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1638)
			hashedVersion_1(bytes32) := TMP_1639(bytes32)
		Expression: typeHash = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
		IRs:
			TMP_1640(bytes32) = SOLIDITY_CALL keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
			typeHash_1(bytes32) := TMP_1640(bytes32)
		Expression: _HASHED_NAME = hashedName
		IRs:
			_HASHED_NAME_1(bytes32) := hashedName_1(bytes32)
		Expression: _HASHED_VERSION = hashedVersion
		IRs:
			_HASHED_VERSION_1(bytes32) := hashedVersion_1(bytes32)
		Expression: _CACHED_CHAIN_ID = block.chainid
		IRs:
			_CACHED_CHAIN_ID_1(uint256) := block.chainid(uint256)
		Expression: _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash,hashedName,hashedVersion)
		IRs:
			TMP_1641(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(typeHash_1,hashedName_1,hashedVersion_1)
			_CACHED_DOMAIN_SEPARATOR_1(bytes32) := TMP_1641(bytes32)
		Expression: _CACHED_THIS = address(this)
		IRs:
			TMP_1642 = CONVERT this to address
			_CACHED_THIS_1(address) := TMP_1642(address)
		Expression: _TYPE_HASH = typeHash
		IRs:
			_TYPE_HASH_1(bytes32) := typeHash_1(bytes32)
	Function EIP712._domainSeparatorV4()
		IRs:
			_CACHED_DOMAIN_SEPARATOR_2(bytes32) := ϕ(['_CACHED_DOMAIN_SEPARATOR_1', '_CACHED_DOMAIN_SEPARATOR_0'])
			_CACHED_CHAIN_ID_2(uint256) := ϕ(['_CACHED_CHAIN_ID_0', '_CACHED_CHAIN_ID_1'])
			_CACHED_THIS_2(address) := ϕ(['_CACHED_THIS_0', '_CACHED_THIS_1'])
			_HASHED_NAME_2(bytes32) := ϕ(['_HASHED_NAME_1', '_HASHED_NAME_0', '_HASHED_NAME_3'])
			_HASHED_VERSION_2(bytes32) := ϕ(['_HASHED_VERSION_0', '_HASHED_VERSION_3', '_HASHED_VERSION_1'])
			_TYPE_HASH_2(bytes32) := ϕ(['_TYPE_HASH_0', '_TYPE_HASH_3', '_TYPE_HASH_1'])
		Expression: address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID
		IRs:
			TMP_1643 = CONVERT this to address
			TMP_1644(bool) = TMP_1643 == _CACHED_THIS_2
			TMP_1645(bool) = block.chainid == _CACHED_CHAIN_ID_2
			TMP_1646(bool) = TMP_1644 && TMP_1645
			CONDITION TMP_1646
		Expression: _CACHED_DOMAIN_SEPARATOR
		IRs:
			RETURN _CACHED_DOMAIN_SEPARATOR_2
		Expression: _buildDomainSeparator(_TYPE_HASH,_HASHED_NAME,_HASHED_VERSION)
		IRs:
			TMP_1647(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(_TYPE_HASH_2,_HASHED_NAME_2,_HASHED_VERSION_2)
			RETURN TMP_1647
	Function EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)
		IRs:
			typeHash_1(bytes32) := ϕ(['typeHash_1', '_TYPE_HASH_2'])
			nameHash_1(bytes32) := ϕ(['_HASHED_NAME_2', 'hashedName_1'])
			versionHash_1(bytes32) := ϕ(['hashedVersion_1', '_HASHED_VERSION_2'])
		Expression: keccak256(bytes)(abi.encode(typeHash,nameHash,versionHash,block.chainid,address(this)))
		IRs:
			TMP_1648 = CONVERT this to address
			TMP_1649(bytes) = SOLIDITY_CALL abi.encode()(typeHash_1,nameHash_1,versionHash_1,block.chainid,TMP_1648)
			TMP_1650(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1649)
			RETURN TMP_1650
	Function EIP712._hashTypedDataV4(bytes32)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_1651(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1652(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_1651', 'structHash_1'] 
			RETURN TMP_1652
	Function IOrderMixin.remaining(bytes32)
	Function IOrderMixin.remainingRaw(bytes32)
	Function IOrderMixin.remainingsRaw(bytes32[])
	Function IOrderMixin.checkPredicate(OrderLib.Order)
	Function IOrderMixin.hashOrder(OrderLib.Order)
	Function IOrderMixin.simulate(address,bytes)
	Function IOrderMixin.cancelOrder(OrderLib.Order)
	Function IOrderMixin.fillOrder(OrderLib.Order,bytes,bytes,uint256,uint256,uint256)
	Function IOrderMixin.fillOrderToWithPermit(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address,bytes)
	Function IOrderMixin.fillOrderTo(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address)
	Function OrderMixin.constructor(IWETH)
		IRs:
			weth_1(IWETH) := ϕ(['_weth_1'])
		Expression: _WETH = weth
		IRs:
			_WETH_1(IWETH) := weth_1(IWETH)
	Function OrderMixin.remaining(bytes32)
		IRs:
			_ORDER_DOES_NOT_EXIST_1(uint256) := ϕ(['_ORDER_DOES_NOT_EXIST_3', '_ORDER_DOES_NOT_EXIST_0'])
			_remaining_1(mapping(bytes32 => uint256)) := ϕ(['_remaining_0', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_1', '_remaining_9'])
		Expression: amount = _remaining[orderHash]
		IRs:
			REF_523(uint256) -> _remaining_1[orderHash_1]
			amount_1(uint256) := REF_523(uint256)
		Expression: amount == _ORDER_DOES_NOT_EXIST
		IRs:
			TMP_1653(bool) = amount_1 == _ORDER_DOES_NOT_EXIST_1
			CONDITION TMP_1653
		Expression: revert UnknownOrder()()
		IRs:
			TMP_1654(None) = SOLIDITY_CALL revert UnknownOrder()()
		Expression: amount - 1
		IRs:
			TMP_1655(uint256) = amount_1 - 1
			RETURN TMP_1655
	Function OrderMixin.remainingRaw(bytes32)
		IRs:
			_remaining_2(mapping(bytes32 => uint256)) := ϕ(['_remaining_0', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_1', '_remaining_9'])
		Expression: _remaining[orderHash]
		IRs:
			REF_524(uint256) -> _remaining_2[orderHash_1]
			RETURN REF_524
	Function OrderMixin.remainingsRaw(bytes32[])
		IRs:
			_remaining_3(mapping(bytes32 => uint256)) := ϕ(['_remaining_0', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_1', '_remaining_9'])
		Expression: results = new uint256[](orderHashes.length)
		IRs:
			REF_525 -> LENGTH orderHashes_1
			TMP_1657(uint256[])  = new uint256[](REF_525)
			results_1(uint256[]) = ['TMP_1657(uint256[])']
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < orderHashes.length
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			REF_526 -> LENGTH orderHashes_1
			TMP_1658(bool) = i_2 < REF_526
			CONDITION TMP_1658
		Expression: results[i] = _remaining[orderHashes[i]]
		IRs:
			REF_527(uint256) -> results_1[i_2]
			REF_528(bytes32) -> orderHashes_1[i_2]
			REF_529(uint256) -> _remaining_3[REF_528]
			results_2(uint256[]) := ϕ(['results_1'])
			REF_527(uint256) (->results_2) := REF_529(uint256)
		Expression: i ++
		IRs:
			TMP_1659(uint256) := i_2(uint256)
			i_3(uint256) = i_2 (c)+ 1
		Expression: results
		IRs:
			RETURN results_1
	Function OrderMixin.simulate(address,bytes)
		Expression: (success,result) = target.delegatecall(data)
		IRs:
			TUPLE_31(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:delegatecall, arguments:['data_1']  
			success_1(bool)= UNPACK TUPLE_31 index: 0 
			result_1(bytes)= UNPACK TUPLE_31 index: 1 
		Expression: revert SimulationResults(bool,bytes)(success,result)
		IRs:
			TMP_1660(None) = SOLIDITY_CALL revert SimulationResults(bool,bytes)(success_1,result_1)
	Function OrderMixin.cancelOrder(OrderLib.Order)
		IRs:
			_ORDER_FILLED_1(uint256) := ϕ(['_ORDER_FILLED_2', '_ORDER_FILLED_4', '_ORDER_FILLED_0'])
			_remaining_4(mapping(bytes32 => uint256)) := ϕ(['_remaining_0', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_1', '_remaining_9'])
		Expression: order.maker != msg.sender
		IRs:
			REF_531(address) -> order_1.maker
			TMP_1661(bool) = REF_531 != msg.sender
			CONDITION TMP_1661
		Expression: revert AccessDenied()()
		IRs:
			TMP_1662(None) = SOLIDITY_CALL revert AccessDenied()()
		Expression: orderHash = hashOrder(order)
		IRs:
			TMP_1663(bytes32) = INTERNAL_CALL, OrderMixin.hashOrder(OrderLib.Order)(order_1)
			orderHash_1(bytes32) := TMP_1663(bytes32)
		Expression: orderRemaining = _remaining[orderHash]
		IRs:
			REF_532(uint256) -> _remaining_5[orderHash_1]
			orderRemaining_1(uint256) := REF_532(uint256)
		Expression: orderRemaining == _ORDER_FILLED
		IRs:
			TMP_1664(bool) = orderRemaining_1 == _ORDER_FILLED_2
			CONDITION TMP_1664
		Expression: revert AlreadyFilled()()
		IRs:
			TMP_1665(None) = SOLIDITY_CALL revert AlreadyFilled()()
		Expression: OrderCanceled(msg.sender,orderHash,orderRemaining)
		IRs:
			Emit OrderCanceled(msg.sender,orderHash_1,orderRemaining_1)
		Expression: _remaining[orderHash] = _ORDER_FILLED
		IRs:
			REF_533(uint256) -> _remaining_5[orderHash_1]
			_remaining_6(mapping(bytes32 => uint256)) := ϕ(['_remaining_5'])
			REF_533(uint256) (->_remaining_6) := _ORDER_FILLED_2(uint256)
		Expression: (orderRemaining,orderHash)
		IRs:
			RETURN orderRemaining_1,orderHash_1
	Function OrderMixin.fillOrder(OrderLib.Order,bytes,bytes,uint256,uint256,uint256)
		Expression: fillOrderTo(order,signature,interaction,makingAmount,takingAmount,skipPermitAndThresholdAmount,msg.sender)
		IRs:
			TUPLE_32(uint256,uint256,bytes32) = INTERNAL_CALL, OrderMixin.fillOrderTo(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address)(order_1,signature_1,interaction_1,makingAmount_1,takingAmount_1,skipPermitAndThresholdAmount_1,msg.sender)
			RETURN TUPLE_32
	Function OrderMixin.fillOrderToWithPermit(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address,bytes)
		Expression: permit.length < 20
		IRs:
			REF_534 -> LENGTH permit_1
			TMP_1667(bool) = REF_534 < 20
			CONDITION TMP_1667
		Expression: revert PermitLengthTooLow()()
		IRs:
			TMP_1668(None) = SOLIDITY_CALL revert PermitLengthTooLow()()
		Expression: (token,permitData) = permit.decodeTargetAndCalldata()
		IRs:
			TUPLE_33(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['permit_1'] 
			token_1(address)= UNPACK TUPLE_33 index: 0 
			permitData_1(bytes)= UNPACK TUPLE_33 index: 1 
		Expression: IERC20(token).safePermit(permitData)
		IRs:
			TMP_1669 = CONVERT token_1 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['TMP_1669', 'permitData_1'] 
		Expression: fillOrderTo(order,signature,interaction,makingAmount,takingAmount,skipPermitAndThresholdAmount,target)
		IRs:
			TUPLE_34(uint256,uint256,bytes32) = INTERNAL_CALL, OrderMixin.fillOrderTo(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address)(order_1,signature_1,interaction_1,makingAmount_1,takingAmount_1,skipPermitAndThresholdAmount_1,target_1)
			RETURN TUPLE_34
	Function OrderMixin.fillOrderTo(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address)
		IRs:
			order__1(OrderLib.Order) := ϕ(['order_1', 'order_1'])
			signature_1(bytes) := ϕ(['signature_1', 'signature_1'])
			interaction_1(bytes) := ϕ(['interaction_1', 'interaction_1'])
			makingAmount_1(uint256) := ϕ(['makingAmount_1', 'makingAmount_1'])
			takingAmount_1(uint256) := ϕ(['takingAmount_1', 'takingAmount_1'])
			skipPermitAndThresholdAmount_1(uint256) := ϕ(['skipPermitAndThresholdAmount_1', 'skipPermitAndThresholdAmount_1'])
			target_1(address) := ϕ(['msg.sender', 'target_1'])
			_RAW_CALL_GAS_LIMIT_1(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_0', '_RAW_CALL_GAS_LIMIT_8', '_RAW_CALL_GAS_LIMIT_10', '_RAW_CALL_GAS_LIMIT_9'])
			_ORDER_DOES_NOT_EXIST_2(uint256) := ϕ(['_ORDER_DOES_NOT_EXIST_3', '_ORDER_DOES_NOT_EXIST_0'])
			_ORDER_FILLED_3(uint256) := ϕ(['_ORDER_FILLED_2', '_ORDER_FILLED_4', '_ORDER_FILLED_0'])
			_SKIP_PERMIT_FLAG_1(uint256) := ϕ(['_SKIP_PERMIT_FLAG_2', '_SKIP_PERMIT_FLAG_0'])
			_THRESHOLD_MASK_1(uint256) := ϕ(['_THRESHOLD_MASK_3', '_THRESHOLD_MASK_0', '_THRESHOLD_MASK_5', '_THRESHOLD_MASK_2', '_THRESHOLD_MASK_6', '_THRESHOLD_MASK_4'])
			_WETH_2(IWETH) := ϕ(['_WETH_1', '_WETH_14', '_WETH_11', '_WETH_0', '_WETH_10', '_WETH_9', '_WETH_13'])
			_remaining_7(mapping(bytes32 => uint256)) := ϕ(['_remaining_0', '_remaining_2', '_remaining_6', '_remaining_3', '_remaining_1', '_remaining_9'])
		Expression: target == address(0)
		IRs:
			TMP_1671 = CONVERT 0 to address
			TMP_1672(bool) = target_1 == TMP_1671
			CONDITION TMP_1672
		Expression: revert ZeroTargetIsForbidden()()
		IRs:
			TMP_1673(None) = SOLIDITY_CALL revert ZeroTargetIsForbidden()()
		Expression: orderHash = hashOrder(order_)
		IRs:
			TMP_1674(bytes32) = INTERNAL_CALL, OrderMixin.hashOrder(OrderLib.Order)(order__1)
			orderHash_1(bytes32) := TMP_1674(bytes32)
		Expression: order = order_
		IRs:
			order_1(OrderLib.Order) := order__1(OrderLib.Order)
		Expression: actualMakingAmount = makingAmount
		IRs:
			actualMakingAmount_1(uint256) := makingAmount_1(uint256)
		Expression: actualTakingAmount = takingAmount
		IRs:
			actualTakingAmount_1(uint256) := takingAmount_1(uint256)
		Expression: remainingMakingAmount = _remaining[orderHash]
		IRs:
			REF_537(uint256) -> _remaining_8[orderHash_1]
			remainingMakingAmount_1(uint256) := REF_537(uint256)
		Expression: remainingMakingAmount == _ORDER_FILLED
		IRs:
			TMP_1675(bool) = remainingMakingAmount_1 == _ORDER_FILLED_4
			CONDITION TMP_1675
		Expression: revert RemainingAmountIsZero()()
		IRs:
			TMP_1676(None) = SOLIDITY_CALL revert RemainingAmountIsZero()()
		Expression: order.allowedSender != address(0) && order.allowedSender != msg.sender
		IRs:
			REF_538(address) -> order_1.allowedSender
			TMP_1677 = CONVERT 0 to address
			TMP_1678(bool) = REF_538 != TMP_1677
			REF_539(address) -> order_1.allowedSender
			TMP_1679(bool) = REF_539 != msg.sender
			TMP_1680(bool) = TMP_1678 && TMP_1679
			CONDITION TMP_1680
		Expression: revert PrivateOrder()()
		IRs:
			TMP_1681(None) = SOLIDITY_CALL revert PrivateOrder()()
		Expression: remainingMakingAmount == _ORDER_DOES_NOT_EXIST
		IRs:
			TMP_1682(bool) = remainingMakingAmount_1 == _ORDER_DOES_NOT_EXIST_3
			CONDITION TMP_1682
		Expression: ! ECDSA.recoverOrIsValidSignature(order.maker,orderHash,signature)
		IRs:
			REF_541(address) -> order_1.maker
			TMP_1683(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recoverOrIsValidSignature(address,bytes32,bytes), arguments:['REF_541', 'orderHash_1', 'signature_1'] 
			TMP_1684 = UnaryType.BANG TMP_1683 
			CONDITION TMP_1684
		Expression: revert BadSignature()()
		IRs:
			TMP_1685(None) = SOLIDITY_CALL revert BadSignature()()
		Expression: remainingMakingAmount = order.makingAmount
		IRs:
			REF_542(uint256) -> order_1.makingAmount
			remainingMakingAmount_2(uint256) := REF_542(uint256)
		Expression: permit = order.permit()
		IRs:
			TMP_1686(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.permit(OrderLib.Order), arguments:['order_1'] 
			permit_1(bytes) := TMP_1686(bytes)
		Expression: skipPermitAndThresholdAmount & _SKIP_PERMIT_FLAG == 0 && permit.length >= 20
		IRs:
			TMP_1687(uint256) = skipPermitAndThresholdAmount_1 & _SKIP_PERMIT_FLAG_2
			TMP_1688(bool) = TMP_1687 == 0
			REF_544 -> LENGTH permit_1
			TMP_1689(bool) = REF_544 >= 20
			TMP_1690(bool) = TMP_1688 && TMP_1689
			CONDITION TMP_1690
		Expression: (token,permitCalldata) = permit.decodeTargetAndCalldata()
		IRs:
			TUPLE_35(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['permit_1'] 
			token_1(address)= UNPACK TUPLE_35 index: 0 
			permitCalldata_1(bytes)= UNPACK TUPLE_35 index: 1 
		Expression: IERC20(token).safePermit(permitCalldata)
		IRs:
			TMP_1691 = CONVERT token_1 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['TMP_1691', 'permitCalldata_1'] 
		Expression: _remaining[orderHash] != _ORDER_DOES_NOT_EXIST
		IRs:
			REF_547(uint256) -> _remaining_8[orderHash_1]
			TMP_1693(bool) = REF_547 != _ORDER_DOES_NOT_EXIST_3
			CONDITION TMP_1693
		Expression: revert ReentrancyDetected()()
		IRs:
			TMP_1694(None) = SOLIDITY_CALL revert ReentrancyDetected()()
		Expression: remainingMakingAmount -= 1
		IRs:
			remainingMakingAmount_3(uint256) = remainingMakingAmount_1 - 1
		IRs:
			remainingMakingAmount_4(uint256) := ϕ(['remainingMakingAmount_1', 'remainingMakingAmount_3', 'remainingMakingAmount_2'])
		Expression: order.predicate().length > 0
		IRs:
			TMP_1695(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.predicate(OrderLib.Order), arguments:['order_1'] 
			REF_549 -> LENGTH TMP_1695
			TMP_1696(bool) = REF_549 > 0
			CONDITION TMP_1696
		Expression: ! checkPredicate(order)
		IRs:
			TMP_1697(bool) = INTERNAL_CALL, OrderMixin.checkPredicate(OrderLib.Order)(order_1)
			TMP_1698 = UnaryType.BANG TMP_1697 
			CONDITION TMP_1698
		Expression: revert PredicateIsNotTrue()()
		IRs:
			TMP_1699(None) = SOLIDITY_CALL revert PredicateIsNotTrue()()
		Expression: (actualTakingAmount == 0) == (actualMakingAmount == 0)
		IRs:
			TMP_1700(bool) = actualTakingAmount_1 == 0
			TMP_1701(bool) = actualMakingAmount_1 == 0
			TMP_1702(bool) = TMP_1700 == TMP_1701
			CONDITION TMP_1702
		Expression: revert OnlyOneAmountShouldBeZero()()
		IRs:
			TMP_1703(None) = SOLIDITY_CALL revert OnlyOneAmountShouldBeZero()()
		Expression: actualTakingAmount == 0
		IRs:
			TMP_1704(bool) = actualTakingAmount_1 == 0
			CONDITION TMP_1704
		Expression: actualMakingAmount > remainingMakingAmount
		IRs:
			TMP_1705(bool) = actualMakingAmount_1 > remainingMakingAmount_4
			CONDITION TMP_1705
		Expression: actualMakingAmount = remainingMakingAmount
		IRs:
			actualMakingAmount_2(uint256) := remainingMakingAmount_4(uint256)
		IRs:
			actualMakingAmount_3(uint256) := ϕ(['actualMakingAmount_2', 'actualMakingAmount_1'])
		Expression: actualTakingAmount = _getTakingAmount(order.getTakingAmount(),order.makingAmount,actualMakingAmount,order.takingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1706(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getTakingAmount(OrderLib.Order), arguments:['order_1'] 
			REF_551(uint256) -> order_1.makingAmount
			REF_552(uint256) -> order_1.takingAmount
			TMP_1707(uint256) = INTERNAL_CALL, OrderMixin._getTakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)(TMP_1706,REF_551,actualMakingAmount_3,REF_552,remainingMakingAmount_4,orderHash_1)
			actualTakingAmount_2(uint256) := TMP_1707(uint256)
		Expression: thresholdAmount = skipPermitAndThresholdAmount & _THRESHOLD_MASK
		IRs:
			TMP_1708(uint256) = skipPermitAndThresholdAmount_1 & _THRESHOLD_MASK_4
			thresholdAmount_1(uint256) := TMP_1708(uint256)
		Expression: actualTakingAmount * makingAmount > thresholdAmount * actualMakingAmount
		IRs:
			TMP_1709(uint256) = actualTakingAmount_2 (c)* makingAmount_1
			TMP_1710(uint256) = thresholdAmount_1 (c)* actualMakingAmount_3
			TMP_1711(bool) = TMP_1709 > TMP_1710
			CONDITION TMP_1711
		Expression: revert TakingAmountTooHigh()()
		IRs:
			TMP_1712(None) = SOLIDITY_CALL revert TakingAmountTooHigh()()
		Expression: actualMakingAmount = _getMakingAmount(order.getMakingAmount(),order.takingAmount,actualTakingAmount,order.makingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1713(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getMakingAmount(OrderLib.Order), arguments:['order_1'] 
			REF_554(uint256) -> order_1.takingAmount
			REF_555(uint256) -> order_1.makingAmount
			TMP_1714(uint256) = INTERNAL_CALL, OrderMixin._getMakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)(TMP_1713,REF_554,actualTakingAmount_1,REF_555,remainingMakingAmount_4,orderHash_1)
			actualMakingAmount_4(uint256) := TMP_1714(uint256)
		Expression: actualMakingAmount > remainingMakingAmount
		IRs:
			TMP_1715(bool) = actualMakingAmount_4 > remainingMakingAmount_4
			CONDITION TMP_1715
		Expression: actualMakingAmount = remainingMakingAmount
		IRs:
			actualMakingAmount_5(uint256) := remainingMakingAmount_4(uint256)
		Expression: actualTakingAmount = _getTakingAmount(order.getTakingAmount(),order.makingAmount,actualMakingAmount,order.takingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1716(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getTakingAmount(OrderLib.Order), arguments:['order_1'] 
			REF_557(uint256) -> order_1.makingAmount
			REF_558(uint256) -> order_1.takingAmount
			TMP_1717(uint256) = INTERNAL_CALL, OrderMixin._getTakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)(TMP_1716,REF_557,actualMakingAmount_5,REF_558,remainingMakingAmount_4,orderHash_1)
			actualTakingAmount_3(uint256) := TMP_1717(uint256)
		Expression: actualTakingAmount > takingAmount
		IRs:
			TMP_1718(bool) = actualTakingAmount_3 > takingAmount_1
			CONDITION TMP_1718
		Expression: revert TakingAmountIncreased()()
		IRs:
			TMP_1719(None) = SOLIDITY_CALL revert TakingAmountIncreased()()
		IRs:
			actualMakingAmount_6(uint256) := ϕ(['actualMakingAmount_4', 'actualMakingAmount_5'])
			actualTakingAmount_4(uint256) := ϕ(['actualTakingAmount_1', 'actualTakingAmount_3'])
		Expression: thresholdAmount_scope_0 = skipPermitAndThresholdAmount & _THRESHOLD_MASK
		IRs:
			TMP_1720(uint256) = skipPermitAndThresholdAmount_1 & _THRESHOLD_MASK_6
			thresholdAmount_scope_0_1(uint256) := TMP_1720(uint256)
		Expression: actualMakingAmount * takingAmount < thresholdAmount_scope_0 * actualTakingAmount
		IRs:
			TMP_1721(uint256) = actualMakingAmount_6 (c)* takingAmount_1
			TMP_1722(uint256) = thresholdAmount_scope_0_1 (c)* actualTakingAmount_4
			TMP_1723(bool) = TMP_1721 < TMP_1722
			CONDITION TMP_1723
		Expression: revert MakingAmountTooLow()()
		IRs:
			TMP_1724(None) = SOLIDITY_CALL revert MakingAmountTooLow()()
		IRs:
			actualMakingAmount_7(uint256) := ϕ(['actualMakingAmount_4', 'actualMakingAmount_1'])
			actualTakingAmount_5(uint256) := ϕ(['actualTakingAmount_1', 'actualTakingAmount_2'])
		Expression: actualMakingAmount == 0 || actualTakingAmount == 0
		IRs:
			TMP_1725(bool) = actualMakingAmount_1 == 0
			TMP_1726(bool) = actualTakingAmount_1 == 0
			TMP_1727(bool) = TMP_1725 || TMP_1726
			CONDITION TMP_1727
		Expression: revert SwapWithZeroAmount()()
		IRs:
			TMP_1728(None) = SOLIDITY_CALL revert SwapWithZeroAmount()()
		Expression: remainingMakingAmount = remainingMakingAmount - actualMakingAmount
		IRs:
			TMP_1729(uint256) = remainingMakingAmount_4 - actualMakingAmount_1
			remainingMakingAmount_5(uint256) := TMP_1729(uint256)
		Expression: _remaining[orderHash] = remainingMakingAmount + 1
		IRs:
			REF_559(uint256) -> _remaining_8[orderHash_1]
			TMP_1730(uint256) = remainingMakingAmount_5 + 1
			_remaining_9(mapping(bytes32 => uint256)) := ϕ(['_remaining_8'])
			REF_559(uint256) (->_remaining_9) := TMP_1730(uint256)
		Expression: OrderFilled(order_.maker,orderHash,remainingMakingAmount)
		IRs:
			REF_560(address) -> order__1.maker
			Emit OrderFilled(REF_560,orderHash_1,remainingMakingAmount_5)
		Expression: order.preInteraction().length >= 20
		IRs:
			TMP_1732(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.preInteraction(OrderLib.Order), arguments:['order_1'] 
			REF_562 -> LENGTH TMP_1732
			TMP_1733(bool) = REF_562 >= 20
			CONDITION TMP_1733
		Expression: (interactionTarget,interactionData) = order.preInteraction().decodeTargetAndCalldata()
		IRs:
			TMP_1734(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.preInteraction(OrderLib.Order), arguments:['order_1'] 
			TUPLE_36(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['TMP_1734'] 
			interactionTarget_1(address)= UNPACK TUPLE_36 index: 0 
			interactionData_1(bytes)= UNPACK TUPLE_36 index: 1 
		Expression: IPreInteractionNotificationReceiver(interactionTarget).fillOrderPreInteraction(orderHash,order.maker,msg.sender,actualMakingAmount,actualTakingAmount,remainingMakingAmount,interactionData)
		IRs:
			TMP_1735 = CONVERT interactionTarget_1 to IPreInteractionNotificationReceiver
			REF_566(address) -> order_1.maker
			HIGH_LEVEL_CALL, dest:TMP_1735(IPreInteractionNotificationReceiver), function:fillOrderPreInteraction, arguments:['orderHash_1', 'REF_566', 'msg.sender', 'actualMakingAmount_1', 'actualTakingAmount_1', 'remainingMakingAmount_5', 'interactionData_1']  
			_RAW_CALL_GAS_LIMIT_7(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_8', '_RAW_CALL_GAS_LIMIT_10', '_RAW_CALL_GAS_LIMIT_6', '_RAW_CALL_GAS_LIMIT_9'])
			_WETH_8(IWETH) := ϕ(['_WETH_7', '_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9', '_WETH_13'])
		Expression: ! _callTransferFrom(order.makerAsset,order.maker,target,actualMakingAmount,order.makerAssetData())
		IRs:
			REF_567(address) -> order_1.makerAsset
			REF_568(address) -> order_1.maker
			TMP_1737(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.makerAssetData(OrderLib.Order), arguments:['order_1'] 
			TMP_1738(bool) = INTERNAL_CALL, OrderMixin._callTransferFrom(address,address,address,uint256,bytes)(REF_567,REF_568,target_1,actualMakingAmount_1,TMP_1737)
			TMP_1739 = UnaryType.BANG TMP_1738 
			CONDITION TMP_1739
		Expression: revert TransferFromMakerToTakerFailed()()
		IRs:
			TMP_1740(None) = SOLIDITY_CALL revert TransferFromMakerToTakerFailed()()
		Expression: interaction.length >= 20
		IRs:
			REF_570 -> LENGTH interaction_1
			TMP_1741(bool) = REF_570 >= 20
			CONDITION TMP_1741
		Expression: (interactionTarget_scope_1,interactionData_scope_2) = interaction.decodeTargetAndCalldata()
		IRs:
			TUPLE_37(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['interaction_1'] 
			interactionTarget_scope_1_1(address)= UNPACK TUPLE_37 index: 0 
			interactionData_scope_2_1(bytes)= UNPACK TUPLE_37 index: 1 
		Expression: offeredTakingAmount = IInteractionNotificationReceiver(interactionTarget_scope_1).fillOrderInteraction(msg.sender,actualMakingAmount,actualTakingAmount,interactionData_scope_2)
		IRs:
			TMP_1742 = CONVERT interactionTarget_scope_1_1 to IInteractionNotificationReceiver
			TMP_1743(uint256) = HIGH_LEVEL_CALL, dest:TMP_1742(IInteractionNotificationReceiver), function:fillOrderInteraction, arguments:['msg.sender', 'actualMakingAmount_1', 'actualTakingAmount_1', 'interactionData_scope_2_1']  
			_RAW_CALL_GAS_LIMIT_9(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_8', '_RAW_CALL_GAS_LIMIT_10', '_RAW_CALL_GAS_LIMIT_9'])
			_WETH_10(IWETH) := ϕ(['_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9', '_WETH_13'])
			offeredTakingAmount_1(uint256) := TMP_1743(uint256)
		Expression: offeredTakingAmount > actualTakingAmount && ! OrderLib.getterIsFrozen(order.getMakingAmount()) && ! OrderLib.getterIsFrozen(order.getTakingAmount())
		IRs:
			TMP_1744(bool) = offeredTakingAmount_1 > actualTakingAmount_1
			TMP_1745(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getMakingAmount(OrderLib.Order), arguments:['order_1'] 
			TMP_1746(bool) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getterIsFrozen(bytes), arguments:['TMP_1745'] 
			TMP_1747 = UnaryType.BANG TMP_1746 
			TMP_1748(bool) = TMP_1744 && TMP_1747
			TMP_1749(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getTakingAmount(OrderLib.Order), arguments:['order_1'] 
			TMP_1750(bool) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getterIsFrozen(bytes), arguments:['TMP_1749'] 
			TMP_1751 = UnaryType.BANG TMP_1750 
			TMP_1752(bool) = TMP_1748 && TMP_1751
			CONDITION TMP_1752
		Expression: actualTakingAmount = offeredTakingAmount
		IRs:
			actualTakingAmount_6(uint256) := offeredTakingAmount_1(uint256)
		IRs:
			actualTakingAmount_7(uint256) := ϕ(['actualTakingAmount_1', 'actualTakingAmount_6'])
		Expression: order.takerAsset == address(_WETH) && msg.value > 0
		IRs:
			REF_577(address) -> order_1.takerAsset
			TMP_1753 = CONVERT _WETH_10 to address
			TMP_1754(bool) = REF_577 == TMP_1753
			TMP_1755(bool) = msg.value > 0
			TMP_1756(bool) = TMP_1754 && TMP_1755
			CONDITION TMP_1756
		Expression: msg.value < actualTakingAmount
		IRs:
			TMP_1757(bool) = msg.value < actualTakingAmount_7
			CONDITION TMP_1757
		Expression: Errors.InvalidMsgValue()
		IRs:
			TMP_1758(None) = SOLIDITY_CALL revert InvalidMsgValue()()
		Expression: msg.value > actualTakingAmount
		IRs:
			TMP_1759(bool) = msg.value > actualTakingAmount_7
			CONDITION TMP_1759
		Expression: (success,None) = msg.sender.call{gas: _RAW_CALL_GAS_LIMIT,value: msg.value - actualTakingAmount}()
		IRs:
			TMP_1760(uint256) = msg.value - actualTakingAmount_7
			TUPLE_38(bool,bytes) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[''] value:TMP_1760 gas:_RAW_CALL_GAS_LIMIT_9
			_RAW_CALL_GAS_LIMIT_10(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_8', '_RAW_CALL_GAS_LIMIT_10', '_RAW_CALL_GAS_LIMIT_9'])
			_WETH_11(IWETH) := ϕ(['_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9', '_WETH_13'])
			success_1(bool)= UNPACK TUPLE_38 index: 0 
		Expression: ! success
		IRs:
			TMP_1761 = UnaryType.BANG success_1 
			CONDITION TMP_1761
		Expression: Errors.ETHTransferFailed()
		IRs:
			TMP_1762(None) = SOLIDITY_CALL revert ETHTransferFailed()()
		Expression: _WETH.deposit{value: actualTakingAmount}()
		IRs:
			HIGH_LEVEL_CALL, dest:_WETH_11(IWETH), function:deposit, arguments:[] value:actualTakingAmount_7 
			_WETH_12(IWETH) := ϕ(['_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9', '_WETH_13'])
		Expression: msg.value != 0
		IRs:
			TMP_1764(bool) = msg.value != 0
			CONDITION TMP_1764
		Expression: Errors.InvalidMsgValue()
		IRs:
			TMP_1765(None) = SOLIDITY_CALL revert InvalidMsgValue()()
		Expression: revert TransferFromTakerToMakerFailed()()
		IRs:
			TMP_1766(None) = SOLIDITY_CALL revert TransferFromTakerToMakerFailed()()
		Expression: order.postInteraction().length >= 20
		IRs:
			TMP_1767(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.postInteraction(OrderLib.Order), arguments:['order_1'] 
			REF_581 -> LENGTH TMP_1767
			TMP_1768(bool) = REF_581 >= 20
			CONDITION TMP_1768
		Expression: (interactionTarget_scope_3,interactionData_scope_4) = order.postInteraction().decodeTargetAndCalldata()
		IRs:
			TMP_1769(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.postInteraction(OrderLib.Order), arguments:['order_1'] 
			TUPLE_39(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['TMP_1769'] 
			interactionTarget_scope_3_1(address)= UNPACK TUPLE_39 index: 0 
			interactionData_scope_4_1(bytes)= UNPACK TUPLE_39 index: 1 
		Expression: IPostInteractionNotificationReceiver(interactionTarget_scope_3).fillOrderPostInteraction(orderHash,order.maker,msg.sender,actualMakingAmount,actualTakingAmount,remainingMakingAmount,interactionData_scope_4)
		IRs:
			TMP_1770 = CONVERT interactionTarget_scope_3_1 to IPostInteractionNotificationReceiver
			REF_585(address) -> order_1.maker
			HIGH_LEVEL_CALL, dest:TMP_1770(IPostInteractionNotificationReceiver), function:fillOrderPostInteraction, arguments:['orderHash_1', 'REF_585', 'msg.sender', 'actualMakingAmount_1', 'actualTakingAmount_7', 'remainingMakingAmount_5', 'interactionData_scope_4_1']  
		Expression: order.receiver == address(0)
		IRs:
			REF_586(address) -> order_1.receiver
			TMP_1772 = CONVERT 0 to address
			TMP_1773(bool) = REF_586 == TMP_1772
			CONDITION TMP_1773
		Expression: _WETH.transfer(order.maker,actualTakingAmount)
		IRs:
			REF_588(address) -> order_1.maker
			TMP_1774(bool) = HIGH_LEVEL_CALL, dest:_WETH_12(IWETH), function:transfer, arguments:['REF_588', 'actualTakingAmount_7']  
			_WETH_14(IWETH) := ϕ(['_WETH_1', '_WETH_14', '_WETH_11', '_WETH_10', '_WETH_9', '_WETH_13'])
		Expression: _WETH.transfer(order.receiver,actualTakingAmount)
		IRs:
			REF_590(address) -> order_1.receiver
			TMP_1775(bool) = HIGH_LEVEL_CALL, dest:_WETH_12(IWETH), function:transfer, arguments:['REF_590', 'actualTakingAmount_7']  
			_WETH_13(IWETH) := ϕ(['_WETH_1', '_WETH_14', '_WETH_12', '_WETH_11', '_WETH_10', '_WETH_9', '_WETH_13'])
		Expression: order.receiver == address(0)
		IRs:
			REF_591(address) -> order_1.receiver
			TMP_1776 = CONVERT 0 to address
			TMP_1777(bool) = REF_591 == TMP_1776
			CONDITION TMP_1777
		Expression: ! _callTransferFrom(order.takerAsset,msg.sender,order.maker,actualTakingAmount,order.takerAssetData())
		IRs:
			REF_592(address) -> order_1.takerAsset
			REF_593(address) -> order_1.maker
			TMP_1778(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.takerAssetData(OrderLib.Order), arguments:['order_1'] 
			TMP_1779(bool) = INTERNAL_CALL, OrderMixin._callTransferFrom(address,address,address,uint256,bytes)(REF_592,msg.sender,REF_593,actualTakingAmount_7,TMP_1778)
			TMP_1780 = UnaryType.BANG TMP_1779 
		Expression: ! _callTransferFrom(order.takerAsset,msg.sender,order.receiver,actualTakingAmount,order.takerAssetData())
		IRs:
			REF_595(address) -> order_1.takerAsset
			REF_596(address) -> order_1.receiver
			TMP_1781(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.takerAssetData(OrderLib.Order), arguments:['order_1'] 
			TMP_1782(bool) = INTERNAL_CALL, OrderMixin._callTransferFrom(address,address,address,uint256,bytes)(REF_595,msg.sender,REF_596,actualTakingAmount_7,TMP_1781)
			TMP_1783 = UnaryType.BANG TMP_1782 
		Expression: (actualMakingAmount,actualTakingAmount,orderHash)
		IRs:
			RETURN actualMakingAmount_1,actualTakingAmount_7,orderHash_1
	Function OrderMixin.checkPredicate(OrderLib.Order)
		IRs:
			order_1(OrderLib.Order) := ϕ(['order_1'])
		Expression: (success,res) = _selfStaticCall(order.predicate())
		IRs:
			TMP_1784(bytes) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.predicate(OrderLib.Order), arguments:['order_1'] 
			TUPLE_40(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(TMP_1784)
			success_1(bool)= UNPACK TUPLE_40 index: 0 
			res_1(uint256)= UNPACK TUPLE_40 index: 1 
		Expression: success && res == 1
		IRs:
			TMP_1785(bool) = res_1 == 1
			TMP_1786(bool) = success_1 && TMP_1785
			RETURN TMP_1786
	Function OrderMixin.hashOrder(OrderLib.Order)
		IRs:
			order_1(OrderLib.Order) := ϕ(['order_1', 'order__1'])
		Expression: order.hash(_domainSeparatorV4())
		IRs:
			TMP_1787(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1788(bytes32) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.hash(OrderLib.Order,bytes32), arguments:['order_1', 'TMP_1787'] 
			RETURN TMP_1788
	Function OrderMixin._callTransferFrom(address,address,address,uint256,bytes)
		IRs:
			asset_1(address) := ϕ(['REF_595', 'REF_567', 'REF_592'])
			from_1(address) := ϕ(['REF_568', 'msg.sender'])
			to_1(address) := ϕ(['target_1', 'REF_593', 'REF_596'])
			amount_1(uint256) := ϕ(['actualTakingAmount_7', 'actualMakingAmount_1'])
			input_1(bytes) := ϕ(['TMP_1737', 'TMP_1778', 'TMP_1781'])
		Expression: selector = IERC20.transferFrom.selector
		IRs:
			REF_601(bytes4) (->None) := 599290589(bytes4)
			selector_1(bytes4) := REF_601(bytes4)
		Expression: data__callTransferFrom_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_1789(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data__callTransferFrom_asm_0_1(uint256) := TMP_1789(uint256)
		Expression: mstore(uint256,uint256)(data__callTransferFrom_asm_0,selector)
		IRs:
			TMP_1790(None) = SOLIDITY_CALL mstore(uint256,uint256)(data__callTransferFrom_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(data__callTransferFrom_asm_0 + 0x04,from)
		IRs:
			TMP_1791(uint256) = data__callTransferFrom_asm_0_1 + 4
			TMP_1792(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_1791,from_1)
		Expression: mstore(uint256,uint256)(data__callTransferFrom_asm_0 + 0x24,to)
		IRs:
			TMP_1793(uint256) = data__callTransferFrom_asm_0_1 + 36
			TMP_1794(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_1793,to_1)
		Expression: mstore(uint256,uint256)(data__callTransferFrom_asm_0 + 0x44,amount)
		IRs:
			TMP_1795(uint256) = data__callTransferFrom_asm_0_1 + 68
			TMP_1796(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_1795,amount_1)
		Expression: calldatacopy(uint256,uint256,uint256)(data__callTransferFrom_asm_0 + 0x64,input,input)
		IRs:
			TMP_1797(uint256) = data__callTransferFrom_asm_0_1 + 100
			TMP_1798(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_1797,input_1,input_1)
		Expression: status__callTransferFrom_asm_0 = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),asset,0,data__callTransferFrom_asm_0,0x64 + input,0x0,0x20)
		IRs:
			TMP_1799(uint256) = SOLIDITY_CALL gas()()
			TMP_1800(uint256) = 100 + input_1
			TMP_1801(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_1799,asset_1,0,data__callTransferFrom_asm_0_1,TMP_1800,0,32)
			status__callTransferFrom_asm_0_1(uint256) := TMP_1801(uint256)
		Expression: success = status__callTransferFrom_asm_0 & ! returndatasize()() | returndatasize()() > 31 & mload(uint256)(0) == 1
		IRs:
			TMP_1802(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_1803 = UnaryType.BANG TMP_1802 
			TMP_1804(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_1805(bool) = TMP_1804 > 31
			TMP_1806(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_1807(bool) = TMP_1806 == 1
			TMP_1808(bool) = TMP_1805 & TMP_1807
			TMP_1809(uint256) = TMP_1803 | TMP_1808
			TMP_1810(uint256) = status__callTransferFrom_asm_0_1 & TMP_1809
			success_1(bool) := TMP_1810(uint256)
		Expression: success
		IRs:
			RETURN success_1
	Function OrderMixin._getMakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)
		IRs:
			getter_1(bytes) := ϕ(['TMP_1713'])
			orderTakingAmount_1(uint256) := ϕ(['REF_554'])
			requestedTakingAmount_1(uint256) := ϕ(['actualTakingAmount_1'])
			orderMakingAmount_1(uint256) := ϕ(['REF_555'])
			remainingMakingAmount_1(uint256) := ϕ(['remainingMakingAmount_4'])
			orderHash_1(bytes32) := ϕ(['orderHash_1'])
		Expression: getter.length == 0
		IRs:
			REF_602 -> LENGTH getter_1
			TMP_1811(bool) = REF_602 == 0
			CONDITION TMP_1811
		Expression: AmountCalculator.getMakingAmount(orderMakingAmount,orderTakingAmount,requestedTakingAmount)
		IRs:
			TMP_1812(uint256) = LIBRARY_CALL, dest:AmountCalculator, function:AmountCalculator.getMakingAmount(uint256,uint256,uint256), arguments:['orderMakingAmount_1', 'orderTakingAmount_1', 'requestedTakingAmount_1'] 
			RETURN TMP_1812
		Expression: _callGetter(getter,orderTakingAmount,requestedTakingAmount,orderMakingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1813(uint256) = INTERNAL_CALL, OrderMixin._callGetter(bytes,uint256,uint256,uint256,uint256,bytes32)(getter_1,orderTakingAmount_1,requestedTakingAmount_1,orderMakingAmount_1,remainingMakingAmount_1,orderHash_1)
			RETURN TMP_1813
	Function OrderMixin._getTakingAmount(bytes,uint256,uint256,uint256,uint256,bytes32)
		IRs:
			getter_1(bytes) := ϕ(['TMP_1716', 'TMP_1706'])
			orderMakingAmount_1(uint256) := ϕ(['REF_551', 'REF_557'])
			requestedMakingAmount_1(uint256) := ϕ(['actualMakingAmount_5', 'actualMakingAmount_3'])
			orderTakingAmount_1(uint256) := ϕ(['REF_552', 'REF_558'])
			remainingMakingAmount_1(uint256) := ϕ(['remainingMakingAmount_4'])
			orderHash_1(bytes32) := ϕ(['orderHash_1'])
		Expression: getter.length == 0
		IRs:
			REF_604 -> LENGTH getter_1
			TMP_1814(bool) = REF_604 == 0
			CONDITION TMP_1814
		Expression: AmountCalculator.getTakingAmount(orderMakingAmount,orderTakingAmount,requestedMakingAmount)
		IRs:
			TMP_1815(uint256) = LIBRARY_CALL, dest:AmountCalculator, function:AmountCalculator.getTakingAmount(uint256,uint256,uint256), arguments:['orderMakingAmount_1', 'orderTakingAmount_1', 'requestedMakingAmount_1'] 
			RETURN TMP_1815
		Expression: _callGetter(getter,orderMakingAmount,requestedMakingAmount,orderTakingAmount,remainingMakingAmount,orderHash)
		IRs:
			TMP_1816(uint256) = INTERNAL_CALL, OrderMixin._callGetter(bytes,uint256,uint256,uint256,uint256,bytes32)(getter_1,orderMakingAmount_1,requestedMakingAmount_1,orderTakingAmount_1,remainingMakingAmount_1,orderHash_1)
			RETURN TMP_1816
	Function OrderMixin._callGetter(bytes,uint256,uint256,uint256,uint256,bytes32)
		IRs:
			getter_1(bytes) := ϕ(['getter_1', 'getter_1'])
			orderExpectedAmount_1(uint256) := ϕ(['orderTakingAmount_1', 'orderMakingAmount_1'])
			requestedAmount_1(uint256) := ϕ(['requestedMakingAmount_1', 'requestedTakingAmount_1'])
			orderResultAmount_1(uint256) := ϕ(['orderTakingAmount_1', 'orderMakingAmount_1'])
			remainingMakingAmount_1(uint256) := ϕ(['remainingMakingAmount_1', 'remainingMakingAmount_1'])
			orderHash_1(bytes32) := ϕ(['orderHash_1', 'orderHash_1'])
		Expression: getter.length == 1
		IRs:
			REF_606 -> LENGTH getter_1
			TMP_1817(bool) = REF_606 == 1
			CONDITION TMP_1817
		Expression: OrderLib.getterIsFrozen(getter)
		IRs:
			TMP_1818(bool) = LIBRARY_CALL, dest:OrderLib, function:OrderLib.getterIsFrozen(bytes), arguments:['getter_1'] 
			CONDITION TMP_1818
		Expression: requestedAmount != orderExpectedAmount
		IRs:
			TMP_1819(bool) = requestedAmount_1 != orderExpectedAmount_1
			CONDITION TMP_1819
		Expression: revert WrongAmount()()
		IRs:
			TMP_1820(None) = SOLIDITY_CALL revert WrongAmount()()
		Expression: orderResultAmount
		IRs:
			RETURN orderResultAmount_1
		Expression: revert WrongGetter()()
		IRs:
			TMP_1821(None) = SOLIDITY_CALL revert WrongGetter()()
		Expression: (target,data) = getter.decodeTargetAndCalldata()
		IRs:
			TUPLE_41(address,bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTargetAndCalldata(bytes), arguments:['getter_1'] 
			target_1(address)= UNPACK TUPLE_41 index: 0 
			data_1(bytes)= UNPACK TUPLE_41 index: 1 
		Expression: (success,result) = target.staticcall(abi.encodePacked(data,requestedAmount,remainingMakingAmount,orderHash))
		IRs:
			TMP_1822(bytes) = SOLIDITY_CALL abi.encodePacked()(data_1,requestedAmount_1,remainingMakingAmount_1,orderHash_1)
			TUPLE_42(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:staticcall, arguments:['TMP_1822']  
			success_1(bool)= UNPACK TUPLE_42 index: 0 
			result_1(bytes)= UNPACK TUPLE_42 index: 1 
		Expression: ! success || result.length != 32
		IRs:
			TMP_1823 = UnaryType.BANG success_1 
			REF_611 -> LENGTH result_1
			TMP_1824(bool) = REF_611 != 32
			TMP_1825(bool) = TMP_1823 || TMP_1824
			CONDITION TMP_1825
		Expression: revert GetAmountCallFailed()()
		IRs:
			TMP_1826(None) = SOLIDITY_CALL revert GetAmountCallFailed()()
		Expression: abi.decode(result,(uint256))
		IRs:
			TMP_1827(uint256) = SOLIDITY_CALL abi.decode()(result_1,uint256)
			RETURN TMP_1827
	Function OrderMixin.slitherConstructorConstantVariables()
		Expression: _RAW_CALL_GAS_LIMIT = 5000
		Expression: _ORDER_DOES_NOT_EXIST = 0
		Expression: _ORDER_FILLED = 1
		Expression: _SKIP_PERMIT_FLAG = 1 << 255
		Expression: _THRESHOLD_MASK = ~ _SKIP_PERMIT_FLAG
Contract OrderRFQLib
	Function OrderRFQLib.hash(OrderRFQLib.OrderRFQ,bytes32)
		IRs:
			_LIMIT_ORDER_RFQ_TYPEHASH_1(bytes32) := ϕ(['_LIMIT_ORDER_RFQ_TYPEHASH_0'])
		Expression: typehash = _LIMIT_ORDER_RFQ_TYPEHASH
		IRs:
			typehash_1(bytes32) := _LIMIT_ORDER_RFQ_TYPEHASH_1(bytes32)
		Expression: ptr_hash_asm_0 = order - 0x20
		IRs:
			TMP_1830(OrderRFQLib.OrderRFQ) = order_1 - 32
			ptr_hash_asm_0_1(uint256) := TMP_1830(OrderRFQLib.OrderRFQ)
		Expression: tmp_hash_asm_0 = mload(uint256)(ptr_hash_asm_0)
		IRs:
			TMP_1831(uint256) = SOLIDITY_CALL mload(uint256)(ptr_hash_asm_0_1)
			tmp_hash_asm_0_1(uint256) := TMP_1831(uint256)
		Expression: mstore(uint256,uint256)(ptr_hash_asm_0,typehash)
		IRs:
			TMP_1832(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_hash_asm_0_1,typehash_1)
		Expression: orderHash = keccak256(uint256,uint256)(ptr_hash_asm_0,0x100)
		IRs:
			TMP_1833(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(ptr_hash_asm_0_1,256)
			orderHash_1(bytes32) := TMP_1833(uint256)
		Expression: mstore(uint256,uint256)(ptr_hash_asm_0,tmp_hash_asm_0)
		IRs:
			TMP_1834(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_hash_asm_0_1,tmp_hash_asm_0_1)
		Expression: ECDSA.toTypedDataHash(domainSeparator,orderHash)
		IRs:
			TMP_1835(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['domainSeparator_1', 'orderHash_1'] 
			RETURN TMP_1835
		Expression: result
	Function OrderRFQLib.slitherConstructorConstantVariables()
		Expression: _LIMIT_ORDER_RFQ_TYPEHASH = keccak256(bytes)(OrderRFQ(uint256 info,address makerAsset,address takerAsset,address maker,address allowedSender,uint256 makingAmount,uint256 takingAmount))
Contract OrderRFQMixin
	Function OnlyWethReceiver.constructor(address)
		Expression: _WETH = address(weth)
		IRs:
			TMP_1837 = CONVERT weth_1 to address
			_WETH_1(address) := TMP_1837(address)
	Function OnlyWethReceiver._receive()
		IRs:
			_WETH_2(address) := ϕ(['_WETH_1', '_WETH_0'])
		Expression: msg.sender != _WETH
		IRs:
			TMP_1838(bool) = msg.sender != _WETH_2
			CONDITION TMP_1838
		Expression: revert EthDepositRejected()()
		IRs:
			TMP_1839(None) = SOLIDITY_CALL revert EthDepositRejected()()
	Function EthReceiver.receive()
		Expression: _receive()
		IRs:
			INTERNAL_CALL, OnlyWethReceiver._receive()()
	Function EthReceiver._receive()
		Expression: msg.sender == tx.origin
		IRs:
			TMP_1841(bool) = msg.sender == tx.origin
			CONDITION TMP_1841
		Expression: revert EthDepositRejected()()
		IRs:
			TMP_1842(None) = SOLIDITY_CALL revert EthDepositRejected()()
	Function EIP712.constructor(string,string)
		Expression: hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_1843 = CONVERT name_1 to bytes
			TMP_1844(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1843)
			hashedName_1(bytes32) := TMP_1844(bytes32)
		Expression: hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_1845 = CONVERT version_1 to bytes
			TMP_1846(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1845)
			hashedVersion_1(bytes32) := TMP_1846(bytes32)
		Expression: typeHash = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
		IRs:
			TMP_1847(bytes32) = SOLIDITY_CALL keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
			typeHash_1(bytes32) := TMP_1847(bytes32)
		Expression: _HASHED_NAME = hashedName
		IRs:
			_HASHED_NAME_1(bytes32) := hashedName_1(bytes32)
		Expression: _HASHED_VERSION = hashedVersion
		IRs:
			_HASHED_VERSION_1(bytes32) := hashedVersion_1(bytes32)
		Expression: _CACHED_CHAIN_ID = block.chainid
		IRs:
			_CACHED_CHAIN_ID_1(uint256) := block.chainid(uint256)
		Expression: _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash,hashedName,hashedVersion)
		IRs:
			TMP_1848(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(typeHash_1,hashedName_1,hashedVersion_1)
			_CACHED_DOMAIN_SEPARATOR_1(bytes32) := TMP_1848(bytes32)
		Expression: _CACHED_THIS = address(this)
		IRs:
			TMP_1849 = CONVERT this to address
			_CACHED_THIS_1(address) := TMP_1849(address)
		Expression: _TYPE_HASH = typeHash
		IRs:
			_TYPE_HASH_1(bytes32) := typeHash_1(bytes32)
	Function EIP712._domainSeparatorV4()
		IRs:
			_CACHED_DOMAIN_SEPARATOR_2(bytes32) := ϕ(['_CACHED_DOMAIN_SEPARATOR_1', '_CACHED_DOMAIN_SEPARATOR_0'])
			_CACHED_CHAIN_ID_2(uint256) := ϕ(['_CACHED_CHAIN_ID_1', '_CACHED_CHAIN_ID_0'])
			_CACHED_THIS_2(address) := ϕ(['_CACHED_THIS_1', '_CACHED_THIS_0'])
			_HASHED_NAME_2(bytes32) := ϕ(['_HASHED_NAME_3', '_HASHED_NAME_0', '_HASHED_NAME_1'])
			_HASHED_VERSION_2(bytes32) := ϕ(['_HASHED_VERSION_3', '_HASHED_VERSION_0', '_HASHED_VERSION_1'])
			_TYPE_HASH_2(bytes32) := ϕ(['_TYPE_HASH_3', '_TYPE_HASH_0', '_TYPE_HASH_1'])
		Expression: address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID
		IRs:
			TMP_1850 = CONVERT this to address
			TMP_1851(bool) = TMP_1850 == _CACHED_THIS_2
			TMP_1852(bool) = block.chainid == _CACHED_CHAIN_ID_2
			TMP_1853(bool) = TMP_1851 && TMP_1852
			CONDITION TMP_1853
		Expression: _CACHED_DOMAIN_SEPARATOR
		IRs:
			RETURN _CACHED_DOMAIN_SEPARATOR_2
		Expression: _buildDomainSeparator(_TYPE_HASH,_HASHED_NAME,_HASHED_VERSION)
		IRs:
			TMP_1854(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(_TYPE_HASH_2,_HASHED_NAME_2,_HASHED_VERSION_2)
			RETURN TMP_1854
	Function EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)
		IRs:
			typeHash_1(bytes32) := ϕ(['_TYPE_HASH_2', 'typeHash_1'])
			nameHash_1(bytes32) := ϕ(['hashedName_1', '_HASHED_NAME_2'])
			versionHash_1(bytes32) := ϕ(['hashedVersion_1', '_HASHED_VERSION_2'])
		Expression: keccak256(bytes)(abi.encode(typeHash,nameHash,versionHash,block.chainid,address(this)))
		IRs:
			TMP_1855 = CONVERT this to address
			TMP_1856(bytes) = SOLIDITY_CALL abi.encode()(typeHash_1,nameHash_1,versionHash_1,block.chainid,TMP_1855)
			TMP_1857(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1856)
			RETURN TMP_1857
	Function EIP712._hashTypedDataV4(bytes32)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_1858(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1859(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_1858', 'structHash_1'] 
			RETURN TMP_1859
	Function OrderRFQMixin.constructor(IWETH)
		IRs:
			weth_1(IWETH) := ϕ(['_weth_1'])
		Expression: _WETH = weth
		IRs:
			_WETH_1(IWETH) := weth_1(IWETH)
		Expression: OnlyWethReceiver(address(weth))
		IRs:
			TMP_1860 = CONVERT weth_1 to address
			INTERNAL_CALL, OnlyWethReceiver.constructor(address)(TMP_1860)
	Function OrderRFQMixin.invalidatorForOrderRFQ(address,uint256)
		IRs:
			_invalidator_1(mapping(address => mapping(uint256 => uint256))) := ϕ(['_invalidator_0', '_invalidator_1', '_invalidator_3'])
		Expression: _invalidator[maker][slot]
		IRs:
			REF_616(mapping(uint256 => uint256)) -> _invalidator_1[maker_1]
			REF_617(uint256) -> REF_616[slot_1]
			RETURN REF_617
	Function OrderRFQMixin.cancelOrderRFQ(uint256)
		Expression: _invalidateOrder(msg.sender,orderInfo,0)
		IRs:
			INTERNAL_CALL, OrderRFQMixin._invalidateOrder(address,uint256,uint256)(msg.sender,orderInfo_1,0)
	Function OrderRFQMixin.cancelOrderRFQ(uint256,uint256)
		Expression: _invalidateOrder(msg.sender,orderInfo,additionalMask)
		IRs:
			INTERNAL_CALL, OrderRFQMixin._invalidateOrder(address,uint256,uint256)(msg.sender,orderInfo_1,additionalMask_1)
	Function OrderRFQMixin.fillOrderRFQ(OrderRFQLib.OrderRFQ,bytes,uint256)
		Expression: fillOrderRFQTo(order,signature,flagsAndAmount,msg.sender)
		IRs:
			TUPLE_43(uint256,uint256,bytes32) = INTERNAL_CALL, OrderRFQMixin.fillOrderRFQTo(OrderRFQLib.OrderRFQ,bytes,uint256,address)(order_1,signature_1,flagsAndAmount_1,msg.sender)
			RETURN TUPLE_43
	Function OrderRFQMixin.fillOrderRFQCompact(OrderRFQLib.OrderRFQ,bytes32,bytes32,uint256)
		IRs:
			_SIGNER_SMART_CONTRACT_HINT_1(uint256) := ϕ(['_SIGNER_SMART_CONTRACT_HINT_2', '_SIGNER_SMART_CONTRACT_HINT_4', '_SIGNER_SMART_CONTRACT_HINT_0'])
			_IS_VALID_SIGNATURE_65_BYTES_1(uint256) := ϕ(['_IS_VALID_SIGNATURE_65_BYTES_2', '_IS_VALID_SIGNATURE_65_BYTES_4', '_IS_VALID_SIGNATURE_65_BYTES_0'])
		Expression: orderHash = order.hash(_domainSeparatorV4())
		IRs:
			TMP_1864(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1865(bytes32) = LIBRARY_CALL, dest:OrderRFQLib, function:OrderRFQLib.hash(OrderRFQLib.OrderRFQ,bytes32), arguments:['order_1', 'TMP_1864'] 
			orderHash_1(bytes32) := TMP_1865(bytes32)
		Expression: flagsAndAmount & _SIGNER_SMART_CONTRACT_HINT != 0
		IRs:
			TMP_1866(uint256) = flagsAndAmount_1 & _SIGNER_SMART_CONTRACT_HINT_2
			TMP_1867(bool) = TMP_1866 != 0
			CONDITION TMP_1867
		Expression: flagsAndAmount & _IS_VALID_SIGNATURE_65_BYTES != 0
		IRs:
			TMP_1868(uint256) = flagsAndAmount_1 & _IS_VALID_SIGNATURE_65_BYTES_2
			TMP_1869(bool) = TMP_1868 != 0
			CONDITION TMP_1869
		Expression: ! ECDSA.isValidSignature65(order.maker,orderHash,r,vs)
		IRs:
			REF_620(address) -> order_1.maker
			TMP_1870(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.isValidSignature65(address,bytes32,bytes32,bytes32), arguments:['REF_620', 'orderHash_1', 'r_1', 'vs_1'] 
			TMP_1871 = UnaryType.BANG TMP_1870 
			CONDITION TMP_1871
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1872(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: ! ECDSA.isValidSignature(order.maker,orderHash,r,vs)
		IRs:
			REF_622(address) -> order_1.maker
			TMP_1873(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.isValidSignature(address,bytes32,bytes32,bytes32), arguments:['REF_622', 'orderHash_1', 'r_1', 'vs_1'] 
			TMP_1874 = UnaryType.BANG TMP_1873 
			CONDITION TMP_1874
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1875(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: ! ECDSA.recoverOrIsValidSignature(order.maker,orderHash,r,vs)
		IRs:
			REF_624(address) -> order_1.maker
			TMP_1876(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recoverOrIsValidSignature(address,bytes32,bytes32,bytes32), arguments:['REF_624', 'orderHash_1', 'r_1', 'vs_1'] 
			TMP_1877 = UnaryType.BANG TMP_1876 
			CONDITION TMP_1877
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1878(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: (filledMakingAmount,filledTakingAmount) = _fillOrderRFQTo(order,flagsAndAmount,msg.sender)
		IRs:
			TUPLE_44(uint256,uint256) = INTERNAL_CALL, OrderRFQMixin._fillOrderRFQTo(OrderRFQLib.OrderRFQ,uint256,address)(order_1,flagsAndAmount_1,msg.sender)
			filledMakingAmount_1(uint256)= UNPACK TUPLE_44 index: 0 
			filledTakingAmount_1(uint256)= UNPACK TUPLE_44 index: 1 
		Expression: OrderFilledRFQ(orderHash,filledMakingAmount)
		IRs:
			Emit OrderFilledRFQ(orderHash_1,filledMakingAmount_1)
		Expression: (filledMakingAmount,filledTakingAmount,orderHash)
		IRs:
			RETURN filledMakingAmount_1,filledTakingAmount_1,orderHash_1
	Function OrderRFQMixin.fillOrderRFQToWithPermit(OrderRFQLib.OrderRFQ,bytes,uint256,address,bytes)
		Expression: IERC20(order.takerAsset).safePermit(permit)
		IRs:
			REF_625(address) -> order_1.takerAsset
			TMP_1880 = CONVERT REF_625 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['TMP_1880', 'permit_1'] 
		Expression: fillOrderRFQTo(order,signature,flagsAndAmount,target)
		IRs:
			TUPLE_45(uint256,uint256,bytes32) = INTERNAL_CALL, OrderRFQMixin.fillOrderRFQTo(OrderRFQLib.OrderRFQ,bytes,uint256,address)(order_1,signature_1,flagsAndAmount_1,target_1)
			RETURN TUPLE_45
	Function OrderRFQMixin.fillOrderRFQTo(OrderRFQLib.OrderRFQ,bytes,uint256,address)
		IRs:
			order_1(OrderRFQLib.OrderRFQ) := ϕ(['order_1', 'order_1'])
			signature_1(bytes) := ϕ(['signature_1', 'signature_1'])
			flagsAndAmount_1(uint256) := ϕ(['flagsAndAmount_1', 'flagsAndAmount_1'])
			target_1(address) := ϕ(['target_1', 'msg.sender'])
			_SIGNER_SMART_CONTRACT_HINT_3(uint256) := ϕ(['_SIGNER_SMART_CONTRACT_HINT_2', '_SIGNER_SMART_CONTRACT_HINT_4', '_SIGNER_SMART_CONTRACT_HINT_0'])
			_IS_VALID_SIGNATURE_65_BYTES_3(uint256) := ϕ(['_IS_VALID_SIGNATURE_65_BYTES_2', '_IS_VALID_SIGNATURE_65_BYTES_4', '_IS_VALID_SIGNATURE_65_BYTES_0'])
		Expression: orderHash = order.hash(_domainSeparatorV4())
		IRs:
			TMP_1882(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1883(bytes32) = LIBRARY_CALL, dest:OrderRFQLib, function:OrderRFQLib.hash(OrderRFQLib.OrderRFQ,bytes32), arguments:['order_1', 'TMP_1882'] 
			orderHash_1(bytes32) := TMP_1883(bytes32)
		Expression: flagsAndAmount & _SIGNER_SMART_CONTRACT_HINT != 0
		IRs:
			TMP_1884(uint256) = flagsAndAmount_1 & _SIGNER_SMART_CONTRACT_HINT_4
			TMP_1885(bool) = TMP_1884 != 0
			CONDITION TMP_1885
		Expression: flagsAndAmount & _IS_VALID_SIGNATURE_65_BYTES != 0 && signature.length != 65
		IRs:
			TMP_1886(uint256) = flagsAndAmount_1 & _IS_VALID_SIGNATURE_65_BYTES_4
			TMP_1887(bool) = TMP_1886 != 0
			REF_628 -> LENGTH signature_1
			TMP_1888(bool) = REF_628 != 65
			TMP_1889(bool) = TMP_1887 && TMP_1888
			CONDITION TMP_1889
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1890(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: ! ECDSA.isValidSignature(order.maker,orderHash,signature)
		IRs:
			REF_630(address) -> order_1.maker
			TMP_1891(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.isValidSignature(address,bytes32,bytes), arguments:['REF_630', 'orderHash_1', 'signature_1'] 
			TMP_1892 = UnaryType.BANG TMP_1891 
			CONDITION TMP_1892
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1893(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: ! ECDSA.recoverOrIsValidSignature(order.maker,orderHash,signature)
		IRs:
			REF_632(address) -> order_1.maker
			TMP_1894(bool) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recoverOrIsValidSignature(address,bytes32,bytes), arguments:['REF_632', 'orderHash_1', 'signature_1'] 
			TMP_1895 = UnaryType.BANG TMP_1894 
			CONDITION TMP_1895
		Expression: revert RFQBadSignature()()
		IRs:
			TMP_1896(None) = SOLIDITY_CALL revert RFQBadSignature()()
		Expression: (filledMakingAmount,filledTakingAmount) = _fillOrderRFQTo(order,flagsAndAmount,target)
		IRs:
			TUPLE_46(uint256,uint256) = INTERNAL_CALL, OrderRFQMixin._fillOrderRFQTo(OrderRFQLib.OrderRFQ,uint256,address)(order_1,flagsAndAmount_1,target_1)
			filledMakingAmount_1(uint256)= UNPACK TUPLE_46 index: 0 
			filledTakingAmount_1(uint256)= UNPACK TUPLE_46 index: 1 
		Expression: OrderFilledRFQ(orderHash,filledMakingAmount)
		IRs:
			Emit OrderFilledRFQ(orderHash_1,filledMakingAmount_1)
		Expression: (filledMakingAmount,filledTakingAmount,orderHash)
		IRs:
			RETURN filledMakingAmount_1,filledTakingAmount_1,orderHash_1
	Function OrderRFQMixin._fillOrderRFQTo(OrderRFQLib.OrderRFQ,uint256,address)
		IRs:
			order_1(OrderRFQLib.OrderRFQ) := ϕ(['order_1', 'order_1'])
			flagsAndAmount_1(uint256) := ϕ(['flagsAndAmount_1', 'flagsAndAmount_1'])
			target_1(address) := ϕ(['target_1', 'msg.sender'])
			_RAW_CALL_GAS_LIMIT_1(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_0', '_RAW_CALL_GAS_LIMIT_5', '_RAW_CALL_GAS_LIMIT_2'])
			_MAKER_AMOUNT_FLAG_1(uint256) := ϕ(['_MAKER_AMOUNT_FLAG_2', '_MAKER_AMOUNT_FLAG_0'])
			_UNWRAP_WETH_FLAG_1(uint256) := ϕ(['_UNWRAP_WETH_FLAG_0', '_UNWRAP_WETH_FLAG_2'])
			_AMOUNT_MASK_1(uint256) := ϕ(['_AMOUNT_MASK_2', '_AMOUNT_MASK_0'])
			_WETH_2(IWETH) := ϕ(['_WETH_8', '_WETH_1', '_WETH_0', '_WETH_3', '_WETH_6'])
		Expression: target == address(0)
		IRs:
			TMP_1898 = CONVERT 0 to address
			TMP_1899(bool) = target_1 == TMP_1898
			CONDITION TMP_1899
		Expression: revert RFQZeroTargetIsForbidden()()
		IRs:
			TMP_1900(None) = SOLIDITY_CALL revert RFQZeroTargetIsForbidden()()
		Expression: maker = order.maker
		IRs:
			REF_633(address) -> order_1.maker
			maker_1(address) := REF_633(address)
		Expression: order.allowedSender != address(0) && order.allowedSender != msg.sender
		IRs:
			REF_634(address) -> order_1.allowedSender
			TMP_1901 = CONVERT 0 to address
			TMP_1902(bool) = REF_634 != TMP_1901
			REF_635(address) -> order_1.allowedSender
			TMP_1903(bool) = REF_635 != msg.sender
			TMP_1904(bool) = TMP_1902 && TMP_1903
			CONDITION TMP_1904
		Expression: revert RFQPrivateOrder()()
		IRs:
			TMP_1905(None) = SOLIDITY_CALL revert RFQPrivateOrder()()
		Expression: info = order.info
		IRs:
			REF_636(uint256) -> order_1.info
			info_1(uint256) := REF_636(uint256)
		Expression: expiration = uint128(info) >> 64
		IRs:
			TMP_1906 = CONVERT info_1 to uint128
			TMP_1907(uint128) = TMP_1906 >> 64
			expiration_1(uint256) := TMP_1907(uint128)
		Expression: expiration != 0 && block.timestamp > expiration
		IRs:
			TMP_1908(bool) = expiration_1 != 0
			TMP_1909(bool) = block.timestamp > expiration_1
			TMP_1910(bool) = TMP_1908 && TMP_1909
			CONDITION TMP_1910
		Expression: revert OrderExpired()()
		IRs:
			TMP_1911(None) = SOLIDITY_CALL revert OrderExpired()()
		Expression: _invalidateOrder(maker,info,0)
		IRs:
			INTERNAL_CALL, OrderRFQMixin._invalidateOrder(address,uint256,uint256)(maker_1,info_1,0)
		Expression: orderMakingAmount = order.makingAmount
		IRs:
			REF_637(uint256) -> order_1.makingAmount
			orderMakingAmount_1(uint256) := REF_637(uint256)
		Expression: orderTakingAmount = order.takingAmount
		IRs:
			REF_638(uint256) -> order_1.takingAmount
			orderTakingAmount_1(uint256) := REF_638(uint256)
		Expression: amount = flagsAndAmount & _AMOUNT_MASK
		IRs:
			TMP_1913(uint256) = flagsAndAmount_1 & _AMOUNT_MASK_2
			amount_1(uint256) := TMP_1913(uint256)
		Expression: amount == 0
		IRs:
			TMP_1914(bool) = amount_1 == 0
			CONDITION TMP_1914
		Expression: makingAmount = orderMakingAmount
		IRs:
			makingAmount_1(uint256) := orderMakingAmount_1(uint256)
		Expression: takingAmount = orderTakingAmount
		IRs:
			takingAmount_1(uint256) := orderTakingAmount_1(uint256)
		Expression: flagsAndAmount & _MAKER_AMOUNT_FLAG != 0
		IRs:
			TMP_1915(uint256) = flagsAndAmount_1 & _MAKER_AMOUNT_FLAG_2
			TMP_1916(bool) = TMP_1915 != 0
			CONDITION TMP_1916
		Expression: amount > orderMakingAmount
		IRs:
			TMP_1917(bool) = amount_1 > orderMakingAmount_1
			CONDITION TMP_1917
		Expression: revert MakingAmountExceeded()()
		IRs:
			TMP_1918(None) = SOLIDITY_CALL revert MakingAmountExceeded()()
		Expression: makingAmount = amount
		IRs:
			makingAmount_2(uint256) := amount_1(uint256)
		Expression: takingAmount = AmountCalculator.getTakingAmount(orderMakingAmount,orderTakingAmount,makingAmount)
		IRs:
			TMP_1919(uint256) = LIBRARY_CALL, dest:AmountCalculator, function:AmountCalculator.getTakingAmount(uint256,uint256,uint256), arguments:['orderMakingAmount_1', 'orderTakingAmount_1', 'makingAmount_2'] 
			takingAmount_2(uint256) := TMP_1919(uint256)
		Expression: amount > orderTakingAmount
		IRs:
			TMP_1920(bool) = amount_1 > orderTakingAmount_1
			CONDITION TMP_1920
		Expression: revert TakingAmountExceeded()()
		IRs:
			TMP_1921(None) = SOLIDITY_CALL revert TakingAmountExceeded()()
		Expression: takingAmount = amount
		IRs:
			takingAmount_3(uint256) := amount_1(uint256)
		Expression: makingAmount = AmountCalculator.getMakingAmount(orderMakingAmount,orderTakingAmount,takingAmount)
		IRs:
			TMP_1922(uint256) = LIBRARY_CALL, dest:AmountCalculator, function:AmountCalculator.getMakingAmount(uint256,uint256,uint256), arguments:['orderMakingAmount_1', 'orderTakingAmount_1', 'takingAmount_3'] 
			makingAmount_3(uint256) := TMP_1922(uint256)
		IRs:
			makingAmount_4(uint256) := ϕ(['makingAmount_0', 'makingAmount_2', 'makingAmount_3'])
			takingAmount_4(uint256) := ϕ(['takingAmount_0', 'takingAmount_3', 'takingAmount_2'])
		IRs:
			makingAmount_5(uint256) := ϕ(['makingAmount_0', 'makingAmount_1'])
			takingAmount_5(uint256) := ϕ(['takingAmount_0', 'takingAmount_1'])
		Expression: makingAmount == 0 || takingAmount == 0
		IRs:
			TMP_1923(bool) = makingAmount_5 == 0
			TMP_1924(bool) = takingAmount_5 == 0
			TMP_1925(bool) = TMP_1923 || TMP_1924
			CONDITION TMP_1925
		Expression: revert RFQSwapWithZeroAmount()()
		IRs:
			TMP_1926(None) = SOLIDITY_CALL revert RFQSwapWithZeroAmount()()
		Expression: order.makerAsset == address(_WETH) && flagsAndAmount & _UNWRAP_WETH_FLAG != 0
		IRs:
			REF_641(address) -> order_1.makerAsset
			TMP_1927 = CONVERT _WETH_3 to address
			TMP_1928(bool) = REF_641 == TMP_1927
			TMP_1929(uint256) = flagsAndAmount_1 & _UNWRAP_WETH_FLAG_2
			TMP_1930(bool) = TMP_1929 != 0
			TMP_1931(bool) = TMP_1928 && TMP_1930
			CONDITION TMP_1931
		Expression: _WETH.transferFrom(maker,address(this),makingAmount)
		IRs:
			TMP_1932 = CONVERT this to address
			TMP_1933(bool) = HIGH_LEVEL_CALL, dest:_WETH_3(IWETH), function:transferFrom, arguments:['maker_1', 'TMP_1932', 'makingAmount_5']  
			_RAW_CALL_GAS_LIMIT_3(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_5', '_RAW_CALL_GAS_LIMIT_2'])
			_WETH_4(IWETH) := ϕ(['_WETH_3', '_WETH_8', '_WETH_1', '_WETH_6'])
		Expression: _WETH.withdraw(makingAmount)
		IRs:
			HIGH_LEVEL_CALL, dest:_WETH_4(IWETH), function:withdraw, arguments:['makingAmount_5']  
			_RAW_CALL_GAS_LIMIT_4(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_5', '_RAW_CALL_GAS_LIMIT_3', '_RAW_CALL_GAS_LIMIT_2'])
			_WETH_5(IWETH) := ϕ(['_WETH_4', '_WETH_8', '_WETH_1', '_WETH_3', '_WETH_6'])
		Expression: (success,None) = target.call{gas: _RAW_CALL_GAS_LIMIT,value: makingAmount}()
		IRs:
			TUPLE_47(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:call, arguments:[''] value:makingAmount_5 gas:_RAW_CALL_GAS_LIMIT_4
			_RAW_CALL_GAS_LIMIT_5(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_5', '_RAW_CALL_GAS_LIMIT_4', '_RAW_CALL_GAS_LIMIT_2'])
			_WETH_6(IWETH) := ϕ(['_WETH_5', '_WETH_8', '_WETH_1', '_WETH_3', '_WETH_6'])
			success_1(bool)= UNPACK TUPLE_47 index: 0 
		Expression: ! success
		IRs:
			TMP_1935 = UnaryType.BANG success_1 
			CONDITION TMP_1935
		Expression: Errors.ETHTransferFailed()
		IRs:
			TMP_1936(None) = SOLIDITY_CALL revert ETHTransferFailed()()
		Expression: IERC20(order.makerAsset).safeTransferFrom(maker,target,makingAmount)
		IRs:
			REF_645(address) -> order_1.makerAsset
			TMP_1937 = CONVERT REF_645 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_1937', 'maker_1', 'target_1', 'makingAmount_5'] 
		Expression: order.takerAsset == address(_WETH) && msg.value > 0
		IRs:
			REF_647(address) -> order_1.takerAsset
			TMP_1939 = CONVERT _WETH_3 to address
			TMP_1940(bool) = REF_647 == TMP_1939
			TMP_1941(bool) = msg.value > 0
			TMP_1942(bool) = TMP_1940 && TMP_1941
			CONDITION TMP_1942
		Expression: msg.value != takingAmount
		IRs:
			TMP_1943(bool) = msg.value != takingAmount_5
			CONDITION TMP_1943
		Expression: Errors.InvalidMsgValue()
		IRs:
			TMP_1944(None) = SOLIDITY_CALL revert InvalidMsgValue()()
		Expression: _WETH.deposit{value: takingAmount}()
		IRs:
			HIGH_LEVEL_CALL, dest:_WETH_3(IWETH), function:deposit, arguments:[] value:takingAmount_5 
			_WETH_7(IWETH) := ϕ(['_WETH_3', '_WETH_8', '_WETH_1', '_WETH_6'])
		Expression: _WETH.transfer(maker,takingAmount)
		IRs:
			TMP_1946(bool) = HIGH_LEVEL_CALL, dest:_WETH_7(IWETH), function:transfer, arguments:['maker_1', 'takingAmount_5']  
			_WETH_8(IWETH) := ϕ(['_WETH_8', '_WETH_1', '_WETH_3', '_WETH_7', '_WETH_6'])
		Expression: msg.value != 0
		IRs:
			TMP_1947(bool) = msg.value != 0
			CONDITION TMP_1947
		Expression: Errors.InvalidMsgValue()
		IRs:
			TMP_1948(None) = SOLIDITY_CALL revert InvalidMsgValue()()
		Expression: IERC20(order.takerAsset).safeTransferFrom(msg.sender,maker,takingAmount)
		IRs:
			REF_650(address) -> order_1.takerAsset
			TMP_1949 = CONVERT REF_650 to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_1949', 'msg.sender', 'maker_1', 'takingAmount_5'] 
		Expression: (makingAmount,takingAmount)
		IRs:
			RETURN makingAmount_5,takingAmount_5
	Function OrderRFQMixin._invalidateOrder(address,uint256,uint256)
		IRs:
			maker_1(address) := ϕ(['maker_1', 'msg.sender'])
			orderInfo_1(uint256) := ϕ(['info_1', 'orderInfo_1', 'orderInfo_1'])
			additionalMask_1(uint256) := ϕ(['additionalMask_1'])
			_invalidator_2(mapping(address => mapping(uint256 => uint256))) := ϕ(['_invalidator_0', '_invalidator_1', '_invalidator_3'])
		Expression: invalidatorSlot = uint64(orderInfo) >> 8
		IRs:
			TMP_1951 = CONVERT orderInfo_1 to uint64
			TMP_1952(uint64) = TMP_1951 >> 8
			invalidatorSlot_1(uint256) := TMP_1952(uint64)
		Expression: invalidatorBits = (1 << uint8(orderInfo)) | additionalMask
		IRs:
			TMP_1953 = CONVERT orderInfo_1 to uint8
			TMP_1954(uint256) = 1 << TMP_1953
			TMP_1955(uint256) = TMP_1954 | additionalMask_1
			invalidatorBits_1(uint256) := TMP_1955(uint256)
		Expression: invalidatorStorage = _invalidator[maker]
		IRs:
			REF_652(mapping(uint256 => uint256)) -> _invalidator_2[maker_1]
			invalidatorStorage_1 (-> ['_invalidator'])(mapping(uint256 => uint256)) := REF_652(mapping(uint256 => uint256))
		Expression: invalidator = invalidatorStorage[invalidatorSlot]
		IRs:
			REF_653(uint256) -> invalidatorStorage_1 (-> ['_invalidator'])[invalidatorSlot_1]
			invalidator_1(uint256) := REF_653(uint256)
		Expression: invalidator & invalidatorBits == invalidatorBits
		IRs:
			TMP_1956(uint256) = invalidator_1 & invalidatorBits_1
			TMP_1957(bool) = TMP_1956 == invalidatorBits_1
			CONDITION TMP_1957
		Expression: revert InvalidatedOrder()()
		IRs:
			TMP_1958(None) = SOLIDITY_CALL revert InvalidatedOrder()()
		Expression: invalidatorStorage[invalidatorSlot] = invalidator | invalidatorBits
		IRs:
			REF_654(uint256) -> invalidatorStorage_1 (-> ['_invalidator'])[invalidatorSlot_1]
			TMP_1959(uint256) = invalidator_1 | invalidatorBits_1
			invalidatorStorage_2 (-> ['_invalidator'])(mapping(uint256 => uint256)) := ϕ(["invalidatorStorage_1 (-> ['_invalidator'])"])
			REF_654(uint256) (->invalidatorStorage_2 (-> ['_invalidator'])) := TMP_1959(uint256)
			_invalidator_3(mapping(address => mapping(uint256 => uint256))) := ϕ(["invalidatorStorage_2 (-> ['_invalidator'])"])
	Function OrderRFQMixin.slitherConstructorConstantVariables()
		Expression: _RAW_CALL_GAS_LIMIT = 5000
		Expression: _MAKER_AMOUNT_FLAG = 1 << 255
		Expression: _SIGNER_SMART_CONTRACT_HINT = 1 << 254
		Expression: _IS_VALID_SIGNATURE_65_BYTES = 1 << 253
		Expression: _UNWRAP_WETH_FLAG = 1 << 252
		Expression: _AMOUNT_MASK = ~ (_MAKER_AMOUNT_FLAG | _SIGNER_SMART_CONTRACT_HINT | _IS_VALID_SIGNATURE_65_BYTES | _UNWRAP_WETH_FLAG)
Contract AmountCalculator
	Function AmountCalculator.getMakingAmount(uint256,uint256,uint256)
		Expression: swapTakerAmount * orderMakerAmount / orderTakerAmount
		IRs:
			TMP_1968(uint256) = swapTakerAmount_1 (c)* orderMakerAmount_1
			TMP_1969(uint256) = TMP_1968 (c)/ orderTakerAmount_1
			RETURN TMP_1969
	Function AmountCalculator.getTakingAmount(uint256,uint256,uint256)
		Expression: (swapMakerAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount
		IRs:
			TMP_1970(uint256) = swapMakerAmount_1 (c)* orderTakerAmount_1
			TMP_1971(uint256) = TMP_1970 (c)+ orderMakerAmount_1
			TMP_1972(uint256) = TMP_1971 (c)- 1
			TMP_1973(uint256) = TMP_1972 (c)/ orderMakerAmount_1
			RETURN TMP_1973
Contract NonceManager
	Function NonceManager.increaseNonce()
		Expression: advanceNonce(1)
		IRs:
			INTERNAL_CALL, NonceManager.advanceNonce(uint256)(1)
	Function NonceManager.advanceNonce(uint256)
		IRs:
			nonce_1(mapping(address => uint256)) := ϕ(['nonce_2', 'nonce_0', 'nonce_3'])
		Expression: amount == 0 || amount > 255
		IRs:
			TMP_1975(bool) = amount_1 == 0
			TMP_1976(bool) = amount_1 > 255
			TMP_1977(bool) = TMP_1975 || TMP_1976
			CONDITION TMP_1977
		Expression: revert AdvanceNonceFailed()()
		IRs:
			TMP_1978(None) = SOLIDITY_CALL revert AdvanceNonceFailed()()
		Expression: newNonce = nonce[msg.sender] + amount
		IRs:
			REF_655(uint256) -> nonce_1[msg.sender]
			TMP_1979(uint256) = REF_655 + amount_1
			newNonce_1(uint256) := TMP_1979(uint256)
		Expression: nonce[msg.sender] = newNonce
		IRs:
			REF_656(uint256) -> nonce_1[msg.sender]
			nonce_2(mapping(address => uint256)) := ϕ(['nonce_1'])
			REF_656(uint256) (->nonce_2) := newNonce_1(uint256)
		Expression: NonceIncreased(msg.sender,newNonce)
		IRs:
			Emit NonceIncreased(msg.sender,newNonce_1)
	Function NonceManager.nonceEquals(address,uint256)
		IRs:
			nonce_3(mapping(address => uint256)) := ϕ(['nonce_2', 'nonce_0', 'nonce_3'])
		Expression: nonce[makerAddress] == makerNonce
		IRs:
			REF_657(uint256) -> nonce_3[makerAddress_1]
			TMP_1981(bool) = REF_657 == makerNonce_1
			RETURN TMP_1981
Contract PredicateHelper
	Function NonceManager.increaseNonce()
		Expression: advanceNonce(1)
		IRs:
			INTERNAL_CALL, NonceManager.advanceNonce(uint256)(1)
	Function NonceManager.advanceNonce(uint256)
		IRs:
			nonce_1(mapping(address => uint256)) := ϕ(['nonce_3', 'nonce_2', 'nonce_0'])
		Expression: amount == 0 || amount > 255
		IRs:
			TMP_1983(bool) = amount_1 == 0
			TMP_1984(bool) = amount_1 > 255
			TMP_1985(bool) = TMP_1983 || TMP_1984
			CONDITION TMP_1985
		Expression: revert AdvanceNonceFailed()()
		IRs:
			TMP_1986(None) = SOLIDITY_CALL revert AdvanceNonceFailed()()
		Expression: newNonce = nonce[msg.sender] + amount
		IRs:
			REF_658(uint256) -> nonce_1[msg.sender]
			TMP_1987(uint256) = REF_658 + amount_1
			newNonce_1(uint256) := TMP_1987(uint256)
		Expression: nonce[msg.sender] = newNonce
		IRs:
			REF_659(uint256) -> nonce_1[msg.sender]
			nonce_2(mapping(address => uint256)) := ϕ(['nonce_1'])
			REF_659(uint256) (->nonce_2) := newNonce_1(uint256)
		Expression: NonceIncreased(msg.sender,newNonce)
		IRs:
			Emit NonceIncreased(msg.sender,newNonce_1)
	Function NonceManager.nonceEquals(address,uint256)
		IRs:
			makerAddress_1(address) := ϕ(['TMP_2064', '_account_1'])
			makerNonce_1(uint256) := ϕ(['_nonce_1', 'TMP_2065'])
			nonce_3(mapping(address => uint256)) := ϕ(['nonce_3', 'nonce_2', 'nonce_0'])
		Expression: nonce[makerAddress] == makerNonce
		IRs:
			REF_660(uint256) -> nonce_3[makerAddress_1]
			TMP_1989(bool) = REF_660 == makerNonce_1
			RETURN TMP_1989
	Function PredicateHelper.or(uint256,bytes)
		IRs:
			offsets_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_2057'])
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: (current = uint32(offsets >> i)) != 0
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_1990(uint256) = offsets_1 >> i_2
			TMP_1991 = CONVERT TMP_1990 to uint32
			current_1(uint256) := TMP_1991(uint32)
			TMP_1992(bool) = current_1 != 0
			CONDITION TMP_1992
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_48(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_48 index: 0 
			res_1(uint256)= UNPACK TUPLE_48 index: 1 
		Expression: success && res == 1
		IRs:
			TMP_1993(bool) = res_1 == 1
			TMP_1994(bool) = success_1 && TMP_1993
			CONDITION TMP_1994
		Expression: true
		IRs:
			RETURN True
		Expression: previous = current
		IRs:
			previous_1(uint256) := current_1(uint256)
		Expression: i += 32
		IRs:
			i_3(uint256) = i_2 (c)+ 32
		Expression: false
		IRs:
			RETURN False
	Function PredicateHelper.and(uint256,bytes)
		IRs:
			offsets_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_2059'])
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: (current = uint32(offsets >> i)) != 0
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_1995(uint256) = offsets_1 >> i_2
			TMP_1996 = CONVERT TMP_1995 to uint32
			current_1(uint256) := TMP_1996(uint32)
			TMP_1997(bool) = current_1 != 0
			CONDITION TMP_1997
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_49(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_49 index: 0 
			res_1(uint256)= UNPACK TUPLE_49 index: 1 
		Expression: ! success || res != 1
		IRs:
			TMP_1998 = UnaryType.BANG success_1 
			TMP_1999(bool) = res_1 != 1
			TMP_2000(bool) = TMP_1998 || TMP_1999
			CONDITION TMP_2000
		Expression: false
		IRs:
			RETURN False
		Expression: previous = current
		IRs:
			previous_1(uint256) := current_1(uint256)
		Expression: i += 32
		IRs:
			i_3(uint256) = i_2 (c)+ 32
		Expression: true
		IRs:
			RETURN True
	Function PredicateHelper.eq(uint256,bytes)
		IRs:
			value_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_2055'])
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_50(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_50 index: 0 
			res_1(uint256)= UNPACK TUPLE_50 index: 1 
		Expression: success && res == value
		IRs:
			TMP_2001(bool) = res_1 == value_1
			TMP_2002(bool) = success_1 && TMP_2001
			RETURN TMP_2002
	Function PredicateHelper.lt(uint256,bytes)
		IRs:
			value_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_2061'])
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_51(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_51 index: 0 
			res_1(uint256)= UNPACK TUPLE_51 index: 1 
		Expression: success && res < value
		IRs:
			TMP_2003(bool) = res_1 < value_1
			TMP_2004(bool) = success_1 && TMP_2003
			RETURN TMP_2004
	Function PredicateHelper.gt(uint256,bytes)
		IRs:
			value_1(uint256) := ϕ(['arg_1'])
			data_1(bytes) := ϕ(['TMP_2052'])
		Expression: (success,res) = _selfStaticCall(data)
		IRs:
			TUPLE_52(bool,uint256) = INTERNAL_CALL, PredicateHelper._selfStaticCall(bytes)(data_1)
			success_1(bool)= UNPACK TUPLE_52 index: 0 
			res_1(uint256)= UNPACK TUPLE_52 index: 1 
		Expression: success && res > value
		IRs:
			TMP_2005(bool) = res_1 > value_1
			TMP_2006(bool) = success_1 && TMP_2005
			RETURN TMP_2006
	Function PredicateHelper.timestampBelow(uint256)
		IRs:
			time_1(uint256) := ϕ(['arg_1', '_time_1'])
		Expression: block.timestamp < time
		IRs:
			TMP_2007(bool) = block.timestamp < time_1
			RETURN TMP_2007
	Function PredicateHelper.arbitraryStaticCall(address,bytes)
		IRs:
			target_1(address) := ϕ(['TMP_2041'])
			data_1(bytes) := ϕ(['TMP_2042'])
		Expression: (success,res) = _staticcallForUint(target,data)
		IRs:
			TUPLE_53(bool,uint256) = INTERNAL_CALL, PredicateHelper._staticcallForUint(address,bytes)(target_1,data_1)
			success_1(bool)= UNPACK TUPLE_53 index: 0 
			res_1(uint256)= UNPACK TUPLE_53 index: 1 
		Expression: ! success
		IRs:
			TMP_2008 = UnaryType.BANG success_1 
			CONDITION TMP_2008
		Expression: revert ArbitraryStaticCallFailed()()
		IRs:
			TMP_2009(None) = SOLIDITY_CALL revert ArbitraryStaticCallFailed()()
		Expression: res
		IRs:
			RETURN res_1
	Function PredicateHelper.timestampBelowAndNonceEquals(uint256)
		IRs:
			timeNonceAccount_1(uint256) := ϕ(['arg_1'])
		Expression: _time = uint48(timeNonceAccount >> 208)
		IRs:
			TMP_2010(uint256) = timeNonceAccount_1 >> 208
			TMP_2011 = CONVERT TMP_2010 to uint48
			_time_1(uint256) := TMP_2011(uint48)
		Expression: _nonce = uint48(timeNonceAccount >> 160)
		IRs:
			TMP_2012(uint256) = timeNonceAccount_1 >> 160
			TMP_2013 = CONVERT TMP_2012 to uint48
			_nonce_1(uint256) := TMP_2013(uint48)
		Expression: _account = address(uint160(timeNonceAccount))
		IRs:
			TMP_2014 = CONVERT timeNonceAccount_1 to uint160
			TMP_2015 = CONVERT TMP_2014 to address
			_account_1(address) := TMP_2015(address)
		Expression: timestampBelow(_time) && nonceEquals(_account,_nonce)
		IRs:
			TMP_2016(bool) = INTERNAL_CALL, PredicateHelper.timestampBelow(uint256)(_time_1)
			TMP_2017(bool) = INTERNAL_CALL, NonceManager.nonceEquals(address,uint256)(_account_1,_nonce_1)
			TMP_2018(bool) = TMP_2016 && TMP_2017
			RETURN TMP_2018
	Function PredicateHelper._selfStaticCall(bytes)
		IRs:
			data_1(bytes) := ϕ(['data_1', 'data_1', 'data_1', 'data_1', 'data_1'])
		Expression: selector = uint32(data.decodeSelector())
		IRs:
			TMP_2019(bytes4) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeSelector(bytes), arguments:['data_1'] 
			TMP_2020 = CONVERT TMP_2019 to uint32
			selector_1(uint256) := TMP_2020(uint32)
		Expression: arg = data.decodeUint256(4)
		IRs:
			TMP_2021(uint256) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeUint256(bytes,uint256), arguments:['data_1', '4'] 
			arg_1(uint256) := TMP_2021(uint256)
		Expression: selector == uint32(this.timestampBelowAndNonceEquals.selector)
		IRs:
			REF_664(bytes4) (->None) := 750946189(bytes4)
			TMP_2022 = CONVERT REF_664 to uint32
			TMP_2023(bool) = selector_1 == TMP_2022
			CONDITION TMP_2023
		Expression: selector < uint32(this.arbitraryStaticCall.selector)
		IRs:
			REF_666(bytes4) (->None) := 3205889240(bytes4)
			TMP_2024 = CONVERT REF_666 to uint32
			TMP_2025(bool) = selector_1 < TMP_2024
			CONDITION TMP_2025
		Expression: selector < uint32(this.eq.selector)
		IRs:
			REF_668(bytes4) (->None) := 1877455034(bytes4)
			TMP_2026 = CONVERT REF_668 to uint32
			TMP_2027(bool) = selector_1 < TMP_2026
			CONDITION TMP_2027
		Expression: selector == uint32(this.gt.selector)
		IRs:
			REF_670(bytes4) (->None) := 1329128120(bytes4)
			TMP_2028 = CONVERT REF_670 to uint32
			TMP_2029(bool) = selector_1 == TMP_2028
			CONDITION TMP_2029
		Expression: selector == uint32(this.timestampBelow.selector)
		IRs:
			REF_672(bytes4) (->None) := 1666788395(bytes4)
			TMP_2030 = CONVERT REF_672 to uint32
			TMP_2031(bool) = selector_1 == TMP_2030
			CONDITION TMP_2031
		Expression: selector == uint32(this.eq.selector)
		IRs:
			REF_674(bytes4) (->None) := 1877455034(bytes4)
			TMP_2032 = CONVERT REF_674 to uint32
			TMP_2033(bool) = selector_1 == TMP_2032
			CONDITION TMP_2033
		Expression: selector == uint32(this.or.selector)
		IRs:
			REF_676(bytes4) (->None) := 1948651845(bytes4)
			TMP_2034 = CONVERT REF_676 to uint32
			TMP_2035(bool) = selector_1 == TMP_2034
			CONDITION TMP_2035
		Expression: selector < uint32(this.lt.selector)
		IRs:
			REF_678(bytes4) (->None) := 3394162210(bytes4)
			TMP_2036 = CONVERT REF_678 to uint32
			TMP_2037(bool) = selector_1 < TMP_2036
			CONDITION TMP_2037
		Expression: selector == uint32(this.arbitraryStaticCall.selector)
		IRs:
			REF_680(bytes4) (->None) := 3205889240(bytes4)
			TMP_2038 = CONVERT REF_680 to uint32
			TMP_2039(bool) = selector_1 == TMP_2038
			CONDITION TMP_2039
		Expression: (true,arbitraryStaticCall(address(uint160(arg)),data.decodeTailCalldata(100)))
		IRs:
			TMP_2040 = CONVERT arg_1 to uint160
			TMP_2041 = CONVERT TMP_2040 to address
			TMP_2042(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_2043(uint256) = INTERNAL_CALL, PredicateHelper.arbitraryStaticCall(address,bytes)(TMP_2041,TMP_2042)
			RETURN True,TMP_2043
		Expression: selector == uint32(this.and.selector)
		IRs:
			REF_683(bytes4) (->None) := 3215413571(bytes4)
			TMP_2044 = CONVERT REF_683 to uint32
			TMP_2045(bool) = selector_1 == TMP_2044
			CONDITION TMP_2045
		Expression: selector == uint32(this.lt.selector)
		IRs:
			REF_685(bytes4) (->None) := 3394162210(bytes4)
			TMP_2046 = CONVERT REF_685 to uint32
			TMP_2047(bool) = selector_1 == TMP_2046
			CONDITION TMP_2047
		Expression: selector == uint32(this.nonceEquals.selector)
		IRs:
			REF_687(bytes4) (->None) := 3480209123(bytes4)
			TMP_2048 = CONVERT REF_687 to uint32
			TMP_2049(bool) = selector_1 == TMP_2048
			CONDITION TMP_2049
		Expression: _staticcallForUint(address(this),data)
		IRs:
			TMP_2050 = CONVERT this to address
			TUPLE_54(bool,uint256) = INTERNAL_CALL, PredicateHelper._staticcallForUint(address,bytes)(TMP_2050,data_1)
			RETURN TUPLE_54
		Expression: timestampBelowAndNonceEquals(arg)
		IRs:
			TMP_2051(bool) = INTERNAL_CALL, PredicateHelper.timestampBelowAndNonceEquals(uint256)(arg_1)
			CONDITION TMP_2051
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: gt(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_2052(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_2053(bool) = INTERNAL_CALL, PredicateHelper.gt(uint256,bytes)(arg_1,TMP_2052)
			CONDITION TMP_2053
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: timestampBelow(arg)
		IRs:
			TMP_2054(bool) = INTERNAL_CALL, PredicateHelper.timestampBelow(uint256)(arg_1)
			CONDITION TMP_2054
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: eq(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_2055(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_2056(bool) = INTERNAL_CALL, PredicateHelper.eq(uint256,bytes)(arg_1,TMP_2055)
			CONDITION TMP_2056
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: or(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_2057(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_2058(bool) = INTERNAL_CALL, PredicateHelper.or(uint256,bytes)(arg_1,TMP_2057)
			CONDITION TMP_2058
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: and(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_2059(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_2060(bool) = INTERNAL_CALL, PredicateHelper.and(uint256,bytes)(arg_1,TMP_2059)
			CONDITION TMP_2060
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: lt(arg,data.decodeTailCalldata(100))
		IRs:
			TMP_2061(bytes) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeTailCalldata(bytes,uint256), arguments:['data_1', '100'] 
			TMP_2062(bool) = INTERNAL_CALL, PredicateHelper.lt(uint256,bytes)(arg_1,TMP_2061)
			CONDITION TMP_2062
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
		Expression: nonceEquals(address(uint160(arg)),data.decodeUint256(0x24))
		IRs:
			TMP_2063 = CONVERT arg_1 to uint160
			TMP_2064 = CONVERT TMP_2063 to address
			TMP_2065(uint256) = LIBRARY_CALL, dest:ArgumentsDecoder, function:ArgumentsDecoder.decodeUint256(bytes,uint256), arguments:['data_1', '36'] 
			TMP_2066(bool) = INTERNAL_CALL, NonceManager.nonceEquals(address,uint256)(TMP_2064,TMP_2065)
			CONDITION TMP_2066
		Expression: (true,1)
		IRs:
			RETURN True,1
		Expression: (true,0)
		IRs:
			RETURN True,0
	Function PredicateHelper._staticcallForUint(address,bytes)
		IRs:
			target_1(address) := ϕ(['TMP_2050', 'target_1'])
			input_1(bytes) := ϕ(['data_1', 'data_1'])
		Expression: data__staticcallForUint_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2067(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data__staticcallForUint_asm_0_1(uint256) := TMP_2067(uint256)
		Expression: calldatacopy(uint256,uint256,uint256)(data__staticcallForUint_asm_0,input,input)
		IRs:
			TMP_2068(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(data__staticcallForUint_asm_0_1,input_1,input_1)
		Expression: success = staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),target,data__staticcallForUint_asm_0,input,0x0,0x20)
		IRs:
			TMP_2069(uint256) = SOLIDITY_CALL gas()()
			TMP_2070(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2069,target_1,data__staticcallForUint_asm_0_1,input_1,0,32)
			success_1(bool) := TMP_2070(uint256)
		Expression: success = success & returndatasize()() == 32
		IRs:
			TMP_2071(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2072(bool) = TMP_2071 == 32
			TMP_2073(bool) = success_1 & TMP_2072
			success_2(bool) := TMP_2073(bool)
		Expression: success
		IRs:
			CONDITION success_2
		IRs:
			res_2(uint256) := ϕ(['res_1', 'res_0'])
		Expression: res = mload(uint256)(0)
		IRs:
			TMP_2074(uint256) = SOLIDITY_CALL mload(uint256)(0)
			res_1(uint256) := TMP_2074(uint256)
		Expression: (success,res)
		IRs:
			RETURN success_2,res_2
Contract IInteractionNotificationReceiver
	Function IInteractionNotificationReceiver.fillOrderInteraction(address,uint256,uint256,bytes)
Contract IOrderMixin
	Function IOrderMixin.remaining(bytes32)
	Function IOrderMixin.remainingRaw(bytes32)
	Function IOrderMixin.remainingsRaw(bytes32[])
	Function IOrderMixin.checkPredicate(OrderLib.Order)
	Function IOrderMixin.hashOrder(OrderLib.Order)
	Function IOrderMixin.simulate(address,bytes)
	Function IOrderMixin.cancelOrder(OrderLib.Order)
	Function IOrderMixin.fillOrder(OrderLib.Order,bytes,bytes,uint256,uint256,uint256)
	Function IOrderMixin.fillOrderToWithPermit(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address,bytes)
	Function IOrderMixin.fillOrderTo(OrderLib.Order,bytes,bytes,uint256,uint256,uint256,address)
Contract IPostInteractionNotificationReceiver
	Function IPostInteractionNotificationReceiver.fillOrderPostInteraction(bytes32,address,address,uint256,uint256,uint256,bytes)
Contract IPreInteractionNotificationReceiver
	Function IPreInteractionNotificationReceiver.fillOrderPreInteraction(bytes32,address,address,uint256,uint256,uint256,bytes)
Contract ArgumentsDecoder
	Function ArgumentsDecoder.decodeUint256(bytes,uint256)
		Expression: data.length < offset + 32
		IRs:
			REF_694 -> LENGTH data_1
			TMP_2075(uint256) = offset_1 + 32
			TMP_2076(bool) = REF_694 < TMP_2075
			CONDITION TMP_2076
		Expression: revert IncorrectDataLength()()
		IRs:
			TMP_2077(None) = SOLIDITY_CALL revert IncorrectDataLength()()
		Expression: value = calldataload(uint256)(data + offset)
		IRs:
			TMP_2078(bytes) = data_1 + offset_1
			TMP_2079(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_2078)
			value_1(uint256) := TMP_2079(uint256)
		Expression: value
		IRs:
			RETURN value_1
	Function ArgumentsDecoder.decodeSelector(bytes)
		Expression: data.length < 4
		IRs:
			REF_695 -> LENGTH data_1
			TMP_2080(bool) = REF_695 < 4
			CONDITION TMP_2080
		Expression: revert IncorrectDataLength()()
		IRs:
			TMP_2081(None) = SOLIDITY_CALL revert IncorrectDataLength()()
		Expression: value = calldataload(uint256)(data)
		IRs:
			TMP_2082(uint256) = SOLIDITY_CALL calldataload(uint256)(data_1)
			value_1(bytes4) := TMP_2082(uint256)
		Expression: value
		IRs:
			RETURN value_1
	Function ArgumentsDecoder.decodeTailCalldata(bytes,uint256)
		Expression: data.length < tailOffset
		IRs:
			REF_696 -> LENGTH data_1
			TMP_2083(bool) = REF_696 < tailOffset_1
			CONDITION TMP_2083
		Expression: revert IncorrectDataLength()()
		IRs:
			TMP_2084(None) = SOLIDITY_CALL revert IncorrectDataLength()()
		Expression: args = data + tailOffset
		IRs:
			TMP_2085(bytes) = data_1 + tailOffset_1
			args_1(bytes) := TMP_2085(bytes)
		Expression: args = data - tailOffset
		IRs:
			TMP_2086(bytes) = data_1 - tailOffset_1
			args_2(bytes) := TMP_2086(bytes)
		Expression: args
		IRs:
			RETURN args_2
	Function ArgumentsDecoder.decodeTargetAndCalldata(bytes)
		Expression: data.length < 20
		IRs:
			REF_697 -> LENGTH data_1
			TMP_2087(bool) = REF_697 < 20
			CONDITION TMP_2087
		Expression: revert IncorrectDataLength()()
		IRs:
			TMP_2088(None) = SOLIDITY_CALL revert IncorrectDataLength()()
		Expression: target = calldataload(uint256)(data) >> 96
		IRs:
			TMP_2089(uint256) = SOLIDITY_CALL calldataload(uint256)(data_1)
			TMP_2090(uint256) = TMP_2089 >> 96
			target_1(address) := TMP_2090(uint256)
		Expression: args = data + 20
		IRs:
			TMP_2091(bytes) = data_1 + 20
			args_1(bytes) := TMP_2091(bytes)
		Expression: args = data - 20
		IRs:
			TMP_2092(bytes) = data_1 - 20
			args_2(bytes) := TMP_2092(bytes)
		Expression: (target,args)
		IRs:
			RETURN target_1,args_2
Contract Errors
Contract WrappedTokenMock
	Function IWETH.deposit()
	Function IWETH.withdraw(uint256)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_2093(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2093)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_2095(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_2096(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_2097(bool) = TMP_2095 == TMP_2096
			TMP_2098(None) = SOLIDITY_CALL require(bool,string)(TMP_2097,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_2099 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2099)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_2102 = CONVERT 0 to address
			TMP_2103(bool) = newOwner_1 != TMP_2102
			TMP_2104(None) = SOLIDITY_CALL require(bool,string)(TMP_2103,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['TMP_2093', 'newOwner_1', 'TMP_2099'])
			_owner_2(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20Permit.constructor(string)
		Expression: EIP712(name,1)
		IRs:
			INTERNAL_CALL, EIP712.constructor(string,string)(name_1,1)
	Function ERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32)
		IRs:
			_PERMIT_TYPEHASH_1(bytes32) := ϕ(['_PERMIT_TYPEHASH_0', '_PERMIT_TYPEHASH_2'])
		Expression: require(bool,string)(block.timestamp <= deadline,ERC20Permit: expired deadline)
		IRs:
			TMP_2109(bool) = block.timestamp <= deadline_1
			TMP_2110(None) = SOLIDITY_CALL require(bool,string)(TMP_2109,ERC20Permit: expired deadline)
		Expression: structHash = keccak256(bytes)(abi.encode(_PERMIT_TYPEHASH,owner,spender,value,_useNonce(owner),deadline))
		IRs:
			TMP_2111(uint256) = INTERNAL_CALL, ERC20Permit._useNonce(address)(owner_1)
			TMP_2112(bytes) = SOLIDITY_CALL abi.encode()(_PERMIT_TYPEHASH_2,owner_1,spender_1,value_1,TMP_2111,deadline_1)
			TMP_2113(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2112)
			structHash_1(bytes32) := TMP_2113(bytes32)
		Expression: hash = _hashTypedDataV4(structHash)
		IRs:
			TMP_2114(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(structHash_1)
			hash_1(bytes32) := TMP_2114(bytes32)
		Expression: signer = ECDSA.recover(hash,v,r,s)
		IRs:
			TMP_2115(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['hash_1', 'v_1', 'r_1', 's_1'] 
			signer_1(address) := TMP_2115(address)
		Expression: require(bool,string)(signer == owner,ERC20Permit: invalid signature)
		IRs:
			TMP_2116(bool) = signer_1 == owner_1
			TMP_2117(None) = SOLIDITY_CALL require(bool,string)(TMP_2116,ERC20Permit: invalid signature)
		Expression: _approve(owner,spender,value)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,value_1)
	Function ERC20Permit.nonces(address)
		IRs:
			_nonces_1(mapping(address => Counters.Counter)) := ϕ(['_nonces_2', '_nonces_1', '_nonces_0'])
		Expression: _nonces[owner].current()
		IRs:
			REF_700(Counters.Counter) -> _nonces_1[owner_1]
			TMP_2119(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['REF_700'] 
			RETURN TMP_2119
	Function ERC20Permit.DOMAIN_SEPARATOR()
		Expression: _domainSeparatorV4()
		IRs:
			TMP_2120(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			RETURN TMP_2120
	Function ERC20Permit._useNonce(address)
		IRs:
			owner_1(address) := ϕ(['owner_1'])
			_nonces_2(mapping(address => Counters.Counter)) := ϕ(['_nonces_2', '_nonces_1', '_nonces_0'])
		Expression: nonce = _nonces[owner]
		IRs:
			REF_702(Counters.Counter) -> _nonces_2[owner_1]
			nonce_1 (-> ['_nonces'])(Counters.Counter) := REF_702(Counters.Counter)
		Expression: current = nonce.current()
		IRs:
			TMP_2121(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:["nonce_1 (-> ['_nonces'])"] 
			current_1(uint256) := TMP_2121(uint256)
		Expression: nonce.increment()
		IRs:
			LIBRARY_CALL, dest:Counters, function:Counters.increment(Counters.Counter), arguments:["nonce_1 (-> ['_nonces'])"] 
		Expression: current
		IRs:
			RETURN current_1
	Function EIP712.constructor(string,string)
		Expression: hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_2123 = CONVERT name_1 to bytes
			TMP_2124(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2123)
			hashedName_1(bytes32) := TMP_2124(bytes32)
		Expression: hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_2125 = CONVERT version_1 to bytes
			TMP_2126(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2125)
			hashedVersion_1(bytes32) := TMP_2126(bytes32)
		Expression: typeHash = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
		IRs:
			TMP_2127(bytes32) = SOLIDITY_CALL keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
			typeHash_1(bytes32) := TMP_2127(bytes32)
		Expression: _HASHED_NAME = hashedName
		IRs:
			_HASHED_NAME_1(bytes32) := hashedName_1(bytes32)
		Expression: _HASHED_VERSION = hashedVersion
		IRs:
			_HASHED_VERSION_1(bytes32) := hashedVersion_1(bytes32)
		Expression: _CACHED_CHAIN_ID = block.chainid
		IRs:
			_CACHED_CHAIN_ID_1(uint256) := block.chainid(uint256)
		Expression: _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash,hashedName,hashedVersion)
		IRs:
			TMP_2128(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(typeHash_1,hashedName_1,hashedVersion_1)
			_CACHED_DOMAIN_SEPARATOR_1(bytes32) := TMP_2128(bytes32)
		Expression: _CACHED_THIS = address(this)
		IRs:
			TMP_2129 = CONVERT this to address
			_CACHED_THIS_1(address) := TMP_2129(address)
		Expression: _TYPE_HASH = typeHash
		IRs:
			_TYPE_HASH_1(bytes32) := typeHash_1(bytes32)
	Function EIP712._domainSeparatorV4()
		IRs:
			_CACHED_DOMAIN_SEPARATOR_2(bytes32) := ϕ(['_CACHED_DOMAIN_SEPARATOR_0', '_CACHED_DOMAIN_SEPARATOR_1'])
			_CACHED_CHAIN_ID_2(uint256) := ϕ(['_CACHED_CHAIN_ID_0', '_CACHED_CHAIN_ID_1'])
			_CACHED_THIS_2(address) := ϕ(['_CACHED_THIS_0', '_CACHED_THIS_1'])
			_HASHED_NAME_2(bytes32) := ϕ(['_HASHED_NAME_0', '_HASHED_NAME_3', '_HASHED_NAME_1'])
			_HASHED_VERSION_2(bytes32) := ϕ(['_HASHED_VERSION_3', '_HASHED_VERSION_1', '_HASHED_VERSION_0'])
			_TYPE_HASH_2(bytes32) := ϕ(['_TYPE_HASH_3', '_TYPE_HASH_1', '_TYPE_HASH_0'])
		Expression: address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID
		IRs:
			TMP_2130 = CONVERT this to address
			TMP_2131(bool) = TMP_2130 == _CACHED_THIS_2
			TMP_2132(bool) = block.chainid == _CACHED_CHAIN_ID_2
			TMP_2133(bool) = TMP_2131 && TMP_2132
			CONDITION TMP_2133
		Expression: _CACHED_DOMAIN_SEPARATOR
		IRs:
			RETURN _CACHED_DOMAIN_SEPARATOR_2
		Expression: _buildDomainSeparator(_TYPE_HASH,_HASHED_NAME,_HASHED_VERSION)
		IRs:
			TMP_2134(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(_TYPE_HASH_2,_HASHED_NAME_2,_HASHED_VERSION_2)
			RETURN TMP_2134
	Function EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)
		IRs:
			typeHash_1(bytes32) := ϕ(['typeHash_1', '_TYPE_HASH_2'])
			nameHash_1(bytes32) := ϕ(['hashedName_1', '_HASHED_NAME_2'])
			versionHash_1(bytes32) := ϕ(['hashedVersion_1', '_HASHED_VERSION_2'])
		Expression: keccak256(bytes)(abi.encode(typeHash,nameHash,versionHash,block.chainid,address(this)))
		IRs:
			TMP_2135 = CONVERT this to address
			TMP_2136(bytes) = SOLIDITY_CALL abi.encode()(typeHash_1,nameHash_1,versionHash_1,block.chainid,TMP_2135)
			TMP_2137(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2136)
			RETURN TMP_2137
	Function EIP712._hashTypedDataV4(bytes32)
		IRs:
			structHash_1(bytes32) := ϕ(['structHash_1'])
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_2138(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_2139(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_2138', 'structHash_1'] 
			RETURN TMP_2139
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32)
	Function IERC20Permit.nonces(address)
	Function IERC20Permit.DOMAIN_SEPARATOR()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_1', '_balances_8', '_balances_0'])
		Expression: _balances[account]
		IRs:
			REF_707(uint256) -> _balances_1[account_1]
			RETURN REF_707
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2140(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2140(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_1', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_708(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_709(uint256) -> REF_708[spender_1]
			RETURN REF_709
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2142(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2142(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_2144(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_2144(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2147(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2147(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_2148(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_2149(uint256) = TMP_2148 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2149)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2151(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2151(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2152(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_2152(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_2153(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_2154(None) = SOLIDITY_CALL require(bool,string)(TMP_2153,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_2155(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2155)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'owner_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_1', '_balances_8', '_balances_0'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_2157 = CONVERT 0 to address
			TMP_2158(bool) = from_1 != TMP_2157
			TMP_2159(None) = SOLIDITY_CALL require(bool,string)(TMP_2158,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_2160 = CONVERT 0 to address
			TMP_2161(bool) = to_1 != TMP_2160
			TMP_2162(None) = SOLIDITY_CALL require(bool,string)(TMP_2161,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_710(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_710(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_2164(bool) = fromBalance_1 >= amount_1
			TMP_2165(None) = SOLIDITY_CALL require(bool,string)(TMP_2164,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_711(uint256) -> _balances_3[from_1]
			TMP_2166(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_711(uint256) (->_balances_4) := TMP_2166(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_712(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_712(-> _balances_5) = REF_712 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1', 'msg.sender'])
			amount_1(uint256) := ϕ(['msg.value', 'amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_1', '_balances_8', '_balances_0'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_2169 = CONVERT 0 to address
			TMP_2170(bool) = account_1 != TMP_2169
			TMP_2171(None) = SOLIDITY_CALL require(bool,string)(TMP_2170,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2172 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_2172,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_713(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_713(-> _balances_8) = REF_713 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_2174 = CONVERT 0 to address
			Emit Transfer(TMP_2174,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2176 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_2176,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1', 'msg.sender'])
			amount_1(uint256) := ϕ(['wad_1', 'amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_11', '_balances_5', '_balances_1', '_balances_8', '_balances_0'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_2178 = CONVERT 0 to address
			TMP_2179(bool) = account_1 != TMP_2178
			TMP_2180(None) = SOLIDITY_CALL require(bool,string)(TMP_2179,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2181 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_2181,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_714(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_714(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_2183(bool) = accountBalance_1 >= amount_1
			TMP_2184(None) = SOLIDITY_CALL require(bool,string)(TMP_2183,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_715(uint256) -> _balances_10[account_1]
			TMP_2185(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_715(uint256) (->_balances_11) := TMP_2185(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_2186 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_2186,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2188 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_2188,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_2203', 'TMP_2155', 'amount_1', 'value_1', 'TMP_2149'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_2190 = CONVERT 0 to address
			TMP_2191(bool) = owner_1 != TMP_2190
			TMP_2192(None) = SOLIDITY_CALL require(bool,string)(TMP_2191,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_2193 = CONVERT 0 to address
			TMP_2194(bool) = spender_1 != TMP_2193
			TMP_2195(None) = SOLIDITY_CALL require(bool,string)(TMP_2194,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_716(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_717(uint256) -> REF_716[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_717(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2197(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_2197(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_2199(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_2200(bool) = currentAllowance_1 != TMP_2199
			CONDITION TMP_2200
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_2201(bool) = currentAllowance_1 >= amount_1
			TMP_2202(None) = SOLIDITY_CALL require(bool,string)(TMP_2201,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_2203(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2203)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'account_1', 'TMP_2172'])
			to_1(address) := ϕ(['to_1', 'TMP_2181', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'account_1', 'TMP_2176'])
			to_1(address) := ϕ(['to_1', 'TMP_2188', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function WrappedTokenMock.constructor(string,string)
		Expression: ERC20(name,symbol)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name_1,symbol_1)
		Expression: ERC20Permit(name)
		IRs:
			INTERNAL_CALL, ERC20Permit.constructor(string)(name_1)
	Function WrappedTokenMock.receive()
		Expression: deposit()
		IRs:
			INTERNAL_CALL, WrappedTokenMock.deposit()()
	Function WrappedTokenMock.mint(address,uint256)
		Expression: _mint(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function WrappedTokenMock.burn(address,uint256)
		Expression: _burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function WrappedTokenMock.getChainId()
		Expression: block.chainid
		IRs:
			RETURN block.chainid
	Function WrappedTokenMock.deposit()
		Expression: _mint(msg.sender,msg.value)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(msg.sender,msg.value)
		Expression: Deposit(msg.sender,msg.value)
		IRs:
			Emit Deposit(msg.sender,msg.value)
	Function WrappedTokenMock.withdraw(uint256)
		Expression: balanceOf(msg.sender) < wad
		IRs:
			TMP_2214(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(msg.sender)
			TMP_2215(bool) = TMP_2214 < wad_1
			CONDITION TMP_2215
		Expression: revert NotEnoughBalance()()
		IRs:
			TMP_2216(None) = SOLIDITY_CALL revert NotEnoughBalance()()
		Expression: _burn(msg.sender,wad)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(msg.sender,wad_1)
		Expression: address(msg.sender).transfer(wad)
		IRs:
			TMP_2218 = CONVERT msg.sender to address
			Transfer dest:TMP_2218 value:wad_1
		Expression: Withdrawal(msg.sender,wad)
		IRs:
			Emit Withdrawal(msg.sender,wad_1)
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
Contract EthReceiver
	Function EthReceiver.receive()
		Expression: _receive()
		IRs:
			INTERNAL_CALL, EthReceiver._receive()()
	Function EthReceiver._receive()
		Expression: msg.sender == tx.origin
		IRs:
			TMP_2223(bool) = msg.sender == tx.origin
			CONDITION TMP_2223
		Expression: revert EthDepositRejected()()
		IRs:
			TMP_2224(None) = SOLIDITY_CALL revert EthDepositRejected()()
Contract OnlyWethReceiver
	Function EthReceiver.receive()
		Expression: _receive()
		IRs:
			INTERNAL_CALL, OnlyWethReceiver._receive()()
	Function EthReceiver._receive()
		Expression: msg.sender == tx.origin
		IRs:
			TMP_2226(bool) = msg.sender == tx.origin
			CONDITION TMP_2226
		Expression: revert EthDepositRejected()()
		IRs:
			TMP_2227(None) = SOLIDITY_CALL revert EthDepositRejected()()
	Function OnlyWethReceiver.constructor(address)
		IRs:
			weth_1(address) := ϕ(['TMP_1125', 'TMP_1860'])
		Expression: _WETH = address(weth)
		IRs:
			TMP_2228 = CONVERT weth_1 to address
			_WETH_1(address) := TMP_2228(address)
	Function OnlyWethReceiver._receive()
		IRs:
			_WETH_2(address) := ϕ(['_WETH_1', '_WETH_0'])
		Expression: msg.sender != _WETH
		IRs:
			TMP_2229(bool) = msg.sender != _WETH_2
			CONDITION TMP_2229
		Expression: revert EthDepositRejected()()
		IRs:
			TMP_2230(None) = SOLIDITY_CALL revert EthDepositRejected()()
Contract IDaiLikePermit
	Function IDaiLikePermit.permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)
Contract IERC20MetadataUppercase
	Function IERC20MetadataUppercase.NAME()
	Function IERC20MetadataUppercase.SYMBOL()
Contract IWETH
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IWETH.deposit()
	Function IWETH.withdraw(uint256)
Contract AddressArray
	Function AddressArray.length(AddressArray.Data)
		IRs:
			self_1 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
		Expression: self._raw[0] >> 160
		IRs:
			REF_719(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_720(uint256) -> REF_719[0]
			TMP_2231(uint256) = REF_720 >> 160
			RETURN TMP_2231
	Function AddressArray.at(AddressArray.Data,uint256)
		Expression: address(uint160(self._raw[i]))
		IRs:
			REF_721(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_722(uint256) -> REF_721[i_1]
			TMP_2232 = CONVERT REF_722 to uint160
			TMP_2233 = CONVERT TMP_2232 to address
			RETURN TMP_2233
	Function AddressArray.get(AddressArray.Data)
		Expression: lengthAndFirst = self._raw[0]
		IRs:
			REF_723(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_724(uint256) -> REF_723[0]
			lengthAndFirst_1(uint256) := REF_724(uint256)
		Expression: arr = new address[](lengthAndFirst >> 160)
		IRs:
			TMP_2235(uint256) = lengthAndFirst_1 >> 160
			TMP_2236(address[])  = new address[](TMP_2235)
			arr_1(address[]) = ['TMP_2236(address[])']
		Expression: _get(self,arr,lengthAndFirst)
		IRs:
			TMP_2237(address[]) = INTERNAL_CALL, AddressArray._get(AddressArray.Data,address[],uint256)(self_1 (-> []),arr_1,lengthAndFirst_1)
		Expression: arr
		IRs:
			RETURN arr_1
	Function AddressArray.get(AddressArray.Data,address[])
		Expression: _get(self,output,self._raw[0])
		IRs:
			REF_725(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_726(uint256) -> REF_725[0]
			TMP_2238(address[]) = INTERNAL_CALL, AddressArray._get(AddressArray.Data,address[],uint256)(self_1 (-> []),output_1,REF_726)
			RETURN TMP_2238
	Function AddressArray._get(AddressArray.Data,address[],uint256)
		IRs:
			self_1 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])', 'self_1 (-> [])'])
			output_1(address[]) := ϕ(['output_1', 'arr_1'])
			lengthAndFirst_1(uint256) := ϕ(['lengthAndFirst_1', 'REF_726'])
		Expression: len = lengthAndFirst >> 160
		IRs:
			TMP_2239(uint256) = lengthAndFirst_1 >> 160
			len_1(uint256) := TMP_2239(uint256)
		Expression: len > output.length
		IRs:
			REF_727 -> LENGTH output_1
			TMP_2240(bool) = len_1 > REF_727
			CONDITION TMP_2240
		Expression: revert OutputArrayTooSmall()()
		IRs:
			TMP_2241(None) = SOLIDITY_CALL revert OutputArrayTooSmall()()
		Expression: len > 0
		IRs:
			TMP_2242(bool) = len_1 > 0
			CONDITION TMP_2242
		Expression: output[0] = address(uint160(lengthAndFirst))
		IRs:
			REF_728(address) -> output_1[0]
			TMP_2243 = CONVERT lengthAndFirst_1 to uint160
			TMP_2244 = CONVERT TMP_2243 to address
			output_2(address[]) := ϕ(['output_1'])
			REF_728(address) (->output_2) := TMP_2244(address)
		Expression: i = 1
		IRs:
			i_1(uint256) := 1(uint256)
		Expression: i < len
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_2245(bool) = i_2 < len_1
			CONDITION TMP_2245
		Expression: output[i] = address(uint160(self._raw[i]))
		IRs:
			REF_729(address) -> output_2[i_2]
			REF_730(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_731(uint256) -> REF_730[i_2]
			TMP_2246 = CONVERT REF_731 to uint160
			TMP_2247 = CONVERT TMP_2246 to address
			output_3(address[]) := ϕ(['output_2'])
			REF_729(address) (->output_3) := TMP_2247(address)
		Expression: i ++
		IRs:
			TMP_2248(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		IRs:
			output_4(address[]) := ϕ(['output_2', 'output_1'])
		Expression: output
		IRs:
			RETURN output_4
	Function AddressArray.push(AddressArray.Data,address)
		Expression: lengthAndFirst = self._raw[0]
		IRs:
			REF_732(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_733(uint256) -> REF_732[0]
			lengthAndFirst_1(uint256) := REF_733(uint256)
		Expression: len = lengthAndFirst >> 160
		IRs:
			TMP_2249(uint256) = lengthAndFirst_1 >> 160
			len_1(uint256) := TMP_2249(uint256)
		Expression: len == 0
		IRs:
			TMP_2250(bool) = len_1 == 0
			CONDITION TMP_2250
		Expression: self._raw[0] = (1 << 160) + uint160(account)
		IRs:
			REF_734(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_735(uint256) -> REF_734[0]
			TMP_2251(uint256) = 1 << 160
			TMP_2252 = CONVERT account_1 to uint160
			TMP_2253(uint256) = TMP_2251 + TMP_2252
			self_4 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_735(uint256) (->self_4 (-> [])) := TMP_2253(uint256)
		Expression: self._raw[0] = lengthAndFirst + (1 << 160)
		IRs:
			REF_736(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_737(uint256) -> REF_736[0]
			TMP_2254(uint256) = 1 << 160
			TMP_2255(uint256) = lengthAndFirst_1 + TMP_2254
			self_2 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_737(uint256) (->self_2 (-> [])) := TMP_2255(uint256)
		Expression: self._raw[len] = uint160(account)
		IRs:
			REF_738(mapping(uint256 => uint256)) -> self_2 (-> [])._raw
			REF_739(uint256) -> REF_738[len_1]
			TMP_2256 = CONVERT account_1 to uint160
			self_3 (-> [])(AddressArray.Data) := ϕ(['self_2 (-> [])'])
			REF_739(uint256) (->self_3 (-> [])) := TMP_2256(uint160)
		Expression: len + 1
		IRs:
			TMP_2257(uint256) = len_1 + 1
			RETURN TMP_2257
	Function AddressArray.pop(AddressArray.Data)
		Expression: lengthAndFirst = self._raw[0]
		IRs:
			REF_740(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_741(uint256) -> REF_740[0]
			lengthAndFirst_1(uint256) := REF_741(uint256)
		Expression: len = lengthAndFirst >> 160
		IRs:
			TMP_2258(uint256) = lengthAndFirst_1 >> 160
			len_1(uint256) := TMP_2258(uint256)
		Expression: len == 0
		IRs:
			TMP_2259(bool) = len_1 == 0
			CONDITION TMP_2259
		Expression: revert PopFromEmptyArray()()
		IRs:
			TMP_2260(None) = SOLIDITY_CALL revert PopFromEmptyArray()()
		Expression: self._raw[len - 1] = 0
		IRs:
			REF_742(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			TMP_2261(uint256) = len_1 - 1
			REF_743(uint256) -> REF_742[TMP_2261]
			self_2 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_743(uint256) (->self_2 (-> [])) := 0(uint256)
		Expression: len > 1
		IRs:
			TMP_2262(bool) = len_1 > 1
			CONDITION TMP_2262
		Expression: self._raw[0] = lengthAndFirst - (1 << 160)
		IRs:
			REF_744(mapping(uint256 => uint256)) -> self_2 (-> [])._raw
			REF_745(uint256) -> REF_744[0]
			TMP_2263(uint256) = 1 << 160
			TMP_2264(uint256) = lengthAndFirst_1 - TMP_2263
			self_3 (-> [])(AddressArray.Data) := ϕ(['self_2 (-> [])'])
			REF_745(uint256) (->self_3 (-> [])) := TMP_2264(uint256)
	Function AddressArray.set(AddressArray.Data,uint256,address)
		Expression: len = length(self)
		IRs:
			TMP_2265(uint256) = INTERNAL_CALL, AddressArray.length(AddressArray.Data)(self_1 (-> []))
			len_1(uint256) := TMP_2265(uint256)
		Expression: index >= len
		IRs:
			TMP_2266(bool) = index_1 >= len_1
			CONDITION TMP_2266
		Expression: revert IndexOutOfBounds()()
		IRs:
			TMP_2267(None) = SOLIDITY_CALL revert IndexOutOfBounds()()
		Expression: index == 0
		IRs:
			TMP_2268(bool) = index_1 == 0
			CONDITION TMP_2268
		Expression: self._raw[0] = (len << 160) | uint160(account)
		IRs:
			REF_746(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_747(uint256) -> REF_746[0]
			TMP_2269(uint256) = len_1 << 160
			TMP_2270 = CONVERT account_1 to uint160
			TMP_2271(uint256) = TMP_2269 | TMP_2270
			self_3 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_747(uint256) (->self_3 (-> [])) := TMP_2271(uint256)
		Expression: self._raw[index] = uint160(account)
		IRs:
			REF_748(mapping(uint256 => uint256)) -> self_1 (-> [])._raw
			REF_749(uint256) -> REF_748[index_1]
			TMP_2272 = CONVERT account_1 to uint160
			self_2 (-> [])(AddressArray.Data) := ϕ(['self_1 (-> [])'])
			REF_749(uint256) (->self_2 (-> [])) := TMP_2272(uint160)
Contract AddressLib
	Function AddressLib.get(Address)
		Expression: address(uint160(Address.unwrap(a)))
		IRs:
			TMP_2273 = CONVERT a_1 to uint256
			TMP_2274 = CONVERT TMP_2273 to uint160
			TMP_2275 = CONVERT TMP_2274 to address
			RETURN TMP_2275
	Function AddressLib.getFlag(Address,uint256)
		Expression: (Address.unwrap(a) & flag) != 0
		IRs:
			TMP_2276 = CONVERT a_1 to uint256
			TMP_2277(uint256) = TMP_2276 & flag_1
			TMP_2278(bool) = TMP_2277 != 0
			RETURN TMP_2278
	Function AddressLib.getUint32(Address,uint256)
		Expression: uint32(Address.unwrap(a) >> offset)
		IRs:
			TMP_2279 = CONVERT a_1 to uint256
			TMP_2280(uint256) = TMP_2279 >> offset_1
			TMP_2281 = CONVERT TMP_2280 to uint32
			RETURN TMP_2281
	Function AddressLib.getUint64(Address,uint256)
		Expression: uint64(Address.unwrap(a) >> offset)
		IRs:
			TMP_2282 = CONVERT a_1 to uint256
			TMP_2283(uint256) = TMP_2282 >> offset_1
			TMP_2284 = CONVERT TMP_2283 to uint64
			RETURN TMP_2284
Contract AddressSet
	Function AddressSet.length(AddressSet.Data)
		Expression: s.items.length()
		IRs:
			REF_750(AddressArray.Data) -> s_1 (-> []).items
			TMP_2285(uint256) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.length(AddressArray.Data), arguments:['REF_750'] 
			RETURN TMP_2285
	Function AddressSet.at(AddressSet.Data,uint256)
		Expression: s.items.at(index)
		IRs:
			REF_752(AddressArray.Data) -> s_1 (-> []).items
			TMP_2286(address) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.at(AddressArray.Data,uint256), arguments:['REF_752', 'index_1'] 
			RETURN TMP_2286
	Function AddressSet.contains(AddressSet.Data,address)
		Expression: s.lookup[item] != 0
		IRs:
			REF_754(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_755(uint256) -> REF_754[item_1]
			TMP_2287(bool) = REF_755 != 0
			RETURN TMP_2287
	Function AddressSet.add(AddressSet.Data,address)
		Expression: s.lookup[item] > 0
		IRs:
			REF_756(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_757(uint256) -> REF_756[item_1]
			TMP_2288(bool) = REF_757 > 0
			CONDITION TMP_2288
		Expression: false
		IRs:
			RETURN False
		Expression: s.lookup[item] = s.items.push(item)
		IRs:
			REF_758(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_759(uint256) -> REF_758[item_1]
			REF_760(AddressArray.Data) -> s_1 (-> []).items
			TMP_2289(uint256) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.push(AddressArray.Data,address), arguments:['REF_760', 'item_1'] 
			s_2 (-> [])(AddressSet.Data) := ϕ(['s_1 (-> [])'])
			REF_759(uint256) (->s_2 (-> [])) := TMP_2289(uint256)
		Expression: true
		IRs:
			RETURN True
	Function AddressSet.remove(AddressSet.Data,address)
		Expression: index = s.lookup[item]
		IRs:
			REF_762(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_763(uint256) -> REF_762[item_1]
			index_1(uint256) := REF_763(uint256)
		Expression: index == 0
		IRs:
			TMP_2290(bool) = index_1 == 0
			CONDITION TMP_2290
		Expression: false
		IRs:
			RETURN False
		Expression: index < s.items.length()
		IRs:
			REF_764(AddressArray.Data) -> s_1 (-> []).items
			TMP_2291(uint256) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.length(AddressArray.Data), arguments:['REF_764'] 
			TMP_2292(bool) = index_1 < TMP_2291
			CONDITION TMP_2292
		Expression: lastItem = s.items.at(s.items.length() - 1)
		IRs:
			REF_766(AddressArray.Data) -> s_1 (-> []).items
			REF_768(AddressArray.Data) -> s_1 (-> []).items
			TMP_2293(uint256) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.length(AddressArray.Data), arguments:['REF_768'] 
			TMP_2294(uint256) = TMP_2293 - 1
			TMP_2295(address) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.at(AddressArray.Data,uint256), arguments:['REF_766', 'TMP_2294'] 
			lastItem_1(address) := TMP_2295(address)
		Expression: s.items.set(index - 1,lastItem)
		IRs:
			REF_770(AddressArray.Data) -> s_1 (-> []).items
			TMP_2296(uint256) = index_1 - 1
			LIBRARY_CALL, dest:AddressArray, function:AddressArray.set(AddressArray.Data,uint256,address), arguments:['REF_770', 'TMP_2296', 'lastItem_1'] 
		Expression: s.lookup[lastItem] = index
		IRs:
			REF_772(mapping(address => uint256)) -> s_1 (-> []).lookup
			REF_773(uint256) -> REF_772[lastItem_1]
			s_2 (-> [])(AddressSet.Data) := ϕ(['s_1 (-> [])'])
			REF_773(uint256) (->s_2 (-> [])) := index_1(uint256)
		IRs:
			s_3 (-> [])(AddressSet.Data) := ϕ(['s_2 (-> [])', 's_1 (-> [])'])
		Expression: s.items.pop()
		IRs:
			REF_774(AddressArray.Data) -> s_3 (-> []).items
			LIBRARY_CALL, dest:AddressArray, function:AddressArray.pop(AddressArray.Data), arguments:['REF_774'] 
		Expression: delete s.lookup[item]
		IRs:
			REF_776(mapping(address => uint256)) -> s_3 (-> []).lookup
			REF_777(uint256) -> REF_776[item_1]
			REF_776 = delete REF_777 
		Expression: true
		IRs:
			RETURN True
Contract ECDSA
	Function ECDSA.recover(bytes32,uint8,bytes32,bytes32)
		IRs:
			hash_1(bytes32) := ϕ(['hash_1'])
			v_1(uint8) := ϕ(['v_1'])
			r_1(bytes32) := ϕ(['r_1'])
			s_1(bytes32) := ϕ(['s_1'])
			_S_BOUNDARY_1(uint256) := ϕ(['_S_BOUNDARY_0'])
		Expression: s < _S_BOUNDARY
		IRs:
			TMP_2299(bool) = s_1 < _S_BOUNDARY_1
			CONDITION TMP_2299
		IRs:
			signer_2(address) := ϕ(['signer_0', 'signer_1'])
		Expression: ptr_recover_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2300(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_recover_asm_0_1(uint256) := TMP_2300(uint256)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0,hash)
		IRs:
			TMP_2301(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_recover_asm_0_1,hash_1)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0 + 0x20,v)
		IRs:
			TMP_2302(uint256) = ptr_recover_asm_0_1 + 32
			TMP_2303(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2302,v_1)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0 + 0x40,r)
		IRs:
			TMP_2304(uint256) = ptr_recover_asm_0_1 + 64
			TMP_2305(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2304,r_1)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0 + 0x60,s)
		IRs:
			TMP_2306(uint256) = ptr_recover_asm_0_1 + 96
			TMP_2307(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2306,s_1)
		Expression: mstore(uint256,uint256)(0,0)
		IRs:
			TMP_2308(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,0)
		Expression: pop(uint256)(staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),0x1,ptr_recover_asm_0,0x80,0,0x20))
		IRs:
			TMP_2309(uint256) = SOLIDITY_CALL gas()()
			TMP_2310(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2309,1,ptr_recover_asm_0_1,128,0,32)
			TMP_2311(None) = SOLIDITY_CALL pop(uint256)(TMP_2310)
		Expression: signer = mload(uint256)(0)
		IRs:
			TMP_2312(uint256) = SOLIDITY_CALL mload(uint256)(0)
			signer_1(address) := TMP_2312(uint256)
		Expression: signer
		IRs:
			RETURN signer_2
	Function ECDSA.recover(bytes32,bytes32,bytes32)
		IRs:
			hash_1(bytes32) := ϕ(['hash_1', 'hash_1'])
			r_1(bytes32) := ϕ(['r_1', 'r_1'])
			vs_1(bytes32) := ϕ(['vs_1', 'vs_1'])
			_S_BOUNDARY_2(uint256) := ϕ(['_S_BOUNDARY_0'])
			_COMPACT_S_MASK_1(uint256) := ϕ(['_COMPACT_S_MASK_0'])
			_COMPACT_V_SHIFT_1(uint256) := ϕ(['_COMPACT_V_SHIFT_0'])
		Expression: s_recover_asm_0 = vs & _COMPACT_S_MASK
		IRs:
			TMP_2313(bytes32) = vs_1 & _COMPACT_S_MASK_1
			s_recover_asm_0_1(uint256) := TMP_2313(bytes32)
		Expression: s_recover_asm_0 < _S_BOUNDARY
		IRs:
			TMP_2314(bool) = s_recover_asm_0_1 < _S_BOUNDARY_2
			CONDITION TMP_2314
		IRs:
			signer_2(address) := ϕ(['signer_1', 'signer_0'])
		Expression: ptr_recover_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2315(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_recover_asm_0_1(uint256) := TMP_2315(uint256)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0,hash)
		IRs:
			TMP_2316(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_recover_asm_0_1,hash_1)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0 + 0x20,27 + vs >> _COMPACT_V_SHIFT)
		IRs:
			TMP_2317(uint256) = ptr_recover_asm_0_1 + 32
			TMP_2318(bytes32) = vs_1 >> _COMPACT_V_SHIFT_1
			TMP_2319(uint256) = 27 + TMP_2318
			TMP_2320(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2317,TMP_2319)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0 + 0x40,r)
		IRs:
			TMP_2321(uint256) = ptr_recover_asm_0_1 + 64
			TMP_2322(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2321,r_1)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0 + 0x60,s_recover_asm_0)
		IRs:
			TMP_2323(uint256) = ptr_recover_asm_0_1 + 96
			TMP_2324(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2323,s_recover_asm_0_1)
		Expression: mstore(uint256,uint256)(0,0)
		IRs:
			TMP_2325(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,0)
		Expression: pop(uint256)(staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),0x1,ptr_recover_asm_0,0x80,0,0x20))
		IRs:
			TMP_2326(uint256) = SOLIDITY_CALL gas()()
			TMP_2327(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2326,1,ptr_recover_asm_0_1,128,0,32)
			TMP_2328(None) = SOLIDITY_CALL pop(uint256)(TMP_2327)
		Expression: signer = mload(uint256)(0)
		IRs:
			TMP_2329(uint256) = SOLIDITY_CALL mload(uint256)(0)
			signer_1(address) := TMP_2329(uint256)
		Expression: signer
		IRs:
			RETURN signer_2
	Function ECDSA.recover(bytes32,bytes)
		IRs:
			hash_1(bytes32) := ϕ(['hash_1'])
			signature_1(bytes) := ϕ(['signature_1'])
			_S_BOUNDARY_3(uint256) := ϕ(['_S_BOUNDARY_0'])
			_COMPACT_S_MASK_2(uint256) := ϕ(['_COMPACT_S_MASK_0'])
			_COMPACT_V_SHIFT_2(uint256) := ϕ(['_COMPACT_V_SHIFT_0'])
		Expression: ptr_recover_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2330(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_recover_asm_0_1(uint256) := TMP_2330(uint256)
		Expression: switch_expr_3531_707_45_recover_asm_0 = signature
		IRs:
			switch_expr_3531_707_45_recover_asm_0_1(uint256) := signature_1(bytes)
		Expression: switch_expr_3531_707_45_recover_asm_0 == 65
		IRs:
			TMP_2331(bool) = switch_expr_3531_707_45_recover_asm_0_1 == 65
			CONDITION TMP_2331
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0 + 0x20,byte(uint256,uint256)(0,calldataload(uint256)(signature + 0x40)))
		IRs:
			TMP_2332(uint256) = ptr_recover_asm_0_1 + 32
			TMP_2333(bytes) = signature_1 + 64
			TMP_2334(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_2333)
			TMP_2335(uint256) = SOLIDITY_CALL byte(uint256,uint256)(0,TMP_2334)
			TMP_2336(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2332,TMP_2335)
		Expression: calldatacopy(uint256,uint256,uint256)(ptr_recover_asm_0 + 0x40,signature,0x40)
		IRs:
			TMP_2337(uint256) = ptr_recover_asm_0_1 + 64
			TMP_2338(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_2337,signature_1,64)
		Expression: switch_expr_3531_707_45_recover_asm_0 == 64
		IRs:
			TMP_2339(bool) = switch_expr_3531_707_45_recover_asm_0_1 == 64
			CONDITION TMP_2339
		IRs:
			ptr_recover_asm_0_3(uint256) := ϕ(['ptr_recover_asm_0_2', 'ptr_recover_asm_0_1'])
		Expression: vs_recover_asm_0 = calldataload(uint256)(signature + 0x20)
		IRs:
			TMP_2340(bytes) = signature_1 + 32
			TMP_2341(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_2340)
			vs_recover_asm_0_1(uint256) := TMP_2341(uint256)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0 + 0x20,27 + vs_recover_asm_0 >> _COMPACT_V_SHIFT)
		IRs:
			TMP_2342(uint256) = ptr_recover_asm_0_1 + 32
			TMP_2343(uint256) = vs_recover_asm_0_1 >> _COMPACT_V_SHIFT_2
			TMP_2344(uint256) = 27 + TMP_2343
			TMP_2345(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2342,TMP_2344)
		Expression: calldatacopy(uint256,uint256,uint256)(ptr_recover_asm_0 + 0x40,signature,0x20)
		IRs:
			TMP_2346(uint256) = ptr_recover_asm_0_1 + 64
			TMP_2347(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_2346,signature_1,32)
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0 + 0x60,vs_recover_asm_0 & _COMPACT_S_MASK)
		IRs:
			TMP_2348(uint256) = ptr_recover_asm_0_1 + 96
			TMP_2349(uint256) = vs_recover_asm_0_1 & _COMPACT_S_MASK_2
			TMP_2350(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2348,TMP_2349)
		Expression: ptr_recover_asm_0 = 0
		IRs:
			ptr_recover_asm_0_2(uint256) := 0(uint256)
		Expression: ptr_recover_asm_0
		IRs:
			CONDITION ptr_recover_asm_0_3
		Expression: mload(uint256)(ptr_recover_asm_0 + 0x60) < _S_BOUNDARY
		IRs:
			TMP_2351(uint256) = ptr_recover_asm_0_3 + 96
			TMP_2352(uint256) = SOLIDITY_CALL mload(uint256)(TMP_2351)
			TMP_2353(bool) = TMP_2352 < _S_BOUNDARY_3
			CONDITION TMP_2353
		IRs:
			signer_2(address) := ϕ(['signer_1', 'signer_0'])
		Expression: mstore(uint256,uint256)(ptr_recover_asm_0,hash)
		IRs:
			TMP_2354(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_recover_asm_0_3,hash_1)
		Expression: mstore(uint256,uint256)(0,0)
		IRs:
			TMP_2355(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,0)
		Expression: pop(uint256)(staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),0x1,ptr_recover_asm_0,0x80,0,0x20))
		IRs:
			TMP_2356(uint256) = SOLIDITY_CALL gas()()
			TMP_2357(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2356,1,ptr_recover_asm_0_3,128,0,32)
			TMP_2358(None) = SOLIDITY_CALL pop(uint256)(TMP_2357)
		Expression: signer = mload(uint256)(0)
		IRs:
			TMP_2359(uint256) = SOLIDITY_CALL mload(uint256)(0)
			signer_1(address) := TMP_2359(uint256)
		Expression: signer
		IRs:
			RETURN signer_2
	Function ECDSA.recoverOrIsValidSignature(address,bytes32,bytes)
		Expression: signer == address(0)
		IRs:
			TMP_2360 = CONVERT 0 to address
			TMP_2361(bool) = signer_1 == TMP_2360
			CONDITION TMP_2361
		Expression: false
		IRs:
			RETURN False
		Expression: (signature.length == 64 || signature.length == 65) && recover(hash,signature) == signer
		IRs:
			REF_778 -> LENGTH signature_1
			TMP_2362(bool) = REF_778 == 64
			REF_779 -> LENGTH signature_1
			TMP_2363(bool) = REF_779 == 65
			TMP_2364(bool) = TMP_2362 || TMP_2363
			TMP_2365(address) = INTERNAL_CALL, ECDSA.recover(bytes32,bytes)(hash_1,signature_1)
			TMP_2366(bool) = TMP_2365 == signer_1
			TMP_2367(bool) = TMP_2364 && TMP_2366
			CONDITION TMP_2367
		Expression: true
		IRs:
			RETURN True
		Expression: isValidSignature(signer,hash,signature)
		IRs:
			TMP_2368(bool) = INTERNAL_CALL, ECDSA.isValidSignature(address,bytes32,bytes)(signer_1,hash_1,signature_1)
			RETURN TMP_2368
		Expression: success
	Function ECDSA.recoverOrIsValidSignature(address,bytes32,uint8,bytes32,bytes32)
		Expression: signer == address(0)
		IRs:
			TMP_2369 = CONVERT 0 to address
			TMP_2370(bool) = signer_1 == TMP_2369
			CONDITION TMP_2370
		Expression: false
		IRs:
			RETURN False
		Expression: recover(hash,v,r,s) == signer
		IRs:
			TMP_2371(address) = INTERNAL_CALL, ECDSA.recover(bytes32,uint8,bytes32,bytes32)(hash_1,v_1,r_1,s_1)
			TMP_2372(bool) = TMP_2371 == signer_1
			CONDITION TMP_2372
		Expression: true
		IRs:
			RETURN True
		Expression: isValidSignature(signer,hash,v,r,s)
		IRs:
			TMP_2373(bool) = INTERNAL_CALL, ECDSA.isValidSignature(address,bytes32,uint8,bytes32,bytes32)(signer_1,hash_1,v_1,r_1,s_1)
			RETURN TMP_2373
		Expression: success
	Function ECDSA.recoverOrIsValidSignature(address,bytes32,bytes32,bytes32)
		Expression: signer == address(0)
		IRs:
			TMP_2374 = CONVERT 0 to address
			TMP_2375(bool) = signer_1 == TMP_2374
			CONDITION TMP_2375
		Expression: false
		IRs:
			RETURN False
		Expression: recover(hash,r,vs) == signer
		IRs:
			TMP_2376(address) = INTERNAL_CALL, ECDSA.recover(bytes32,bytes32,bytes32)(hash_1,r_1,vs_1)
			TMP_2377(bool) = TMP_2376 == signer_1
			CONDITION TMP_2377
		Expression: true
		IRs:
			RETURN True
		Expression: isValidSignature(signer,hash,r,vs)
		IRs:
			TMP_2378(bool) = INTERNAL_CALL, ECDSA.isValidSignature(address,bytes32,bytes32,bytes32)(signer_1,hash_1,r_1,vs_1)
			RETURN TMP_2378
		Expression: success
	Function ECDSA.recoverOrIsValidSignature65(address,bytes32,bytes32,bytes32)
		Expression: signer == address(0)
		IRs:
			TMP_2379 = CONVERT 0 to address
			TMP_2380(bool) = signer_1 == TMP_2379
			CONDITION TMP_2380
		Expression: false
		IRs:
			RETURN False
		Expression: recover(hash,r,vs) == signer
		IRs:
			TMP_2381(address) = INTERNAL_CALL, ECDSA.recover(bytes32,bytes32,bytes32)(hash_1,r_1,vs_1)
			TMP_2382(bool) = TMP_2381 == signer_1
			CONDITION TMP_2382
		Expression: true
		IRs:
			RETURN True
		Expression: isValidSignature65(signer,hash,r,vs)
		IRs:
			TMP_2383(bool) = INTERNAL_CALL, ECDSA.isValidSignature65(address,bytes32,bytes32,bytes32)(signer_1,hash_1,r_1,vs_1)
			RETURN TMP_2383
		Expression: success
	Function ECDSA.isValidSignature(address,bytes32,bytes)
		IRs:
			signer_1(address) := ϕ(['signer_1'])
			hash_1(bytes32) := ϕ(['hash_1'])
			signature_1(bytes) := ϕ(['signature_1'])
		Expression: selector = IERC1271.isValidSignature.selector
		IRs:
			REF_781(bytes4) (->None) := 371636862(bytes4)
			selector_1(bytes4) := REF_781(bytes4)
		Expression: ptr_isValidSignature_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2384(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_isValidSignature_asm_0_1(uint256) := TMP_2384(uint256)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0,selector)
		IRs:
			TMP_2385(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_isValidSignature_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x04,hash)
		IRs:
			TMP_2386(uint256) = ptr_isValidSignature_asm_0_1 + 4
			TMP_2387(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2386,hash_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x24,0x40)
		IRs:
			TMP_2388(uint256) = ptr_isValidSignature_asm_0_1 + 36
			TMP_2389(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2388,64)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x44,signature)
		IRs:
			TMP_2390(uint256) = ptr_isValidSignature_asm_0_1 + 68
			TMP_2391(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2390,signature_1)
		Expression: calldatacopy(uint256,uint256,uint256)(ptr_isValidSignature_asm_0 + 0x64,signature,signature)
		IRs:
			TMP_2392(uint256) = ptr_isValidSignature_asm_0_1 + 100
			TMP_2393(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_2392,signature_1,signature_1)
		Expression: staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),signer,ptr_isValidSignature_asm_0,0x64 + signature,0,0x20)
		IRs:
			TMP_2394(uint256) = SOLIDITY_CALL gas()()
			TMP_2395(uint256) = 100 + signature_1
			TMP_2396(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2394,signer_1,ptr_isValidSignature_asm_0_1,TMP_2395,0,32)
			CONDITION TMP_2396
		IRs:
			success_2(bool) := ϕ(['success_0', 'success_1'])
		Expression: success = selector == mload(uint256)(0) & returndatasize()() == 0x20
		IRs:
			TMP_2397(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_2398(bool) = selector_1 == TMP_2397
			TMP_2399(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2400(bool) = TMP_2399 == 32
			TMP_2401(bool) = TMP_2398 & TMP_2400
			success_1(bool) := TMP_2401(bool)
		Expression: success
		IRs:
			RETURN success_2
	Function ECDSA.isValidSignature(address,bytes32,uint8,bytes32,bytes32)
		IRs:
			signer_1(address) := ϕ(['signer_1'])
			hash_1(bytes32) := ϕ(['hash_1'])
			v_1(uint8) := ϕ(['v_1'])
			r_1(bytes32) := ϕ(['r_1'])
			s_1(bytes32) := ϕ(['s_1'])
		Expression: selector = IERC1271.isValidSignature.selector
		IRs:
			REF_783(bytes4) (->None) := 371636862(bytes4)
			selector_1(bytes4) := REF_783(bytes4)
		Expression: ptr_isValidSignature_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2402(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_isValidSignature_asm_0_1(uint256) := TMP_2402(uint256)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0,selector)
		IRs:
			TMP_2403(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_isValidSignature_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x04,hash)
		IRs:
			TMP_2404(uint256) = ptr_isValidSignature_asm_0_1 + 4
			TMP_2405(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2404,hash_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x24,0x40)
		IRs:
			TMP_2406(uint256) = ptr_isValidSignature_asm_0_1 + 36
			TMP_2407(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2406,64)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x44,65)
		IRs:
			TMP_2408(uint256) = ptr_isValidSignature_asm_0_1 + 68
			TMP_2409(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2408,65)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x64,r)
		IRs:
			TMP_2410(uint256) = ptr_isValidSignature_asm_0_1 + 100
			TMP_2411(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2410,r_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x84,s)
		IRs:
			TMP_2412(uint256) = ptr_isValidSignature_asm_0_1 + 132
			TMP_2413(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2412,s_1)
		Expression: mstore8(uint256,uint256)(ptr_isValidSignature_asm_0 + 0xa4,v)
		IRs:
			TMP_2414(uint256) = ptr_isValidSignature_asm_0_1 + 164
			TMP_2415(None) = SOLIDITY_CALL mstore8(uint256,uint256)(TMP_2414,v_1)
		Expression: staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),signer,ptr_isValidSignature_asm_0,0xa5,0,0x20)
		IRs:
			TMP_2416(uint256) = SOLIDITY_CALL gas()()
			TMP_2417(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2416,signer_1,ptr_isValidSignature_asm_0_1,165,0,32)
			CONDITION TMP_2417
		IRs:
			success_2(bool) := ϕ(['success_1', 'success_0'])
		Expression: success = selector == mload(uint256)(0) & returndatasize()() == 0x20
		IRs:
			TMP_2418(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_2419(bool) = selector_1 == TMP_2418
			TMP_2420(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2421(bool) = TMP_2420 == 32
			TMP_2422(bool) = TMP_2419 & TMP_2421
			success_1(bool) := TMP_2422(bool)
		Expression: success
		IRs:
			RETURN success_2
	Function ECDSA.isValidSignature(address,bytes32,bytes32,bytes32)
		IRs:
			signer_1(address) := ϕ(['signer_1'])
			hash_1(bytes32) := ϕ(['hash_1'])
			r_1(bytes32) := ϕ(['r_1'])
			vs_1(bytes32) := ϕ(['vs_1'])
		Expression: selector = IERC1271.isValidSignature.selector
		IRs:
			REF_785(bytes4) (->None) := 371636862(bytes4)
			selector_1(bytes4) := REF_785(bytes4)
		Expression: ptr_isValidSignature_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2423(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_isValidSignature_asm_0_1(uint256) := TMP_2423(uint256)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0,selector)
		IRs:
			TMP_2424(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_isValidSignature_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x04,hash)
		IRs:
			TMP_2425(uint256) = ptr_isValidSignature_asm_0_1 + 4
			TMP_2426(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2425,hash_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x24,0x40)
		IRs:
			TMP_2427(uint256) = ptr_isValidSignature_asm_0_1 + 36
			TMP_2428(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2427,64)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x44,64)
		IRs:
			TMP_2429(uint256) = ptr_isValidSignature_asm_0_1 + 68
			TMP_2430(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2429,64)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x64,r)
		IRs:
			TMP_2431(uint256) = ptr_isValidSignature_asm_0_1 + 100
			TMP_2432(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2431,r_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature_asm_0 + 0x84,vs)
		IRs:
			TMP_2433(uint256) = ptr_isValidSignature_asm_0_1 + 132
			TMP_2434(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2433,vs_1)
		Expression: staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),signer,ptr_isValidSignature_asm_0,0xa4,0,0x20)
		IRs:
			TMP_2435(uint256) = SOLIDITY_CALL gas()()
			TMP_2436(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2435,signer_1,ptr_isValidSignature_asm_0_1,164,0,32)
			CONDITION TMP_2436
		IRs:
			success_2(bool) := ϕ(['success_0', 'success_1'])
		Expression: success = selector == mload(uint256)(0) & returndatasize()() == 0x20
		IRs:
			TMP_2437(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_2438(bool) = selector_1 == TMP_2437
			TMP_2439(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2440(bool) = TMP_2439 == 32
			TMP_2441(bool) = TMP_2438 & TMP_2440
			success_1(bool) := TMP_2441(bool)
		Expression: success
		IRs:
			RETURN success_2
	Function ECDSA.isValidSignature65(address,bytes32,bytes32,bytes32)
		IRs:
			signer_1(address) := ϕ(['signer_1'])
			hash_1(bytes32) := ϕ(['hash_1'])
			r_1(bytes32) := ϕ(['r_1'])
			vs_1(bytes32) := ϕ(['vs_1'])
			_COMPACT_S_MASK_3(uint256) := ϕ(['_COMPACT_S_MASK_0'])
			_COMPACT_V_SHIFT_3(uint256) := ϕ(['_COMPACT_V_SHIFT_0'])
		Expression: selector = IERC1271.isValidSignature.selector
		IRs:
			REF_787(bytes4) (->None) := 371636862(bytes4)
			selector_1(bytes4) := REF_787(bytes4)
		Expression: ptr_isValidSignature65_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2442(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_isValidSignature65_asm_0_1(uint256) := TMP_2442(uint256)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature65_asm_0,selector)
		IRs:
			TMP_2443(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_isValidSignature65_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature65_asm_0 + 0x04,hash)
		IRs:
			TMP_2444(uint256) = ptr_isValidSignature65_asm_0_1 + 4
			TMP_2445(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2444,hash_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature65_asm_0 + 0x24,0x40)
		IRs:
			TMP_2446(uint256) = ptr_isValidSignature65_asm_0_1 + 36
			TMP_2447(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2446,64)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature65_asm_0 + 0x44,65)
		IRs:
			TMP_2448(uint256) = ptr_isValidSignature65_asm_0_1 + 68
			TMP_2449(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2448,65)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature65_asm_0 + 0x64,r)
		IRs:
			TMP_2450(uint256) = ptr_isValidSignature65_asm_0_1 + 100
			TMP_2451(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2450,r_1)
		Expression: mstore(uint256,uint256)(ptr_isValidSignature65_asm_0 + 0x84,vs & _COMPACT_S_MASK)
		IRs:
			TMP_2452(uint256) = ptr_isValidSignature65_asm_0_1 + 132
			TMP_2453(bytes32) = vs_1 & _COMPACT_S_MASK_3
			TMP_2454(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2452,TMP_2453)
		Expression: mstore8(uint256,uint256)(ptr_isValidSignature65_asm_0 + 0xa4,27 + vs >> _COMPACT_V_SHIFT)
		IRs:
			TMP_2455(uint256) = ptr_isValidSignature65_asm_0_1 + 164
			TMP_2456(bytes32) = vs_1 >> _COMPACT_V_SHIFT_3
			TMP_2457(uint256) = 27 + TMP_2456
			TMP_2458(None) = SOLIDITY_CALL mstore8(uint256,uint256)(TMP_2455,TMP_2457)
		Expression: staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),signer,ptr_isValidSignature65_asm_0,0xa5,0,0x20)
		IRs:
			TMP_2459(uint256) = SOLIDITY_CALL gas()()
			TMP_2460(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2459,signer_1,ptr_isValidSignature65_asm_0_1,165,0,32)
			CONDITION TMP_2460
		IRs:
			success_2(bool) := ϕ(['success_1', 'success_0'])
		Expression: success = selector == mload(uint256)(0) & returndatasize()() == 0x20
		IRs:
			TMP_2461(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_2462(bool) = selector_1 == TMP_2461
			TMP_2463(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2464(bool) = TMP_2463 == 32
			TMP_2465(bool) = TMP_2462 & TMP_2464
			success_1(bool) := TMP_2465(bool)
		Expression: success
		IRs:
			RETURN success_2
	Function ECDSA.toEthSignedMessageHash(bytes32)
		Expression: mstore(uint256,uint256)(0,0x19457468657265756d205369676e6564204d6573736167653a0a333200000000)
		IRs:
			TMP_2466(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,11430537079145650693387304458692941425836787954612963690241153482819318579200)
		Expression: mstore(uint256,uint256)(28,hash)
		IRs:
			TMP_2467(None) = SOLIDITY_CALL mstore(uint256,uint256)(28,hash_1)
		Expression: res = keccak256(uint256,uint256)(0,60)
		IRs:
			TMP_2468(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(0,60)
			res_1(bytes32) := TMP_2468(uint256)
		Expression: res
		IRs:
			RETURN res_1
	Function ECDSA.toTypedDataHash(bytes32,bytes32)
		Expression: ptr_toTypedDataHash_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2469(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_toTypedDataHash_asm_0_1(uint256) := TMP_2469(uint256)
		Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0,0x1901000000000000000000000000000000000000000000000000000000000000)
		IRs:
			TMP_2470(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0_1,11309588061646438093662687302255421419811724423900836950936401294474059186176)
		Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0 + 0x02,domainSeparator)
		IRs:
			TMP_2471(uint256) = ptr_toTypedDataHash_asm_0_1 + 2
			TMP_2472(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2471,domainSeparator_1)
		Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0 + 0x22,structHash)
		IRs:
			TMP_2473(uint256) = ptr_toTypedDataHash_asm_0_1 + 34
			TMP_2474(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2473,structHash_1)
		Expression: res = keccak256(uint256,uint256)(ptr_toTypedDataHash_asm_0,66)
		IRs:
			TMP_2475(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(ptr_toTypedDataHash_asm_0_1,66)
			res_1(bytes32) := TMP_2475(uint256)
		Expression: res
		IRs:
			RETURN res_1
	Function ECDSA.slitherConstructorConstantVariables()
		Expression: _S_BOUNDARY = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 + 1
		Expression: _COMPACT_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
		Expression: _COMPACT_V_SHIFT = 255
Contract RevertReasonForwarder
	Function RevertReasonForwarder.reRevert()
		Expression: ptr_reRevert_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2477(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_reRevert_asm_0_1(uint256) := TMP_2477(uint256)
		Expression: returndatacopy(uint256,uint256,uint256)(ptr_reRevert_asm_0,0,returndatasize()())
		IRs:
			TMP_2478(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2479(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(ptr_reRevert_asm_0_1,0,TMP_2478)
		Expression: revert(uint256,uint256)(ptr_reRevert_asm_0,returndatasize()())
		IRs:
			TMP_2480(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2481(None) = SOLIDITY_CALL revert(uint256,uint256)(ptr_reRevert_asm_0_1,TMP_2480)
Contract SafeERC20
	Function SafeERC20.safeTransferFrom(IERC20,address,address,uint256)
		Expression: selector = token.transferFrom.selector
		IRs:
			REF_789(bytes4) (->None) := 599290589(bytes4)
			selector_1(bytes4) := REF_789(bytes4)
		Expression: data_safeTransferFrom_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2482(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data_safeTransferFrom_asm_0_1(uint256) := TMP_2482(uint256)
		Expression: mstore(uint256,uint256)(data_safeTransferFrom_asm_0,selector)
		IRs:
			TMP_2483(None) = SOLIDITY_CALL mstore(uint256,uint256)(data_safeTransferFrom_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(data_safeTransferFrom_asm_0 + 0x04,from)
		IRs:
			TMP_2484(uint256) = data_safeTransferFrom_asm_0_1 + 4
			TMP_2485(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2484,from_1)
		Expression: mstore(uint256,uint256)(data_safeTransferFrom_asm_0 + 0x24,to)
		IRs:
			TMP_2486(uint256) = data_safeTransferFrom_asm_0_1 + 36
			TMP_2487(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2486,to_1)
		Expression: mstore(uint256,uint256)(data_safeTransferFrom_asm_0 + 0x44,amount)
		IRs:
			TMP_2488(uint256) = data_safeTransferFrom_asm_0_1 + 68
			TMP_2489(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2488,amount_1)
		Expression: success = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data_safeTransferFrom_asm_0,100,0x0,0x20)
		IRs:
			TMP_2490(uint256) = SOLIDITY_CALL gas()()
			TMP_2491(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2490,token_1,0,data_safeTransferFrom_asm_0_1,100,0,32)
			success_1(bool) := TMP_2491(uint256)
		Expression: success
		IRs:
			CONDITION success_1
		Expression: switch_expr_1336_245_47_safeTransferFrom_asm_0 = returndatasize()()
		IRs:
			TMP_2492(uint256) = SOLIDITY_CALL returndatasize()()
			switch_expr_1336_245_47_safeTransferFrom_asm_0_1(uint256) := TMP_2492(uint256)
		Expression: switch_expr_1336_245_47_safeTransferFrom_asm_0 == 0
		IRs:
			TMP_2493(bool) = switch_expr_1336_245_47_safeTransferFrom_asm_0_1 == 0
			CONDITION TMP_2493
		IRs:
			success_4(bool) := ϕ(['success_2', 'success_3'])
		Expression: success = extcodesize(uint256)(token) > 0
		IRs:
			REF_790(None) -> token_1.codesize
			TMP_2494(bool) = REF_790 > 0
			success_3(bool) := TMP_2494(bool)
		Expression: success = returndatasize()() > 31 & mload(uint256)(0) == 1
		IRs:
			TMP_2495(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2496(bool) = TMP_2495 > 31
			TMP_2497(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_2498(bool) = TMP_2497 == 1
			TMP_2499(bool) = TMP_2496 & TMP_2498
			success_2(bool) := TMP_2499(bool)
		Expression: ! success
		IRs:
			TMP_2500 = UnaryType.BANG success_4 
			CONDITION TMP_2500
		Expression: revert SafeTransferFromFailed()()
		IRs:
			TMP_2501(None) = SOLIDITY_CALL revert SafeTransferFromFailed()()
	Function SafeERC20.safeTransfer(IERC20,address,uint256)
		Expression: ! _makeCall(token,token.transfer.selector,to,value)
		IRs:
			REF_792(bytes4) (->None) := 2835717307(bytes4)
			TMP_2502(bool) = INTERNAL_CALL, SafeERC20._makeCall(IERC20,bytes4,address,uint256)(token_1,REF_792,to_1,value_1)
			TMP_2503 = UnaryType.BANG TMP_2502 
			CONDITION TMP_2503
		Expression: revert SafeTransferFailed()()
		IRs:
			TMP_2504(None) = SOLIDITY_CALL revert SafeTransferFailed()()
	Function SafeERC20.forceApprove(IERC20,address,uint256)
		IRs:
			token_1(IERC20) := ϕ(['token_1', 'token_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1'])
			value_1(uint256) := ϕ(['TMP_2520', 'TMP_2526'])
		Expression: ! _makeCall(token,token.approve.selector,spender,value)
		IRs:
			REF_794(bytes4) (->None) := 157198259(bytes4)
			TMP_2505(bool) = INTERNAL_CALL, SafeERC20._makeCall(IERC20,bytes4,address,uint256)(token_1,REF_794,spender_1,value_1)
			TMP_2506 = UnaryType.BANG TMP_2505 
			CONDITION TMP_2506
		Expression: ! _makeCall(token,token.approve.selector,spender,0) || ! _makeCall(token,token.approve.selector,spender,value)
		IRs:
			REF_796(bytes4) (->None) := 157198259(bytes4)
			TMP_2507(bool) = INTERNAL_CALL, SafeERC20._makeCall(IERC20,bytes4,address,uint256)(token_1,REF_796,spender_1,0)
			TMP_2508 = UnaryType.BANG TMP_2507 
			REF_798(bytes4) (->None) := 157198259(bytes4)
			TMP_2509(bool) = INTERNAL_CALL, SafeERC20._makeCall(IERC20,bytes4,address,uint256)(token_1,REF_798,spender_1,value_1)
			TMP_2510 = UnaryType.BANG TMP_2509 
			TMP_2511(bool) = TMP_2508 || TMP_2510
			CONDITION TMP_2511
		Expression: revert ForceApproveFailed()()
		IRs:
			TMP_2512(None) = SOLIDITY_CALL revert ForceApproveFailed()()
	Function SafeERC20.safeIncreaseAllowance(IERC20,address,uint256)
		Expression: allowance = token.allowance(address(this),spender)
		IRs:
			TMP_2513 = CONVERT this to address
			TMP_2514(uint256) = HIGH_LEVEL_CALL, dest:token_1(IERC20), function:allowance, arguments:['TMP_2513', 'spender_1']  
			allowance_1(uint256) := TMP_2514(uint256)
		Expression: value > type()(uint256).max - allowance
		IRs:
			TMP_2516(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_2517(uint256) = TMP_2516 (c)- allowance_1
			TMP_2518(bool) = value_1 > TMP_2517
			CONDITION TMP_2518
		Expression: revert SafeIncreaseAllowanceFailed()()
		IRs:
			TMP_2519(None) = SOLIDITY_CALL revert SafeIncreaseAllowanceFailed()()
		Expression: forceApprove(token,spender,allowance + value)
		IRs:
			TMP_2520(uint256) = allowance_1 (c)+ value_1
			INTERNAL_CALL, SafeERC20.forceApprove(IERC20,address,uint256)(token_1,spender_1,TMP_2520)
	Function SafeERC20.safeDecreaseAllowance(IERC20,address,uint256)
		Expression: allowance = token.allowance(address(this),spender)
		IRs:
			TMP_2522 = CONVERT this to address
			TMP_2523(uint256) = HIGH_LEVEL_CALL, dest:token_1(IERC20), function:allowance, arguments:['TMP_2522', 'spender_1']  
			allowance_1(uint256) := TMP_2523(uint256)
		Expression: value > allowance
		IRs:
			TMP_2524(bool) = value_1 > allowance_1
			CONDITION TMP_2524
		Expression: revert SafeDecreaseAllowanceFailed()()
		IRs:
			TMP_2525(None) = SOLIDITY_CALL revert SafeDecreaseAllowanceFailed()()
		Expression: forceApprove(token,spender,allowance - value)
		IRs:
			TMP_2526(uint256) = allowance_1 (c)- value_1
			INTERNAL_CALL, SafeERC20.forceApprove(IERC20,address,uint256)(token_1,spender_1,TMP_2526)
	Function SafeERC20.safePermit(IERC20,bytes)
		Expression: ! tryPermit(token,permit)
		IRs:
			TMP_2528(bool) = INTERNAL_CALL, SafeERC20.tryPermit(IERC20,bytes)(token_1,permit_1)
			TMP_2529 = UnaryType.BANG TMP_2528 
			CONDITION TMP_2529
		Expression: RevertReasonForwarder.reRevert()
		IRs:
			LIBRARY_CALL, dest:RevertReasonForwarder, function:RevertReasonForwarder.reRevert(), arguments:[] 
	Function SafeERC20.tryPermit(IERC20,bytes)
		IRs:
			token_1(IERC20) := ϕ(['token_1'])
			permit_1(bytes) := ϕ(['permit_1'])
		Expression: permit.length == 32 * 7
		IRs:
			REF_802 -> LENGTH permit_1
			TMP_2531(uint256) = 32 (c)* 7
			TMP_2532(bool) = REF_802 == TMP_2531
			CONDITION TMP_2532
		Expression: _makeCalldataCall(token,IERC20Permit.permit.selector,permit)
		IRs:
			REF_804(bytes4) (->None) := 3573918927(bytes4)
			TMP_2533(bool) = INTERNAL_CALL, SafeERC20._makeCalldataCall(IERC20,bytes4,bytes)(token_1,REF_804,permit_1)
			RETURN TMP_2533
		Expression: permit.length == 32 * 8
		IRs:
			REF_805 -> LENGTH permit_1
			TMP_2534(uint256) = 32 (c)* 8
			TMP_2535(bool) = REF_805 == TMP_2534
			CONDITION TMP_2535
		Expression: _makeCalldataCall(token,IDaiLikePermit.permit.selector,permit)
		IRs:
			REF_807(bytes4) (->None) := 2412490508(bytes4)
			TMP_2536(bool) = INTERNAL_CALL, SafeERC20._makeCalldataCall(IERC20,bytes4,bytes)(token_1,REF_807,permit_1)
			RETURN TMP_2536
		Expression: revert SafePermitBadLength()()
		IRs:
			TMP_2537(None) = SOLIDITY_CALL revert SafePermitBadLength()()
	Function SafeERC20._makeCall(IERC20,bytes4,address,uint256)
		IRs:
			token_1(IERC20) := ϕ(['token_1', 'token_1'])
			selector_1(bytes4) := ϕ(['REF_796', 'REF_794', 'REF_798', 'REF_792'])
			to_1(address) := ϕ(['spender_1', 'to_1'])
			amount_1(uint256) := ϕ(['value_1', 'value_1'])
		Expression: data__makeCall_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2538(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data__makeCall_asm_0_1(uint256) := TMP_2538(uint256)
		Expression: mstore(uint256,uint256)(data__makeCall_asm_0,selector)
		IRs:
			TMP_2539(None) = SOLIDITY_CALL mstore(uint256,uint256)(data__makeCall_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(data__makeCall_asm_0 + 0x04,to)
		IRs:
			TMP_2540(uint256) = data__makeCall_asm_0_1 + 4
			TMP_2541(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2540,to_1)
		Expression: mstore(uint256,uint256)(data__makeCall_asm_0 + 0x24,amount)
		IRs:
			TMP_2542(uint256) = data__makeCall_asm_0_1 + 36
			TMP_2543(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2542,amount_1)
		Expression: success = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data__makeCall_asm_0,0x44,0x0,0x20)
		IRs:
			TMP_2544(uint256) = SOLIDITY_CALL gas()()
			TMP_2545(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2544,token_1,0,data__makeCall_asm_0_1,68,0,32)
			success_1(bool) := TMP_2545(uint256)
		Expression: success
		IRs:
			CONDITION success_1
		Expression: switch_expr_4503_245_47__makeCall_asm_0 = returndatasize()()
		IRs:
			TMP_2546(uint256) = SOLIDITY_CALL returndatasize()()
			switch_expr_4503_245_47__makeCall_asm_0_1(uint256) := TMP_2546(uint256)
		Expression: switch_expr_4503_245_47__makeCall_asm_0 == 0
		IRs:
			TMP_2547(bool) = switch_expr_4503_245_47__makeCall_asm_0_1 == 0
			CONDITION TMP_2547
		IRs:
			success_4(bool) := ϕ(['success_2', 'success_3'])
		Expression: success = extcodesize(uint256)(token) > 0
		IRs:
			REF_808(None) -> token_1.codesize
			TMP_2548(bool) = REF_808 > 0
			success_3(bool) := TMP_2548(bool)
		Expression: success = returndatasize()() > 31 & mload(uint256)(0) == 1
		IRs:
			TMP_2549(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2550(bool) = TMP_2549 > 31
			TMP_2551(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_2552(bool) = TMP_2551 == 1
			TMP_2553(bool) = TMP_2550 & TMP_2552
			success_2(bool) := TMP_2553(bool)
		Expression: success
		IRs:
			RETURN success_4
	Function SafeERC20._makeCalldataCall(IERC20,bytes4,bytes)
		IRs:
			token_1(IERC20) := ϕ(['token_1'])
			selector_1(bytes4) := ϕ(['REF_807', 'REF_804'])
			args_1(bytes) := ϕ(['permit_1'])
		Expression: len__makeCalldataCall_asm_0 = 4 + args
		IRs:
			TMP_2554(uint256) = 4 + args_1
			len__makeCalldataCall_asm_0_1(uint256) := TMP_2554(uint256)
		Expression: data__makeCalldataCall_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_2555(uint256) = SOLIDITY_CALL mload(uint256)(64)
			data__makeCalldataCall_asm_0_1(uint256) := TMP_2555(uint256)
		Expression: mstore(uint256,uint256)(data__makeCalldataCall_asm_0,selector)
		IRs:
			TMP_2556(None) = SOLIDITY_CALL mstore(uint256,uint256)(data__makeCalldataCall_asm_0_1,selector_1)
		Expression: calldatacopy(uint256,uint256,uint256)(data__makeCalldataCall_asm_0 + 0x04,args,args)
		IRs:
			TMP_2557(uint256) = data__makeCalldataCall_asm_0_1 + 4
			TMP_2558(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_2557,args_1,args_1)
		Expression: success = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data__makeCalldataCall_asm_0,len__makeCalldataCall_asm_0,0x0,0x20)
		IRs:
			TMP_2559(uint256) = SOLIDITY_CALL gas()()
			TMP_2560(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2559,token_1,0,data__makeCalldataCall_asm_0_1,len__makeCalldataCall_asm_0_1,0,32)
			success_1(bool) := TMP_2560(uint256)
		Expression: success
		IRs:
			CONDITION success_1
		Expression: switch_expr_5322_245_47__makeCalldataCall_asm_0 = returndatasize()()
		IRs:
			TMP_2561(uint256) = SOLIDITY_CALL returndatasize()()
			switch_expr_5322_245_47__makeCalldataCall_asm_0_1(uint256) := TMP_2561(uint256)
		Expression: switch_expr_5322_245_47__makeCalldataCall_asm_0 == 0
		IRs:
			TMP_2562(bool) = switch_expr_5322_245_47__makeCalldataCall_asm_0_1 == 0
			CONDITION TMP_2562
		IRs:
			success_4(bool) := ϕ(['success_2', 'success_3'])
		Expression: success = extcodesize(uint256)(token) > 0
		IRs:
			REF_809(None) -> token_1.codesize
			TMP_2563(bool) = REF_809 > 0
			success_2(bool) := TMP_2563(bool)
		Expression: success = returndatasize()() > 31 & mload(uint256)(0) == 1
		IRs:
			TMP_2564(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2565(bool) = TMP_2564 > 31
			TMP_2566(uint256) = SOLIDITY_CALL mload(uint256)(0)
			TMP_2567(bool) = TMP_2566 == 1
			TMP_2568(bool) = TMP_2565 & TMP_2567
			success_3(bool) := TMP_2568(bool)
		Expression: success
		IRs:
			RETURN success_4
Contract StringUtil
	Function StringUtil.toHex(uint256)
		Expression: toHex(abi.encodePacked(value))
		IRs:
			TMP_2569(bytes) = SOLIDITY_CALL abi.encodePacked()(value_1)
			TMP_2570(string) = INTERNAL_CALL, StringUtil.toHex(bytes)(TMP_2569)
			RETURN TMP_2570
	Function StringUtil.toHex(address)
		Expression: toHex(abi.encodePacked(value))
		IRs:
			TMP_2571(bytes) = SOLIDITY_CALL abi.encodePacked()(value_1)
			TMP_2572(string) = INTERNAL_CALL, StringUtil.toHex(bytes)(TMP_2571)
			RETURN TMP_2572
	Function StringUtil.toHex(bytes)
		IRs:
			data_1(bytes) := ϕ(['TMP_2569', 'TMP_2571'])
		Expression: result = mload(uint256)(0x40)
		IRs:
			TMP_2573(uint256) = SOLIDITY_CALL mload(uint256)(64)
			result_1(string) := TMP_2573(uint256)
		Expression: length_toHex_asm_0 = mload(uint256)(data)
		IRs:
			TMP_2574(uint256) = SOLIDITY_CALL mload(uint256)(data_1)
			length_toHex_asm_0_1(uint256) := TMP_2574(uint256)
		Expression: resultLength_toHex_asm_0 = length_toHex_asm_0 << 1
		IRs:
			TMP_2575(uint256) = length_toHex_asm_0_1 << 1
			resultLength_toHex_asm_0_1(uint256) := TMP_2575(uint256)
		Expression: toPtr_toHex_asm_0 = result + 0x22
		IRs:
			TMP_2576(string) = result_1 + 34
			toPtr_toHex_asm_0_1(uint256) := TMP_2576(string)
		Expression: mstore(uint256,uint256)(0x40,toPtr_toHex_asm_0 + resultLength_toHex_asm_0)
		IRs:
			TMP_2577(uint256) = toPtr_toHex_asm_0_1 + resultLength_toHex_asm_0_1
			TMP_2578(None) = SOLIDITY_CALL mstore(uint256,uint256)(64,TMP_2577)
		Expression: mstore(uint256,uint256)(result + 2,0x3078)
		IRs:
			TMP_2579(string) = result_1 + 2
			TMP_2580(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2579,12408)
		Expression: mstore(uint256,uint256)(result,resultLength_toHex_asm_0 + 2)
		IRs:
			TMP_2581(uint256) = resultLength_toHex_asm_0_1 + 2
			TMP_2582(None) = SOLIDITY_CALL mstore(uint256,uint256)(result_1,TMP_2581)
		Expression: fromPtr_toHex_asm_0 = data + 0x20
		IRs:
			TMP_2583(bytes) = data_1 + 32
			fromPtr_toHex_asm_0_1(uint256) := TMP_2583(bytes)
		Expression: endPtr_toHex_asm_0 = fromPtr_toHex_asm_0 + length_toHex_asm_0
		IRs:
			TMP_2584(uint256) = fromPtr_toHex_asm_0_1 + length_toHex_asm_0_1
			endPtr_toHex_asm_0_1(uint256) := TMP_2584(uint256)
		Expression: fromPtr_toHex_asm_0 < endPtr_toHex_asm_0
		IRs:
			toPtr_toHex_asm_0_2(uint256) := ϕ(['toPtr_toHex_asm_0_4', 'toPtr_toHex_asm_0_1'])
			fromPtr_toHex_asm_0_2(uint256) := ϕ(['fromPtr_toHex_asm_0_3', 'fromPtr_toHex_asm_0_1'])
			TMP_2585(bool) = fromPtr_toHex_asm_0_2 < endPtr_toHex_asm_0_1
			CONDITION TMP_2585
		Expression: rawData_toHex_asm_0 = mload(uint256)(fromPtr_toHex_asm_0)
		IRs:
			TMP_2586(uint256) = SOLIDITY_CALL mload(uint256)(fromPtr_toHex_asm_0_2)
			rawData_toHex_asm_0_1(uint256) := TMP_2586(uint256)
		Expression: hexData_toHex_asm_0 = _toHex16(rawData_toHex_asm_0)
		IRs:
			TMP_2587(uint256) = INTERNAL_CALL, StringUtil.toHex.asm_0._toHex16()(rawData_toHex_asm_0_1)
			hexData_toHex_asm_0_1(uint256) := TMP_2587(uint256)
		Expression: mstore(uint256,uint256)(toPtr_toHex_asm_0,hexData_toHex_asm_0)
		IRs:
			TMP_2588(None) = SOLIDITY_CALL mstore(uint256,uint256)(toPtr_toHex_asm_0_2,hexData_toHex_asm_0_1)
		Expression: toPtr_toHex_asm_0 = toPtr_toHex_asm_0 + 0x20
		IRs:
			TMP_2589(uint256) = toPtr_toHex_asm_0_2 + 32
			toPtr_toHex_asm_0_3(uint256) := TMP_2589(uint256)
		Expression: hexData_toHex_asm_0 = _toHex16(rawData_toHex_asm_0 << 128)
		IRs:
			TMP_2590(uint256) = rawData_toHex_asm_0_1 << 128
			TMP_2591(uint256) = INTERNAL_CALL, StringUtil.toHex.asm_0._toHex16()(TMP_2590)
			hexData_toHex_asm_0_2(uint256) := TMP_2591(uint256)
		Expression: mstore(uint256,uint256)(toPtr_toHex_asm_0,hexData_toHex_asm_0)
		IRs:
			TMP_2592(None) = SOLIDITY_CALL mstore(uint256,uint256)(toPtr_toHex_asm_0_3,hexData_toHex_asm_0_2)
		Expression: toPtr_toHex_asm_0 = toPtr_toHex_asm_0 + 0x20
		IRs:
			TMP_2593(uint256) = toPtr_toHex_asm_0_3 + 32
			toPtr_toHex_asm_0_4(uint256) := TMP_2593(uint256)
		Expression: fromPtr_toHex_asm_0 = fromPtr_toHex_asm_0 + 0x20
		IRs:
			TMP_2594(uint256) = fromPtr_toHex_asm_0_2 + 32
			fromPtr_toHex_asm_0_3(uint256) := TMP_2594(uint256)
		Expression: result
		IRs:
			RETURN result_1
	Function StringUtil.toHex.asm_0._toHex16()
		IRs:
			input_toHex_asm_0__toHex16_2(uint256) := ϕ(['rawData_toHex_asm_0_1', 'TMP_2590'])
		Expression: output_toHex_asm_0__toHex16 = input_toHex_asm_0__toHex16 & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000 | input_toHex_asm_0__toHex16 & 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000 >> 64
		Expression: output_toHex_asm_0__toHex16 = output_toHex_asm_0__toHex16 & 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000 | output_toHex_asm_0__toHex16 & 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000 >> 32
		Expression: output_toHex_asm_0__toHex16 = output_toHex_asm_0__toHex16 & 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000 | output_toHex_asm_0__toHex16 & 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000 >> 16
		Expression: output_toHex_asm_0__toHex16 = output_toHex_asm_0__toHex16 & 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000 | output_toHex_asm_0__toHex16 & 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000 >> 8
		Expression: output_toHex_asm_0__toHex16 = output_toHex_asm_0__toHex16 & 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000 >> 4 | output_toHex_asm_0__toHex16 & 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00 >> 8
		Expression: output_toHex_asm_0__toHex16 = 0x3030303030303030303030303030303030303030303030303030303030303030 + output_toHex_asm_0__toHex16 + output_toHex_asm_0__toHex16 + 0x0606060606060606060606060606060606060606060606060606060606060606 >> 4 & 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F * 7
Contract UniERC20
	Function UniERC20.isETH(IERC20)
		IRs:
			token_1(IERC20) := ϕ(['token_1', 'token_1', 'token_1', 'token_1', 'token_1'])
			_ETH_ADDRESS_1(IERC20) := ϕ(['_ETH_ADDRESS_0'])
			_ZERO_ADDRESS_1(IERC20) := ϕ(['_ZERO_ADDRESS_0'])
		Expression: (token == _ZERO_ADDRESS || token == _ETH_ADDRESS)
		IRs:
			TMP_2622(bool) = token_1 == _ZERO_ADDRESS_1
			TMP_2623(bool) = token_1 == _ETH_ADDRESS_1
			TMP_2624(bool) = TMP_2622 || TMP_2623
			RETURN TMP_2624
	Function UniERC20.uniBalanceOf(IERC20,address)
		Expression: isETH(token)
		IRs:
			TMP_2625(bool) = INTERNAL_CALL, UniERC20.isETH(IERC20)(token_1)
			CONDITION TMP_2625
		Expression: account.balance
		IRs:
			TMP_2626(uint256) = SOLIDITY_CALL balance(address)(account_1)
			RETURN TMP_2626
		Expression: token.balanceOf(account)
		IRs:
			TMP_2627(uint256) = HIGH_LEVEL_CALL, dest:token_1(IERC20), function:balanceOf, arguments:['account_1']  
			RETURN TMP_2627
	Function UniERC20.uniTransfer(IERC20,address,uint256)
		IRs:
			_RAW_CALL_GAS_LIMIT_1(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_0', '_RAW_CALL_GAS_LIMIT_5', '_RAW_CALL_GAS_LIMIT_2', '_RAW_CALL_GAS_LIMIT_3'])
		Expression: amount > 0
		IRs:
			TMP_2628(bool) = amount_1 > 0
			CONDITION TMP_2628
		Expression: isETH(token)
		IRs:
			TMP_2629(bool) = INTERNAL_CALL, UniERC20.isETH(IERC20)(token_1)
			CONDITION TMP_2629
		Expression: address(this).balance < amount
		IRs:
			TMP_2630 = CONVERT this to address
			TMP_2631(uint256) = SOLIDITY_CALL balance(address)(TMP_2630)
			TMP_2632(bool) = TMP_2631 < amount_1
			CONDITION TMP_2632
		Expression: revert InsufficientBalance()()
		IRs:
			TMP_2633(None) = SOLIDITY_CALL revert InsufficientBalance()()
		Expression: (success,None) = to.call{gas: _RAW_CALL_GAS_LIMIT,value: amount}()
		IRs:
			TUPLE_55(bool,bytes) = LOW_LEVEL_CALL, dest:to_1, function:call, arguments:[''] value:amount_1 gas:_RAW_CALL_GAS_LIMIT_2
			_RAW_CALL_GAS_LIMIT_3(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_5', '_RAW_CALL_GAS_LIMIT_2', '_RAW_CALL_GAS_LIMIT_3'])
			success_1(bool)= UNPACK TUPLE_55 index: 0 
		Expression: ! success
		IRs:
			TMP_2634 = UnaryType.BANG success_1 
			CONDITION TMP_2634
		Expression: revert ETHTransferFailed()()
		IRs:
			TMP_2635(None) = SOLIDITY_CALL revert ETHTransferFailed()()
		Expression: token.safeTransfer(to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['token_1', 'to_1', 'amount_1'] 
	Function UniERC20.uniTransferFrom(IERC20,address,address,uint256)
		IRs:
			_RAW_CALL_GAS_LIMIT_4(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_0', '_RAW_CALL_GAS_LIMIT_5', '_RAW_CALL_GAS_LIMIT_2', '_RAW_CALL_GAS_LIMIT_3'])
		Expression: amount > 0
		IRs:
			TMP_2637(bool) = amount_1 > 0
			CONDITION TMP_2637
		Expression: isETH(token)
		IRs:
			TMP_2638(bool) = INTERNAL_CALL, UniERC20.isETH(IERC20)(token_1)
			CONDITION TMP_2638
		Expression: msg.value < amount
		IRs:
			TMP_2639(bool) = msg.value < amount_1
			CONDITION TMP_2639
		Expression: revert NotEnoughValue()()
		IRs:
			TMP_2640(None) = SOLIDITY_CALL revert NotEnoughValue()()
		Expression: from != msg.sender
		IRs:
			TMP_2641(bool) = from_1 != msg.sender
			CONDITION TMP_2641
		Expression: revert FromIsNotSender()()
		IRs:
			TMP_2642(None) = SOLIDITY_CALL revert FromIsNotSender()()
		Expression: to != address(this)
		IRs:
			TMP_2643 = CONVERT this to address
			TMP_2644(bool) = to_1 != TMP_2643
			CONDITION TMP_2644
		Expression: revert ToIsNotThis()()
		IRs:
			TMP_2645(None) = SOLIDITY_CALL revert ToIsNotThis()()
		Expression: msg.value > amount
		IRs:
			TMP_2646(bool) = msg.value > amount_1
			CONDITION TMP_2646
		Expression: (success,None) = from.call{gas: _RAW_CALL_GAS_LIMIT,value: msg.value - amount}()
		IRs:
			TMP_2647(uint256) = msg.value - amount_1
			TUPLE_56(bool,bytes) = LOW_LEVEL_CALL, dest:from_1, function:call, arguments:[''] value:TMP_2647 gas:_RAW_CALL_GAS_LIMIT_5
			_RAW_CALL_GAS_LIMIT_6(uint256) := ϕ(['_RAW_CALL_GAS_LIMIT_5', '_RAW_CALL_GAS_LIMIT_2', '_RAW_CALL_GAS_LIMIT_3'])
			success_1(bool)= UNPACK TUPLE_56 index: 0 
		Expression: ! success
		IRs:
			TMP_2648 = UnaryType.BANG success_1 
			CONDITION TMP_2648
		Expression: revert ETHTransferFailed()()
		IRs:
			TMP_2649(None) = SOLIDITY_CALL revert ETHTransferFailed()()
		Expression: token.safeTransferFrom(from,to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['token_1', 'from_1', 'to_1', 'amount_1'] 
	Function UniERC20.uniSymbol(IERC20)
		Expression: _uniDecode(token,IERC20Metadata.symbol.selector,IERC20MetadataUppercase.SYMBOL.selector)
		IRs:
			REF_818(bytes4) (->None) := 2514000705(bytes4)
			REF_820(bytes4) (->None) := 4151283064(bytes4)
			TMP_2651(string) = INTERNAL_CALL, UniERC20._uniDecode(IERC20,bytes4,bytes4)(token_1,REF_818,REF_820)
			RETURN TMP_2651
	Function UniERC20.uniName(IERC20)
		Expression: _uniDecode(token,IERC20Metadata.name.selector,IERC20MetadataUppercase.NAME.selector)
		IRs:
			REF_822(bytes4) (->None) := 117300739(bytes4)
			REF_824(bytes4) (->None) := 2750734206(bytes4)
			TMP_2652(string) = INTERNAL_CALL, UniERC20._uniDecode(IERC20,bytes4,bytes4)(token_1,REF_822,REF_824)
			RETURN TMP_2652
	Function UniERC20.uniApprove(IERC20,address,uint256)
		Expression: isETH(token)
		IRs:
			TMP_2653(bool) = INTERNAL_CALL, UniERC20.isETH(IERC20)(token_1)
			CONDITION TMP_2653
		Expression: revert ApproveCalledOnETH()()
		IRs:
			TMP_2654(None) = SOLIDITY_CALL revert ApproveCalledOnETH()()
		Expression: token.forceApprove(to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.forceApprove(IERC20,address,uint256), arguments:['token_1', 'to_1', 'amount_1'] 
	Function UniERC20._uniDecode(IERC20,bytes4,bytes4)
		IRs:
			token_1(IERC20) := ϕ(['token_1', 'token_1'])
			lowerCaseSelector_1(bytes4) := ϕ(['REF_818', 'REF_822'])
			upperCaseSelector_1(bytes4) := ϕ(['REF_820', 'REF_824'])
		Expression: isETH(token)
		IRs:
			TMP_2656(bool) = INTERNAL_CALL, UniERC20.isETH(IERC20)(token_1)
			CONDITION TMP_2656
		Expression: ETH
		IRs:
			RETURN ETH
		Expression: (success,data) = address(token).staticcall{gas: 20000}(abi.encodeWithSelector(lowerCaseSelector))
		IRs:
			TMP_2657 = CONVERT token_1 to address
			TMP_2658(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(lowerCaseSelector_1)
			TUPLE_57(bool,bytes) = LOW_LEVEL_CALL, dest:TMP_2657, function:staticcall, arguments:['TMP_2658']  gas:20000
			success_1(bool)= UNPACK TUPLE_57 index: 0 
			data_1(bytes)= UNPACK TUPLE_57 index: 1 
		Expression: ! success
		IRs:
			TMP_2659 = UnaryType.BANG success_1 
			CONDITION TMP_2659
		Expression: (success,data) = address(token).staticcall{gas: 20000}(abi.encodeWithSelector(upperCaseSelector))
		IRs:
			TMP_2660 = CONVERT token_1 to address
			TMP_2661(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(upperCaseSelector_1)
			TUPLE_58(bool,bytes) = LOW_LEVEL_CALL, dest:TMP_2660, function:staticcall, arguments:['TMP_2661']  gas:20000
			success_2(bool)= UNPACK TUPLE_58 index: 0 
			data_2(bytes)= UNPACK TUPLE_58 index: 1 
		IRs:
			success_3(bool) := ϕ(['success_1', 'success_2'])
			data_3(bytes) := ϕ(['data_1', 'data_2'])
		Expression: success && data.length >= 0x40
		IRs:
			REF_830 -> LENGTH data_3
			TMP_2662(bool) = REF_830 >= 64
			TMP_2663(bool) = success_3 && TMP_2662
			CONDITION TMP_2663
		Expression: (offset,len) = abi.decode(data,(uint256,uint256))
		IRs:
			TUPLE_59(uint256,uint256) = SOLIDITY_CALL abi.decode()(data_3(uint256,uint256))
			offset_1(uint256)= UNPACK TUPLE_59 index: 0 
			len_1(uint256)= UNPACK TUPLE_59 index: 1 
		Expression: offset == 0x20 && data.length >= 0x40 + len
		IRs:
			TMP_2664(bool) = offset_1 == 32
			REF_832 -> LENGTH data_3
			TMP_2665(uint256) = 64 (c)+ len_1
			TMP_2666(bool) = REF_832 >= TMP_2665
			TMP_2667(bool) = TMP_2664 && TMP_2666
			CONDITION TMP_2667
		Expression: result = data + 0x40
		IRs:
			TMP_2668(bytes) = data_3 + 64
			result_1(string) := TMP_2668(bytes)
		Expression: result
		IRs:
			RETURN result_1
		Expression: success && data.length == 32
		IRs:
			REF_833 -> LENGTH data_3
			TMP_2669(bool) = REF_833 == 32
			TMP_2670(bool) = success_3 && TMP_2669
			CONDITION TMP_2670
		Expression: len_scope_0 = 0
		IRs:
			len_scope_0_1(uint256) := 0(uint256)
		Expression: len_scope_0 < data.length && data[len_scope_0] >= 0x20 && data[len_scope_0] <= 0x7E
		IRs:
			len_scope_0_2(uint256) := ϕ(['len_scope_0_3', 'len_scope_0_1'])
			REF_834 -> LENGTH data_3
			TMP_2671(bool) = len_scope_0_2 < REF_834
			REF_835(None) -> data_3[len_scope_0_2]
			TMP_2672(bool) = REF_835 >= 32
			TMP_2673(bool) = TMP_2671 && TMP_2672
			REF_836(None) -> data_3[len_scope_0_2]
			TMP_2674(bool) = REF_836 <= 126
			TMP_2675(bool) = TMP_2673 && TMP_2674
			CONDITION TMP_2675
		Expression: len_scope_0 ++
		IRs:
			TMP_2676(uint256) := len_scope_0_2(uint256)
			len_scope_0_3(uint256) = len_scope_0_2 + 1
		Expression: len_scope_0 > 0
		IRs:
			TMP_2677(bool) = len_scope_0_2 > 0
			CONDITION TMP_2677
		Expression: mstore(uint256,uint256)(data,len)
		IRs:
			TMP_2678(None) = SOLIDITY_CALL mstore(uint256,uint256)(data_3,len_1)
		Expression: string(data)
		IRs:
			TMP_2679 = CONVERT data_3 to string
			RETURN TMP_2679
		Expression: StringUtil.toHex(address(token))
		IRs:
			TMP_2680 = CONVERT token_1 to address
			TMP_2681(string) = LIBRARY_CALL, dest:StringUtil, function:StringUtil.toHex(address), arguments:['TMP_2680'] 
			RETURN TMP_2681
		Expression: result
	Function UniERC20.slitherConstructorConstantVariables()
		Expression: _RAW_CALL_GAS_LIMIT = 5000
		Expression: _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)
		Expression: _ZERO_ADDRESS = IERC20(address(0))
Contract ERC20PermitMock
	Function TokenMock.constructor(string,string)
		Expression: ERC20(name,symbol)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name_1,symbol_1)
	Function TokenMock.mint(address,uint256)
		Expression: _mint(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function TokenMock.burn(address,uint256)
		Expression: _burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_2690(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2690)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_2692(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_2693(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_2694(bool) = TMP_2692 == TMP_2693
			TMP_2695(None) = SOLIDITY_CALL require(bool,string)(TMP_2694,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_2696 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2696)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_2699 = CONVERT 0 to address
			TMP_2700(bool) = newOwner_1 != TMP_2699
			TMP_2701(None) = SOLIDITY_CALL require(bool,string)(TMP_2700,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['newOwner_1', 'TMP_2696', 'TMP_2690'])
			_owner_2(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_4', '_totalSupply_7'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: _balances[account]
		IRs:
			REF_838(uint256) -> _balances_1[account_1]
			RETURN REF_838
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2705(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2705(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_0', '_allowances_1'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_839(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_840(uint256) -> REF_839[spender_1]
			RETURN REF_840
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2707(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2707(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_2709(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_2709(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2712(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2712(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_2713(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_2714(uint256) = TMP_2713 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2714)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2716(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2716(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2717(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_2717(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_2718(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_2719(None) = SOLIDITY_CALL require(bool,string)(TMP_2718,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_2720(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2720)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_2722 = CONVERT 0 to address
			TMP_2723(bool) = from_1 != TMP_2722
			TMP_2724(None) = SOLIDITY_CALL require(bool,string)(TMP_2723,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_2725 = CONVERT 0 to address
			TMP_2726(bool) = to_1 != TMP_2725
			TMP_2727(None) = SOLIDITY_CALL require(bool,string)(TMP_2726,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_841(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_841(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_2729(bool) = fromBalance_1 >= amount_1
			TMP_2730(None) = SOLIDITY_CALL require(bool,string)(TMP_2729,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_842(uint256) -> _balances_3[from_1]
			TMP_2731(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_842(uint256) (->_balances_4) := TMP_2731(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_843(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_843(-> _balances_5) = REF_843 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1', 'initialAccount_1'])
			amount_1(uint256) := ϕ(['initialBalance_1', 'amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_4', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_2734 = CONVERT 0 to address
			TMP_2735(bool) = account_1 != TMP_2734
			TMP_2736(None) = SOLIDITY_CALL require(bool,string)(TMP_2735,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2737 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_2737,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_844(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_844(-> _balances_8) = REF_844 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_2739 = CONVERT 0 to address
			Emit Transfer(TMP_2739,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2741 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_2741,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_0', '_totalSupply_4', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_2743 = CONVERT 0 to address
			TMP_2744(bool) = account_1 != TMP_2743
			TMP_2745(None) = SOLIDITY_CALL require(bool,string)(TMP_2744,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2746 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_2746,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_845(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_845(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_2748(bool) = accountBalance_1 >= amount_1
			TMP_2749(None) = SOLIDITY_CALL require(bool,string)(TMP_2748,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_846(uint256) -> _balances_10[account_1]
			TMP_2750(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_846(uint256) (->_balances_11) := TMP_2750(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_2751 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_2751,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2753 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_2753,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['value_1', 'TMP_2720', 'TMP_2768', 'amount_1', 'TMP_2714'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_2755 = CONVERT 0 to address
			TMP_2756(bool) = owner_1 != TMP_2755
			TMP_2757(None) = SOLIDITY_CALL require(bool,string)(TMP_2756,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_2758 = CONVERT 0 to address
			TMP_2759(bool) = spender_1 != TMP_2758
			TMP_2760(None) = SOLIDITY_CALL require(bool,string)(TMP_2759,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_847(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_848(uint256) -> REF_847[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_848(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2762(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_2762(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_2764(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_2765(bool) = currentAllowance_1 != TMP_2764
			CONDITION TMP_2765
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_2766(bool) = currentAllowance_1 >= amount_1
			TMP_2767(None) = SOLIDITY_CALL require(bool,string)(TMP_2766,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_2768(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2768)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_2737', 'account_1', 'from_1'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_2746'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_2741'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_2753'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function ERC20Permit.constructor(string)
		Expression: EIP712(name,1)
		IRs:
			INTERNAL_CALL, EIP712.constructor(string,string)(name_1,1)
	Function ERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32)
		IRs:
			_PERMIT_TYPEHASH_1(bytes32) := ϕ(['_PERMIT_TYPEHASH_0', '_PERMIT_TYPEHASH_2'])
		Expression: require(bool,string)(block.timestamp <= deadline,ERC20Permit: expired deadline)
		IRs:
			TMP_2771(bool) = block.timestamp <= deadline_1
			TMP_2772(None) = SOLIDITY_CALL require(bool,string)(TMP_2771,ERC20Permit: expired deadline)
		Expression: structHash = keccak256(bytes)(abi.encode(_PERMIT_TYPEHASH,owner,spender,value,_useNonce(owner),deadline))
		IRs:
			TMP_2773(uint256) = INTERNAL_CALL, ERC20Permit._useNonce(address)(owner_1)
			TMP_2774(bytes) = SOLIDITY_CALL abi.encode()(_PERMIT_TYPEHASH_2,owner_1,spender_1,value_1,TMP_2773,deadline_1)
			TMP_2775(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2774)
			structHash_1(bytes32) := TMP_2775(bytes32)
		Expression: hash = _hashTypedDataV4(structHash)
		IRs:
			TMP_2776(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(structHash_1)
			hash_1(bytes32) := TMP_2776(bytes32)
		Expression: signer = ECDSA.recover(hash,v,r,s)
		IRs:
			TMP_2777(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['hash_1', 'v_1', 'r_1', 's_1'] 
			signer_1(address) := TMP_2777(address)
		Expression: require(bool,string)(signer == owner,ERC20Permit: invalid signature)
		IRs:
			TMP_2778(bool) = signer_1 == owner_1
			TMP_2779(None) = SOLIDITY_CALL require(bool,string)(TMP_2778,ERC20Permit: invalid signature)
		Expression: _approve(owner,spender,value)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,value_1)
	Function ERC20Permit.nonces(address)
		IRs:
			_nonces_1(mapping(address => Counters.Counter)) := ϕ(['_nonces_2', '_nonces_1', '_nonces_0'])
		Expression: _nonces[owner].current()
		IRs:
			REF_851(Counters.Counter) -> _nonces_1[owner_1]
			TMP_2781(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['REF_851'] 
			RETURN TMP_2781
	Function ERC20Permit.DOMAIN_SEPARATOR()
		Expression: _domainSeparatorV4()
		IRs:
			TMP_2782(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			RETURN TMP_2782
	Function ERC20Permit._useNonce(address)
		IRs:
			owner_1(address) := ϕ(['owner_1'])
			_nonces_2(mapping(address => Counters.Counter)) := ϕ(['_nonces_2', '_nonces_1', '_nonces_0'])
		Expression: nonce = _nonces[owner]
		IRs:
			REF_853(Counters.Counter) -> _nonces_2[owner_1]
			nonce_1 (-> ['_nonces'])(Counters.Counter) := REF_853(Counters.Counter)
		Expression: current = nonce.current()
		IRs:
			TMP_2783(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:["nonce_1 (-> ['_nonces'])"] 
			current_1(uint256) := TMP_2783(uint256)
		Expression: nonce.increment()
		IRs:
			LIBRARY_CALL, dest:Counters, function:Counters.increment(Counters.Counter), arguments:["nonce_1 (-> ['_nonces'])"] 
		Expression: current
		IRs:
			RETURN current_1
	Function EIP712.constructor(string,string)
		Expression: hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_2785 = CONVERT name_1 to bytes
			TMP_2786(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2785)
			hashedName_1(bytes32) := TMP_2786(bytes32)
		Expression: hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_2787 = CONVERT version_1 to bytes
			TMP_2788(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2787)
			hashedVersion_1(bytes32) := TMP_2788(bytes32)
		Expression: typeHash = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
		IRs:
			TMP_2789(bytes32) = SOLIDITY_CALL keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
			typeHash_1(bytes32) := TMP_2789(bytes32)
		Expression: _HASHED_NAME = hashedName
		IRs:
			_HASHED_NAME_1(bytes32) := hashedName_1(bytes32)
		Expression: _HASHED_VERSION = hashedVersion
		IRs:
			_HASHED_VERSION_1(bytes32) := hashedVersion_1(bytes32)
		Expression: _CACHED_CHAIN_ID = block.chainid
		IRs:
			_CACHED_CHAIN_ID_1(uint256) := block.chainid(uint256)
		Expression: _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash,hashedName,hashedVersion)
		IRs:
			TMP_2790(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(typeHash_1,hashedName_1,hashedVersion_1)
			_CACHED_DOMAIN_SEPARATOR_1(bytes32) := TMP_2790(bytes32)
		Expression: _CACHED_THIS = address(this)
		IRs:
			TMP_2791 = CONVERT this to address
			_CACHED_THIS_1(address) := TMP_2791(address)
		Expression: _TYPE_HASH = typeHash
		IRs:
			_TYPE_HASH_1(bytes32) := typeHash_1(bytes32)
	Function EIP712._domainSeparatorV4()
		IRs:
			_CACHED_DOMAIN_SEPARATOR_2(bytes32) := ϕ(['_CACHED_DOMAIN_SEPARATOR_1', '_CACHED_DOMAIN_SEPARATOR_0'])
			_CACHED_CHAIN_ID_2(uint256) := ϕ(['_CACHED_CHAIN_ID_1', '_CACHED_CHAIN_ID_0'])
			_CACHED_THIS_2(address) := ϕ(['_CACHED_THIS_0', '_CACHED_THIS_1'])
			_HASHED_NAME_2(bytes32) := ϕ(['_HASHED_NAME_0', '_HASHED_NAME_1', '_HASHED_NAME_3'])
			_HASHED_VERSION_2(bytes32) := ϕ(['_HASHED_VERSION_1', '_HASHED_VERSION_3', '_HASHED_VERSION_0'])
			_TYPE_HASH_2(bytes32) := ϕ(['_TYPE_HASH_1', '_TYPE_HASH_3', '_TYPE_HASH_0'])
		Expression: address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID
		IRs:
			TMP_2792 = CONVERT this to address
			TMP_2793(bool) = TMP_2792 == _CACHED_THIS_2
			TMP_2794(bool) = block.chainid == _CACHED_CHAIN_ID_2
			TMP_2795(bool) = TMP_2793 && TMP_2794
			CONDITION TMP_2795
		Expression: _CACHED_DOMAIN_SEPARATOR
		IRs:
			RETURN _CACHED_DOMAIN_SEPARATOR_2
		Expression: _buildDomainSeparator(_TYPE_HASH,_HASHED_NAME,_HASHED_VERSION)
		IRs:
			TMP_2796(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(_TYPE_HASH_2,_HASHED_NAME_2,_HASHED_VERSION_2)
			RETURN TMP_2796
	Function EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)
		IRs:
			typeHash_1(bytes32) := ϕ(['_TYPE_HASH_2', 'typeHash_1'])
			nameHash_1(bytes32) := ϕ(['_HASHED_NAME_2', 'hashedName_1'])
			versionHash_1(bytes32) := ϕ(['_HASHED_VERSION_2', 'hashedVersion_1'])
		Expression: keccak256(bytes)(abi.encode(typeHash,nameHash,versionHash,block.chainid,address(this)))
		IRs:
			TMP_2797 = CONVERT this to address
			TMP_2798(bytes) = SOLIDITY_CALL abi.encode()(typeHash_1,nameHash_1,versionHash_1,block.chainid,TMP_2797)
			TMP_2799(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2798)
			RETURN TMP_2799
	Function EIP712._hashTypedDataV4(bytes32)
		IRs:
			structHash_1(bytes32) := ϕ(['structHash_1'])
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_2800(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_2801(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_2800', 'structHash_1'] 
			RETURN TMP_2801
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32)
	Function IERC20Permit.nonces(address)
	Function IERC20Permit.DOMAIN_SEPARATOR()
	Function ERC20PermitMock.constructor(string,string,address,uint256)
		Expression: _mint(initialAccount,initialBalance)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(initialAccount_1,initialBalance_1)
		Expression: TokenMock(name,symbol)
		IRs:
			INTERNAL_CALL, TokenMock.constructor(string,string)(name_1,symbol_1)
		Expression: ERC20Permit(name)
		IRs:
			INTERNAL_CALL, ERC20Permit.constructor(string)(name_1)
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
Contract TokenMock
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_2806(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2806)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_2808(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_2809(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_2810(bool) = TMP_2808 == TMP_2809
			TMP_2811(None) = SOLIDITY_CALL require(bool,string)(TMP_2810,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_2812 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2812)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_2815 = CONVERT 0 to address
			TMP_2816(bool) = newOwner_1 != TMP_2815
			TMP_2817(None) = SOLIDITY_CALL require(bool,string)(TMP_2816,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['TMP_2812', 'newOwner_1', 'TMP_2806'])
			_owner_2(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_4', '_totalSupply_7'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: _balances[account]
		IRs:
			REF_858(uint256) -> _balances_1[account_1]
			RETURN REF_858
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2821(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2821(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_0', '_allowances_1'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_859(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_860(uint256) -> REF_859[spender_1]
			RETURN REF_860
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2823(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2823(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_2825(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_2825(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2828(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2828(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_2829(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_2830(uint256) = TMP_2829 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2830)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2832(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2832(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2833(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_2833(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_2834(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_2835(None) = SOLIDITY_CALL require(bool,string)(TMP_2834,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_2836(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2836)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_2838 = CONVERT 0 to address
			TMP_2839(bool) = from_1 != TMP_2838
			TMP_2840(None) = SOLIDITY_CALL require(bool,string)(TMP_2839,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_2841 = CONVERT 0 to address
			TMP_2842(bool) = to_1 != TMP_2841
			TMP_2843(None) = SOLIDITY_CALL require(bool,string)(TMP_2842,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_861(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_861(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_2845(bool) = fromBalance_1 >= amount_1
			TMP_2846(None) = SOLIDITY_CALL require(bool,string)(TMP_2845,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_862(uint256) -> _balances_3[from_1]
			TMP_2847(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_862(uint256) (->_balances_4) := TMP_2847(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_863(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_863(-> _balances_5) = REF_863 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_4', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_2850 = CONVERT 0 to address
			TMP_2851(bool) = account_1 != TMP_2850
			TMP_2852(None) = SOLIDITY_CALL require(bool,string)(TMP_2851,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2853 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_2853,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_864(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_864(-> _balances_8) = REF_864 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_2855 = CONVERT 0 to address
			Emit Transfer(TMP_2855,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2857 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_2857,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_0', '_totalSupply_4', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_2859 = CONVERT 0 to address
			TMP_2860(bool) = account_1 != TMP_2859
			TMP_2861(None) = SOLIDITY_CALL require(bool,string)(TMP_2860,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2862 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_2862,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_865(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_865(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_2864(bool) = accountBalance_1 >= amount_1
			TMP_2865(None) = SOLIDITY_CALL require(bool,string)(TMP_2864,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_866(uint256) -> _balances_10[account_1]
			TMP_2866(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_866(uint256) (->_balances_11) := TMP_2866(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_2867 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_2867,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2869 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_2869,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_2836', 'TMP_2884', 'amount_1', 'TMP_2830'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_2871 = CONVERT 0 to address
			TMP_2872(bool) = owner_1 != TMP_2871
			TMP_2873(None) = SOLIDITY_CALL require(bool,string)(TMP_2872,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_2874 = CONVERT 0 to address
			TMP_2875(bool) = spender_1 != TMP_2874
			TMP_2876(None) = SOLIDITY_CALL require(bool,string)(TMP_2875,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_867(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_868(uint256) -> REF_867[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_868(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2878(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_2878(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_2880(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_2881(bool) = currentAllowance_1 != TMP_2880
			CONDITION TMP_2881
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_2882(bool) = currentAllowance_1 >= amount_1
			TMP_2883(None) = SOLIDITY_CALL require(bool,string)(TMP_2882,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_2884(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2884)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_2853', 'account_1', 'from_1'])
			to_1(address) := ϕ(['account_1', 'TMP_2862', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_2857'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_2869'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function TokenMock.constructor(string,string)
		IRs:
			name_1(string) := ϕ(['name_1'])
			symbol_1(string) := ϕ(['symbol_1'])
		Expression: ERC20(name,symbol)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name_1,symbol_1)
	Function TokenMock.mint(address,uint256)
		Expression: _mint(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function TokenMock.burn(address,uint256)
		Expression: _burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account_1,amount_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
Contract Ownable
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_2892(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2892)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_2894(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_2895(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_2896(bool) = TMP_2894 == TMP_2895
			TMP_2897(None) = SOLIDITY_CALL require(bool,string)(TMP_2896,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_2898 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2898)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_2901 = CONVERT 0 to address
			TMP_2902(bool) = newOwner_1 != TMP_2901
			TMP_2903(None) = SOLIDITY_CALL require(bool,string)(TMP_2902,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['TMP_2892', 'newOwner_1', 'TMP_2898'])
			_owner_2(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
Contract IERC1271
	Function IERC1271.isValidSignature(bytes32,bytes)
Contract ERC20
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20.constructor(string,string)
		IRs:
			name__1(string) := ϕ(['name_1', 'name_1', 'name__1', 'name_1', 'name__1', 'name_1', 'name_1', 'name_1', 'name__1', 'name__1', 'name__1'])
			symbol__1(string) := ϕ(['symbol_1', 'symbol__1', 'symbol__1', 'symbol_1', 'symbol_1', 'symbol__1', 'symbol__1', 'symbol_1', 'symbol_1', 'symbol_1', 'symbol__1'])
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_7', '_totalSupply_4', '_totalSupply_0'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_5', '_balances_0', '_balances_1'])
		Expression: _balances[account]
		IRs:
			REF_869(uint256) -> _balances_1[account_1]
			RETURN REF_869
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2908(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2908(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1', '_allowances_2', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_870(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_871(uint256) -> REF_870[spender_1]
			RETURN REF_871
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2910(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2910(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_2912(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_2912(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2915(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2915(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_2916(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_2917(uint256) = TMP_2916 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2917)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2919(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2919(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2920(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_2920(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_2921(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_2922(None) = SOLIDITY_CALL require(bool,string)(TMP_2921,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_2923(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2923)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_5', '_balances_0', '_balances_1'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_2925 = CONVERT 0 to address
			TMP_2926(bool) = from_1 != TMP_2925
			TMP_2927(None) = SOLIDITY_CALL require(bool,string)(TMP_2926,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_2928 = CONVERT 0 to address
			TMP_2929(bool) = to_1 != TMP_2928
			TMP_2930(None) = SOLIDITY_CALL require(bool,string)(TMP_2929,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_872(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_872(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_2932(bool) = fromBalance_1 >= amount_1
			TMP_2933(None) = SOLIDITY_CALL require(bool,string)(TMP_2932,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_873(uint256) -> _balances_3[from_1]
			TMP_2934(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_873(uint256) (->_balances_4) := TMP_2934(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_874(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_874(-> _balances_5) = REF_874 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_5', '_balances_0', '_balances_1'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_7', '_totalSupply_4', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_2937 = CONVERT 0 to address
			TMP_2938(bool) = account_1 != TMP_2937
			TMP_2939(None) = SOLIDITY_CALL require(bool,string)(TMP_2938,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2940 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_2940,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_875(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_875(-> _balances_8) = REF_875 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_2942 = CONVERT 0 to address
			Emit Transfer(TMP_2942,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2944 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_2944,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_5', '_balances_0', '_balances_1'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_7', '_totalSupply_4', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_2946 = CONVERT 0 to address
			TMP_2947(bool) = account_1 != TMP_2946
			TMP_2948(None) = SOLIDITY_CALL require(bool,string)(TMP_2947,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2949 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_2949,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_876(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_876(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_2951(bool) = accountBalance_1 >= amount_1
			TMP_2952(None) = SOLIDITY_CALL require(bool,string)(TMP_2951,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_877(uint256) -> _balances_10[account_1]
			TMP_2953(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_877(uint256) (->_balances_11) := TMP_2953(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_2954 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_2954,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2956 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_2956,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['amount_1', 'TMP_2923', 'TMP_2917', 'TMP_2971'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_2958 = CONVERT 0 to address
			TMP_2959(bool) = owner_1 != TMP_2958
			TMP_2960(None) = SOLIDITY_CALL require(bool,string)(TMP_2959,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_2961 = CONVERT 0 to address
			TMP_2962(bool) = spender_1 != TMP_2961
			TMP_2963(None) = SOLIDITY_CALL require(bool,string)(TMP_2962,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_878(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_879(uint256) -> REF_878[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_879(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2965(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_2965(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_2967(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_2968(bool) = currentAllowance_1 != TMP_2967
			CONDITION TMP_2968
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_2969(bool) = currentAllowance_1 >= amount_1
			TMP_2970(None) = SOLIDITY_CALL require(bool,string)(TMP_2969,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_2971(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2971)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_2940'])
			to_1(address) := ϕ(['TMP_2949', 'to_1', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_2944'])
			to_1(address) := ϕ(['to_1', 'TMP_2956', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
Contract IERC20
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
Contract IERC20Metadata
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
Contract ERC20Permit
	Function EIP712.constructor(string,string)
		Expression: hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_2973 = CONVERT name_1 to bytes
			TMP_2974(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2973)
			hashedName_1(bytes32) := TMP_2974(bytes32)
		Expression: hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_2975 = CONVERT version_1 to bytes
			TMP_2976(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2975)
			hashedVersion_1(bytes32) := TMP_2976(bytes32)
		Expression: typeHash = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
		IRs:
			TMP_2977(bytes32) = SOLIDITY_CALL keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
			typeHash_1(bytes32) := TMP_2977(bytes32)
		Expression: _HASHED_NAME = hashedName
		IRs:
			_HASHED_NAME_1(bytes32) := hashedName_1(bytes32)
		Expression: _HASHED_VERSION = hashedVersion
		IRs:
			_HASHED_VERSION_1(bytes32) := hashedVersion_1(bytes32)
		Expression: _CACHED_CHAIN_ID = block.chainid
		IRs:
			_CACHED_CHAIN_ID_1(uint256) := block.chainid(uint256)
		Expression: _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash,hashedName,hashedVersion)
		IRs:
			TMP_2978(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(typeHash_1,hashedName_1,hashedVersion_1)
			_CACHED_DOMAIN_SEPARATOR_1(bytes32) := TMP_2978(bytes32)
		Expression: _CACHED_THIS = address(this)
		IRs:
			TMP_2979 = CONVERT this to address
			_CACHED_THIS_1(address) := TMP_2979(address)
		Expression: _TYPE_HASH = typeHash
		IRs:
			_TYPE_HASH_1(bytes32) := typeHash_1(bytes32)
	Function EIP712._domainSeparatorV4()
		IRs:
			_CACHED_DOMAIN_SEPARATOR_2(bytes32) := ϕ(['_CACHED_DOMAIN_SEPARATOR_0', '_CACHED_DOMAIN_SEPARATOR_1'])
			_CACHED_CHAIN_ID_2(uint256) := ϕ(['_CACHED_CHAIN_ID_1', '_CACHED_CHAIN_ID_0'])
			_CACHED_THIS_2(address) := ϕ(['_CACHED_THIS_0', '_CACHED_THIS_1'])
			_HASHED_NAME_2(bytes32) := ϕ(['_HASHED_NAME_1', '_HASHED_NAME_3', '_HASHED_NAME_0'])
			_HASHED_VERSION_2(bytes32) := ϕ(['_HASHED_VERSION_3', '_HASHED_VERSION_1', '_HASHED_VERSION_0'])
			_TYPE_HASH_2(bytes32) := ϕ(['_TYPE_HASH_3', '_TYPE_HASH_1', '_TYPE_HASH_0'])
		Expression: address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID
		IRs:
			TMP_2980 = CONVERT this to address
			TMP_2981(bool) = TMP_2980 == _CACHED_THIS_2
			TMP_2982(bool) = block.chainid == _CACHED_CHAIN_ID_2
			TMP_2983(bool) = TMP_2981 && TMP_2982
			CONDITION TMP_2983
		Expression: _CACHED_DOMAIN_SEPARATOR
		IRs:
			RETURN _CACHED_DOMAIN_SEPARATOR_2
		Expression: _buildDomainSeparator(_TYPE_HASH,_HASHED_NAME,_HASHED_VERSION)
		IRs:
			TMP_2984(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(_TYPE_HASH_2,_HASHED_NAME_2,_HASHED_VERSION_2)
			RETURN TMP_2984
	Function EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)
		IRs:
			typeHash_1(bytes32) := ϕ(['typeHash_1', '_TYPE_HASH_2'])
			nameHash_1(bytes32) := ϕ(['hashedName_1', '_HASHED_NAME_2'])
			versionHash_1(bytes32) := ϕ(['hashedVersion_1', '_HASHED_VERSION_2'])
		Expression: keccak256(bytes)(abi.encode(typeHash,nameHash,versionHash,block.chainid,address(this)))
		IRs:
			TMP_2985 = CONVERT this to address
			TMP_2986(bytes) = SOLIDITY_CALL abi.encode()(typeHash_1,nameHash_1,versionHash_1,block.chainid,TMP_2985)
			TMP_2987(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2986)
			RETURN TMP_2987
	Function EIP712._hashTypedDataV4(bytes32)
		IRs:
			structHash_1(bytes32) := ϕ(['structHash_1'])
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_2988(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_2989(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_2988', 'structHash_1'] 
			RETURN TMP_2989
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32)
	Function IERC20Permit.nonces(address)
	Function IERC20Permit.DOMAIN_SEPARATOR()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_0', '_symbol_1'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_4', '_totalSupply_7'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
		Expression: _balances[account]
		IRs:
			REF_882(uint256) -> _balances_1[account_1]
			RETURN REF_882
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2990(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2990(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_0', '_allowances_1'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_883(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_884(uint256) -> REF_883[spender_1]
			RETURN REF_884
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2992(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2992(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_2994(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_2994(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_2997(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_2997(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_2998(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_2999(uint256) = TMP_2998 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_2999)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_3001(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_3001(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_3002(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_3002(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_3003(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_3004(None) = SOLIDITY_CALL require(bool,string)(TMP_3003,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_3005(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_3005)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_3007 = CONVERT 0 to address
			TMP_3008(bool) = from_1 != TMP_3007
			TMP_3009(None) = SOLIDITY_CALL require(bool,string)(TMP_3008,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_3010 = CONVERT 0 to address
			TMP_3011(bool) = to_1 != TMP_3010
			TMP_3012(None) = SOLIDITY_CALL require(bool,string)(TMP_3011,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_885(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_885(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_3014(bool) = fromBalance_1 >= amount_1
			TMP_3015(None) = SOLIDITY_CALL require(bool,string)(TMP_3014,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_886(uint256) -> _balances_3[from_1]
			TMP_3016(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_886(uint256) (->_balances_4) := TMP_3016(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_887(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_887(-> _balances_5) = REF_887 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_4', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_3019 = CONVERT 0 to address
			TMP_3020(bool) = account_1 != TMP_3019
			TMP_3021(None) = SOLIDITY_CALL require(bool,string)(TMP_3020,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_3022 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_3022,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_888(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_888(-> _balances_8) = REF_888 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_3024 = CONVERT 0 to address
			Emit Transfer(TMP_3024,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_3026 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_3026,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_0', '_totalSupply_4', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_3028 = CONVERT 0 to address
			TMP_3029(bool) = account_1 != TMP_3028
			TMP_3030(None) = SOLIDITY_CALL require(bool,string)(TMP_3029,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_3031 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_3031,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_889(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_889(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_3033(bool) = accountBalance_1 >= amount_1
			TMP_3034(None) = SOLIDITY_CALL require(bool,string)(TMP_3033,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_890(uint256) -> _balances_10[account_1]
			TMP_3035(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_890(uint256) (->_balances_11) := TMP_3035(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_3036 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_3036,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_3038 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_3038,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_3005', 'TMP_3053', 'TMP_2999', 'value_1', 'amount_1'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_3040 = CONVERT 0 to address
			TMP_3041(bool) = owner_1 != TMP_3040
			TMP_3042(None) = SOLIDITY_CALL require(bool,string)(TMP_3041,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_3043 = CONVERT 0 to address
			TMP_3044(bool) = spender_1 != TMP_3043
			TMP_3045(None) = SOLIDITY_CALL require(bool,string)(TMP_3044,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_891(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_892(uint256) -> REF_891[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_892(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_3047(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_3047(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_3049(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_3050(bool) = currentAllowance_1 != TMP_3049
			CONDITION TMP_3050
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_3051(bool) = currentAllowance_1 >= amount_1
			TMP_3052(None) = SOLIDITY_CALL require(bool,string)(TMP_3051,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_3053(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_3053)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'account_1', 'TMP_3022'])
			to_1(address) := ϕ(['to_1', 'TMP_3031', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'TMP_3026', 'account_1'])
			to_1(address) := ϕ(['to_1', 'TMP_3038', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20Permit.constructor(string)
		IRs:
			name_1(string) := ϕ(['name_1', 'name_1'])
		Expression: EIP712(name,1)
		IRs:
			INTERNAL_CALL, EIP712.constructor(string,string)(name_1,1)
	Function ERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32)
		IRs:
			_PERMIT_TYPEHASH_1(bytes32) := ϕ(['_PERMIT_TYPEHASH_2', '_PERMIT_TYPEHASH_0'])
		Expression: require(bool,string)(block.timestamp <= deadline,ERC20Permit: expired deadline)
		IRs:
			TMP_3056(bool) = block.timestamp <= deadline_1
			TMP_3057(None) = SOLIDITY_CALL require(bool,string)(TMP_3056,ERC20Permit: expired deadline)
		Expression: structHash = keccak256(bytes)(abi.encode(_PERMIT_TYPEHASH,owner,spender,value,_useNonce(owner),deadline))
		IRs:
			TMP_3058(uint256) = INTERNAL_CALL, ERC20Permit._useNonce(address)(owner_1)
			TMP_3059(bytes) = SOLIDITY_CALL abi.encode()(_PERMIT_TYPEHASH_2,owner_1,spender_1,value_1,TMP_3058,deadline_1)
			TMP_3060(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3059)
			structHash_1(bytes32) := TMP_3060(bytes32)
		Expression: hash = _hashTypedDataV4(structHash)
		IRs:
			TMP_3061(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(structHash_1)
			hash_1(bytes32) := TMP_3061(bytes32)
		Expression: signer = ECDSA.recover(hash,v,r,s)
		IRs:
			TMP_3062(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['hash_1', 'v_1', 'r_1', 's_1'] 
			signer_1(address) := TMP_3062(address)
		Expression: require(bool,string)(signer == owner,ERC20Permit: invalid signature)
		IRs:
			TMP_3063(bool) = signer_1 == owner_1
			TMP_3064(None) = SOLIDITY_CALL require(bool,string)(TMP_3063,ERC20Permit: invalid signature)
		Expression: _approve(owner,spender,value)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,value_1)
	Function ERC20Permit.nonces(address)
		IRs:
			_nonces_1(mapping(address => Counters.Counter)) := ϕ(['_nonces_2', '_nonces_1', '_nonces_0'])
		Expression: _nonces[owner].current()
		IRs:
			REF_895(Counters.Counter) -> _nonces_1[owner_1]
			TMP_3066(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['REF_895'] 
			RETURN TMP_3066
	Function ERC20Permit.DOMAIN_SEPARATOR()
		Expression: _domainSeparatorV4()
		IRs:
			TMP_3067(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			RETURN TMP_3067
	Function ERC20Permit._useNonce(address)
		IRs:
			owner_1(address) := ϕ(['owner_1'])
			_nonces_2(mapping(address => Counters.Counter)) := ϕ(['_nonces_2', '_nonces_1', '_nonces_0'])
		Expression: nonce = _nonces[owner]
		IRs:
			REF_897(Counters.Counter) -> _nonces_2[owner_1]
			nonce_1 (-> ['_nonces'])(Counters.Counter) := REF_897(Counters.Counter)
		Expression: current = nonce.current()
		IRs:
			TMP_3068(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:["nonce_1 (-> ['_nonces'])"] 
			current_1(uint256) := TMP_3068(uint256)
		Expression: nonce.increment()
		IRs:
			LIBRARY_CALL, dest:Counters, function:Counters.increment(Counters.Counter), arguments:["nonce_1 (-> ['_nonces'])"] 
		Expression: current
		IRs:
			RETURN current_1
	Function ERC20Permit.slitherConstructorConstantVariables()
		Expression: _PERMIT_TYPEHASH = keccak256(bytes)(Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline))
Contract IERC20Permit
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32)
	Function IERC20Permit.nonces(address)
	Function IERC20Permit.DOMAIN_SEPARATOR()
Contract Address
	Function Address.isContract(address)
		IRs:
			account_1(address) := ϕ(['target_1'])
		Expression: account.code.length > 0
		IRs:
			TMP_3071(bytes) = SOLIDITY_CALL code(address)(account_1)
			REF_900 -> LENGTH TMP_3071
			TMP_3072(bool) = REF_900 > 0
			RETURN TMP_3072
	Function Address.sendValue(address,uint256)
		Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)
		IRs:
			TMP_3073 = CONVERT this to address
			TMP_3074(uint256) = SOLIDITY_CALL balance(address)(TMP_3073)
			TMP_3075(bool) = TMP_3074 >= amount_1
			TMP_3076(None) = SOLIDITY_CALL require(bool,string)(TMP_3075,Address: insufficient balance)
		Expression: (success,None) = recipient.call{value: amount}()
		IRs:
			TUPLE_60(bool,bytes) = LOW_LEVEL_CALL, dest:recipient_1, function:call, arguments:[''] value:amount_1 
			success_1(bool)= UNPACK TUPLE_60 index: 0 
		Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)
		IRs:
			TMP_3077(None) = SOLIDITY_CALL require(bool,string)(success_1,Address: unable to send value, recipient may have reverted)
	Function Address.functionCall(address,bytes)
		Expression: functionCallWithValue(target,data,0,Address: low-level call failed)
		IRs:
			TMP_3078(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target_1,data_1,0,Address: low-level call failed)
			RETURN TMP_3078
	Function Address.functionCall(address,bytes,string)
		Expression: functionCallWithValue(target,data,0,errorMessage)
		IRs:
			TMP_3079(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target_1,data_1,0,errorMessage_1)
			RETURN TMP_3079
	Function Address.functionCallWithValue(address,bytes,uint256)
		Expression: functionCallWithValue(target,data,value,Address: low-level call with value failed)
		IRs:
			TMP_3080(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target_1,data_1,value_1,Address: low-level call with value failed)
			RETURN TMP_3080
	Function Address.functionCallWithValue(address,bytes,uint256,string)
		IRs:
			target_1(address) := ϕ(['target_1', 'target_1', 'target_1'])
			data_1(bytes) := ϕ(['data_1', 'data_1', 'data_1'])
			value_1(uint256) := ϕ(['value_1'])
			errorMessage_1(string) := ϕ(['errorMessage_1'])
		Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)
		IRs:
			TMP_3081 = CONVERT this to address
			TMP_3082(uint256) = SOLIDITY_CALL balance(address)(TMP_3081)
			TMP_3083(bool) = TMP_3082 >= value_1
			TMP_3084(None) = SOLIDITY_CALL require(bool,string)(TMP_3083,Address: insufficient balance for call)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_61(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:call, arguments:['data_1'] value:value_1 
			success_1(bool)= UNPACK TUPLE_61 index: 0 
			returndata_1(bytes)= UNPACK TUPLE_61 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_3085(bytes) = INTERNAL_CALL, Address.verifyCallResultFromTarget(address,bool,bytes,string)(target_1,success_1,returndata_1,errorMessage_1)
			RETURN TMP_3085
	Function Address.functionStaticCall(address,bytes)
		Expression: functionStaticCall(target,data,Address: low-level static call failed)
		IRs:
			TMP_3086(bytes) = INTERNAL_CALL, Address.functionStaticCall(address,bytes,string)(target_1,data_1,Address: low-level static call failed)
			RETURN TMP_3086
	Function Address.functionStaticCall(address,bytes,string)
		IRs:
			target_1(address) := ϕ(['target_1'])
			data_1(bytes) := ϕ(['data_1'])
		Expression: (success,returndata) = target.staticcall(data)
		IRs:
			TUPLE_62(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:staticcall, arguments:['data_1']  
			success_1(bool)= UNPACK TUPLE_62 index: 0 
			returndata_1(bytes)= UNPACK TUPLE_62 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_3087(bytes) = INTERNAL_CALL, Address.verifyCallResultFromTarget(address,bool,bytes,string)(target_1,success_1,returndata_1,errorMessage_1)
			RETURN TMP_3087
	Function Address.functionDelegateCall(address,bytes)
		Expression: functionDelegateCall(target,data,Address: low-level delegate call failed)
		IRs:
			TMP_3088(bytes) = INTERNAL_CALL, Address.functionDelegateCall(address,bytes,string)(target_1,data_1,Address: low-level delegate call failed)
			RETURN TMP_3088
	Function Address.functionDelegateCall(address,bytes,string)
		IRs:
			target_1(address) := ϕ(['target_1'])
			data_1(bytes) := ϕ(['data_1'])
		Expression: (success,returndata) = target.delegatecall(data)
		IRs:
			TUPLE_63(bool,bytes) = LOW_LEVEL_CALL, dest:target_1, function:delegatecall, arguments:['data_1']  
			success_1(bool)= UNPACK TUPLE_63 index: 0 
			returndata_1(bytes)= UNPACK TUPLE_63 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_3089(bytes) = INTERNAL_CALL, Address.verifyCallResultFromTarget(address,bool,bytes,string)(target_1,success_1,returndata_1,errorMessage_1)
			RETURN TMP_3089
	Function Address.verifyCallResultFromTarget(address,bool,bytes,string)
		IRs:
			target_1(address) := ϕ(['target_1', 'target_1', 'target_1'])
			success_1(bool) := ϕ(['success_1', 'success_1', 'success_1'])
			returndata_1(bytes) := ϕ(['returndata_1', 'returndata_1', 'returndata_1'])
			errorMessage_1(string) := ϕ(['errorMessage_1', 'errorMessage_1', 'errorMessage_1'])
		Expression: success
		IRs:
			CONDITION success_1
		Expression: returndata.length == 0
		IRs:
			REF_905 -> LENGTH returndata_1
			TMP_3090(bool) = REF_905 == 0
			CONDITION TMP_3090
		Expression: require(bool,string)(isContract(target),Address: call to non-contract)
		IRs:
			TMP_3091(bool) = INTERNAL_CALL, Address.isContract(address)(target_1)
			TMP_3092(None) = SOLIDITY_CALL require(bool,string)(TMP_3091,Address: call to non-contract)
		Expression: returndata
		IRs:
			RETURN returndata_1
		Expression: _revert(returndata,errorMessage)
		IRs:
			INTERNAL_CALL, Address._revert(bytes,string)(returndata_1,errorMessage_1)
	Function Address.verifyCallResult(bool,bytes,string)
		Expression: success
		IRs:
			CONDITION success_1
		Expression: returndata
		IRs:
			RETURN returndata_1
		Expression: _revert(returndata,errorMessage)
		IRs:
			INTERNAL_CALL, Address._revert(bytes,string)(returndata_1,errorMessage_1)
	Function Address._revert(bytes,string)
		IRs:
			returndata_1(bytes) := ϕ(['returndata_1', 'returndata_1'])
			errorMessage_1(string) := ϕ(['errorMessage_1', 'errorMessage_1'])
		Expression: returndata.length > 0
		IRs:
			REF_906 -> LENGTH returndata_1
			TMP_3095(bool) = REF_906 > 0
			CONDITION TMP_3095
		Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)
		IRs:
			TMP_3096(uint256) = SOLIDITY_CALL mload(uint256)(returndata_1)
			returndata_size__revert_asm_0_1(uint256) := TMP_3096(uint256)
		Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)
		IRs:
			TMP_3097(uint256) = 32 + returndata_1
			TMP_3098(None) = SOLIDITY_CALL revert(uint256,uint256)(TMP_3097,returndata_size__revert_asm_0_1)
		Expression: revert(string)(errorMessage)
		IRs:
			TMP_3099(None) = SOLIDITY_CALL revert(string)(errorMessage_1)
Contract Context
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
Contract Counters
	Function Counters.current(Counters.Counter)
		Expression: counter._value
		IRs:
			REF_907(uint256) -> counter_1 (-> [])._value
			RETURN REF_907
	Function Counters.increment(Counters.Counter)
		Expression: counter._value += 1
		IRs:
			REF_908(uint256) -> counter_1 (-> [])._value
			counter_2 (-> [])(Counters.Counter) := ϕ(['counter_1 (-> [])'])
			REF_908(-> counter_2 (-> [])) = REF_908 + 1
	Function Counters.decrement(Counters.Counter)
		Expression: value = counter._value
		IRs:
			REF_909(uint256) -> counter_1 (-> [])._value
			value_1(uint256) := REF_909(uint256)
		Expression: require(bool,string)(value > 0,Counter: decrement overflow)
		IRs:
			TMP_3100(bool) = value_1 > 0
			TMP_3101(None) = SOLIDITY_CALL require(bool,string)(TMP_3100,Counter: decrement overflow)
		Expression: counter._value = value - 1
		IRs:
			REF_910(uint256) -> counter_1 (-> [])._value
			TMP_3102(uint256) = value_1 - 1
			counter_2 (-> [])(Counters.Counter) := ϕ(['counter_1 (-> [])'])
			REF_910(uint256) (->counter_2 (-> [])) := TMP_3102(uint256)
	Function Counters.reset(Counters.Counter)
		Expression: counter._value = 0
		IRs:
			REF_911(uint256) -> counter_1 (-> [])._value
			counter_2 (-> [])(Counters.Counter) := ϕ(['counter_1 (-> [])'])
			REF_911(uint256) (->counter_2 (-> [])) := 0(uint256)
Contract Strings
	Function Strings.toString(uint256)
		IRs:
			_SYMBOLS_1(bytes16) := ϕ(['_SYMBOLS_0', '_SYMBOLS_2'])
		Expression: length = Math.log10(value) + 1
		IRs:
			TMP_3103(uint256) = LIBRARY_CALL, dest:Math, function:Math.log10(uint256), arguments:['value_1'] 
			TMP_3104(uint256) = TMP_3103 + 1
			length_1(uint256) := TMP_3104(uint256)
		Expression: buffer = new string(length)
		IRs:
			TMP_3106 = new string(length_1)
			buffer_1(string) := TMP_3106(string)
		Expression: ptr = buffer + 32 + length
		IRs:
			TMP_3107(uint256) = 32 + length_1
			TMP_3108(string) = buffer_1 + TMP_3107
			ptr_1(uint256) := TMP_3108(string)
		Expression: true
		IRs:
			value_2(uint256) := ϕ(['value_3', 'value_1'])
			ptr_2(uint256) := ϕ(['ptr_1', 'ptr_3'])
			CONDITION True
		Expression: ptr --
		IRs:
			TMP_3109(uint256) := ptr_2(uint256)
			ptr_3(uint256) = ptr_2 - 1
		Expression: mstore8(uint256,uint256)(ptr,byte(uint256,uint256)(value % 10,_SYMBOLS))
		IRs:
			TMP_3110(uint256) = value_2 % 10
			TMP_3111(uint256) = SOLIDITY_CALL byte(uint256,uint256)(TMP_3110,_SYMBOLS_1)
			TMP_3112(None) = SOLIDITY_CALL mstore8(uint256,uint256)(ptr_3,TMP_3111)
		Expression: value /= 10
		IRs:
			value_3(uint256) = value_2 / 10
		Expression: value == 0
		IRs:
			TMP_3113(bool) = value_3 == 0
			CONDITION TMP_3113
		Expression: buffer
		IRs:
			RETURN buffer_1
	Function Strings.toHexString(uint256)
		Expression: toHexString(value,Math.log256(value) + 1)
		IRs:
			TMP_3114(uint256) = LIBRARY_CALL, dest:Math, function:Math.log256(uint256), arguments:['value_1'] 
			TMP_3115(uint256) = TMP_3114 + 1
			TMP_3116(string) = INTERNAL_CALL, Strings.toHexString(uint256,uint256)(value_1,TMP_3115)
			RETURN TMP_3116
	Function Strings.toHexString(uint256,uint256)
		IRs:
			value_1(uint256) := ϕ(['TMP_3129', 'value_1'])
			length_1(uint256) := ϕ(['TMP_3115', '_ADDRESS_LENGTH_1'])
			_SYMBOLS_2(bytes16) := ϕ(['_SYMBOLS_0', '_SYMBOLS_2'])
		Expression: buffer = new bytes(2 * length + 2)
		IRs:
			TMP_3118(uint256) = 2 (c)* length_1
			TMP_3119(uint256) = TMP_3118 (c)+ 2
			TMP_3120 = new bytes(TMP_3119)
			buffer_1(bytes) := TMP_3120(bytes)
		Expression: buffer[0] = 0
		IRs:
			REF_914(string) -> buffer_1[0]
			buffer_2(bytes) := ϕ(['buffer_1'])
			REF_914(string) (->buffer_2) := 0(string)
		Expression: buffer[1] = x
		IRs:
			REF_915(string) -> buffer_2[1]
			buffer_3(bytes) := ϕ(['buffer_2'])
			REF_915(string) (->buffer_3) := x(string)
		Expression: i = 2 * length + 1
		IRs:
			TMP_3121(uint256) = 2 (c)* length_1
			TMP_3122(uint256) = TMP_3121 (c)+ 1
			i_1(uint256) := TMP_3122(uint256)
		Expression: i > 1
		IRs:
			value_2(uint256) := ϕ(['value_3', 'value_1'])
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_3123(bool) = i_2 > 1
			CONDITION TMP_3123
		Expression: buffer[i] = _SYMBOLS[value & 0xf]
		IRs:
			REF_916(None) -> buffer_3[i_2]
			TMP_3124(uint256) = value_2 & 15
			REF_917(None) -> _SYMBOLS_2[TMP_3124]
			buffer_4(bytes) := ϕ(['buffer_3'])
			REF_916(None) (->buffer_4) := REF_917(None)
		Expression: value >>= 4
		IRs:
			value_3(uint256) = value_2 >> 4
		Expression: -- i
		IRs:
			i_3(uint256) = i_2 (c)- 1
		Expression: require(bool,string)(value == 0,Strings: hex length insufficient)
		IRs:
			TMP_3125(bool) = value_2 == 0
			TMP_3126(None) = SOLIDITY_CALL require(bool,string)(TMP_3125,Strings: hex length insufficient)
		Expression: string(buffer)
		IRs:
			TMP_3127 = CONVERT buffer_3 to string
			RETURN TMP_3127
	Function Strings.toHexString(address)
		IRs:
			_ADDRESS_LENGTH_1(uint8) := ϕ(['_ADDRESS_LENGTH_0', '_ADDRESS_LENGTH_2'])
		Expression: toHexString(uint256(uint160(addr)),_ADDRESS_LENGTH)
		IRs:
			TMP_3128 = CONVERT addr_1 to uint160
			TMP_3129 = CONVERT TMP_3128 to uint256
			TMP_3130(string) = INTERNAL_CALL, Strings.toHexString(uint256,uint256)(TMP_3129,_ADDRESS_LENGTH_1)
			RETURN TMP_3130
	Function Strings.slitherConstructorConstantVariables()
		Expression: _SYMBOLS = 0123456789abcdef
		Expression: _ADDRESS_LENGTH = 20
Contract ECDSA
	Function ECDSA._throwError(ECDSA.RecoverError)
		IRs:
			error_1(ECDSA.RecoverError) := ϕ(['error_1', 'error_1', 'error_1'])
		Expression: error == RecoverError.NoError
		IRs:
			REF_918(ECDSA.RecoverError) -> RecoverError.NoError
			TMP_3131(bool) = error_1 == REF_918
			CONDITION TMP_3131
		Expression: error == RecoverError.InvalidSignature
		IRs:
			REF_919(ECDSA.RecoverError) -> RecoverError.InvalidSignature
			TMP_3132(bool) = error_1 == REF_919
			CONDITION TMP_3132
		Expression: revert(string)(ECDSA: invalid signature)
		IRs:
			TMP_3133(None) = SOLIDITY_CALL revert(string)(ECDSA: invalid signature)
		Expression: error == RecoverError.InvalidSignatureLength
		IRs:
			REF_920(ECDSA.RecoverError) -> RecoverError.InvalidSignatureLength
			TMP_3134(bool) = error_1 == REF_920
			CONDITION TMP_3134
		Expression: revert(string)(ECDSA: invalid signature length)
		IRs:
			TMP_3135(None) = SOLIDITY_CALL revert(string)(ECDSA: invalid signature length)
		Expression: error == RecoverError.InvalidSignatureS
		IRs:
			REF_921(ECDSA.RecoverError) -> RecoverError.InvalidSignatureS
			TMP_3136(bool) = error_1 == REF_921
			CONDITION TMP_3136
		Expression: revert(string)(ECDSA: invalid signature 's' value)
		IRs:
			TMP_3137(None) = SOLIDITY_CALL revert(string)(ECDSA: invalid signature 's' value)
	Function ECDSA.tryRecover(bytes32,bytes)
		IRs:
			hash_1(bytes32) := ϕ(['hash_1'])
			signature_1(bytes) := ϕ(['signature_1'])
		Expression: signature.length == 65
		IRs:
			REF_922 -> LENGTH signature_1
			TMP_3138(bool) = REF_922 == 65
			CONDITION TMP_3138
		Expression: r = mload(uint256)(signature + 0x20)
		IRs:
			TMP_3139(bytes) = signature_1 + 32
			TMP_3140(uint256) = SOLIDITY_CALL mload(uint256)(TMP_3139)
			r_1(bytes32) := TMP_3140(uint256)
		Expression: s = mload(uint256)(signature + 0x40)
		IRs:
			TMP_3141(bytes) = signature_1 + 64
			TMP_3142(uint256) = SOLIDITY_CALL mload(uint256)(TMP_3141)
			s_1(bytes32) := TMP_3142(uint256)
		Expression: v = byte(uint256,uint256)(0,mload(uint256)(signature + 0x60))
		IRs:
			TMP_3143(bytes) = signature_1 + 96
			TMP_3144(uint256) = SOLIDITY_CALL mload(uint256)(TMP_3143)
			TMP_3145(uint256) = SOLIDITY_CALL byte(uint256,uint256)(0,TMP_3144)
			v_1(uint8) := TMP_3145(uint256)
		Expression: tryRecover(hash,v,r,s)
		IRs:
			TUPLE_64(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,uint8,bytes32,bytes32)(hash_1,v_1,r_1,s_1)
			RETURN TUPLE_64
		Expression: (address(0),RecoverError.InvalidSignatureLength)
		IRs:
			TMP_3146 = CONVERT 0 to address
			REF_923(ECDSA.RecoverError) -> RecoverError.InvalidSignatureLength
			RETURN TMP_3146,REF_923
	Function ECDSA.recover(bytes32,bytes)
		Expression: (recovered,error) = tryRecover(hash,signature)
		IRs:
			TUPLE_65(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,bytes)(hash_1,signature_1)
			recovered_1(address)= UNPACK TUPLE_65 index: 0 
			error_1(ECDSA.RecoverError)= UNPACK TUPLE_65 index: 1 
		Expression: _throwError(error)
		IRs:
			INTERNAL_CALL, ECDSA._throwError(ECDSA.RecoverError)(error_1)
		Expression: recovered
		IRs:
			RETURN recovered_1
	Function ECDSA.tryRecover(bytes32,bytes32,bytes32)
		IRs:
			hash_1(bytes32) := ϕ(['hash_1'])
			r_1(bytes32) := ϕ(['r_1'])
			vs_1(bytes32) := ϕ(['vs_1'])
		Expression: s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
		IRs:
			TMP_3148 = CONVERT 57896044618658097711785492504343953926634992332820282019728792003956564819967 to bytes32
			TMP_3149(bytes32) = vs_1 & TMP_3148
			s_1(bytes32) := TMP_3149(bytes32)
		Expression: v = uint8((uint256(vs) >> 255) + 27)
		IRs:
			TMP_3150 = CONVERT vs_1 to uint256
			TMP_3151(uint256) = TMP_3150 >> 255
			TMP_3152(uint256) = TMP_3151 (c)+ 27
			TMP_3153 = CONVERT TMP_3152 to uint8
			v_1(uint8) := TMP_3153(uint8)
		Expression: tryRecover(hash,v,r,s)
		IRs:
			TUPLE_66(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,uint8,bytes32,bytes32)(hash_1,v_1,r_1,s_1)
			RETURN TUPLE_66
	Function ECDSA.recover(bytes32,bytes32,bytes32)
		Expression: (recovered,error) = tryRecover(hash,r,vs)
		IRs:
			TUPLE_67(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,bytes32,bytes32)(hash_1,r_1,vs_1)
			recovered_1(address)= UNPACK TUPLE_67 index: 0 
			error_1(ECDSA.RecoverError)= UNPACK TUPLE_67 index: 1 
		Expression: _throwError(error)
		IRs:
			INTERNAL_CALL, ECDSA._throwError(ECDSA.RecoverError)(error_1)
		Expression: recovered
		IRs:
			RETURN recovered_1
	Function ECDSA.tryRecover(bytes32,uint8,bytes32,bytes32)
		IRs:
			hash_1(bytes32) := ϕ(['hash_1', 'hash_1', 'hash_1'])
			v_1(uint8) := ϕ(['v_1', 'v_1', 'v_1'])
			r_1(bytes32) := ϕ(['r_1', 'r_1', 'r_1'])
			s_1(bytes32) := ϕ(['s_1', 's_1', 's_1'])
		Expression: uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
		IRs:
			TMP_3155 = CONVERT s_1 to uint256
			TMP_3156(bool) = TMP_3155 > 57896044618658097711785492504343953926418782139537452191302581570759080747168
			CONDITION TMP_3156
		Expression: (address(0),RecoverError.InvalidSignatureS)
		IRs:
			TMP_3157 = CONVERT 0 to address
			REF_924(ECDSA.RecoverError) -> RecoverError.InvalidSignatureS
			RETURN TMP_3157,REF_924
		Expression: signer = ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
		IRs:
			TMP_3158(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(hash_1,v_1,r_1,s_1)
			signer_1(address) := TMP_3158(address)
		Expression: signer == address(0)
		IRs:
			TMP_3159 = CONVERT 0 to address
			TMP_3160(bool) = signer_1 == TMP_3159
			CONDITION TMP_3160
		Expression: (address(0),RecoverError.InvalidSignature)
		IRs:
			TMP_3161 = CONVERT 0 to address
			REF_925(ECDSA.RecoverError) -> RecoverError.InvalidSignature
			RETURN TMP_3161,REF_925
		Expression: (signer,RecoverError.NoError)
		IRs:
			REF_926(ECDSA.RecoverError) -> RecoverError.NoError
			RETURN signer_1,REF_926
	Function ECDSA.recover(bytes32,uint8,bytes32,bytes32)
		Expression: (recovered,error) = tryRecover(hash,v,r,s)
		IRs:
			TUPLE_68(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,uint8,bytes32,bytes32)(hash_1,v_1,r_1,s_1)
			recovered_1(address)= UNPACK TUPLE_68 index: 0 
			error_1(ECDSA.RecoverError)= UNPACK TUPLE_68 index: 1 
		Expression: _throwError(error)
		IRs:
			INTERNAL_CALL, ECDSA._throwError(ECDSA.RecoverError)(error_1)
		Expression: recovered
		IRs:
			RETURN recovered_1
	Function ECDSA.toEthSignedMessageHash(bytes32)
		Expression: keccak256(bytes)(abi.encodePacked(Ethereum Signed Message:
32,hash))
		IRs:
			TMP_3163(bytes) = SOLIDITY_CALL abi.encodePacked()(Ethereum Signed Message:
32,hash_1)
			TMP_3164(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3163)
			RETURN TMP_3164
	Function ECDSA.toEthSignedMessageHash(bytes)
		Expression: keccak256(bytes)(abi.encodePacked(Ethereum Signed Message:
,Strings.toString(s.length),s))
		IRs:
			REF_930 -> LENGTH s_1
			TMP_3165(string) = LIBRARY_CALL, dest:Strings, function:Strings.toString(uint256), arguments:['REF_930'] 
			TMP_3166(bytes) = SOLIDITY_CALL abi.encodePacked()(Ethereum Signed Message:
,TMP_3165,s_1)
			TMP_3167(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3166)
			RETURN TMP_3167
	Function ECDSA.toTypedDataHash(bytes32,bytes32)
		Expression: keccak256(bytes)(abi.encodePacked(,domainSeparator,structHash))
		IRs:
			TMP_3168(bytes) = SOLIDITY_CALL abi.encodePacked()(,domainSeparator_1,structHash_1)
			TMP_3169(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3168)
			RETURN TMP_3169
Contract EIP712
	Function EIP712.constructor(string,string)
		IRs:
			name_1(string) := ϕ(['name_1', 'name_1', 'name_1'])
		Expression: hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_3170 = CONVERT name_1 to bytes
			TMP_3171(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3170)
			hashedName_1(bytes32) := TMP_3171(bytes32)
		Expression: hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_3172 = CONVERT version_1 to bytes
			TMP_3173(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3172)
			hashedVersion_1(bytes32) := TMP_3173(bytes32)
		Expression: typeHash = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
		IRs:
			TMP_3174(bytes32) = SOLIDITY_CALL keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
			typeHash_1(bytes32) := TMP_3174(bytes32)
		Expression: _HASHED_NAME = hashedName
		IRs:
			_HASHED_NAME_1(bytes32) := hashedName_1(bytes32)
		Expression: _HASHED_VERSION = hashedVersion
		IRs:
			_HASHED_VERSION_1(bytes32) := hashedVersion_1(bytes32)
		Expression: _CACHED_CHAIN_ID = block.chainid
		IRs:
			_CACHED_CHAIN_ID_1(uint256) := block.chainid(uint256)
		Expression: _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash,hashedName,hashedVersion)
		IRs:
			TMP_3175(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(typeHash_1,hashedName_1,hashedVersion_1)
			_CACHED_DOMAIN_SEPARATOR_1(bytes32) := TMP_3175(bytes32)
		Expression: _CACHED_THIS = address(this)
		IRs:
			TMP_3176 = CONVERT this to address
			_CACHED_THIS_1(address) := TMP_3176(address)
		Expression: _TYPE_HASH = typeHash
		IRs:
			_TYPE_HASH_1(bytes32) := typeHash_1(bytes32)
	Function EIP712._domainSeparatorV4()
		IRs:
			_CACHED_DOMAIN_SEPARATOR_2(bytes32) := ϕ(['_CACHED_DOMAIN_SEPARATOR_0', '_CACHED_DOMAIN_SEPARATOR_1'])
			_CACHED_CHAIN_ID_2(uint256) := ϕ(['_CACHED_CHAIN_ID_1', '_CACHED_CHAIN_ID_0'])
			_CACHED_THIS_2(address) := ϕ(['_CACHED_THIS_1', '_CACHED_THIS_0'])
			_HASHED_NAME_2(bytes32) := ϕ(['_HASHED_NAME_0', '_HASHED_NAME_1', '_HASHED_NAME_3'])
			_HASHED_VERSION_2(bytes32) := ϕ(['_HASHED_VERSION_3', '_HASHED_VERSION_0', '_HASHED_VERSION_1'])
			_TYPE_HASH_2(bytes32) := ϕ(['_TYPE_HASH_3', '_TYPE_HASH_0', '_TYPE_HASH_1'])
		Expression: address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID
		IRs:
			TMP_3177 = CONVERT this to address
			TMP_3178(bool) = TMP_3177 == _CACHED_THIS_2
			TMP_3179(bool) = block.chainid == _CACHED_CHAIN_ID_2
			TMP_3180(bool) = TMP_3178 && TMP_3179
			CONDITION TMP_3180
		Expression: _CACHED_DOMAIN_SEPARATOR
		IRs:
			RETURN _CACHED_DOMAIN_SEPARATOR_2
		Expression: _buildDomainSeparator(_TYPE_HASH,_HASHED_NAME,_HASHED_VERSION)
		IRs:
			TMP_3181(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)(_TYPE_HASH_2,_HASHED_NAME_2,_HASHED_VERSION_2)
			RETURN TMP_3181
	Function EIP712._buildDomainSeparator(bytes32,bytes32,bytes32)
		IRs:
			typeHash_1(bytes32) := ϕ(['_TYPE_HASH_2', 'typeHash_1'])
			nameHash_1(bytes32) := ϕ(['_HASHED_NAME_2', 'hashedName_1'])
			versionHash_1(bytes32) := ϕ(['hashedVersion_1', '_HASHED_VERSION_2'])
		Expression: keccak256(bytes)(abi.encode(typeHash,nameHash,versionHash,block.chainid,address(this)))
		IRs:
			TMP_3182 = CONVERT this to address
			TMP_3183(bytes) = SOLIDITY_CALL abi.encode()(typeHash_1,nameHash_1,versionHash_1,block.chainid,TMP_3182)
			TMP_3184(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3183)
			RETURN TMP_3184
	Function EIP712._hashTypedDataV4(bytes32)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_3185(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_3186(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_3185', 'structHash_1'] 
			RETURN TMP_3186
Contract Math
	Function Math.max(uint256,uint256)
		Expression: a > b
		IRs:
			TMP_3187(bool) = a_1 > b_1
			CONDITION TMP_3187
		Expression: a
		IRs:
			RETURN a_1
		Expression: b
		IRs:
			RETURN b_1
	Function Math.min(uint256,uint256)
		IRs:
			a_1(uint256) := ϕ(['result_8'])
			b_1(uint256) := ϕ(['TMP_3265'])
		Expression: a < b
		IRs:
			TMP_3188(bool) = a_1 < b_1
			CONDITION TMP_3188
		Expression: a
		IRs:
			RETURN a_1
		Expression: b
		IRs:
			RETURN b_1
	Function Math.average(uint256,uint256)
		Expression: (a & b) + (a ^ b) / 2
		IRs:
			TMP_3189(uint256) = a_1 & b_1
			TMP_3190(uint256) = a_1 ^ b_1
			TMP_3191(uint256) = TMP_3190 (c)/ 2
			TMP_3192(uint256) = TMP_3189 (c)+ TMP_3191
			RETURN TMP_3192
	Function Math.ceilDiv(uint256,uint256)
		Expression: a == 0
		IRs:
			TMP_3193(bool) = a_1 == 0
			CONDITION TMP_3193
		Expression: 0
		IRs:
			RETURN 0
		Expression: (a - 1) / b + 1
		IRs:
			TMP_3194(uint256) = a_1 (c)- 1
			TMP_3195(uint256) = TMP_3194 (c)/ b_1
			TMP_3196(uint256) = TMP_3195 (c)+ 1
			RETURN TMP_3196
	Function Math.mulDiv(uint256,uint256,uint256)
		IRs:
			x_1(uint256) := ϕ(['x_1'])
			y_1(uint256) := ϕ(['y_1'])
			denominator_1(uint256) := ϕ(['denominator_1'])
		Expression: mm_mulDiv_asm_0 = mulmod(uint256,uint256,uint256)(x,y,~ 0)
		IRs:
			TMP_3197 = UnaryType.TILD 0 
			TMP_3198(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x_1,y_1,TMP_3197)
			mm_mulDiv_asm_0_1(uint256) := TMP_3198(uint256)
		Expression: prod0 = x * y
		IRs:
			TMP_3199(uint256) = x_1 * y_1
			prod0_1(uint256) := TMP_3199(uint256)
		Expression: prod1 = mm_mulDiv_asm_0 - prod0 - mm_mulDiv_asm_0 < prod0
		IRs:
			TMP_3200(uint256) = mm_mulDiv_asm_0_1 - prod0_1
			TMP_3201(bool) = mm_mulDiv_asm_0_1 < prod0_1
			TMP_3202(uint256) = TMP_3200 - TMP_3201
			prod1_1(uint256) := TMP_3202(uint256)
		Expression: prod1 == 0
		IRs:
			TMP_3203(bool) = prod1_1 == 0
			CONDITION TMP_3203
		Expression: prod0 / denominator
		IRs:
			TMP_3204(uint256) = prod0_1 / denominator_1
			RETURN TMP_3204
		Expression: require(bool)(denominator > prod1)
		IRs:
			TMP_3205(bool) = denominator_1 > prod1_1
			TMP_3206(None) = SOLIDITY_CALL require(bool)(TMP_3205)
		Expression: remainder = mulmod(uint256,uint256,uint256)(x,y,denominator)
		IRs:
			TMP_3207(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x_1,y_1,denominator_1)
			remainder_1(uint256) := TMP_3207(uint256)
		Expression: prod1 = prod1 - remainder > prod0
		IRs:
			TMP_3208(bool) = remainder_1 > prod0_1
			TMP_3209(uint256) = prod1_1 - TMP_3208
			prod1_2(uint256) := TMP_3209(uint256)
		Expression: prod0 = prod0 - remainder
		IRs:
			TMP_3210(uint256) = prod0_1 - remainder_1
			prod0_2(uint256) := TMP_3210(uint256)
		Expression: twos = denominator & (~ denominator + 1)
		IRs:
			TMP_3211 = UnaryType.TILD denominator_1 
			TMP_3212(uint256) = TMP_3211 + 1
			TMP_3213(uint256) = denominator_1 & TMP_3212
			twos_1(uint256) := TMP_3213(uint256)
		Expression: denominator = denominator / twos
		IRs:
			TMP_3214(uint256) = denominator_1 / twos_1
			denominator_2(uint256) := TMP_3214(uint256)
		Expression: prod0 = prod0 / twos
		IRs:
			TMP_3215(uint256) = prod0_2 / twos_1
			prod0_3(uint256) := TMP_3215(uint256)
		Expression: twos = 0 - twos / twos + 1
		IRs:
			TMP_3216(uint256) = 0 - twos_1
			TMP_3217(uint256) = TMP_3216 / twos_1
			TMP_3218(uint256) = TMP_3217 + 1
			twos_2(uint256) := TMP_3218(uint256)
		Expression: prod0 |= prod1 * twos
		IRs:
			TMP_3219(uint256) = prod1_2 * twos_2
			prod0_4(uint256) = prod0_3 | TMP_3219
		Expression: inverse = (3 * denominator) ^ 2
		IRs:
			TMP_3220(uint256) = 3 * denominator_2
			TMP_3221(uint256) = TMP_3220 ^ 2
			inverse_1(uint256) := TMP_3221(uint256)
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3222(uint256) = denominator_2 * inverse_1
			TMP_3223(uint256) = 2 - TMP_3222
			inverse_2(uint256) = inverse_1 * TMP_3223
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3224(uint256) = denominator_2 * inverse_2
			TMP_3225(uint256) = 2 - TMP_3224
			inverse_3(uint256) = inverse_2 * TMP_3225
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3226(uint256) = denominator_2 * inverse_3
			TMP_3227(uint256) = 2 - TMP_3226
			inverse_4(uint256) = inverse_3 * TMP_3227
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3228(uint256) = denominator_2 * inverse_4
			TMP_3229(uint256) = 2 - TMP_3228
			inverse_5(uint256) = inverse_4 * TMP_3229
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3230(uint256) = denominator_2 * inverse_5
			TMP_3231(uint256) = 2 - TMP_3230
			inverse_6(uint256) = inverse_5 * TMP_3231
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3232(uint256) = denominator_2 * inverse_6
			TMP_3233(uint256) = 2 - TMP_3232
			inverse_7(uint256) = inverse_6 * TMP_3233
		Expression: result = prod0 * inverse
		IRs:
			TMP_3234(uint256) = prod0_4 * inverse_7
			result_1(uint256) := TMP_3234(uint256)
		Expression: result
		IRs:
			RETURN result_1
		Expression: result
	Function Math.mulDiv(uint256,uint256,uint256,Math.Rounding)
		Expression: result = mulDiv(x,y,denominator)
		IRs:
			TMP_3235(uint256) = INTERNAL_CALL, Math.mulDiv(uint256,uint256,uint256)(x_1,y_1,denominator_1)
			result_1(uint256) := TMP_3235(uint256)
		Expression: rounding == Rounding.Up && mulmod(uint256,uint256,uint256)(x,y,denominator) > 0
		IRs:
			REF_934(Math.Rounding) -> Rounding.Up
			TMP_3236(bool) = rounding_1 == REF_934
			TMP_3237(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x_1,y_1,denominator_1)
			TMP_3238(bool) = TMP_3237 > 0
			TMP_3239(bool) = TMP_3236 && TMP_3238
			CONDITION TMP_3239
		Expression: result += 1
		IRs:
			result_2(uint256) = result_1 (c)+ 1
		IRs:
			result_3(uint256) := ϕ(['result_1', 'result_2'])
		Expression: result
		IRs:
			RETURN result_3
	Function Math.sqrt(uint256)
		IRs:
			a_1(uint256) := ϕ(['a_1'])
		Expression: a == 0
		IRs:
			TMP_3240(bool) = a_1 == 0
			CONDITION TMP_3240
		Expression: 0
		IRs:
			RETURN 0
		Expression: result = 1 << (log2(a) >> 1)
		IRs:
			TMP_3241(uint256) = INTERNAL_CALL, Math.log2(uint256)(a_1)
			TMP_3242(uint256) = TMP_3241 >> 1
			TMP_3243(uint256) = 1 << TMP_3242
			result_1(uint256) := TMP_3243(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3244(uint256) = a_1 / result_1
			TMP_3245(uint256) = result_1 + TMP_3244
			TMP_3246(uint256) = TMP_3245 >> 1
			result_2(uint256) := TMP_3246(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3247(uint256) = a_1 / result_2
			TMP_3248(uint256) = result_2 + TMP_3247
			TMP_3249(uint256) = TMP_3248 >> 1
			result_3(uint256) := TMP_3249(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3250(uint256) = a_1 / result_3
			TMP_3251(uint256) = result_3 + TMP_3250
			TMP_3252(uint256) = TMP_3251 >> 1
			result_4(uint256) := TMP_3252(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3253(uint256) = a_1 / result_4
			TMP_3254(uint256) = result_4 + TMP_3253
			TMP_3255(uint256) = TMP_3254 >> 1
			result_5(uint256) := TMP_3255(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3256(uint256) = a_1 / result_5
			TMP_3257(uint256) = result_5 + TMP_3256
			TMP_3258(uint256) = TMP_3257 >> 1
			result_6(uint256) := TMP_3258(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3259(uint256) = a_1 / result_6
			TMP_3260(uint256) = result_6 + TMP_3259
			TMP_3261(uint256) = TMP_3260 >> 1
			result_7(uint256) := TMP_3261(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3262(uint256) = a_1 / result_7
			TMP_3263(uint256) = result_7 + TMP_3262
			TMP_3264(uint256) = TMP_3263 >> 1
			result_8(uint256) := TMP_3264(uint256)
		Expression: min(result,a / result)
		IRs:
			TMP_3265(uint256) = a_1 / result_8
			TMP_3266(uint256) = INTERNAL_CALL, Math.min(uint256,uint256)(result_8,TMP_3265)
			RETURN TMP_3266
	Function Math.sqrt(uint256,Math.Rounding)
		Expression: result = sqrt(a)
		IRs:
			TMP_3267(uint256) = INTERNAL_CALL, Math.sqrt(uint256)(a_1)
			result_1(uint256) := TMP_3267(uint256)
		Expression: rounding == Rounding.Up && result * result < a
		IRs:
			REF_935(Math.Rounding) -> Rounding.Up
			TMP_3268(bool) = rounding_1 == REF_935
			TMP_3269(uint256) = result_1 * result_1
			TMP_3270(bool) = TMP_3269 < a_1
			TMP_3271(bool) = TMP_3268 && TMP_3270
			CONDITION TMP_3271
		Expression: result + 1
		IRs:
			TMP_3272(uint256) = result_1 + 1
			RETURN TMP_3272
		Expression: result + 0
		IRs:
			TMP_3273(uint256) = result_1 + 0
			RETURN TMP_3273
	Function Math.log2(uint256)
		IRs:
			value_1(uint256) := ϕ(['value_1', 'a_1'])
		Expression: result = 0
		IRs:
			result_1(uint256) := 0(uint256)
		Expression: value >> 128 > 0
		IRs:
			TMP_3274(uint256) = value_1 >> 128
			TMP_3275(bool) = TMP_3274 > 0
			CONDITION TMP_3275
		Expression: value >>= 128
		IRs:
			value_2(uint256) = value_1 >> 128
		Expression: result += 128
		IRs:
			result_2(uint256) = result_1 + 128
		IRs:
			value_3(uint256) := ϕ(['value_1', 'value_2'])
			result_3(uint256) := ϕ(['result_2', 'result_1'])
		Expression: value >> 64 > 0
		IRs:
			TMP_3276(uint256) = value_3 >> 64
			TMP_3277(bool) = TMP_3276 > 0
			CONDITION TMP_3277
		Expression: value >>= 64
		IRs:
			value_4(uint256) = value_3 >> 64
		Expression: result += 64
		IRs:
			result_4(uint256) = result_3 + 64
		IRs:
			value_5(uint256) := ϕ(['value_1', 'value_4'])
			result_5(uint256) := ϕ(['result_4', 'result_1'])
		Expression: value >> 32 > 0
		IRs:
			TMP_3278(uint256) = value_5 >> 32
			TMP_3279(bool) = TMP_3278 > 0
			CONDITION TMP_3279
		Expression: value >>= 32
		IRs:
			value_6(uint256) = value_5 >> 32
		Expression: result += 32
		IRs:
			result_6(uint256) = result_5 + 32
		IRs:
			value_7(uint256) := ϕ(['value_1', 'value_6'])
			result_7(uint256) := ϕ(['result_6', 'result_1'])
		Expression: value >> 16 > 0
		IRs:
			TMP_3280(uint256) = value_7 >> 16
			TMP_3281(bool) = TMP_3280 > 0
			CONDITION TMP_3281
		Expression: value >>= 16
		IRs:
			value_8(uint256) = value_7 >> 16
		Expression: result += 16
		IRs:
			result_8(uint256) = result_7 + 16
		IRs:
			value_9(uint256) := ϕ(['value_1', 'value_8'])
			result_9(uint256) := ϕ(['result_8', 'result_1'])
		Expression: value >> 8 > 0
		IRs:
			TMP_3282(uint256) = value_9 >> 8
			TMP_3283(bool) = TMP_3282 > 0
			CONDITION TMP_3283
		Expression: value >>= 8
		IRs:
			value_10(uint256) = value_9 >> 8
		Expression: result += 8
		IRs:
			result_10(uint256) = result_9 + 8
		IRs:
			value_11(uint256) := ϕ(['value_1', 'value_10'])
			result_11(uint256) := ϕ(['result_10', 'result_1'])
		Expression: value >> 4 > 0
		IRs:
			TMP_3284(uint256) = value_11 >> 4
			TMP_3285(bool) = TMP_3284 > 0
			CONDITION TMP_3285
		Expression: value >>= 4
		IRs:
			value_12(uint256) = value_11 >> 4
		Expression: result += 4
		IRs:
			result_12(uint256) = result_11 + 4
		IRs:
			value_13(uint256) := ϕ(['value_1', 'value_12'])
			result_13(uint256) := ϕ(['result_12', 'result_1'])
		Expression: value >> 2 > 0
		IRs:
			TMP_3286(uint256) = value_13 >> 2
			TMP_3287(bool) = TMP_3286 > 0
			CONDITION TMP_3287
		Expression: value >>= 2
		IRs:
			value_14(uint256) = value_13 >> 2
		Expression: result += 2
		IRs:
			result_14(uint256) = result_13 + 2
		IRs:
			value_15(uint256) := ϕ(['value_1', 'value_14'])
			result_15(uint256) := ϕ(['result_14', 'result_1'])
		Expression: value >> 1 > 0
		IRs:
			TMP_3288(uint256) = value_15 >> 1
			TMP_3289(bool) = TMP_3288 > 0
			CONDITION TMP_3289
		Expression: result += 1
		IRs:
			result_16(uint256) = result_15 + 1
		IRs:
			result_17(uint256) := ϕ(['result_16', 'result_1'])
		Expression: result
		IRs:
			RETURN result_17
	Function Math.log2(uint256,Math.Rounding)
		Expression: result = log2(value)
		IRs:
			TMP_3290(uint256) = INTERNAL_CALL, Math.log2(uint256)(value_1)
			result_1(uint256) := TMP_3290(uint256)
		Expression: rounding == Rounding.Up && 1 << result < value
		IRs:
			REF_936(Math.Rounding) -> Rounding.Up
			TMP_3291(bool) = rounding_1 == REF_936
			TMP_3292(uint256) = 1 << result_1
			TMP_3293(bool) = TMP_3292 < value_1
			TMP_3294(bool) = TMP_3291 && TMP_3293
			CONDITION TMP_3294
		Expression: result + 1
		IRs:
			TMP_3295(uint256) = result_1 + 1
			RETURN TMP_3295
		Expression: result + 0
		IRs:
			TMP_3296(uint256) = result_1 + 0
			RETURN TMP_3296
	Function Math.log10(uint256)
		IRs:
			value_1(uint256) := ϕ(['value_1'])
		Expression: result = 0
		IRs:
			result_1(uint256) := 0(uint256)
		Expression: value >= 10 ** 64
		IRs:
			TMP_3297(uint256) = 10 ** 64
			TMP_3298(bool) = value_1 >= TMP_3297
			CONDITION TMP_3298
		Expression: value /= 10 ** 64
		IRs:
			TMP_3299(uint256) = 10 ** 64
			value_2(uint256) = value_1 / TMP_3299
		Expression: result += 64
		IRs:
			result_2(uint256) = result_1 + 64
		IRs:
			value_3(uint256) := ϕ(['value_2', 'value_1'])
			result_3(uint256) := ϕ(['result_1', 'result_2'])
		Expression: value >= 10 ** 32
		IRs:
			TMP_3300(uint256) = 10 ** 32
			TMP_3301(bool) = value_3 >= TMP_3300
			CONDITION TMP_3301
		Expression: value /= 10 ** 32
		IRs:
			TMP_3302(uint256) = 10 ** 32
			value_4(uint256) = value_3 / TMP_3302
		Expression: result += 32
		IRs:
			result_4(uint256) = result_3 + 32
		IRs:
			value_5(uint256) := ϕ(['value_1', 'value_4'])
			result_5(uint256) := ϕ(['result_1', 'result_4'])
		Expression: value >= 10 ** 16
		IRs:
			TMP_3303(uint256) = 10 ** 16
			TMP_3304(bool) = value_5 >= TMP_3303
			CONDITION TMP_3304
		Expression: value /= 10 ** 16
		IRs:
			TMP_3305(uint256) = 10 ** 16
			value_6(uint256) = value_5 / TMP_3305
		Expression: result += 16
		IRs:
			result_6(uint256) = result_5 + 16
		IRs:
			value_7(uint256) := ϕ(['value_6', 'value_1'])
			result_7(uint256) := ϕ(['result_1', 'result_6'])
		Expression: value >= 10 ** 8
		IRs:
			TMP_3306(uint256) = 10 ** 8
			TMP_3307(bool) = value_7 >= TMP_3306
			CONDITION TMP_3307
		Expression: value /= 10 ** 8
		IRs:
			TMP_3308(uint256) = 10 ** 8
			value_8(uint256) = value_7 / TMP_3308
		Expression: result += 8
		IRs:
			result_8(uint256) = result_7 + 8
		IRs:
			value_9(uint256) := ϕ(['value_1', 'value_8'])
			result_9(uint256) := ϕ(['result_1', 'result_8'])
		Expression: value >= 10 ** 4
		IRs:
			TMP_3309(uint256) = 10 ** 4
			TMP_3310(bool) = value_9 >= TMP_3309
			CONDITION TMP_3310
		Expression: value /= 10 ** 4
		IRs:
			TMP_3311(uint256) = 10 ** 4
			value_10(uint256) = value_9 / TMP_3311
		Expression: result += 4
		IRs:
			result_10(uint256) = result_9 + 4
		IRs:
			value_11(uint256) := ϕ(['value_10', 'value_1'])
			result_11(uint256) := ϕ(['result_1', 'result_10'])
		Expression: value >= 10 ** 2
		IRs:
			TMP_3312(uint256) = 10 ** 2
			TMP_3313(bool) = value_11 >= TMP_3312
			CONDITION TMP_3313
		Expression: value /= 10 ** 2
		IRs:
			TMP_3314(uint256) = 10 ** 2
			value_12(uint256) = value_11 / TMP_3314
		Expression: result += 2
		IRs:
			result_12(uint256) = result_11 + 2
		IRs:
			value_13(uint256) := ϕ(['value_1', 'value_12'])
			result_13(uint256) := ϕ(['result_1', 'result_12'])
		Expression: value >= 10 ** 1
		IRs:
			TMP_3315(uint256) = 10 ** 1
			TMP_3316(bool) = value_13 >= TMP_3315
			CONDITION TMP_3316
		Expression: result += 1
		IRs:
			result_14(uint256) = result_13 + 1
		IRs:
			result_15(uint256) := ϕ(['result_1', 'result_14'])
		Expression: result
		IRs:
			RETURN result_15
	Function Math.log10(uint256,Math.Rounding)
		Expression: result = log10(value)
		IRs:
			TMP_3317(uint256) = INTERNAL_CALL, Math.log10(uint256)(value_1)
			result_1(uint256) := TMP_3317(uint256)
		Expression: rounding == Rounding.Up && 10 ** result < value
		IRs:
			REF_937(Math.Rounding) -> Rounding.Up
			TMP_3318(bool) = rounding_1 == REF_937
			TMP_3319(uint256) = 10 ** result_1
			TMP_3320(bool) = TMP_3319 < value_1
			TMP_3321(bool) = TMP_3318 && TMP_3320
			CONDITION TMP_3321
		Expression: result + 1
		IRs:
			TMP_3322(uint256) = result_1 + 1
			RETURN TMP_3322
		Expression: result + 0
		IRs:
			TMP_3323(uint256) = result_1 + 0
			RETURN TMP_3323
	Function Math.log256(uint256)
		IRs:
			value_1(uint256) := ϕ(['value_1'])
		Expression: result = 0
		IRs:
			result_1(uint256) := 0(uint256)
		Expression: value >> 128 > 0
		IRs:
			TMP_3324(uint256) = value_1 >> 128
			TMP_3325(bool) = TMP_3324 > 0
			CONDITION TMP_3325
		Expression: value >>= 128
		IRs:
			value_2(uint256) = value_1 >> 128
		Expression: result += 16
		IRs:
			result_2(uint256) = result_1 + 16
		IRs:
			value_3(uint256) := ϕ(['value_2', 'value_1'])
			result_3(uint256) := ϕ(['result_2', 'result_1'])
		Expression: value >> 64 > 0
		IRs:
			TMP_3326(uint256) = value_3 >> 64
			TMP_3327(bool) = TMP_3326 > 0
			CONDITION TMP_3327
		Expression: value >>= 64
		IRs:
			value_4(uint256) = value_3 >> 64
		Expression: result += 8
		IRs:
			result_4(uint256) = result_3 + 8
		IRs:
			value_5(uint256) := ϕ(['value_1', 'value_4'])
			result_5(uint256) := ϕ(['result_4', 'result_1'])
		Expression: value >> 32 > 0
		IRs:
			TMP_3328(uint256) = value_5 >> 32
			TMP_3329(bool) = TMP_3328 > 0
			CONDITION TMP_3329
		Expression: value >>= 32
		IRs:
			value_6(uint256) = value_5 >> 32
		Expression: result += 4
		IRs:
			result_6(uint256) = result_5 + 4
		IRs:
			value_7(uint256) := ϕ(['value_6', 'value_1'])
			result_7(uint256) := ϕ(['result_6', 'result_1'])
		Expression: value >> 16 > 0
		IRs:
			TMP_3330(uint256) = value_7 >> 16
			TMP_3331(bool) = TMP_3330 > 0
			CONDITION TMP_3331
		Expression: value >>= 16
		IRs:
			value_8(uint256) = value_7 >> 16
		Expression: result += 2
		IRs:
			result_8(uint256) = result_7 + 2
		IRs:
			value_9(uint256) := ϕ(['value_1', 'value_8'])
			result_9(uint256) := ϕ(['result_8', 'result_1'])
		Expression: value >> 8 > 0
		IRs:
			TMP_3332(uint256) = value_9 >> 8
			TMP_3333(bool) = TMP_3332 > 0
			CONDITION TMP_3333
		Expression: result += 1
		IRs:
			result_10(uint256) = result_9 + 1
		IRs:
			result_11(uint256) := ϕ(['result_10', 'result_1'])
		Expression: result
		IRs:
			RETURN result_11
	Function Math.log256(uint256,Math.Rounding)
		Expression: result = log256(value)
		IRs:
			TMP_3334(uint256) = INTERNAL_CALL, Math.log256(uint256)(value_1)
			result_1(uint256) := TMP_3334(uint256)
		Expression: rounding == Rounding.Up && 1 << (result * 8) < value
		IRs:
			REF_938(Math.Rounding) -> Rounding.Up
			TMP_3335(bool) = rounding_1 == REF_938
			TMP_3336(uint256) = result_1 * 8
			TMP_3337(uint256) = 1 << TMP_3336
			TMP_3338(bool) = TMP_3337 < value_1
			TMP_3339(bool) = TMP_3335 && TMP_3338
			CONDITION TMP_3339
		Expression: result + 1
		IRs:
			TMP_3340(uint256) = result_1 + 1
			RETURN TMP_3340
		Expression: result + 0
		IRs:
			TMP_3341(uint256) = result_1 + 0
			RETURN TMP_3341
Contract FeeBank
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_3342(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_3342)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_3344(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_3345(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_3346(bool) = TMP_3344 == TMP_3345
			TMP_3347(None) = SOLIDITY_CALL require(bool,string)(TMP_3346,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_3348 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_3348)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['owner__1'])
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_3351 = CONVERT 0 to address
			TMP_3352(bool) = newOwner_1 != TMP_3351
			TMP_3353(None) = SOLIDITY_CALL require(bool,string)(TMP_3352,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['TMP_3348', 'TMP_3342', 'newOwner_1'])
			_owner_2(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function IFeeBank.availableCredit(address)
	Function IFeeBank.deposit(uint256)
	Function IFeeBank.depositFor(address,uint256)
	Function IFeeBank.depositWithPermit(uint256,bytes)
	Function IFeeBank.depositForWithPermit(address,uint256,bytes)
	Function IFeeBank.withdraw(uint256)
	Function IFeeBank.withdrawTo(address,uint256)
	Function FeeBank.constructor(IFeeBankCharger,IERC20,address)
		Expression: address(charger_) == address(0)
		IRs:
			TMP_3357 = CONVERT charger__1 to address
			TMP_3358 = CONVERT 0 to address
			TMP_3359(bool) = TMP_3357 == TMP_3358
			CONDITION TMP_3359
		Expression: revert ZeroAddress()()
		IRs:
			TMP_3360(None) = SOLIDITY_CALL revert ZeroAddress()()
		Expression: address(inch_) == address(0)
		IRs:
			TMP_3361 = CONVERT inch__1 to address
			TMP_3362 = CONVERT 0 to address
			TMP_3363(bool) = TMP_3361 == TMP_3362
			CONDITION TMP_3363
		Expression: revert ZeroAddress()()
		IRs:
			TMP_3364(None) = SOLIDITY_CALL revert ZeroAddress()()
		Expression: _charger = charger_
		IRs:
			_charger_1(IFeeBankCharger) := charger__1(IFeeBankCharger)
		Expression: _token = inch_
		IRs:
			_token_1(IERC20) := inch__1(IERC20)
		Expression: transferOwnership(owner_)
		IRs:
			INTERNAL_CALL, Ownable.transferOwnership(address)(owner__1)
	Function FeeBank.availableCredit(address)
		IRs:
			_charger_2(IFeeBankCharger) := ϕ(['_charger_8', '_charger_0', '_charger_5', '_charger_1', '_charger_10', '_charger_3'])
		Expression: _charger.availableCredit(account)
		IRs:
			TMP_3366(uint256) = HIGH_LEVEL_CALL, dest:_charger_2(IFeeBankCharger), function:availableCredit, arguments:['account_1']  
			_charger_3(IFeeBankCharger) := ϕ(['_charger_8', '_charger_2', '_charger_5', '_charger_1', '_charger_10', '_charger_3'])
			RETURN TMP_3366
	Function FeeBank.deposit(uint256)
		Expression: _depositFor(msg.sender,amount)
		IRs:
			TMP_3367(uint256) = INTERNAL_CALL, FeeBank._depositFor(address,uint256)(msg.sender,amount_1)
			RETURN TMP_3367
		Expression: totalAvailableCredit
	Function FeeBank.depositFor(address,uint256)
		Expression: _depositFor(account,amount)
		IRs:
			TMP_3368(uint256) = INTERNAL_CALL, FeeBank._depositFor(address,uint256)(account_1,amount_1)
			RETURN TMP_3368
		Expression: totalAvailableCredit
	Function FeeBank.depositWithPermit(uint256,bytes)
		Expression: depositForWithPermit(msg.sender,amount,permit)
		IRs:
			TMP_3369(uint256) = INTERNAL_CALL, FeeBank.depositForWithPermit(address,uint256,bytes)(msg.sender,amount_1,permit_1)
			RETURN TMP_3369
		Expression: totalAvailableCredit
	Function FeeBank.depositForWithPermit(address,uint256,bytes)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			amount_1(uint256) := ϕ(['amount_1'])
			permit_1(bytes) := ϕ(['permit_1'])
			_token_2(IERC20) := ϕ(['_token_4', '_token_1', '_token_8', '_token_0'])
		Expression: _token.safePermit(permit)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['_token_2', 'permit_1'] 
		Expression: _depositFor(account,amount)
		IRs:
			TMP_3371(uint256) = INTERNAL_CALL, FeeBank._depositFor(address,uint256)(account_1,amount_1)
			RETURN TMP_3371
		Expression: totalAvailableCredit
	Function FeeBank.withdraw(uint256)
		Expression: _withdrawTo(msg.sender,amount)
		IRs:
			TMP_3372(uint256) = INTERNAL_CALL, FeeBank._withdrawTo(address,uint256)(msg.sender,amount_1)
			RETURN TMP_3372
		Expression: totalAvailableCredit
	Function FeeBank.withdrawTo(address,uint256)
		Expression: _withdrawTo(account,amount)
		IRs:
			TMP_3373(uint256) = INTERNAL_CALL, FeeBank._withdrawTo(address,uint256)(account_1,amount_1)
			RETURN TMP_3373
		Expression: totalAvailableCredit
	Function FeeBank.gatherFees(address[])
		IRs:
			_token_3(IERC20) := ϕ(['_token_4', '_token_1', '_token_8', '_token_0'])
			_charger_4(IFeeBankCharger) := ϕ(['_charger_8', '_charger_0', '_charger_5', '_charger_1', '_charger_10', '_charger_3'])
			_accountDeposits_1(mapping(address => uint256)) := ϕ(['_accountDeposits_0', '_accountDeposits_2', '_accountDeposits_5', '_accountDeposits_8'])
		Expression: accountsLength = accounts.length
		IRs:
			REF_941 -> LENGTH accounts_1
			accountsLength_1(uint256) := REF_941(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < accountsLength
		IRs:
			totalAccountFees_1(uint256) := ϕ(['totalAccountFees_0', 'totalAccountFees_2'])
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_3374(bool) = i_2 < accountsLength_1
			CONDITION TMP_3374
		Expression: account = accounts[i]
		IRs:
			REF_942(address) -> accounts_1[i_2]
			account_1(address) := REF_942(address)
		Expression: accountDeposit = _accountDeposits[account]
		IRs:
			REF_943(uint256) -> _accountDeposits_2[account_1]
			accountDeposit_1(uint256) := REF_943(uint256)
		Expression: availableCredit_ = _charger.availableCredit(account)
		IRs:
			TMP_3375(uint256) = HIGH_LEVEL_CALL, dest:_charger_5(IFeeBankCharger), function:availableCredit, arguments:['account_1']  
			_token_5(IERC20) := ϕ(['_token_4', '_token_1', '_token_8'])
			_charger_6(IFeeBankCharger) := ϕ(['_charger_8', '_charger_5', '_charger_1', '_charger_10', '_charger_3'])
			availableCredit__1(uint256) := TMP_3375(uint256)
		Expression: _accountDeposits[account] = availableCredit_
		IRs:
			REF_945(uint256) -> _accountDeposits_2[account_1]
			_accountDeposits_3(mapping(address => uint256)) := ϕ(['_accountDeposits_2'])
			REF_945(uint256) (->_accountDeposits_3) := availableCredit__1(uint256)
		Expression: totalAccountFees += accountDeposit - availableCredit_
		IRs:
			TMP_3376(uint256) = accountDeposit_1 - availableCredit__1
			totalAccountFees_2(uint256) = totalAccountFees_1 + TMP_3376
		Expression: ++ i
		IRs:
			i_3(uint256) = i_2 + 1
		Expression: _token.safeTransfer(msg.sender,totalAccountFees)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['_token_4', 'msg.sender', 'totalAccountFees_1'] 
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
		Expression: totalAccountFees
		IRs:
			RETURN totalAccountFees_1
	Function FeeBank._depositFor(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1', 'msg.sender'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_token_6(IERC20) := ϕ(['_token_4', '_token_1', '_token_8', '_token_0'])
			_charger_7(IFeeBankCharger) := ϕ(['_charger_8', '_charger_0', '_charger_5', '_charger_1', '_charger_10', '_charger_3'])
			_accountDeposits_4(mapping(address => uint256)) := ϕ(['_accountDeposits_0', '_accountDeposits_2', '_accountDeposits_5', '_accountDeposits_8'])
		Expression: account == address(0)
		IRs:
			TMP_3379 = CONVERT 0 to address
			TMP_3380(bool) = account_1 == TMP_3379
			CONDITION TMP_3380
		Expression: revert ZeroAddress()()
		IRs:
			TMP_3381(None) = SOLIDITY_CALL revert ZeroAddress()()
		Expression: _token.safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_3382 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['_token_6', 'msg.sender', 'TMP_3382', 'amount_1'] 
		Expression: _accountDeposits[account] += amount
		IRs:
			REF_948(uint256) -> _accountDeposits_4[account_1]
			_accountDeposits_5(mapping(address => uint256)) := ϕ(['_accountDeposits_4'])
			REF_948(-> _accountDeposits_5) = REF_948 + amount_1
		Expression: totalAvailableCredit = _charger.increaseAvailableCredit(account,amount)
		IRs:
			TMP_3384(uint256) = HIGH_LEVEL_CALL, dest:_charger_7(IFeeBankCharger), function:increaseAvailableCredit, arguments:['account_1', 'amount_1']  
			_charger_8(IFeeBankCharger) := ϕ(['_charger_7', '_charger_8', '_charger_5', '_charger_1', '_charger_10', '_charger_3'])
			totalAvailableCredit_1(uint256) := TMP_3384(uint256)
		Expression: totalAvailableCredit
		IRs:
			RETURN totalAvailableCredit_1
	Function FeeBank._withdrawTo(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1', 'msg.sender'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_token_7(IERC20) := ϕ(['_token_4', '_token_1', '_token_8', '_token_0'])
			_charger_9(IFeeBankCharger) := ϕ(['_charger_8', '_charger_0', '_charger_5', '_charger_1', '_charger_10', '_charger_3'])
			_accountDeposits_6(mapping(address => uint256)) := ϕ(['_accountDeposits_0', '_accountDeposits_2', '_accountDeposits_5', '_accountDeposits_8'])
		Expression: totalAvailableCredit = _charger.decreaseAvailableCredit(msg.sender,amount)
		IRs:
			TMP_3385(uint256) = HIGH_LEVEL_CALL, dest:_charger_9(IFeeBankCharger), function:decreaseAvailableCredit, arguments:['msg.sender', 'amount_1']  
			_token_8(IERC20) := ϕ(['_token_4', '_token_1', '_token_8', '_token_7'])
			_charger_10(IFeeBankCharger) := ϕ(['_charger_9', '_charger_8', '_charger_5', '_charger_1', '_charger_10', '_charger_3'])
			_accountDeposits_7(mapping(address => uint256)) := ϕ(['_accountDeposits_6', '_accountDeposits_2', '_accountDeposits_5', '_accountDeposits_8'])
			totalAvailableCredit_1(uint256) := TMP_3385(uint256)
		Expression: _accountDeposits[msg.sender] -= amount
		IRs:
			REF_951(uint256) -> _accountDeposits_7[msg.sender]
			_accountDeposits_8(mapping(address => uint256)) := ϕ(['_accountDeposits_7'])
			REF_951(-> _accountDeposits_8) = REF_951 - amount_1
		Expression: _token.safeTransfer(account,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['_token_8', 'account_1', 'amount_1'] 
		Expression: totalAvailableCredit
		IRs:
			RETURN totalAvailableCredit_1
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
Contract FeeBankCharger
	Function IFeeBankCharger.feeBank()
	Function IFeeBankCharger.availableCredit(address)
	Function IFeeBankCharger.increaseAvailableCredit(address,uint256)
	Function IFeeBankCharger.decreaseAvailableCredit(address,uint256)
	Function FeeBankCharger.constructor(IERC20)
		IRs:
			token_1(IERC20) := ϕ(['token_1', 'token_1'])
		Expression: feeBank = new FeeBank(this,token,msg.sender)
		IRs:
			TMP_3389(FeeBank) = new FeeBank(this,token_1,msg.sender) 
			feeBank_1(IFeeBank) := TMP_3389(FeeBank)
	Function FeeBankCharger.availableCredit(address)
		IRs:
			_creditAllowance_1(mapping(address => uint256)) := ϕ(['_creditAllowance_7', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9', '_creditAllowance_0'])
		Expression: _creditAllowance[account]
		IRs:
			REF_953(uint256) -> _creditAllowance_1[account_1]
			RETURN REF_953
	Function FeeBankCharger.increaseAvailableCredit(address,uint256)
		IRs:
			_creditAllowance_2(mapping(address => uint256)) := ϕ(['_creditAllowance_7', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9', '_creditAllowance_0'])
		Expression: allowance = _creditAllowance[account]
		IRs:
			REF_954(uint256) -> _creditAllowance_3[account_1]
			allowance_1(uint256) := REF_954(uint256)
		Expression: allowance += amount
		IRs:
			allowance_2(uint256) = allowance_1 + amount_1
		Expression: _creditAllowance[account] = allowance
		IRs:
			REF_955(uint256) -> _creditAllowance_3[account_1]
			_creditAllowance_4(mapping(address => uint256)) := ϕ(['_creditAllowance_3'])
			REF_955(uint256) (->_creditAllowance_4) := allowance_2(uint256)
		Expression: onlyFeeBank()
		IRs:
			MODIFIER_CALL, FeeBankCharger.onlyFeeBank()()
		Expression: allowance
		IRs:
			RETURN allowance_2
	Function FeeBankCharger.decreaseAvailableCredit(address,uint256)
		IRs:
			_creditAllowance_5(mapping(address => uint256)) := ϕ(['_creditAllowance_7', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9', '_creditAllowance_0'])
		Expression: allowance = _creditAllowance[account]
		IRs:
			REF_956(uint256) -> _creditAllowance_6[account_1]
			allowance_1(uint256) := REF_956(uint256)
		Expression: allowance -= amount
		IRs:
			allowance_2(uint256) = allowance_1 (c)- amount_1
		Expression: _creditAllowance[account] = allowance
		IRs:
			REF_957(uint256) -> _creditAllowance_6[account_1]
			_creditAllowance_7(mapping(address => uint256)) := ϕ(['_creditAllowance_6'])
			REF_957(uint256) (->_creditAllowance_7) := allowance_2(uint256)
		Expression: onlyFeeBank()
		IRs:
			MODIFIER_CALL, FeeBankCharger.onlyFeeBank()()
		Expression: allowance
		IRs:
			RETURN allowance_2
	Function FeeBankCharger._chargeFee(address,uint256)
		IRs:
			_creditAllowance_8(mapping(address => uint256)) := ϕ(['_creditAllowance_7', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9', '_creditAllowance_0'])
		Expression: fee > 0
		IRs:
			TMP_3392(bool) = fee_1 > 0
			CONDITION TMP_3392
		Expression: currentAllowance = _creditAllowance[account]
		IRs:
			REF_958(uint256) -> _creditAllowance_8[account_1]
			currentAllowance_1(uint256) := REF_958(uint256)
		Expression: currentAllowance < fee
		IRs:
			TMP_3393(bool) = currentAllowance_1 < fee_1
			CONDITION TMP_3393
		Expression: revert NotEnoughCredit()()
		IRs:
			TMP_3394(None) = SOLIDITY_CALL revert NotEnoughCredit()()
		Expression: _creditAllowance[account] = currentAllowance - fee
		IRs:
			REF_959(uint256) -> _creditAllowance_8[account_1]
			TMP_3395(uint256) = currentAllowance_1 - fee_1
			_creditAllowance_9(mapping(address => uint256)) := ϕ(['_creditAllowance_8'])
			REF_959(uint256) (->_creditAllowance_9) := TMP_3395(uint256)
	Modifier FeeBankCharger.onlyFeeBank()
ENTRY_POINT
		IRs:
			feeBank_2(IFeeBank) := ϕ(['feeBank_1', 'feeBank_0'])
IF msg.sender != address(feeBank)
		Expression: msg.sender != address(feeBank)
		IRs:
			TMP_3396 = CONVERT feeBank_2 to address
			TMP_3397(bool) = msg.sender != TMP_3396
			CONDITION TMP_3397
EXPRESSION revert OnlyFeeBankAccess()()
		Expression: revert OnlyFeeBankAccess()()
		IRs:
			TMP_3398(None) = SOLIDITY_CALL revert OnlyFeeBankAccess()()
END_IF
_
Contract PowerPod
	Function IVotable.votingPowerOf(address)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function VotingPowerCalculator.constructor(uint256,uint256)
		IRs:
			_ONE_E18_1(uint256) := ϕ(['_ONE_E18_0'])
		Expression: origin_ > block.timestamp
		IRs:
			TMP_3399(bool) = origin__1 > block.timestamp
			CONDITION TMP_3399
		Expression: revert OriginInTheFuture()()
		IRs:
			TMP_3400(None) = SOLIDITY_CALL revert OriginInTheFuture()()
		Expression: origin = origin_
		IRs:
			origin_1(uint256) := origin__1(uint256)
		Expression: expBase = expBase_
		IRs:
			expBase_1(uint256) := expBase__1(uint256)
		Expression: _expTable0 = expBase_
		IRs:
			_expTable0_1(uint256) := expBase__1(uint256)
		Expression: _expTable1 = (_expTable0 * _expTable0) / _ONE_E18
		IRs:
			TMP_3401(uint256) = _expTable0_1 (c)* _expTable0_1
			TMP_3402(uint256) = TMP_3401 (c)/ _ONE_E18_1
			_expTable1_1(uint256) := TMP_3402(uint256)
		Expression: _expTable2 = (_expTable1 * _expTable1) / _ONE_E18
		IRs:
			TMP_3403(uint256) = _expTable1_1 (c)* _expTable1_1
			TMP_3404(uint256) = TMP_3403 (c)/ _ONE_E18_1
			_expTable2_1(uint256) := TMP_3404(uint256)
		Expression: _expTable3 = (_expTable2 * _expTable2) / _ONE_E18
		IRs:
			TMP_3405(uint256) = _expTable2_1 (c)* _expTable2_1
			TMP_3406(uint256) = TMP_3405 (c)/ _ONE_E18_1
			_expTable3_1(uint256) := TMP_3406(uint256)
		Expression: _expTable4 = (_expTable3 * _expTable3) / _ONE_E18
		IRs:
			TMP_3407(uint256) = _expTable3_1 (c)* _expTable3_1
			TMP_3408(uint256) = TMP_3407 (c)/ _ONE_E18_1
			_expTable4_1(uint256) := TMP_3408(uint256)
		Expression: _expTable5 = (_expTable4 * _expTable4) / _ONE_E18
		IRs:
			TMP_3409(uint256) = _expTable4_1 (c)* _expTable4_1
			TMP_3410(uint256) = TMP_3409 (c)/ _ONE_E18_1
			_expTable5_1(uint256) := TMP_3410(uint256)
		Expression: _expTable6 = (_expTable5 * _expTable5) / _ONE_E18
		IRs:
			TMP_3411(uint256) = _expTable5_1 (c)* _expTable5_1
			TMP_3412(uint256) = TMP_3411 (c)/ _ONE_E18_1
			_expTable6_1(uint256) := TMP_3412(uint256)
		Expression: _expTable7 = (_expTable6 * _expTable6) / _ONE_E18
		IRs:
			TMP_3413(uint256) = _expTable6_1 (c)* _expTable6_1
			TMP_3414(uint256) = TMP_3413 (c)/ _ONE_E18_1
			_expTable7_1(uint256) := TMP_3414(uint256)
		Expression: _expTable8 = (_expTable7 * _expTable7) / _ONE_E18
		IRs:
			TMP_3415(uint256) = _expTable7_1 (c)* _expTable7_1
			TMP_3416(uint256) = TMP_3415 (c)/ _ONE_E18_1
			_expTable8_1(uint256) := TMP_3416(uint256)
		Expression: _expTable9 = (_expTable8 * _expTable8) / _ONE_E18
		IRs:
			TMP_3417(uint256) = _expTable8_1 (c)* _expTable8_1
			TMP_3418(uint256) = TMP_3417 (c)/ _ONE_E18_1
			_expTable9_1(uint256) := TMP_3418(uint256)
		Expression: _expTable10 = (_expTable9 * _expTable9) / _ONE_E18
		IRs:
			TMP_3419(uint256) = _expTable9_1 (c)* _expTable9_1
			TMP_3420(uint256) = TMP_3419 (c)/ _ONE_E18_1
			_expTable10_1(uint256) := TMP_3420(uint256)
		Expression: _expTable11 = (_expTable10 * _expTable10) / _ONE_E18
		IRs:
			TMP_3421(uint256) = _expTable10_1 (c)* _expTable10_1
			TMP_3422(uint256) = TMP_3421 (c)/ _ONE_E18_1
			_expTable11_1(uint256) := TMP_3422(uint256)
		Expression: _expTable12 = (_expTable11 * _expTable11) / _ONE_E18
		IRs:
			TMP_3423(uint256) = _expTable11_1 (c)* _expTable11_1
			TMP_3424(uint256) = TMP_3423 (c)/ _ONE_E18_1
			_expTable12_1(uint256) := TMP_3424(uint256)
		Expression: _expTable13 = (_expTable12 * _expTable12) / _ONE_E18
		IRs:
			TMP_3425(uint256) = _expTable12_1 (c)* _expTable12_1
			TMP_3426(uint256) = TMP_3425 (c)/ _ONE_E18_1
			_expTable13_1(uint256) := TMP_3426(uint256)
		Expression: _expTable14 = (_expTable13 * _expTable13) / _ONE_E18
		IRs:
			TMP_3427(uint256) = _expTable13_1 (c)* _expTable13_1
			TMP_3428(uint256) = TMP_3427 (c)/ _ONE_E18_1
			_expTable14_1(uint256) := TMP_3428(uint256)
		Expression: _expTable15 = (_expTable14 * _expTable14) / _ONE_E18
		IRs:
			TMP_3429(uint256) = _expTable14_1 (c)* _expTable14_1
			TMP_3430(uint256) = TMP_3429 (c)/ _ONE_E18_1
			_expTable15_1(uint256) := TMP_3430(uint256)
		Expression: _expTable16 = (_expTable15 * _expTable15) / _ONE_E18
		IRs:
			TMP_3431(uint256) = _expTable15_1 (c)* _expTable15_1
			TMP_3432(uint256) = TMP_3431 (c)/ _ONE_E18_1
			_expTable16_1(uint256) := TMP_3432(uint256)
		Expression: _expTable17 = (_expTable16 * _expTable16) / _ONE_E18
		IRs:
			TMP_3433(uint256) = _expTable16_1 (c)* _expTable16_1
			TMP_3434(uint256) = TMP_3433 (c)/ _ONE_E18_1
			_expTable17_1(uint256) := TMP_3434(uint256)
		Expression: _expTable18 = (_expTable17 * _expTable17) / _ONE_E18
		IRs:
			TMP_3435(uint256) = _expTable17_1 (c)* _expTable17_1
			TMP_3436(uint256) = TMP_3435 (c)/ _ONE_E18_1
			_expTable18_1(uint256) := TMP_3436(uint256)
		Expression: _expTable19 = (_expTable18 * _expTable18) / _ONE_E18
		IRs:
			TMP_3437(uint256) = _expTable18_1 (c)* _expTable18_1
			TMP_3438(uint256) = TMP_3437 (c)/ _ONE_E18_1
			_expTable19_1(uint256) := TMP_3438(uint256)
		Expression: _expTable20 = (_expTable19 * _expTable19) / _ONE_E18
		IRs:
			TMP_3439(uint256) = _expTable19_1 (c)* _expTable19_1
			TMP_3440(uint256) = TMP_3439 (c)/ _ONE_E18_1
			_expTable20_1(uint256) := TMP_3440(uint256)
		Expression: _expTable21 = (_expTable20 * _expTable20) / _ONE_E18
		IRs:
			TMP_3441(uint256) = _expTable20_1 (c)* _expTable20_1
			TMP_3442(uint256) = TMP_3441 (c)/ _ONE_E18_1
			_expTable21_1(uint256) := TMP_3442(uint256)
		Expression: _expTable22 = (_expTable21 * _expTable21) / _ONE_E18
		IRs:
			TMP_3443(uint256) = _expTable21_1 (c)* _expTable21_1
			TMP_3444(uint256) = TMP_3443 (c)/ _ONE_E18_1
			_expTable22_1(uint256) := TMP_3444(uint256)
		Expression: _expTable23 = (_expTable22 * _expTable22) / _ONE_E18
		IRs:
			TMP_3445(uint256) = _expTable22_1 (c)* _expTable22_1
			TMP_3446(uint256) = TMP_3445 (c)/ _ONE_E18_1
			_expTable23_1(uint256) := TMP_3446(uint256)
		Expression: _expTable24 = (_expTable23 * _expTable23) / _ONE_E18
		IRs:
			TMP_3447(uint256) = _expTable23_1 (c)* _expTable23_1
			TMP_3448(uint256) = TMP_3447 (c)/ _ONE_E18_1
			_expTable24_1(uint256) := TMP_3448(uint256)
		Expression: _expTable25 = (_expTable24 * _expTable24) / _ONE_E18
		IRs:
			TMP_3449(uint256) = _expTable24_1 (c)* _expTable24_1
			TMP_3450(uint256) = TMP_3449 (c)/ _ONE_E18_1
			_expTable25_1(uint256) := TMP_3450(uint256)
		Expression: _expTable26 = (_expTable25 * _expTable25) / _ONE_E18
		IRs:
			TMP_3451(uint256) = _expTable25_1 (c)* _expTable25_1
			TMP_3452(uint256) = TMP_3451 (c)/ _ONE_E18_1
			_expTable26_1(uint256) := TMP_3452(uint256)
		Expression: _expTable27 = (_expTable26 * _expTable26) / _ONE_E18
		IRs:
			TMP_3453(uint256) = _expTable26_1 (c)* _expTable26_1
			TMP_3454(uint256) = TMP_3453 (c)/ _ONE_E18_1
			_expTable27_1(uint256) := TMP_3454(uint256)
		Expression: _expTable28 = (_expTable27 * _expTable27) / _ONE_E18
		IRs:
			TMP_3455(uint256) = _expTable27_1 (c)* _expTable27_1
			TMP_3456(uint256) = TMP_3455 (c)/ _ONE_E18_1
			_expTable28_1(uint256) := TMP_3456(uint256)
		Expression: _expTable29 = (_expTable28 * _expTable28) / _ONE_E18
		IRs:
			TMP_3457(uint256) = _expTable28_1 (c)* _expTable28_1
			TMP_3458(uint256) = TMP_3457 (c)/ _ONE_E18_1
			_expTable29_1(uint256) := TMP_3458(uint256)
	Function VotingPowerCalculator._votingPowerAt(uint256,uint256)
		IRs:
			balance_1(uint256) := ϕ(['TMP_3843'])
			timestamp_1(uint256) := ϕ(['block.timestamp'])
			_ONE_E18_2(uint256) := ϕ(['_ONE_E18_0'])
			origin_2(uint256) := ϕ(['origin_0', 'origin_1'])
			_expTable0_2(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_2(uint256) := ϕ(['_expTable1_0', '_expTable1_1'])
			_expTable2_2(uint256) := ϕ(['_expTable2_0', '_expTable2_1'])
			_expTable3_2(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_2(uint256) := ϕ(['_expTable4_0', '_expTable4_1'])
			_expTable5_2(uint256) := ϕ(['_expTable5_0', '_expTable5_1'])
			_expTable6_2(uint256) := ϕ(['_expTable6_0', '_expTable6_1'])
			_expTable7_2(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_2(uint256) := ϕ(['_expTable8_0', '_expTable8_1'])
			_expTable9_2(uint256) := ϕ(['_expTable9_0', '_expTable9_1'])
			_expTable10_2(uint256) := ϕ(['_expTable10_0', '_expTable10_1'])
			_expTable11_2(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_2(uint256) := ϕ(['_expTable12_0', '_expTable12_1'])
			_expTable13_2(uint256) := ϕ(['_expTable13_0', '_expTable13_1'])
			_expTable14_2(uint256) := ϕ(['_expTable14_0', '_expTable14_1'])
			_expTable15_2(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_2(uint256) := ϕ(['_expTable16_0', '_expTable16_1'])
			_expTable17_2(uint256) := ϕ(['_expTable17_0', '_expTable17_1'])
			_expTable18_2(uint256) := ϕ(['_expTable18_0', '_expTable18_1'])
			_expTable19_2(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_2(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_2(uint256) := ϕ(['_expTable21_1', '_expTable21_0'])
			_expTable22_2(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_2(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_2(uint256) := ϕ(['_expTable24_0', '_expTable24_1'])
			_expTable25_2(uint256) := ϕ(['_expTable25_0', '_expTable25_1'])
			_expTable26_2(uint256) := ϕ(['_expTable26_0', '_expTable26_1'])
			_expTable27_2(uint256) := ϕ(['_expTable27_1', '_expTable27_0'])
			_expTable28_2(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_2(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_3459(uint256) = timestamp_4 - origin_2
			t_1(uint256) := TMP_3459(uint256)
		Expression: votingPower = balance
		IRs:
			votingPower_1(uint256) := balance_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_3460(uint256) = t_1 & 1
			TMP_3461(bool) = TMP_3460 != 0
			CONDITION TMP_3461
		Expression: votingPower = (votingPower * _expTable0) / _ONE_E18
		IRs:
			TMP_3462(uint256) = votingPower_1 * _expTable0_2
			TMP_3463(uint256) = TMP_3462 / _ONE_E18_2
			votingPower_2(uint256) := TMP_3463(uint256)
		IRs:
			votingPower_3(uint256) := ϕ(['votingPower_1', 'votingPower_2'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_3464(uint256) = t_1 & 2
			TMP_3465(bool) = TMP_3464 != 0
			CONDITION TMP_3465
		Expression: votingPower = (votingPower * _expTable1) / _ONE_E18
		IRs:
			TMP_3466(uint256) = votingPower_3 * _expTable1_2
			TMP_3467(uint256) = TMP_3466 / _ONE_E18_2
			votingPower_4(uint256) := TMP_3467(uint256)
		IRs:
			votingPower_5(uint256) := ϕ(['votingPower_1', 'votingPower_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_3468(uint256) = t_1 & 4
			TMP_3469(bool) = TMP_3468 != 0
			CONDITION TMP_3469
		Expression: votingPower = (votingPower * _expTable2) / _ONE_E18
		IRs:
			TMP_3470(uint256) = votingPower_5 * _expTable2_2
			TMP_3471(uint256) = TMP_3470 / _ONE_E18_2
			votingPower_6(uint256) := TMP_3471(uint256)
		IRs:
			votingPower_7(uint256) := ϕ(['votingPower_1', 'votingPower_6'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_3472(uint256) = t_1 & 8
			TMP_3473(bool) = TMP_3472 != 0
			CONDITION TMP_3473
		Expression: votingPower = (votingPower * _expTable3) / _ONE_E18
		IRs:
			TMP_3474(uint256) = votingPower_7 * _expTable3_2
			TMP_3475(uint256) = TMP_3474 / _ONE_E18_2
			votingPower_8(uint256) := TMP_3475(uint256)
		IRs:
			votingPower_9(uint256) := ϕ(['votingPower_8', 'votingPower_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_3476(uint256) = t_1 & 16
			TMP_3477(bool) = TMP_3476 != 0
			CONDITION TMP_3477
		Expression: votingPower = (votingPower * _expTable4) / _ONE_E18
		IRs:
			TMP_3478(uint256) = votingPower_9 * _expTable4_2
			TMP_3479(uint256) = TMP_3478 / _ONE_E18_2
			votingPower_10(uint256) := TMP_3479(uint256)
		IRs:
			votingPower_11(uint256) := ϕ(['votingPower_10', 'votingPower_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_3480(uint256) = t_1 & 32
			TMP_3481(bool) = TMP_3480 != 0
			CONDITION TMP_3481
		Expression: votingPower = (votingPower * _expTable5) / _ONE_E18
		IRs:
			TMP_3482(uint256) = votingPower_11 * _expTable5_2
			TMP_3483(uint256) = TMP_3482 / _ONE_E18_2
			votingPower_12(uint256) := TMP_3483(uint256)
		IRs:
			votingPower_13(uint256) := ϕ(['votingPower_12', 'votingPower_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_3484(uint256) = t_1 & 64
			TMP_3485(bool) = TMP_3484 != 0
			CONDITION TMP_3485
		Expression: votingPower = (votingPower * _expTable6) / _ONE_E18
		IRs:
			TMP_3486(uint256) = votingPower_13 * _expTable6_2
			TMP_3487(uint256) = TMP_3486 / _ONE_E18_2
			votingPower_14(uint256) := TMP_3487(uint256)
		IRs:
			votingPower_15(uint256) := ϕ(['votingPower_1', 'votingPower_14'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_3488(uint256) = t_1 & 128
			TMP_3489(bool) = TMP_3488 != 0
			CONDITION TMP_3489
		Expression: votingPower = (votingPower * _expTable7) / _ONE_E18
		IRs:
			TMP_3490(uint256) = votingPower_15 * _expTable7_2
			TMP_3491(uint256) = TMP_3490 / _ONE_E18_2
			votingPower_16(uint256) := TMP_3491(uint256)
		IRs:
			votingPower_17(uint256) := ϕ(['votingPower_1', 'votingPower_16'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_3492(uint256) = t_1 & 256
			TMP_3493(bool) = TMP_3492 != 0
			CONDITION TMP_3493
		Expression: votingPower = (votingPower * _expTable8) / _ONE_E18
		IRs:
			TMP_3494(uint256) = votingPower_17 * _expTable8_2
			TMP_3495(uint256) = TMP_3494 / _ONE_E18_2
			votingPower_18(uint256) := TMP_3495(uint256)
		IRs:
			votingPower_19(uint256) := ϕ(['votingPower_1', 'votingPower_18'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_3496(uint256) = t_1 & 512
			TMP_3497(bool) = TMP_3496 != 0
			CONDITION TMP_3497
		Expression: votingPower = (votingPower * _expTable9) / _ONE_E18
		IRs:
			TMP_3498(uint256) = votingPower_19 * _expTable9_2
			TMP_3499(uint256) = TMP_3498 / _ONE_E18_2
			votingPower_20(uint256) := TMP_3499(uint256)
		IRs:
			votingPower_21(uint256) := ϕ(['votingPower_1', 'votingPower_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_3500(uint256) = t_1 & 1024
			TMP_3501(bool) = TMP_3500 != 0
			CONDITION TMP_3501
		Expression: votingPower = (votingPower * _expTable10) / _ONE_E18
		IRs:
			TMP_3502(uint256) = votingPower_21 * _expTable10_2
			TMP_3503(uint256) = TMP_3502 / _ONE_E18_2
			votingPower_22(uint256) := TMP_3503(uint256)
		IRs:
			votingPower_23(uint256) := ϕ(['votingPower_1', 'votingPower_22'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_3504(uint256) = t_1 & 2048
			TMP_3505(bool) = TMP_3504 != 0
			CONDITION TMP_3505
		Expression: votingPower = (votingPower * _expTable11) / _ONE_E18
		IRs:
			TMP_3506(uint256) = votingPower_23 * _expTable11_2
			TMP_3507(uint256) = TMP_3506 / _ONE_E18_2
			votingPower_24(uint256) := TMP_3507(uint256)
		IRs:
			votingPower_25(uint256) := ϕ(['votingPower_24', 'votingPower_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_3508(uint256) = t_1 & 4096
			TMP_3509(bool) = TMP_3508 != 0
			CONDITION TMP_3509
		Expression: votingPower = (votingPower * _expTable12) / _ONE_E18
		IRs:
			TMP_3510(uint256) = votingPower_25 * _expTable12_2
			TMP_3511(uint256) = TMP_3510 / _ONE_E18_2
			votingPower_26(uint256) := TMP_3511(uint256)
		IRs:
			votingPower_27(uint256) := ϕ(['votingPower_26', 'votingPower_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_3512(uint256) = t_1 & 8192
			TMP_3513(bool) = TMP_3512 != 0
			CONDITION TMP_3513
		Expression: votingPower = (votingPower * _expTable13) / _ONE_E18
		IRs:
			TMP_3514(uint256) = votingPower_27 * _expTable13_2
			TMP_3515(uint256) = TMP_3514 / _ONE_E18_2
			votingPower_28(uint256) := TMP_3515(uint256)
		IRs:
			votingPower_29(uint256) := ϕ(['votingPower_28', 'votingPower_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_3516(uint256) = t_1 & 16384
			TMP_3517(bool) = TMP_3516 != 0
			CONDITION TMP_3517
		Expression: votingPower = (votingPower * _expTable14) / _ONE_E18
		IRs:
			TMP_3518(uint256) = votingPower_29 * _expTable14_2
			TMP_3519(uint256) = TMP_3518 / _ONE_E18_2
			votingPower_30(uint256) := TMP_3519(uint256)
		IRs:
			votingPower_31(uint256) := ϕ(['votingPower_1', 'votingPower_30'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_3520(uint256) = t_1 & 32768
			TMP_3521(bool) = TMP_3520 != 0
			CONDITION TMP_3521
		Expression: votingPower = (votingPower * _expTable15) / _ONE_E18
		IRs:
			TMP_3522(uint256) = votingPower_31 * _expTable15_2
			TMP_3523(uint256) = TMP_3522 / _ONE_E18_2
			votingPower_32(uint256) := TMP_3523(uint256)
		IRs:
			votingPower_33(uint256) := ϕ(['votingPower_1', 'votingPower_32'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_3524(uint256) = t_1 & 65536
			TMP_3525(bool) = TMP_3524 != 0
			CONDITION TMP_3525
		Expression: votingPower = (votingPower * _expTable16) / _ONE_E18
		IRs:
			TMP_3526(uint256) = votingPower_33 * _expTable16_2
			TMP_3527(uint256) = TMP_3526 / _ONE_E18_2
			votingPower_34(uint256) := TMP_3527(uint256)
		IRs:
			votingPower_35(uint256) := ϕ(['votingPower_1', 'votingPower_34'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_3528(uint256) = t_1 & 131072
			TMP_3529(bool) = TMP_3528 != 0
			CONDITION TMP_3529
		Expression: votingPower = (votingPower * _expTable17) / _ONE_E18
		IRs:
			TMP_3530(uint256) = votingPower_35 * _expTable17_2
			TMP_3531(uint256) = TMP_3530 / _ONE_E18_2
			votingPower_36(uint256) := TMP_3531(uint256)
		IRs:
			votingPower_37(uint256) := ϕ(['votingPower_1', 'votingPower_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_3532(uint256) = t_1 & 262144
			TMP_3533(bool) = TMP_3532 != 0
			CONDITION TMP_3533
		Expression: votingPower = (votingPower * _expTable18) / _ONE_E18
		IRs:
			TMP_3534(uint256) = votingPower_37 * _expTable18_2
			TMP_3535(uint256) = TMP_3534 / _ONE_E18_2
			votingPower_38(uint256) := TMP_3535(uint256)
		IRs:
			votingPower_39(uint256) := ϕ(['votingPower_1', 'votingPower_38'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_3536(uint256) = t_1 & 524288
			TMP_3537(bool) = TMP_3536 != 0
			CONDITION TMP_3537
		Expression: votingPower = (votingPower * _expTable19) / _ONE_E18
		IRs:
			TMP_3538(uint256) = votingPower_39 * _expTable19_2
			TMP_3539(uint256) = TMP_3538 / _ONE_E18_2
			votingPower_40(uint256) := TMP_3539(uint256)
		IRs:
			votingPower_41(uint256) := ϕ(['votingPower_40', 'votingPower_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_3540(uint256) = t_1 & 1048576
			TMP_3541(bool) = TMP_3540 != 0
			CONDITION TMP_3541
		Expression: votingPower = (votingPower * _expTable20) / _ONE_E18
		IRs:
			TMP_3542(uint256) = votingPower_41 * _expTable20_2
			TMP_3543(uint256) = TMP_3542 / _ONE_E18_2
			votingPower_42(uint256) := TMP_3543(uint256)
		IRs:
			votingPower_43(uint256) := ϕ(['votingPower_42', 'votingPower_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_3544(uint256) = t_1 & 2097152
			TMP_3545(bool) = TMP_3544 != 0
			CONDITION TMP_3545
		Expression: votingPower = (votingPower * _expTable21) / _ONE_E18
		IRs:
			TMP_3546(uint256) = votingPower_43 * _expTable21_2
			TMP_3547(uint256) = TMP_3546 / _ONE_E18_2
			votingPower_44(uint256) := TMP_3547(uint256)
		IRs:
			votingPower_45(uint256) := ϕ(['votingPower_44', 'votingPower_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_3548(uint256) = t_1 & 4194304
			TMP_3549(bool) = TMP_3548 != 0
			CONDITION TMP_3549
		Expression: votingPower = (votingPower * _expTable22) / _ONE_E18
		IRs:
			TMP_3550(uint256) = votingPower_45 * _expTable22_2
			TMP_3551(uint256) = TMP_3550 / _ONE_E18_2
			votingPower_46(uint256) := TMP_3551(uint256)
		IRs:
			votingPower_47(uint256) := ϕ(['votingPower_1', 'votingPower_46'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_3552(uint256) = t_1 & 8388608
			TMP_3553(bool) = TMP_3552 != 0
			CONDITION TMP_3553
		Expression: votingPower = (votingPower * _expTable23) / _ONE_E18
		IRs:
			TMP_3554(uint256) = votingPower_47 * _expTable23_2
			TMP_3555(uint256) = TMP_3554 / _ONE_E18_2
			votingPower_48(uint256) := TMP_3555(uint256)
		IRs:
			votingPower_49(uint256) := ϕ(['votingPower_1', 'votingPower_48'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_3556(uint256) = t_1 & 16777216
			TMP_3557(bool) = TMP_3556 != 0
			CONDITION TMP_3557
		Expression: votingPower = (votingPower * _expTable24) / _ONE_E18
		IRs:
			TMP_3558(uint256) = votingPower_49 * _expTable24_2
			TMP_3559(uint256) = TMP_3558 / _ONE_E18_2
			votingPower_50(uint256) := TMP_3559(uint256)
		IRs:
			votingPower_51(uint256) := ϕ(['votingPower_1', 'votingPower_50'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_3560(uint256) = t_1 & 33554432
			TMP_3561(bool) = TMP_3560 != 0
			CONDITION TMP_3561
		Expression: votingPower = (votingPower * _expTable25) / _ONE_E18
		IRs:
			TMP_3562(uint256) = votingPower_51 * _expTable25_2
			TMP_3563(uint256) = TMP_3562 / _ONE_E18_2
			votingPower_52(uint256) := TMP_3563(uint256)
		IRs:
			votingPower_53(uint256) := ϕ(['votingPower_1', 'votingPower_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_3564(uint256) = t_1 & 67108864
			TMP_3565(bool) = TMP_3564 != 0
			CONDITION TMP_3565
		Expression: votingPower = (votingPower * _expTable26) / _ONE_E18
		IRs:
			TMP_3566(uint256) = votingPower_53 * _expTable26_2
			TMP_3567(uint256) = TMP_3566 / _ONE_E18_2
			votingPower_54(uint256) := TMP_3567(uint256)
		IRs:
			votingPower_55(uint256) := ϕ(['votingPower_1', 'votingPower_54'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_3568(uint256) = t_1 & 134217728
			TMP_3569(bool) = TMP_3568 != 0
			CONDITION TMP_3569
		Expression: votingPower = (votingPower * _expTable27) / _ONE_E18
		IRs:
			TMP_3570(uint256) = votingPower_55 * _expTable27_2
			TMP_3571(uint256) = TMP_3570 / _ONE_E18_2
			votingPower_56(uint256) := TMP_3571(uint256)
		IRs:
			votingPower_57(uint256) := ϕ(['votingPower_56', 'votingPower_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_3572(uint256) = t_1 & 268435456
			TMP_3573(bool) = TMP_3572 != 0
			CONDITION TMP_3573
		Expression: votingPower = (votingPower * _expTable28) / _ONE_E18
		IRs:
			TMP_3574(uint256) = votingPower_57 * _expTable28_2
			TMP_3575(uint256) = TMP_3574 / _ONE_E18_2
			votingPower_58(uint256) := TMP_3575(uint256)
		IRs:
			votingPower_59(uint256) := ϕ(['votingPower_58', 'votingPower_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_3576(uint256) = t_1 & 536870912
			TMP_3577(bool) = TMP_3576 != 0
			CONDITION TMP_3577
		Expression: votingPower = (votingPower * _expTable29) / _ONE_E18
		IRs:
			TMP_3578(uint256) = votingPower_59 * _expTable29_2
			TMP_3579(uint256) = TMP_3578 / _ONE_E18_2
			votingPower_60(uint256) := TMP_3579(uint256)
		IRs:
			votingPower_61(uint256) := ϕ(['votingPower_60', 'votingPower_1'])
		Expression: votingPower
		IRs:
			RETURN votingPower_61
		Expression: timestamp < origin
		IRs:
			TMP_3580(bool) = timestamp_1 < origin_2
			CONDITION TMP_3580
		Expression: timestamp = origin
		IRs:
			timestamp_3(uint256) := origin_2(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_2(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: votingPower
	Function VotingPowerCalculator._balanceAt(uint256,uint256)
		IRs:
			_ONE_E18_3(uint256) := ϕ(['_ONE_E18_0'])
			origin_3(uint256) := ϕ(['origin_0', 'origin_1'])
			_expTable0_3(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_3(uint256) := ϕ(['_expTable1_0', '_expTable1_1'])
			_expTable2_3(uint256) := ϕ(['_expTable2_0', '_expTable2_1'])
			_expTable3_3(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_3(uint256) := ϕ(['_expTable4_0', '_expTable4_1'])
			_expTable5_3(uint256) := ϕ(['_expTable5_0', '_expTable5_1'])
			_expTable6_3(uint256) := ϕ(['_expTable6_0', '_expTable6_1'])
			_expTable7_3(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_3(uint256) := ϕ(['_expTable8_0', '_expTable8_1'])
			_expTable9_3(uint256) := ϕ(['_expTable9_0', '_expTable9_1'])
			_expTable10_3(uint256) := ϕ(['_expTable10_0', '_expTable10_1'])
			_expTable11_3(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_3(uint256) := ϕ(['_expTable12_0', '_expTable12_1'])
			_expTable13_3(uint256) := ϕ(['_expTable13_0', '_expTable13_1'])
			_expTable14_3(uint256) := ϕ(['_expTable14_0', '_expTable14_1'])
			_expTable15_3(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_3(uint256) := ϕ(['_expTable16_0', '_expTable16_1'])
			_expTable17_3(uint256) := ϕ(['_expTable17_0', '_expTable17_1'])
			_expTable18_3(uint256) := ϕ(['_expTable18_0', '_expTable18_1'])
			_expTable19_3(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_3(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_3(uint256) := ϕ(['_expTable21_1', '_expTable21_0'])
			_expTable22_3(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_3(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_3(uint256) := ϕ(['_expTable24_0', '_expTable24_1'])
			_expTable25_3(uint256) := ϕ(['_expTable25_0', '_expTable25_1'])
			_expTable26_3(uint256) := ϕ(['_expTable26_0', '_expTable26_1'])
			_expTable27_3(uint256) := ϕ(['_expTable27_1', '_expTable27_0'])
			_expTable28_3(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_3(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_3581(uint256) = timestamp_4 - origin_3
			t_1(uint256) := TMP_3581(uint256)
		Expression: balance = votingPower
		IRs:
			balance_1(uint256) := votingPower_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_3582(uint256) = t_1 & 1
			TMP_3583(bool) = TMP_3582 != 0
			CONDITION TMP_3583
		Expression: balance = (balance * _ONE_E18) / _expTable0
		IRs:
			TMP_3584(uint256) = balance_1 * _ONE_E18_3
			TMP_3585(uint256) = TMP_3584 / _expTable0_3
			balance_2(uint256) := TMP_3585(uint256)
		IRs:
			balance_3(uint256) := ϕ(['balance_1', 'balance_2'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_3586(uint256) = t_1 & 2
			TMP_3587(bool) = TMP_3586 != 0
			CONDITION TMP_3587
		Expression: balance = (balance * _ONE_E18) / _expTable1
		IRs:
			TMP_3588(uint256) = balance_3 * _ONE_E18_3
			TMP_3589(uint256) = TMP_3588 / _expTable1_3
			balance_4(uint256) := TMP_3589(uint256)
		IRs:
			balance_5(uint256) := ϕ(['balance_1', 'balance_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_3590(uint256) = t_1 & 4
			TMP_3591(bool) = TMP_3590 != 0
			CONDITION TMP_3591
		Expression: balance = (balance * _ONE_E18) / _expTable2
		IRs:
			TMP_3592(uint256) = balance_5 * _ONE_E18_3
			TMP_3593(uint256) = TMP_3592 / _expTable2_3
			balance_6(uint256) := TMP_3593(uint256)
		IRs:
			balance_7(uint256) := ϕ(['balance_6', 'balance_1'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_3594(uint256) = t_1 & 8
			TMP_3595(bool) = TMP_3594 != 0
			CONDITION TMP_3595
		Expression: balance = (balance * _ONE_E18) / _expTable3
		IRs:
			TMP_3596(uint256) = balance_7 * _ONE_E18_3
			TMP_3597(uint256) = TMP_3596 / _expTable3_3
			balance_8(uint256) := TMP_3597(uint256)
		IRs:
			balance_9(uint256) := ϕ(['balance_8', 'balance_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_3598(uint256) = t_1 & 16
			TMP_3599(bool) = TMP_3598 != 0
			CONDITION TMP_3599
		Expression: balance = (balance * _ONE_E18) / _expTable4
		IRs:
			TMP_3600(uint256) = balance_9 * _ONE_E18_3
			TMP_3601(uint256) = TMP_3600 / _expTable4_3
			balance_10(uint256) := TMP_3601(uint256)
		IRs:
			balance_11(uint256) := ϕ(['balance_10', 'balance_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_3602(uint256) = t_1 & 32
			TMP_3603(bool) = TMP_3602 != 0
			CONDITION TMP_3603
		Expression: balance = (balance * _ONE_E18) / _expTable5
		IRs:
			TMP_3604(uint256) = balance_11 * _ONE_E18_3
			TMP_3605(uint256) = TMP_3604 / _expTable5_3
			balance_12(uint256) := TMP_3605(uint256)
		IRs:
			balance_13(uint256) := ϕ(['balance_1', 'balance_12'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_3606(uint256) = t_1 & 64
			TMP_3607(bool) = TMP_3606 != 0
			CONDITION TMP_3607
		Expression: balance = (balance * _ONE_E18) / _expTable6
		IRs:
			TMP_3608(uint256) = balance_13 * _ONE_E18_3
			TMP_3609(uint256) = TMP_3608 / _expTable6_3
			balance_14(uint256) := TMP_3609(uint256)
		IRs:
			balance_15(uint256) := ϕ(['balance_1', 'balance_14'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_3610(uint256) = t_1 & 128
			TMP_3611(bool) = TMP_3610 != 0
			CONDITION TMP_3611
		Expression: balance = (balance * _ONE_E18) / _expTable7
		IRs:
			TMP_3612(uint256) = balance_15 * _ONE_E18_3
			TMP_3613(uint256) = TMP_3612 / _expTable7_3
			balance_16(uint256) := TMP_3613(uint256)
		IRs:
			balance_17(uint256) := ϕ(['balance_1', 'balance_16'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_3614(uint256) = t_1 & 256
			TMP_3615(bool) = TMP_3614 != 0
			CONDITION TMP_3615
		Expression: balance = (balance * _ONE_E18) / _expTable8
		IRs:
			TMP_3616(uint256) = balance_17 * _ONE_E18_3
			TMP_3617(uint256) = TMP_3616 / _expTable8_3
			balance_18(uint256) := TMP_3617(uint256)
		IRs:
			balance_19(uint256) := ϕ(['balance_1', 'balance_18'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_3618(uint256) = t_1 & 512
			TMP_3619(bool) = TMP_3618 != 0
			CONDITION TMP_3619
		Expression: balance = (balance * _ONE_E18) / _expTable9
		IRs:
			TMP_3620(uint256) = balance_19 * _ONE_E18_3
			TMP_3621(uint256) = TMP_3620 / _expTable9_3
			balance_20(uint256) := TMP_3621(uint256)
		IRs:
			balance_21(uint256) := ϕ(['balance_1', 'balance_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_3622(uint256) = t_1 & 1024
			TMP_3623(bool) = TMP_3622 != 0
			CONDITION TMP_3623
		Expression: balance = (balance * _ONE_E18) / _expTable10
		IRs:
			TMP_3624(uint256) = balance_21 * _ONE_E18_3
			TMP_3625(uint256) = TMP_3624 / _expTable10_3
			balance_22(uint256) := TMP_3625(uint256)
		IRs:
			balance_23(uint256) := ϕ(['balance_22', 'balance_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_3626(uint256) = t_1 & 2048
			TMP_3627(bool) = TMP_3626 != 0
			CONDITION TMP_3627
		Expression: balance = (balance * _ONE_E18) / _expTable11
		IRs:
			TMP_3628(uint256) = balance_23 * _ONE_E18_3
			TMP_3629(uint256) = TMP_3628 / _expTable11_3
			balance_24(uint256) := TMP_3629(uint256)
		IRs:
			balance_25(uint256) := ϕ(['balance_24', 'balance_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_3630(uint256) = t_1 & 4096
			TMP_3631(bool) = TMP_3630 != 0
			CONDITION TMP_3631
		Expression: balance = (balance * _ONE_E18) / _expTable12
		IRs:
			TMP_3632(uint256) = balance_25 * _ONE_E18_3
			TMP_3633(uint256) = TMP_3632 / _expTable12_3
			balance_26(uint256) := TMP_3633(uint256)
		IRs:
			balance_27(uint256) := ϕ(['balance_26', 'balance_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_3634(uint256) = t_1 & 8192
			TMP_3635(bool) = TMP_3634 != 0
			CONDITION TMP_3635
		Expression: balance = (balance * _ONE_E18) / _expTable13
		IRs:
			TMP_3636(uint256) = balance_27 * _ONE_E18_3
			TMP_3637(uint256) = TMP_3636 / _expTable13_3
			balance_28(uint256) := TMP_3637(uint256)
		IRs:
			balance_29(uint256) := ϕ(['balance_1', 'balance_28'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_3638(uint256) = t_1 & 16384
			TMP_3639(bool) = TMP_3638 != 0
			CONDITION TMP_3639
		Expression: balance = (balance * _ONE_E18) / _expTable14
		IRs:
			TMP_3640(uint256) = balance_29 * _ONE_E18_3
			TMP_3641(uint256) = TMP_3640 / _expTable14_3
			balance_30(uint256) := TMP_3641(uint256)
		IRs:
			balance_31(uint256) := ϕ(['balance_1', 'balance_30'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_3642(uint256) = t_1 & 32768
			TMP_3643(bool) = TMP_3642 != 0
			CONDITION TMP_3643
		Expression: balance = (balance * _ONE_E18) / _expTable15
		IRs:
			TMP_3644(uint256) = balance_31 * _ONE_E18_3
			TMP_3645(uint256) = TMP_3644 / _expTable15_3
			balance_32(uint256) := TMP_3645(uint256)
		IRs:
			balance_33(uint256) := ϕ(['balance_1', 'balance_32'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_3646(uint256) = t_1 & 65536
			TMP_3647(bool) = TMP_3646 != 0
			CONDITION TMP_3647
		Expression: balance = (balance * _ONE_E18) / _expTable16
		IRs:
			TMP_3648(uint256) = balance_33 * _ONE_E18_3
			TMP_3649(uint256) = TMP_3648 / _expTable16_3
			balance_34(uint256) := TMP_3649(uint256)
		IRs:
			balance_35(uint256) := ϕ(['balance_1', 'balance_34'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_3650(uint256) = t_1 & 131072
			TMP_3651(bool) = TMP_3650 != 0
			CONDITION TMP_3651
		Expression: balance = (balance * _ONE_E18) / _expTable17
		IRs:
			TMP_3652(uint256) = balance_35 * _ONE_E18_3
			TMP_3653(uint256) = TMP_3652 / _expTable17_3
			balance_36(uint256) := TMP_3653(uint256)
		IRs:
			balance_37(uint256) := ϕ(['balance_1', 'balance_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_3654(uint256) = t_1 & 262144
			TMP_3655(bool) = TMP_3654 != 0
			CONDITION TMP_3655
		Expression: balance = (balance * _ONE_E18) / _expTable18
		IRs:
			TMP_3656(uint256) = balance_37 * _ONE_E18_3
			TMP_3657(uint256) = TMP_3656 / _expTable18_3
			balance_38(uint256) := TMP_3657(uint256)
		IRs:
			balance_39(uint256) := ϕ(['balance_38', 'balance_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_3658(uint256) = t_1 & 524288
			TMP_3659(bool) = TMP_3658 != 0
			CONDITION TMP_3659
		Expression: balance = (balance * _ONE_E18) / _expTable19
		IRs:
			TMP_3660(uint256) = balance_39 * _ONE_E18_3
			TMP_3661(uint256) = TMP_3660 / _expTable19_3
			balance_40(uint256) := TMP_3661(uint256)
		IRs:
			balance_41(uint256) := ϕ(['balance_40', 'balance_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_3662(uint256) = t_1 & 1048576
			TMP_3663(bool) = TMP_3662 != 0
			CONDITION TMP_3663
		Expression: balance = (balance * _ONE_E18) / _expTable20
		IRs:
			TMP_3664(uint256) = balance_41 * _ONE_E18_3
			TMP_3665(uint256) = TMP_3664 / _expTable20_3
			balance_42(uint256) := TMP_3665(uint256)
		IRs:
			balance_43(uint256) := ϕ(['balance_42', 'balance_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_3666(uint256) = t_1 & 2097152
			TMP_3667(bool) = TMP_3666 != 0
			CONDITION TMP_3667
		Expression: balance = (balance * _ONE_E18) / _expTable21
		IRs:
			TMP_3668(uint256) = balance_43 * _ONE_E18_3
			TMP_3669(uint256) = TMP_3668 / _expTable21_3
			balance_44(uint256) := TMP_3669(uint256)
		IRs:
			balance_45(uint256) := ϕ(['balance_1', 'balance_44'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_3670(uint256) = t_1 & 4194304
			TMP_3671(bool) = TMP_3670 != 0
			CONDITION TMP_3671
		Expression: balance = (balance * _ONE_E18) / _expTable22
		IRs:
			TMP_3672(uint256) = balance_45 * _ONE_E18_3
			TMP_3673(uint256) = TMP_3672 / _expTable22_3
			balance_46(uint256) := TMP_3673(uint256)
		IRs:
			balance_47(uint256) := ϕ(['balance_1', 'balance_46'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_3674(uint256) = t_1 & 8388608
			TMP_3675(bool) = TMP_3674 != 0
			CONDITION TMP_3675
		Expression: balance = (balance * _ONE_E18) / _expTable23
		IRs:
			TMP_3676(uint256) = balance_47 * _ONE_E18_3
			TMP_3677(uint256) = TMP_3676 / _expTable23_3
			balance_48(uint256) := TMP_3677(uint256)
		IRs:
			balance_49(uint256) := ϕ(['balance_1', 'balance_48'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_3678(uint256) = t_1 & 16777216
			TMP_3679(bool) = TMP_3678 != 0
			CONDITION TMP_3679
		Expression: balance = (balance * _ONE_E18) / _expTable24
		IRs:
			TMP_3680(uint256) = balance_49 * _ONE_E18_3
			TMP_3681(uint256) = TMP_3680 / _expTable24_3
			balance_50(uint256) := TMP_3681(uint256)
		IRs:
			balance_51(uint256) := ϕ(['balance_1', 'balance_50'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_3682(uint256) = t_1 & 33554432
			TMP_3683(bool) = TMP_3682 != 0
			CONDITION TMP_3683
		Expression: balance = (balance * _ONE_E18) / _expTable25
		IRs:
			TMP_3684(uint256) = balance_51 * _ONE_E18_3
			TMP_3685(uint256) = TMP_3684 / _expTable25_3
			balance_52(uint256) := TMP_3685(uint256)
		IRs:
			balance_53(uint256) := ϕ(['balance_1', 'balance_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_3686(uint256) = t_1 & 67108864
			TMP_3687(bool) = TMP_3686 != 0
			CONDITION TMP_3687
		Expression: balance = (balance * _ONE_E18) / _expTable26
		IRs:
			TMP_3688(uint256) = balance_53 * _ONE_E18_3
			TMP_3689(uint256) = TMP_3688 / _expTable26_3
			balance_54(uint256) := TMP_3689(uint256)
		IRs:
			balance_55(uint256) := ϕ(['balance_54', 'balance_1'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_3690(uint256) = t_1 & 134217728
			TMP_3691(bool) = TMP_3690 != 0
			CONDITION TMP_3691
		Expression: balance = (balance * _ONE_E18) / _expTable27
		IRs:
			TMP_3692(uint256) = balance_55 * _ONE_E18_3
			TMP_3693(uint256) = TMP_3692 / _expTable27_3
			balance_56(uint256) := TMP_3693(uint256)
		IRs:
			balance_57(uint256) := ϕ(['balance_56', 'balance_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_3694(uint256) = t_1 & 268435456
			TMP_3695(bool) = TMP_3694 != 0
			CONDITION TMP_3695
		Expression: balance = (balance * _ONE_E18) / _expTable28
		IRs:
			TMP_3696(uint256) = balance_57 * _ONE_E18_3
			TMP_3697(uint256) = TMP_3696 / _expTable28_3
			balance_58(uint256) := TMP_3697(uint256)
		IRs:
			balance_59(uint256) := ϕ(['balance_58', 'balance_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_3698(uint256) = t_1 & 536870912
			TMP_3699(bool) = TMP_3698 != 0
			CONDITION TMP_3699
		Expression: balance = (balance * _ONE_E18) / _expTable29
		IRs:
			TMP_3700(uint256) = balance_59 * _ONE_E18_3
			TMP_3701(uint256) = TMP_3700 / _expTable29_3
			balance_60(uint256) := TMP_3701(uint256)
		IRs:
			balance_61(uint256) := ϕ(['balance_1', 'balance_60'])
		Expression: balance
		IRs:
			RETURN balance_61
		Expression: timestamp < origin
		IRs:
			TMP_3702(bool) = timestamp_1 < origin_3
			CONDITION TMP_3702
		Expression: timestamp = origin
		IRs:
			timestamp_3(uint256) := origin_3(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_2(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: balance
	Function FarmingDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		Expression: TokenizedDelegationPod(name_,symbol_,token_,maxSharePods_,sharePodGasLimit_)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)(name__1,symbol__1,token__1,maxSharePods__1,sharePodGasLimit__1)
	Function FarmingDelegationPod.register(string,string)
		IRs:
			_MAX_FARM_REWARDS_1(uint256) := ϕ(['_MAX_FARM_REWARDS_0', '_MAX_FARM_REWARDS_2'])
		Expression: shareToken = super.register(name,symbol)
		IRs:
			TMP_3704(IDelegatedShare) = INTERNAL_CALL, TokenizedDelegationPod.register(string,string)(name_1,symbol_1)
			shareToken_1(IDelegatedShare) := TMP_3704(IDelegatedShare)
		Expression: farm = new MultiFarmingPod(shareToken,_MAX_FARM_REWARDS)
		IRs:
			TMP_3706(MultiFarmingPod) = new MultiFarmingPod(shareToken_1,_MAX_FARM_REWARDS_2) 
			farm_1(MultiFarmingPod) := TMP_3706(MultiFarmingPod)
		Expression: farm.transferOwnership(msg.sender)
		IRs:
			HIGH_LEVEL_CALL, dest:farm_1(MultiFarmingPod), function:transferOwnership, arguments:['msg.sender']  
		Expression: defaultFarms[msg.sender] = address(farm)
		IRs:
			REF_961(address) -> defaultFarms_0[msg.sender]
			TMP_3708 = CONVERT farm_1 to address
			defaultFarms_1(mapping(address => address)) := ϕ(['defaultFarms_0'])
			REF_961(address) (->defaultFarms_1) := TMP_3708(address)
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function FarmingDelegationPod.delegate(address)
		IRs:
			defaultFarms_2(mapping(address => address)) := ϕ(['defaultFarms_4', 'defaultFarms_0', 'defaultFarms_3', 'defaultFarms_1'])
			registration_1(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_11', 'registration_13', 'registration_0', 'registration_6', 'registration_8', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_3'])
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.delegate(address)(delegatee_1)
			registration_2(mapping(address => IDelegatedShare)) := ϕ(['registration_7'])
		Expression: defaultFarm = defaultFarms[delegatee]
		IRs:
			REF_962(address) -> defaultFarms_3[delegatee_1]
			defaultFarm_1(address) := REF_962(address)
		Expression: defaultFarm != address(0)
		IRs:
			TMP_3710 = CONVERT 0 to address
			TMP_3711(bool) = defaultFarm_1 != TMP_3710
			CONDITION TMP_3711
		Expression: registration[delegatee].addDefaultFarmIfNeeded(msg.sender,defaultFarm)
		IRs:
			REF_963(IDelegatedShare) -> registration_2[delegatee_1]
			HIGH_LEVEL_CALL, dest:REF_963(IDelegatedShare), function:addDefaultFarmIfNeeded, arguments:['msg.sender', 'defaultFarm_1']  
			registration_3(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_3', 'registration_11', 'registration_13', 'registration_6', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_8'])
	Function FarmingDelegationPod.setDefaultFarm(address)
		IRs:
			registration_4(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_11', 'registration_13', 'registration_0', 'registration_6', 'registration_8', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_3'])
		Expression: farm != address(0) && Pod(farm).token() != registration[msg.sender]
		IRs:
			TMP_3713 = CONVERT 0 to address
			TMP_3714(bool) = farm_1 != TMP_3713
			TMP_3715 = CONVERT farm_1 to Pod
			TMP_3716(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_3715(Pod), function:token, arguments:[]  
			registration_6(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_3', 'registration_11', 'registration_13', 'registration_6', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_5', 'registration_8'])
			REF_966(IDelegatedShare) -> registration_6[msg.sender]
			TMP_3717(bool) = TMP_3716 != REF_966
			TMP_3718(bool) = TMP_3714 && TMP_3717
			CONDITION TMP_3718
		Expression: revert DefaultFarmTokenMismatch()()
		IRs:
			TMP_3719(None) = SOLIDITY_CALL revert DefaultFarmTokenMismatch()()
		Expression: defaultFarms[msg.sender] = farm
		IRs:
			REF_967(address) -> defaultFarms_3[msg.sender]
			defaultFarms_4(mapping(address => address)) := ϕ(['defaultFarms_3'])
			REF_967(address) (->defaultFarms_4) := farm_1(address)
		Expression: DefaultFarmSet(farm)
		IRs:
			Emit DefaultFarmSet(farm_1)
		Expression: onlyRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyRegistered()()
			registration_5(mapping(address => IDelegatedShare)) := ϕ(['registration_13'])
	Function TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		Expression: maxSharePods = maxSharePods_
		IRs:
			maxSharePods_1(uint256) := maxSharePods__1(uint256)
		Expression: sharePodGasLimit = sharePodGasLimit_
		IRs:
			sharePodGasLimit_1(uint256) := sharePodGasLimit__1(uint256)
		Expression: DelegationPod(name_,symbol_,token_)
		IRs:
			INTERNAL_CALL, DelegationPod.constructor(string,string,IERC20Pods)(name__1,symbol__1,token__1)
	Function TokenizedDelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			registration_7(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_11', 'registration_13', 'registration_0', 'registration_6', 'registration_8', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_3'])
		Expression: delegatee != address(0) && address(registration[delegatee]) == address(0)
		IRs:
			TMP_3723 = CONVERT 0 to address
			TMP_3724(bool) = delegatee_1 != TMP_3723
			REF_968(IDelegatedShare) -> registration_7[delegatee_1]
			TMP_3725 = CONVERT REF_968 to address
			TMP_3726 = CONVERT 0 to address
			TMP_3727(bool) = TMP_3725 == TMP_3726
			TMP_3728(bool) = TMP_3724 && TMP_3727
			CONDITION TMP_3728
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_3729(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, DelegationPod.delegate(address)(delegatee_1)
	Function TokenizedDelegationPod.register(string,string)
		IRs:
			name_1(string) := ϕ(['name_1'])
			symbol_1(string) := ϕ(['symbol_1'])
			maxSharePods_2(uint256) := ϕ(['maxSharePods_0', 'maxSharePods_1', 'maxSharePods_3'])
			sharePodGasLimit_2(uint256) := ϕ(['sharePodGasLimit_3', 'sharePodGasLimit_0', 'sharePodGasLimit_1'])
		Expression: shareToken = new DelegatedShare(name,symbol,maxSharePods,sharePodGasLimit)
		IRs:
			TMP_3732(DelegatedShare) = new DelegatedShare(name_1,symbol_1,maxSharePods_3,sharePodGasLimit_3) 
			shareToken_1(IDelegatedShare) := TMP_3732(DelegatedShare)
		Expression: registration[msg.sender] = shareToken
		IRs:
			REF_969(IDelegatedShare) -> registration_7[msg.sender]
			registration_8(mapping(address => IDelegatedShare)) := ϕ(['registration_7'])
			REF_969(IDelegatedShare) (->registration_8) := shareToken_1(IDelegatedShare)
		Expression: RegisterDelegatee(msg.sender)
		IRs:
			Emit RegisterDelegatee(msg.sender)
		Expression: onlyNotRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyNotRegistered()()
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'msg.sender'])
			to_1(address) := ϕ(['to_1', 'msg.sender'])
			fromDelegatee_1(address) := ϕ(['TMP_3753', 'prevDelegatee_1', 'REF_977'])
			toDelegatee_1(address) := ϕ(['delegatee_1', 'REF_978', 'TMP_3754'])
			amount_1(uint256) := ϕ(['amount_1', 'balance_1'])
			registration_9(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_11', 'registration_13', 'registration_0', 'registration_6', 'registration_8', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_3'])
		Expression: super._updateBalances(from,to,fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,fromDelegatee_1,toDelegatee_1,amount_1)
		Expression: fromDelegatee != address(0)
		IRs:
			TMP_3736 = CONVERT 0 to address
			TMP_3737(bool) = fromDelegatee_1 != TMP_3736
			CONDITION TMP_3737
		Expression: registration[fromDelegatee].burn(from,amount)
		IRs:
			REF_970(IDelegatedShare) -> registration_10[fromDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_970(IDelegatedShare), function:burn, arguments:['from_1', 'amount_1']  
			registration_11(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_3', 'registration_11', 'registration_13', 'registration_6', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_8'])
		Expression: toDelegatee != address(0)
		IRs:
			TMP_3739 = CONVERT 0 to address
			TMP_3740(bool) = toDelegatee_1 != TMP_3739
			CONDITION TMP_3740
		Expression: registration[toDelegatee].mint(to,amount)
		IRs:
			REF_972(IDelegatedShare) -> registration_11[toDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_972(IDelegatedShare), function:mint, arguments:['to_1', 'amount_1']  
			registration_12(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_3', 'registration_11', 'registration_13', 'registration_6', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_8'])
	Function DelegationPod.constructor(string,string,IERC20Pods)
		Expression: ERC20(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name__1,symbol__1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function DelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			delegated_1(mapping(address => address)) := ϕ(['delegated_4', 'delegated_1', 'delegated_2', 'delegated_0'])
			token_1(IERC20Pods) := ϕ(['token_3', 'token_0', 'token_2'])
		Expression: prevDelegatee = delegated[msg.sender]
		IRs:
			REF_974(address) -> delegated_1[msg.sender]
			prevDelegatee_1(address) := REF_974(address)
		Expression: prevDelegatee != delegatee
		IRs:
			TMP_3744(bool) = prevDelegatee_1 != delegatee_1
			CONDITION TMP_3744
		Expression: delegated[msg.sender] = delegatee
		IRs:
			REF_975(address) -> delegated_1[msg.sender]
			delegated_2(mapping(address => address)) := ϕ(['delegated_1'])
			REF_975(address) (->delegated_2) := delegatee_1(address)
		Expression: Delegated(msg.sender,delegatee)
		IRs:
			Emit Delegated(msg.sender,delegatee_1)
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_3746 = CONVERT token_1 to IERC20Pods
			TMP_3747 = CONVERT this to address
			TMP_3748(uint256) = HIGH_LEVEL_CALL, dest:TMP_3746(IERC20Pods), function:podBalanceOf, arguments:['TMP_3747', 'msg.sender']  
			token_2(IERC20Pods) := ϕ(['token_3', 'token_1', 'token_2'])
			balance_1(uint256) := TMP_3748(uint256)
		Expression: balance > 0
		IRs:
			TMP_3749(bool) = balance_1 > 0
			CONDITION TMP_3749
		Expression: _updateBalances(msg.sender,msg.sender,prevDelegatee,delegatee,balance)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(msg.sender,msg.sender,prevDelegatee_1,delegatee_1,balance_1)
	Function DelegationPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			delegated_3(mapping(address => address)) := ϕ(['delegated_4', 'delegated_1', 'delegated_2', 'delegated_0'])
		Expression: to == address(0)
		IRs:
			TMP_3751 = CONVERT 0 to address
			TMP_3752(bool) = to_1 == TMP_3751
			CONDITION TMP_3752
		Expression: _updateBalances(from,to,address(0),address(0),amount)
		IRs:
			TMP_3753 = CONVERT 0 to address
			TMP_3754 = CONVERT 0 to address
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,TMP_3753,TMP_3754,amount_1)
		Expression: _updateBalances(from,to,delegated[from],delegated[to],amount)
		IRs:
			REF_977(address) -> delegated_3[from_1]
			REF_978(address) -> delegated_3[to_1]
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,REF_977,REF_978,amount_1)
	Function DelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			fromDelegatee_1(address) := ϕ(['fromDelegatee_1'])
			toDelegatee_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: fromDelegatee != toDelegatee && amount > 0
		IRs:
			TMP_3757(bool) = fromDelegatee_1 != toDelegatee_1
			TMP_3758(bool) = amount_1 > 0
			TMP_3759(bool) = TMP_3757 && TMP_3758
			CONDITION TMP_3759
		Expression: fromDelegatee == address(0)
		IRs:
			TMP_3760 = CONVERT 0 to address
			TMP_3761(bool) = fromDelegatee_1 == TMP_3760
			CONDITION TMP_3761
		Expression: _mint(toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(toDelegatee_1,amount_1)
		Expression: toDelegatee == address(0)
		IRs:
			TMP_3763 = CONVERT 0 to address
			TMP_3764(bool) = toDelegatee_1 == TMP_3763
			CONDITION TMP_3764
		Expression: _burn(fromDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(fromDelegatee_1,amount_1)
		Expression: _transfer(fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(fromDelegatee_1,toDelegatee_1,amount_1)
	Function DelegationPod.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_3767(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_3768(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_3769(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_3770(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_3771(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_0', '_balances_5', '_balances_1'])
		Expression: _balances[account]
		IRs:
			REF_979(uint256) -> _balances_1[account_1]
			RETURN REF_979
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_3772(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_3772(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1', '_allowances_2', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_980(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_981(uint256) -> REF_980[spender_1]
			RETURN REF_981
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_3774(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_3774(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_3776(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_3776(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_3779(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_3779(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_3780(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_3781(uint256) = TMP_3780 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_3781)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_3783(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_3783(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_3784(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_3784(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_3785(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_3786(None) = SOLIDITY_CALL require(bool,string)(TMP_3785,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_3787(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_3787)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1', 'fromDelegatee_1'])
			to_1(address) := ϕ(['to_1', 'toDelegatee_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_0', '_balances_5', '_balances_1'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_3789 = CONVERT 0 to address
			TMP_3790(bool) = from_1 != TMP_3789
			TMP_3791(None) = SOLIDITY_CALL require(bool,string)(TMP_3790,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_3792 = CONVERT 0 to address
			TMP_3793(bool) = to_1 != TMP_3792
			TMP_3794(None) = SOLIDITY_CALL require(bool,string)(TMP_3793,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_982(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_982(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_3796(bool) = fromBalance_1 >= amount_1
			TMP_3797(None) = SOLIDITY_CALL require(bool,string)(TMP_3796,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_983(uint256) -> _balances_3[from_1]
			TMP_3798(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_983(uint256) (->_balances_4) := TMP_3798(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_984(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_984(-> _balances_5) = REF_984 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_0', '_balances_5', '_balances_1'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_3801 = CONVERT 0 to address
			TMP_3802(bool) = account_1 != TMP_3801
			TMP_3803(None) = SOLIDITY_CALL require(bool,string)(TMP_3802,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_3804 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_3804,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_985(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_985(-> _balances_8) = REF_985 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_3806 = CONVERT 0 to address
			Emit Transfer(TMP_3806,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_3808 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_3808,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['fromDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_8', '_balances_11', '_balances_0', '_balances_5', '_balances_1'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_3810 = CONVERT 0 to address
			TMP_3811(bool) = account_1 != TMP_3810
			TMP_3812(None) = SOLIDITY_CALL require(bool,string)(TMP_3811,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_3813 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_3813,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_986(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_986(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_3815(bool) = accountBalance_1 >= amount_1
			TMP_3816(None) = SOLIDITY_CALL require(bool,string)(TMP_3815,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_987(uint256) -> _balances_10[account_1]
			TMP_3817(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_987(uint256) (->_balances_11) := TMP_3817(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_3818 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_3818,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_3820 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_3820,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['amount_1', 'TMP_3781', 'TMP_3787', 'TMP_3835'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_3822 = CONVERT 0 to address
			TMP_3823(bool) = owner_1 != TMP_3822
			TMP_3824(None) = SOLIDITY_CALL require(bool,string)(TMP_3823,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_3825 = CONVERT 0 to address
			TMP_3826(bool) = spender_1 != TMP_3825
			TMP_3827(None) = SOLIDITY_CALL require(bool,string)(TMP_3826,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_988(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_989(uint256) -> REF_988[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_989(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_3829(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_3829(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_3831(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_3832(bool) = currentAllowance_1 != TMP_3831
			CONDITION TMP_3832
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_3833(bool) = currentAllowance_1 >= amount_1
			TMP_3834(None) = SOLIDITY_CALL require(bool,string)(TMP_3833,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_3835(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_3835)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_3804'])
			to_1(address) := ϕ(['TMP_3813', 'account_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'TMP_3808', 'from_1'])
			to_1(address) := ϕ(['TMP_3820', 'account_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_3(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
	Function IFarmingDelegationPod.setDefaultFarm(address)
	Function PowerPod.constructor(string,string,ISt1inch)
		IRs:
			name__1(string) := ϕ(['name_1'])
			symbol__1(string) := ϕ(['symbol_1'])
			st1inch_1(ISt1inch) := ϕ(['st1inch_1'])
			_MAX_SHARE_PODS_1(uint256) := ϕ(['_MAX_SHARE_PODS_0', '_MAX_SHARE_PODS_2'])
			_SHARE_POD_GAS_LIMIT_1(uint256) := ϕ(['_SHARE_POD_GAS_LIMIT_2', '_SHARE_POD_GAS_LIMIT_0'])
		Expression: FarmingDelegationPod(name_,symbol_,st1inch,_MAX_SHARE_PODS,_SHARE_POD_GAS_LIMIT)
		IRs:
			INTERNAL_CALL, FarmingDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)(name__1,symbol__1,st1inch_1,_MAX_SHARE_PODS_1,_SHARE_POD_GAS_LIMIT_1)
		Expression: VotingPowerCalculator(st1inch.expBase(),st1inch.origin())
		IRs:
			TMP_3840(uint256) = HIGH_LEVEL_CALL, dest:st1inch_1(ISt1inch), function:expBase, arguments:[]  
			TMP_3841(uint256) = HIGH_LEVEL_CALL, dest:st1inch_1(ISt1inch), function:origin, arguments:[]  
			INTERNAL_CALL, VotingPowerCalculator.constructor(uint256,uint256)(TMP_3840,TMP_3841)
	Function PowerPod.votingPowerOf(address)
		Expression: _votingPowerAt(balanceOf(account),block.timestamp)
		IRs:
			TMP_3843(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			TMP_3844(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(TMP_3843,block.timestamp)
			RETURN TMP_3844
	Function PowerPod.slitherConstructorConstantVariables()
		Expression: _MAX_SHARE_PODS = 3
		Expression: _SHARE_POD_GAS_LIMIT = 140_000
	Modifier TokenizedDelegationPod.onlyRegistered()
ENTRY_POINT
		IRs:
			registration_13(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_11', 'registration_13', 'registration_0', 'registration_6', 'registration_8', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_3'])
IF address(registration[msg.sender]) == address(0)
		Expression: address(registration[msg.sender]) == address(0)
		IRs:
			REF_992(IDelegatedShare) -> registration_13[msg.sender]
			TMP_3845 = CONVERT REF_992 to address
			TMP_3846 = CONVERT 0 to address
			TMP_3847(bool) = TMP_3845 == TMP_3846
			CONDITION TMP_3847
EXPRESSION revert NotRegisteredDelegatee()()
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_3848(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
END_IF
_
	Modifier TokenizedDelegationPod.onlyNotRegistered()
ENTRY_POINT
		IRs:
			registration_14(mapping(address => IDelegatedShare)) := ϕ(['registration_2', 'registration_11', 'registration_13', 'registration_0', 'registration_6', 'registration_8', 'registration_12', 'registration_14', 'registration_10', 'registration_7', 'registration_3'])
IF address(registration[msg.sender]) != address(0)
		Expression: address(registration[msg.sender]) != address(0)
		IRs:
			REF_993(IDelegatedShare) -> registration_14[msg.sender]
			TMP_3849 = CONVERT REF_993 to address
			TMP_3850 = CONVERT 0 to address
			TMP_3851(bool) = TMP_3849 != TMP_3850
			CONDITION TMP_3851
EXPRESSION revert AlreadyRegistered()()
		Expression: revert AlreadyRegistered()()
		IRs:
			TMP_3852(None) = SOLIDITY_CALL revert AlreadyRegistered()()
END_IF
_
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_4(IERC20Pods) := ϕ(['token_3', 'token_0', 'token_2'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_3853 = CONVERT token_4 to address
			TMP_3854(bool) = msg.sender != TMP_3853
			CONDITION TMP_3854
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_3855(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract Settlement
	Function FeeBankCharger.constructor(IERC20)
		Expression: feeBank = new FeeBank(this,token,msg.sender)
		IRs:
			TMP_3857(FeeBank) = new FeeBank(this,token_1,msg.sender) 
			feeBank_1(IFeeBank) := TMP_3857(FeeBank)
	Function FeeBankCharger.availableCredit(address)
		IRs:
			_creditAllowance_1(mapping(address => uint256)) := ϕ(['_creditAllowance_0', '_creditAllowance_7', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9'])
		Expression: _creditAllowance[account]
		IRs:
			REF_994(uint256) -> _creditAllowance_1[account_1]
			RETURN REF_994
	Function FeeBankCharger.increaseAvailableCredit(address,uint256)
		IRs:
			_creditAllowance_2(mapping(address => uint256)) := ϕ(['_creditAllowance_0', '_creditAllowance_7', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9'])
		Expression: allowance = _creditAllowance[account]
		IRs:
			REF_995(uint256) -> _creditAllowance_3[account_1]
			allowance_1(uint256) := REF_995(uint256)
		Expression: allowance += amount
		IRs:
			allowance_2(uint256) = allowance_1 + amount_1
		Expression: _creditAllowance[account] = allowance
		IRs:
			REF_996(uint256) -> _creditAllowance_3[account_1]
			_creditAllowance_4(mapping(address => uint256)) := ϕ(['_creditAllowance_3'])
			REF_996(uint256) (->_creditAllowance_4) := allowance_2(uint256)
		Expression: onlyFeeBank()
		IRs:
			MODIFIER_CALL, FeeBankCharger.onlyFeeBank()()
		Expression: allowance
		IRs:
			RETURN allowance_2
	Function FeeBankCharger.decreaseAvailableCredit(address,uint256)
		IRs:
			_creditAllowance_5(mapping(address => uint256)) := ϕ(['_creditAllowance_0', '_creditAllowance_7', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9'])
		Expression: allowance = _creditAllowance[account]
		IRs:
			REF_997(uint256) -> _creditAllowance_6[account_1]
			allowance_1(uint256) := REF_997(uint256)
		Expression: allowance -= amount
		IRs:
			allowance_2(uint256) = allowance_1 (c)- amount_1
		Expression: _creditAllowance[account] = allowance
		IRs:
			REF_998(uint256) -> _creditAllowance_6[account_1]
			_creditAllowance_7(mapping(address => uint256)) := ϕ(['_creditAllowance_6'])
			REF_998(uint256) (->_creditAllowance_7) := allowance_2(uint256)
		Expression: onlyFeeBank()
		IRs:
			MODIFIER_CALL, FeeBankCharger.onlyFeeBank()()
		Expression: allowance
		IRs:
			RETURN allowance_2
	Function FeeBankCharger._chargeFee(address,uint256)
		IRs:
			account_1(address) := ϕ(['TMP_3887'])
			fee_1(uint256) := ϕ(['REF_1012'])
			_creditAllowance_8(mapping(address => uint256)) := ϕ(['_creditAllowance_0', '_creditAllowance_7', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9'])
		Expression: fee > 0
		IRs:
			TMP_3860(bool) = fee_1 > 0
			CONDITION TMP_3860
		Expression: currentAllowance = _creditAllowance[account]
		IRs:
			REF_999(uint256) -> _creditAllowance_8[account_1]
			currentAllowance_1(uint256) := REF_999(uint256)
		Expression: currentAllowance < fee
		IRs:
			TMP_3861(bool) = currentAllowance_1 < fee_1
			CONDITION TMP_3861
		Expression: revert NotEnoughCredit()()
		IRs:
			TMP_3862(None) = SOLIDITY_CALL revert NotEnoughCredit()()
		Expression: _creditAllowance[account] = currentAllowance - fee
		IRs:
			REF_1000(uint256) -> _creditAllowance_8[account_1]
			TMP_3863(uint256) = currentAllowance_1 - fee_1
			_creditAllowance_9(mapping(address => uint256)) := ϕ(['_creditAllowance_8'])
			REF_1000(uint256) (->_creditAllowance_9) := TMP_3863(uint256)
	Function IFeeBankCharger.feeBank()
	Function IFeeBankCharger.availableCredit(address)
	Function IFeeBankCharger.increaseAvailableCredit(address,uint256)
	Function IFeeBankCharger.decreaseAvailableCredit(address,uint256)
	Function ISettlement.settleOrders(bytes)
	Function IInteractionNotificationReceiver.fillOrderInteraction(address,uint256,uint256,bytes)
	Function Settlement.constructor(IOrderMixin,IERC20)
		IRs:
			limitOrderProtocol_1(IOrderMixin) := ϕ(['limitOrderProtocol_1'])
			token_1(IERC20) := ϕ(['token_1'])
		Expression: _limitOrderProtocol = limitOrderProtocol
		IRs:
			_limitOrderProtocol_1(IOrderMixin) := limitOrderProtocol_1(IOrderMixin)
		Expression: FeeBankCharger(token)
		IRs:
			INTERNAL_CALL, FeeBankCharger.constructor(IERC20)(token_1)
	Function Settlement.settleOrders(bytes)
		Expression: _settleOrder(data,msg.sender,0,new bytes(0))
		IRs:
			TMP_3866 = new bytes(0)
			INTERNAL_CALL, Settlement._settleOrder(bytes,address,uint256,bytes)(data_1,msg.sender,0,TMP_3866)
	Function Settlement.fillOrderInteraction(address,uint256,uint256,bytes)
		IRs:
			_FINALIZE_INTERACTION_1(bytes1) := ϕ(['_FINALIZE_INTERACTION_3', '_FINALIZE_INTERACTION_0'])
			_BASE_POINTS_1(uint256) := ϕ(['_BASE_POINTS_0', '_BASE_POINTS_3'])
			_limitOrderProtocol_2(IOrderMixin) := ϕ(['_limitOrderProtocol_7', '_limitOrderProtocol_6', '_limitOrderProtocol_1', '_limitOrderProtocol_0'])
		Expression: (suffix,tokensAndAmounts,interaction) = interactiveData.decodeSuffix()
		IRs:
			TUPLE_69(DynamicSuffix.Data,bytes,bytes) = LIBRARY_CALL, dest:DynamicSuffix, function:DynamicSuffix.decodeSuffix(bytes), arguments:['interactiveData_1'] 
			suffix_1(DynamicSuffix.Data)= UNPACK TUPLE_69 index: 0 
			tokensAndAmounts_1(bytes)= UNPACK TUPLE_69 index: 1 
			interaction_1(bytes)= UNPACK TUPLE_69 index: 2 
		Expression: token = IERC20(suffix.token.get())
		IRs:
			REF_1002(Address) -> suffix_1.token
			TMP_3868(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1002'] 
			TMP_3869 = CONVERT TMP_3868 to IERC20
			token_1(IERC20) := TMP_3869(IERC20)
		Ex.dst__settleOrder_asm_1_memcpypression: result = takingAmount * (_BASE_POINTS + suffix.rateBump) / _BASE_POINTS
		IRs:
			REF_1004(uint256) -> suffix_1.rateBump
			TMP_3870(uint256) = _BASE_POINTS_3 (c)+ REF_1004
			TMP_3871(uint256) = takingAmount_1 (c)* TMP_3870
			TMP_3872(uint256) = TMP_3871 (c)/ _BASE_POINTS_3
			result_1(uint256) := TMP_3872(uint256)
		Expression: takingFee = result * suffix.takingFee.ratio() / TakingFee._TAKING_FEE_BASE
		IRs:
			REF_1005(TakingFee.Data) -> suffix_1.takingFee
			TMP_3873(uint256) = LIBRARY_CALL, dest:TakingFee, function:TakingFee.ratio(TakingFee.Data), arguments:['REF_1005'] 
			TMP_3874(uint256) = result_1 (c)* TMP_3873
			REF_1007(uint256) -> TakingFee._TAKING_FEE_BASE
			TMP_3875(uint256) = TMP_3874 (c)/ REF_1007
			takingFee_1(uint256) := TMP_3875(uint256)
		Expression: allTokensAndAmounts = new bytes(tokensAndAmounts.length + 0x40)
		IRs:
			REF_1008 -> LENGTH tokensAndAmounts_1
			TMP_3877(uint256) = REF_1008 (c)+ 64
			TMP_3878 = new bytes(TMP_3877)
			allTokensAndAmounts_1(bytes) := TMP_3878(bytes)
		Expression: ptr_fillOrderInteraction_asm_0 = allTokensAndAmounts + 0x20
		IRs:
			TMP_3879(bytes) = allTokensAndAmounts_1 + 32
			ptr_fillOrderInteraction_asm_0_1(uint256) := TMP_3879(bytes)
		Expression: calldatacopy(uint256,uint256,uint256)(ptr_fillOrderInteraction_asm_0,tokensAndAmounts,tokensAndAmounts)
		IRs:
			TMP_3880(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(ptr_fillOrderInteraction_asm_0_1,tokensAndAmounts_1,tokensAndAmounts_1)
		Expression: ptr_fillOrderInteraction_asm_0 = ptr_fillOrderInteraction_asm_0 + tokensAndAmounts
		IRs:
			TMP_3881(uint256) = ptr_fillOrderInteraction_asm_0_1 + tokensAndAmounts_1
			ptr_fillOrderInteraction_asm_0_2(uint256) := TMP_3881(uint256)
		Expression: mstore(uint256,uint256)(ptr_fillOrderInteraction_asm_0,token)
		IRs:
			TMP_3882(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_fillOrderInteraction_asm_0_2,token_1)
		Expression: mstore(uint256,uint256)(ptr_fillOrderInteraction_asm_0 + 0x20,result + takingFee)
		IRs:
			TMP_3883(uint256) = ptr_fillOrderInteraction_asm_0_2 + 32
			TMP_3884(uint256) = result_1 + takingFee_1
			TMP_3885(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3883,TMP_3884)
		Expression: interactiveData[0] == _FINALIZE_INTERACTION
		IRs:
			REF_1009(None) -> interactiveData_1[0]
			TMP_3886(bool) = REF_1009 == _FINALIZE_INTERACTION_3
			CONDITION TMP_3886
		Expression: _chargeFee(suffix.resolver.get(),suffix.totalFee)
		IRs:
			REF_1010(Address) -> suffix_1.resolver
			TMP_3887(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1010'] 
			REF_1012(uint256) -> suffix_1.totalFee
			INTERNAL_CALL, FeeBankCharger._chargeFee(address,uint256)(TMP_3887,REF_1012)
		Expression: target = address(bytes20(interaction))
		IRs:
			TMP_3889 = CONVERT interaction_1 to bytes20
			TMP_3890 = CONVERT TMP_3889 to address
			target_1(address) := TMP_3890(address)
		Expression: data = interaction
		IRs:
			data_1(bytes) := interaction_1(bytes)
		Expression: IResolver(target).resolveOrders(suffix.resolver.get(),allTokensAndAmounts,data)
		IRs:
			TMP_3891 = CONVERT target_1 to IResolver
			REF_1014(Address) -> suffix_1.resolver
			TMP_3892(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1014'] 
			HIGH_LEVEL_CALL, dest:TMP_3891(IResolver), function:resolveOrders, arguments:['TMP_3892', 'allTokensAndAmounts_1', 'data_1']  
			_limitOrderProtocol_6(IOrderMixin) := ϕ(['_limitOrderProtocol_5', '_limitOrderProtocol_7', '_limitOrderProtocol_6', '_limitOrderProtocol_1'])
		Expression: _settleOrder(interaction,suffix.resolver.get(),suffix.totalFee,allTokensAndAmounts)
		IRs:
			REF_1016(Address) -> suffix_1.resolver
			TMP_3894(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1016'] 
			REF_1018(uint256) -> suffix_1.totalFee
			INTERNAL_CALL, Settlement._settleOrder(bytes,address,uint256,bytes)(interaction_1,TMP_3894,REF_1018,allTokensAndAmounts_1)
		Expression: takingFee > 0
		IRs:
			TMP_3896(bool) = takingFee_1 > 0
			CONDITION TMP_3896
		Expression: token.safeTransfer(suffix.takingFee.receiver(),takingFee)
		IRs:
			REF_1020(TakingFee.Data) -> suffix_1.takingFee
			TMP_3897(address) = LIBRARY_CALL, dest:TakingFee, function:TakingFee.receiver(TakingFee.Data), arguments:['REF_1020'] 
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['token_1', 'TMP_3897', 'takingFee_1'] 
		Expression: token.forceApprove(address(_limitOrderProtocol),result)
		IRs:
			TMP_3899 = CONVERT _limitOrderProtocol_7 to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.forceApprove(IERC20,address,uint256), arguments:['token_1', 'TMP_3899', 'result_1'] 
		Expression: onlyThis(taker)
		IRs:
			MODIFIER_CALL, Settlement.onlyThis(address)(taker_1)
		Expression: onlyLimitOrderProtocol()
		IRs:
			MODIFIER_CALL, Settlement.onlyLimitOrderProtocol()()
		Expression: result
		IRs:
			RETURN result_1
	Function Settlement._settleOrder(bytes,address,uint256,bytes)
		IRs:
			data_1(bytes) := ϕ(['interaction_1', 'data_1'])
			resolver_1(address) := ϕ(['TMP_3894', 'msg.sender'])
			totalFee_1(uint256) := ϕ(['REF_1018'])
			tokensAndAmounts_1(bytes) := ϕ(['allTokensAndAmounts_1', 'TMP_3866'])
			_ORDER_FEE_BASE_POINTS_1(uint256) := ϕ(['_ORDER_FEE_BASE_POINTS_0'])
			_limitOrderProtocol_8(IOrderMixin) := ϕ(['_limitOrderProtocol_7', '_limitOrderProtocol_6', '_limitOrderProtocol_1', '_limitOrderProtocol_0'])
			_FILL_ORDER_TO_SELECTOR_1(bytes4) := ϕ(['_FILL_ORDER_TO_SELECTOR_0'])
			_WRONG_INTERACTION_TARGET_SELECTOR_1(bytes4) := ϕ(['_WRONG_INTERACTION_TARGET_SELECTOR_0'])
		Expression: order = data + calldataload(uint256)(data)
		IRs:
			TMP_3903(uint256) = SOLIDITY_CALL calldataload(uint256)(data_1)
			TMP_3904(bytes) = data_1 + TMP_3903
			order_1(OrderLib.Order) := TMP_3904(bytes)
		Expression: ! order.checkResolver(resolver)
		IRs:
			TMP_3905(bool) = LIBRARY_CALL, dest:OrderSuffix, function:OrderSuffix.checkResolver(OrderLib.Order,address), arguments:['order_1', 'resolver_1'] 
			TMP_3906 = UnaryType.BANG TMP_3905 
			CONDITION TMP_3906
		Expression: revert ResolverIsNotWhitelisted()()
		IRs:
			TMP_3907(None) = SOLIDITY_CALL revert ResolverIsNotWhitelisted()()
		Expression: takingFeeData = order.takingFee()
		IRs:
			TMP_3908(TakingFee.Data) = LIBRARY_CALL, dest:OrderSuffix, function:OrderSuffix.takingFee(OrderLib.Order), arguments:['order_1'] 
			takingFeeData_1(TakingFee.Data) := TMP_3908(TakingFee.Data)
		Expression: totalFee += order.salt.getFee() * _ORDER_FEE_BASE_POINTS
		IRs:
			REF_1025(uint256) -> order_1.salt
			TMP_3909(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getFee(uint256), arguments:['REF_1025'] 
			TMP_3910(uint256) = TMP_3909 (c)* _ORDER_FEE_BASE_POINTS_1
			totalFee_2(uint256) = totalFee_1 (c)+ TMP_3910
		Expression: rateBump = order.rateBump()
		IRs:
			TMP_3911(uint256) = LIBRARY_CALL, dest:OrderSuffix, function:OrderSuffix.rateBump(OrderLib.Order), arguments:['order_1'] 
			rateBump_1(uint256) := TMP_3911(uint256)
		Expression: suffixLength = DynamicSuffix._STATIC_DATA_SIZE + tokensAndAmounts.length + 0x20
		IRs:
			REF_1028(uint256) -> DynamicSuffix._STATIC_DATA_SIZE
			REF_1029 -> LENGTH tokensAndAmounts_1
			TMP_3912(uint256) = REF_1028 (c)+ REF_1029
			TMP_3913(uint256) = TMP_3912 (c)+ 32
			suffixLength_1(uint256) := TMP_3913(uint256)
		Expression: limitOrderProtocol = _limitOrderProtocol
		IRs:
			limitOrderProtocol_1(IOrderMixin) := _limitOrderProtocol_8(IOrderMixin)
		Expression: interactionLengthOffset__settleOrder_asm_1 = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_3914(bytes) = data_1 + 64
			TMP_3915(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_3914)
			interactionLengthOffset__settleOrder_asm_1_1(uint256) := TMP_3915(uint256)
		Expression: interactionOffset__settleOrder_asm_1 = interactionLengthOffset__settleOrder_asm_1 + 0x20
		IRs:
			TMP_3916(uint256) = interactionLengthOffset__settleOrder_asm_1_1 + 32
			interactionOffset__settleOrder_asm_1_1(uint256) := TMP_3916(uint256)
		Expression: interactionLength__settleOrder_asm_1 = calldataload(uint256)(data + interactionLengthOffset__settleOrder_asm_1)
		IRs:
			TMP_3917(bytes) = data_1 + interactionLengthOffset__settleOrder_asm_1_1
			TMP_3918(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_3917)
			interactionLength__settleOrder_asm_1_1(uint256) := TMP_3918(uint256)
		Expression: target__settleOrder_asm_1 = calldataload(uint256)(data + interactionOffset__settleOrder_asm_1) >> 96
		IRs:
			TMP_3919(bytes) = data_1 + interactionOffset__settleOrder_asm_1_1
			TMP_3920(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_3919)
			TMP_3921(uint256) = TMP_3920 >> 96
			target__settleOrder_asm_1_1(uint256) := TMP_3921(uint256)
		Expression: interactionLength__settleOrder_asm_1 < 20 | ! target__settleOrder_asm_1 == address()()
		IRs:
			TMP_3922(bool) = interactionLength__settleOrder_asm_1_1 < 20
			TMP_3923 = CONVERT this to address
			TMP_3924(bool) = target__settleOrder_asm_1_1 == TMP_3923
			TMP_3925 = UnaryType.BANG TMP_3924 
			TMP_3926(bool) = TMP_3922 | TMP_3925
			CONDITION TMP_3926
		Expression: mstore(uint256,uint256)(0,_WRONG_INTERACTION_TARGET_SELECTOR)
		IRs:
			TMP_3927(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,_WRONG_INTERACTION_TARGET_SELECTOR_1)
		Expression: revert(uint256,uint256)(0,4)
		IRs:
			TMP_3928(None) = SOLIDITY_CALL revert(uint256,uint256)(0,4)
		Expression: ptr__settleOrder_asm_1 = mload(uint256)(0x40)
		IRs:
			TMP_3929(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr__settleOrder_asm_1_1(uint256) := TMP_3929(uint256)
		Expression: mstore(uint256,uint256)(ptr__settleOrder_asm_1,_FILL_ORDER_TO_SELECTOR)
		IRs:
			TMP_3930(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr__settleOrder_asm_1_1,_FILL_ORDER_TO_SELECTOR_1)
		Expression: calldatacopy(uint256,uint256,uint256)(ptr__settleOrder_asm_1 + 4,data,data)
		IRs:
			TMP_3931(uint256) = ptr__settleOrder_asm_1_1 + 4
			TMP_3932(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_3931,data_1,data_1)
		Expression: mstore(uint256,uint256)(ptr__settleOrder_asm_1 + interactionLengthOffset__settleOrder_asm_1 + 4,interactionLength__settleOrder_asm_1 + suffixLength)
		IRs:
			TMP_3933(uint256) = ptr__settleOrder_asm_1_1 + interactionLengthOffset__settleOrder_asm_1_1
			TMP_3934(uint256) = TMP_3933 + 4
			TMP_3935(uint256) = interactionLength__settleOrder_asm_1_1 + suffixLength_1
			TMP_3936(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3934,TMP_3935)
		Expression: offset__settleOrder_asm_1 = ptr__settleOrder_asm_1 + interactionOffset__settleOrder_asm_1 + interactionLength__settleOrder_asm_1
		IRs:
			TMP_3937(uint256) = ptr__settleOrder_asm_1_1 + interactionOffset__settleOrder_asm_1_1
			TMP_3938(uint256) = TMP_3937 + interactionLength__settleOrder_asm_1_1
			offset__settleOrder_asm_1_1(uint256) := TMP_3938(uint256)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x04,totalFee)
		IRs:
			TMP_3939(uint256) = offset__settleOrder_asm_1_1 + 4
			TMP_3940(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3939,totalFee_2)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x24,resolver)
		IRs:
			TMP_3941(uint256) = offset__settleOrder_asm_1_1 + 36
			TMP_3942(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3941,resolver_1)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x44,calldataload(uint256)(order + 0x40))
		IRs:
			TMP_3943(uint256) = offset__settleOrder_asm_1_1 + 68
			TMP_3944(OrderLib.Order) = order_1 + 64
			TMP_3945(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_3944)
			TMP_3946(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3943,TMP_3945)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x64,rateBump)
		IRs:
			TMP_3947(uint256) = offset__settleOrder_asm_1_1 + 100
			TMP_3948(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3947,rateBump_1)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x84,takingFeeData)
		IRs:
			TMP_3949(uint256) = offset__settleOrder_asm_1_1 + 132
			TMP_3950(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3949,takingFeeData_1)
		Expression: tokensAndAmountsLength__settleOrder_asm_1 = mload(uint256)(tokensAndAmounts)
		IRs:
			TMP_3951(uint256) = SOLIDITY_CALL mload(uint256)(tokensAndAmounts_1)
			tokensAndAmountsLength__settleOrder_asm_1_1(uint256) := TMP_3951(uint256)
		Expression: memcpy(offset__settleOrder_asm_1 + 0xa4,tokensAndAmounts + 0x20,tokensAndAmountsLength__settleOrder_asm_1)
		IRs:
			TMP_3952(uint256) = offset__settleOrder_asm_1_1 + 164
			TMP_3953(bytes) = tokensAndAmounts_1 + 32
			INTERNAL_CALL, Settlement._settleOrder.asm_1.memcpy()(TMP_3952,TMP_3953,tokensAndAmountsLength__settleOrder_asm_1_1)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0xa4 + tokensAndAmountsLength__settleOrder_asm_1,tokensAndAmountsLength__settleOrder_asm_1)
		IRs:
			TMP_3955(uint256) = 164 + tokensAndAmountsLength__settleOrder_asm_1_1
			TMP_3956(uint256) = offset__settleOrder_asm_1_1 + TMP_3955
			TMP_3957(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3956,tokensAndAmountsLength__settleOrder_asm_1_1)
		Expression: ! call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),limitOrderProtocol,0,ptr__settleOrder_asm_1,4 + suffixLength + data,ptr__settleOrder_asm_1,0)
		IRs:
			TMP_3958(uint256) = SOLIDITY_CALL gas()()
			TMP_3959(uint256) = 4 + suffixLength_1
			TMP_3960(uint256) = TMP_3959 + data_1
			TMP_3961(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_3958,limitOrderProtocol_1,0,ptr__settleOrder_asm_1_1,TMP_3960,ptr__settleOrder_asm_1_1,0)
			TMP_3962 = UnaryType.BANG TMP_3961 
			CONDITION TMP_3962
		Expression: returndatacopy(uint256,uint256,uint256)(ptr__settleOrder_asm_1,0,returndatasize()())
		IRs:
			TMP_3963(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_3964(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(ptr__settleOrder_asm_1_1,0,TMP_3963)
		Expression: revert(uint256,uint256)(ptr__settleOrder_asm_1,returndatasize()())
		IRs:
			TMP_3965(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_3966(None) = SOLIDITY_CALL revert(uint256,uint256)(ptr__settleOrder_asm_1_1,TMP_3965)
	Function Settlement._settleOrder.asm_1.memcpy()
		IRs:
			dst__settleOrder_asm_1_memcpy_2(uint256) := ϕ(['TMP_3952'])
			src__settleOrder_asm_1_memcpy_2(uint256) := ϕ(['TMP_3953'])
			len__settleOrder_asm_1_memcpy_2(uint256) := ϕ(['tokensAndAmountsLength__settleOrder_asm_1_1'])
		Expression: pop(uint256)(staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),0x4,src__settleOrder_asm_1_memcpy,len__settleOrder_asm_1_memcpy,dst__settleOrder_asm_1_memcpy,len__settleOrder_asm_1_memcpy))
	Function Settlement.slitherConstructorConstantVariables()
		Expression: _FINALIZE_INTERACTION = 0x01
		Expression: _ORDER_FEE_BASE_POINTS = 1e15
		Expression: _BASE_POINTS = 10_000_000
		Expression: _FILL_ORDER_TO_SELECTOR = 0xe5d7bde6
		Expression: _WRONG_INTERACTION_TARGET_SELECTOR = 0x5b34bf89
	Modifier FeeBankCharger.onlyFeeBank()
ENTRY_POINT
		IRs:
			feeBank_2(IFeeBank) := ϕ(['feeBank_1', 'feeBank_0'])
IF msg.sender != address(feeBank)
		Expression: msg.sender != address(feeBank)
		IRs:
			TMP_3970 = CONVERT feeBank_2 to address
			TMP_3971(bool) = msg.sender != TMP_3970
			CONDITION TMP_3971
EXPRESSION revert OnlyFeeBankAccess()()
		Expression: revert OnlyFeeBankAccess()()
		IRs:
			TMP_3972(None) = SOLIDITY_CALL revert OnlyFeeBankAccess()()
END_IF
_
	Modifier Settlement.onlyThis(address)
ENTRY_POINT
		IRs:
			account_1(address) := ϕ(['taker_1'])
IF account != address(this)
		Expression: account != address(this)
		IRs:
			TMP_3973 = CONVERT this to address
			TMP_3974(bool) = account_1 != TMP_3973
			CONDITION TMP_3974
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_3975(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
	Modifier Settlement.onlyLimitOrderProtocol()
ENTRY_POINT
		IRs:
			_limitOrderProtocol_9(IOrderMixin) := ϕ(['_limitOrderProtocol_7', '_limitOrderProtocol_6', '_limitOrderProtocol_1', '_limitOrderProtocol_0'])
IF msg.sender != address(_limitOrderProtocol)
		Expression: msg.sender != address(_limitOrderProtocol)
		IRs:
			TMP_3976 = CONVERT _limitOrderProtocol_9 to address
			TMP_3977(bool) = msg.sender != TMP_3976
			CONDITION TMP_3977
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_3978(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract St1inch
	Function IVotable.votingPowerOf(address)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function VotingPowerCalculator.constructor(uint256,uint256)
		IRs:
			_ONE_E18_1(uint256) := ϕ(['_ONE_E18_0'])
		Expression: origin_ > block.timestamp
		IRs:
			TMP_3979(bool) = origin__1 > block.timestamp
			CONDITION TMP_3979
		Expression: revert OriginInTheFuture()()
		IRs:
			TMP_3980(None) = SOLIDITY_CALL revert OriginInTheFuture()()
		Expression: origin = origin_
		IRs:
			origin_1(uint256) := origin__1(uint256)
		Expression: expBase = expBase_
		IRs:
			expBase_1(uint256) := expBase__1(uint256)
		Expression: _expTable0 = expBase_
		IRs:
			_expTable0_1(uint256) := expBase__1(uint256)
		Expression: _expTable1 = (_expTable0 * _expTable0) / _ONE_E18
		IRs:
			TMP_3981(uint256) = _expTable0_1 (c)* _expTable0_1
			TMP_3982(uint256) = TMP_3981 (c)/ _ONE_E18_1
			_expTable1_1(uint256) := TMP_3982(uint256)
		Expression: _expTable2 = (_expTable1 * _expTable1) / _ONE_E18
		IRs:
			TMP_3983(uint256) = _expTable1_1 (c)* _expTable1_1
			TMP_3984(uint256) = TMP_3983 (c)/ _ONE_E18_1
			_expTable2_1(uint256) := TMP_3984(uint256)
		Expression: _expTable3 = (_expTable2 * _expTable2) / _ONE_E18
		IRs:
			TMP_3985(uint256) = _expTable2_1 (c)* _expTable2_1
			TMP_3986(uint256) = TMP_3985 (c)/ _ONE_E18_1
			_expTable3_1(uint256) := TMP_3986(uint256)
		Expression: _expTable4 = (_expTable3 * _expTable3) / _ONE_E18
		IRs:
			TMP_3987(uint256) = _expTable3_1 (c)* _expTable3_1
			TMP_3988(uint256) = TMP_3987 (c)/ _ONE_E18_1
			_expTable4_1(uint256) := TMP_3988(uint256)
		Expression: _expTable5 = (_expTable4 * _expTable4) / _ONE_E18
		IRs:
			TMP_3989(uint256) = _expTable4_1 (c)* _expTable4_1
			TMP_3990(uint256) = TMP_3989 (c)/ _ONE_E18_1
			_expTable5_1(uint256) := TMP_3990(uint256)
		Expression: _expTable6 = (_expTable5 * _expTable5) / _ONE_E18
		IRs:
			TMP_3991(uint256) = _expTable5_1 (c)* _expTable5_1
			TMP_3992(uint256) = TMP_3991 (c)/ _ONE_E18_1
			_expTable6_1(uint256) := TMP_3992(uint256)
		Expression: _expTable7 = (_expTable6 * _expTable6) / _ONE_E18
		IRs:
			TMP_3993(uint256) = _expTable6_1 (c)* _expTable6_1
			TMP_3994(uint256) = TMP_3993 (c)/ _ONE_E18_1
			_expTable7_1(uint256) := TMP_3994(uint256)
		Expression: _expTable8 = (_expTable7 * _expTable7) / _ONE_E18
		IRs:
			TMP_3995(uint256) = _expTable7_1 (c)* _expTable7_1
			TMP_3996(uint256) = TMP_3995 (c)/ _ONE_E18_1
			_expTable8_1(uint256) := TMP_3996(uint256)
		Expression: _expTable9 = (_expTable8 * _expTable8) / _ONE_E18
		IRs:
			TMP_3997(uint256) = _expTable8_1 (c)* _expTable8_1
			TMP_3998(uint256) = TMP_3997 (c)/ _ONE_E18_1
			_expTable9_1(uint256) := TMP_3998(uint256)
		Expression: _expTable10 = (_expTable9 * _expTable9) / _ONE_E18
		IRs:
			TMP_3999(uint256) = _expTable9_1 (c)* _expTable9_1
			TMP_4000(uint256) = TMP_3999 (c)/ _ONE_E18_1
			_expTable10_1(uint256) := TMP_4000(uint256)
		Expression: _expTable11 = (_expTable10 * _expTable10) / _ONE_E18
		IRs:
			TMP_4001(uint256) = _expTable10_1 (c)* _expTable10_1
			TMP_4002(uint256) = TMP_4001 (c)/ _ONE_E18_1
			_expTable11_1(uint256) := TMP_4002(uint256)
		Expression: _expTable12 = (_expTable11 * _expTable11) / _ONE_E18
		IRs:
			TMP_4003(uint256) = _expTable11_1 (c)* _expTable11_1
			TMP_4004(uint256) = TMP_4003 (c)/ _ONE_E18_1
			_expTable12_1(uint256) := TMP_4004(uint256)
		Expression: _expTable13 = (_expTable12 * _expTable12) / _ONE_E18
		IRs:
			TMP_4005(uint256) = _expTable12_1 (c)* _expTable12_1
			TMP_4006(uint256) = TMP_4005 (c)/ _ONE_E18_1
			_expTable13_1(uint256) := TMP_4006(uint256)
		Expression: _expTable14 = (_expTable13 * _expTable13) / _ONE_E18
		IRs:
			TMP_4007(uint256) = _expTable13_1 (c)* _expTable13_1
			TMP_4008(uint256) = TMP_4007 (c)/ _ONE_E18_1
			_expTable14_1(uint256) := TMP_4008(uint256)
		Expression: _expTable15 = (_expTable14 * _expTable14) / _ONE_E18
		IRs:
			TMP_4009(uint256) = _expTable14_1 (c)* _expTable14_1
			TMP_4010(uint256) = TMP_4009 (c)/ _ONE_E18_1
			_expTable15_1(uint256) := TMP_4010(uint256)
		Expression: _expTable16 = (_expTable15 * _expTable15) / _ONE_E18
		IRs:
			TMP_4011(uint256) = _expTable15_1 (c)* _expTable15_1
			TMP_4012(uint256) = TMP_4011 (c)/ _ONE_E18_1
			_expTable16_1(uint256) := TMP_4012(uint256)
		Expression: _expTable17 = (_expTable16 * _expTable16) / _ONE_E18
		IRs:
			TMP_4013(uint256) = _expTable16_1 (c)* _expTable16_1
			TMP_4014(uint256) = TMP_4013 (c)/ _ONE_E18_1
			_expTable17_1(uint256) := TMP_4014(uint256)
		Expression: _expTable18 = (_expTable17 * _expTable17) / _ONE_E18
		IRs:
			TMP_4015(uint256) = _expTable17_1 (c)* _expTable17_1
			TMP_4016(uint256) = TMP_4015 (c)/ _ONE_E18_1
			_expTable18_1(uint256) := TMP_4016(uint256)
		Expression: _expTable19 = (_expTable18 * _expTable18) / _ONE_E18
		IRs:
			TMP_4017(uint256) = _expTable18_1 (c)* _expTable18_1
			TMP_4018(uint256) = TMP_4017 (c)/ _ONE_E18_1
			_expTable19_1(uint256) := TMP_4018(uint256)
		Expression: _expTable20 = (_expTable19 * _expTable19) / _ONE_E18
		IRs:
			TMP_4019(uint256) = _expTable19_1 (c)* _expTable19_1
			TMP_4020(uint256) = TMP_4019 (c)/ _ONE_E18_1
			_expTable20_1(uint256) := TMP_4020(uint256)
		Expression: _expTable21 = (_expTable20 * _expTable20) / _ONE_E18
		IRs:
			TMP_4021(uint256) = _expTable20_1 (c)* _expTable20_1
			TMP_4022(uint256) = TMP_4021 (c)/ _ONE_E18_1
			_expTable21_1(uint256) := TMP_4022(uint256)
		Expression: _expTable22 = (_expTable21 * _expTable21) / _ONE_E18
		IRs:
			TMP_4023(uint256) = _expTable21_1 (c)* _expTable21_1
			TMP_4024(uint256) = TMP_4023 (c)/ _ONE_E18_1
			_expTable22_1(uint256) := TMP_4024(uint256)
		Expression: _expTable23 = (_expTable22 * _expTable22) / _ONE_E18
		IRs:
			TMP_4025(uint256) = _expTable22_1 (c)* _expTable22_1
			TMP_4026(uint256) = TMP_4025 (c)/ _ONE_E18_1
			_expTable23_1(uint256) := TMP_4026(uint256)
		Expression: _expTable24 = (_expTable23 * _expTable23) / _ONE_E18
		IRs:
			TMP_4027(uint256) = _expTable23_1 (c)* _expTable23_1
			TMP_4028(uint256) = TMP_4027 (c)/ _ONE_E18_1
			_expTable24_1(uint256) := TMP_4028(uint256)
		Expression: _expTable25 = (_expTable24 * _expTable24) / _ONE_E18
		IRs:
			TMP_4029(uint256) = _expTable24_1 (c)* _expTable24_1
			TMP_4030(uint256) = TMP_4029 (c)/ _ONE_E18_1
			_expTable25_1(uint256) := TMP_4030(uint256)
		Expression: _expTable26 = (_expTable25 * _expTable25) / _ONE_E18
		IRs:
			TMP_4031(uint256) = _expTable25_1 (c)* _expTable25_1
			TMP_4032(uint256) = TMP_4031 (c)/ _ONE_E18_1
			_expTable26_1(uint256) := TMP_4032(uint256)
		Expression: _expTable27 = (_expTable26 * _expTable26) / _ONE_E18
		IRs:
			TMP_4033(uint256) = _expTable26_1 (c)* _expTable26_1
			TMP_4034(uint256) = TMP_4033 (c)/ _ONE_E18_1
			_expTable27_1(uint256) := TMP_4034(uint256)
		Expression: _expTable28 = (_expTable27 * _expTable27) / _ONE_E18
		IRs:
			TMP_4035(uint256) = _expTable27_1 (c)* _expTable27_1
			TMP_4036(uint256) = TMP_4035 (c)/ _ONE_E18_1
			_expTable28_1(uint256) := TMP_4036(uint256)
		Expression: _expTable29 = (_expTable28 * _expTable28) / _ONE_E18
		IRs:
			TMP_4037(uint256) = _expTable28_1 (c)* _expTable28_1
			TMP_4038(uint256) = TMP_4037 (c)/ _ONE_E18_1
			_expTable29_1(uint256) := TMP_4038(uint256)
	Function VotingPowerCalculator._votingPowerAt(uint256,uint256)
		IRs:
			balance_1(uint256) := ϕ(['TMP_4498', 'TMP_4496', 'stBalance_1', 'balance_1', 'balance_1'])
			timestamp_1(uint256) := ϕ(['timestamp_1', 'TMP_4463', 'block.timestamp', 'timestamp_1', 'TMP_4457'])
			_ONE_E18_2(uint256) := ϕ(['_ONE_E18_0'])
			origin_2(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_2(uint256) := ϕ(['_expTable0_1', '_expTable0_0'])
			_expTable1_2(uint256) := ϕ(['_expTable1_1', '_expTable1_0'])
			_expTable2_2(uint256) := ϕ(['_expTable2_1', '_expTable2_0'])
			_expTable3_2(uint256) := ϕ(['_expTable3_1', '_expTable3_0'])
			_expTable4_2(uint256) := ϕ(['_expTable4_1', '_expTable4_0'])
			_expTable5_2(uint256) := ϕ(['_expTable5_0', '_expTable5_1'])
			_expTable6_2(uint256) := ϕ(['_expTable6_1', '_expTable6_0'])
			_expTable7_2(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_2(uint256) := ϕ(['_expTable8_1', '_expTable8_0'])
			_expTable9_2(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_2(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_2(uint256) := ϕ(['_expTable11_1', '_expTable11_0'])
			_expTable12_2(uint256) := ϕ(['_expTable12_1', '_expTable12_0'])
			_expTable13_2(uint256) := ϕ(['_expTable13_0', '_expTable13_1'])
			_expTable14_2(uint256) := ϕ(['_expTable14_1', '_expTable14_0'])
			_expTable15_2(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_2(uint256) := ϕ(['_expTable16_1', '_expTable16_0'])
			_expTable17_2(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_2(uint256) := ϕ(['_expTable18_1', '_expTable18_0'])
			_expTable19_2(uint256) := ϕ(['_expTable19_1', '_expTable19_0'])
			_expTable20_2(uint256) := ϕ(['_expTable20_1', '_expTable20_0'])
			_expTable21_2(uint256) := ϕ(['_expTable21_0', '_expTable21_1'])
			_expTable22_2(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_2(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_2(uint256) := ϕ(['_expTable24_1', '_expTable24_0'])
			_expTable25_2(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_2(uint256) := ϕ(['_expTable26_1', '_expTable26_0'])
			_expTable27_2(uint256) := ϕ(['_expTable27_1', '_expTable27_0'])
			_expTable28_2(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_2(uint256) := ϕ(['_expTable29_0', '_expTable29_1'])
		Expression: t = timestamp - origin
		IRs:
			TMP_4039(uint256) = timestamp_4 - origin_2
			t_1(uint256) := TMP_4039(uint256)
		Expression: votingPower = balance
		IRs:
			votingPower_1(uint256) := balance_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_4040(uint256) = t_1 & 1
			TMP_4041(bool) = TMP_4040 != 0
			CONDITION TMP_4041
		Expression: votingPower = (votingPower * _expTable0) / _ONE_E18
		IRs:
			TMP_4042(uint256) = votingPower_1 * _expTable0_2
			TMP_4043(uint256) = TMP_4042 / _ONE_E18_2
			votingPower_2(uint256) := TMP_4043(uint256)
		IRs:
			votingPower_3(uint256) := ϕ(['votingPower_1', 'votingPower_2'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_4044(uint256) = t_1 & 2
			TMP_4045(bool) = TMP_4044 != 0
			CONDITION TMP_4045
		Expression: votingPower = (votingPower * _expTable1) / _ONE_E18
		IRs:
			TMP_4046(uint256) = votingPower_3 * _expTable1_2
			TMP_4047(uint256) = TMP_4046 / _ONE_E18_2
			votingPower_4(uint256) := TMP_4047(uint256)
		IRs:
			votingPower_5(uint256) := ϕ(['votingPower_1', 'votingPower_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_4048(uint256) = t_1 & 4
			TMP_4049(bool) = TMP_4048 != 0
			CONDITION TMP_4049
		Expression: votingPower = (votingPower * _expTable2) / _ONE_E18
		IRs:
			TMP_4050(uint256) = votingPower_5 * _expTable2_2
			TMP_4051(uint256) = TMP_4050 / _ONE_E18_2
			votingPower_6(uint256) := TMP_4051(uint256)
		IRs:
			votingPower_7(uint256) := ϕ(['votingPower_1', 'votingPower_6'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_4052(uint256) = t_1 & 8
			TMP_4053(bool) = TMP_4052 != 0
			CONDITION TMP_4053
		Expression: votingPower = (votingPower * _expTable3) / _ONE_E18
		IRs:
			TMP_4054(uint256) = votingPower_7 * _expTable3_2
			TMP_4055(uint256) = TMP_4054 / _ONE_E18_2
			votingPower_8(uint256) := TMP_4055(uint256)
		IRs:
			votingPower_9(uint256) := ϕ(['votingPower_1', 'votingPower_8'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_4056(uint256) = t_1 & 16
			TMP_4057(bool) = TMP_4056 != 0
			CONDITION TMP_4057
		Expression: votingPower = (votingPower * _expTable4) / _ONE_E18
		IRs:
			TMP_4058(uint256) = votingPower_9 * _expTable4_2
			TMP_4059(uint256) = TMP_4058 / _ONE_E18_2
			votingPower_10(uint256) := TMP_4059(uint256)
		IRs:
			votingPower_11(uint256) := ϕ(['votingPower_1', 'votingPower_10'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_4060(uint256) = t_1 & 32
			TMP_4061(bool) = TMP_4060 != 0
			CONDITION TMP_4061
		Expression: votingPower = (votingPower * _expTable5) / _ONE_E18
		IRs:
			TMP_4062(uint256) = votingPower_11 * _expTable5_2
			TMP_4063(uint256) = TMP_4062 / _ONE_E18_2
			votingPower_12(uint256) := TMP_4063(uint256)
		IRs:
			votingPower_13(uint256) := ϕ(['votingPower_1', 'votingPower_12'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_4064(uint256) = t_1 & 64
			TMP_4065(bool) = TMP_4064 != 0
			CONDITION TMP_4065
		Expression: votingPower = (votingPower * _expTable6) / _ONE_E18
		IRs:
			TMP_4066(uint256) = votingPower_13 * _expTable6_2
			TMP_4067(uint256) = TMP_4066 / _ONE_E18_2
			votingPower_14(uint256) := TMP_4067(uint256)
		IRs:
			votingPower_15(uint256) := ϕ(['votingPower_1', 'votingPower_14'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_4068(uint256) = t_1 & 128
			TMP_4069(bool) = TMP_4068 != 0
			CONDITION TMP_4069
		Expression: votingPower = (votingPower * _expTable7) / _ONE_E18
		IRs:
			TMP_4070(uint256) = votingPower_15 * _expTable7_2
			TMP_4071(uint256) = TMP_4070 / _ONE_E18_2
			votingPower_16(uint256) := TMP_4071(uint256)
		IRs:
			votingPower_17(uint256) := ϕ(['votingPower_1', 'votingPower_16'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_4072(uint256) = t_1 & 256
			TMP_4073(bool) = TMP_4072 != 0
			CONDITION TMP_4073
		Expression: votingPower = (votingPower * _expTable8) / _ONE_E18
		IRs:
			TMP_4074(uint256) = votingPower_17 * _expTable8_2
			TMP_4075(uint256) = TMP_4074 / _ONE_E18_2
			votingPower_18(uint256) := TMP_4075(uint256)
		IRs:
			votingPower_19(uint256) := ϕ(['votingPower_1', 'votingPower_18'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_4076(uint256) = t_1 & 512
			TMP_4077(bool) = TMP_4076 != 0
			CONDITION TMP_4077
		Expression: votingPower = (votingPower * _expTable9) / _ONE_E18
		IRs:
			TMP_4078(uint256) = votingPower_19 * _expTable9_2
			TMP_4079(uint256) = TMP_4078 / _ONE_E18_2
			votingPower_20(uint256) := TMP_4079(uint256)
		IRs:
			votingPower_21(uint256) := ϕ(['votingPower_1', 'votingPower_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_4080(uint256) = t_1 & 1024
			TMP_4081(bool) = TMP_4080 != 0
			CONDITION TMP_4081
		Expression: votingPower = (votingPower * _expTable10) / _ONE_E18
		IRs:
			TMP_4082(uint256) = votingPower_21 * _expTable10_2
			TMP_4083(uint256) = TMP_4082 / _ONE_E18_2
			votingPower_22(uint256) := TMP_4083(uint256)
		IRs:
			votingPower_23(uint256) := ϕ(['votingPower_1', 'votingPower_22'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_4084(uint256) = t_1 & 2048
			TMP_4085(bool) = TMP_4084 != 0
			CONDITION TMP_4085
		Expression: votingPower = (votingPower * _expTable11) / _ONE_E18
		IRs:
			TMP_4086(uint256) = votingPower_23 * _expTable11_2
			TMP_4087(uint256) = TMP_4086 / _ONE_E18_2
			votingPower_24(uint256) := TMP_4087(uint256)
		IRs:
			votingPower_25(uint256) := ϕ(['votingPower_1', 'votingPower_24'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_4088(uint256) = t_1 & 4096
			TMP_4089(bool) = TMP_4088 != 0
			CONDITION TMP_4089
		Expression: votingPower = (votingPower * _expTable12) / _ONE_E18
		IRs:
			TMP_4090(uint256) = votingPower_25 * _expTable12_2
			TMP_4091(uint256) = TMP_4090 / _ONE_E18_2
			votingPower_26(uint256) := TMP_4091(uint256)
		IRs:
			votingPower_27(uint256) := ϕ(['votingPower_1', 'votingPower_26'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_4092(uint256) = t_1 & 8192
			TMP_4093(bool) = TMP_4092 != 0
			CONDITION TMP_4093
		Expression: votingPower = (votingPower * _expTable13) / _ONE_E18
		IRs:
			TMP_4094(uint256) = votingPower_27 * _expTable13_2
			TMP_4095(uint256) = TMP_4094 / _ONE_E18_2
			votingPower_28(uint256) := TMP_4095(uint256)
		IRs:
			votingPower_29(uint256) := ϕ(['votingPower_1', 'votingPower_28'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_4096(uint256) = t_1 & 16384
			TMP_4097(bool) = TMP_4096 != 0
			CONDITION TMP_4097
		Expression: votingPower = (votingPower * _expTable14) / _ONE_E18
		IRs:
			TMP_4098(uint256) = votingPower_29 * _expTable14_2
			TMP_4099(uint256) = TMP_4098 / _ONE_E18_2
			votingPower_30(uint256) := TMP_4099(uint256)
		IRs:
			votingPower_31(uint256) := ϕ(['votingPower_1', 'votingPower_30'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_4100(uint256) = t_1 & 32768
			TMP_4101(bool) = TMP_4100 != 0
			CONDITION TMP_4101
		Expression: votingPower = (votingPower * _expTable15) / _ONE_E18
		IRs:
			TMP_4102(uint256) = votingPower_31 * _expTable15_2
			TMP_4103(uint256) = TMP_4102 / _ONE_E18_2
			votingPower_32(uint256) := TMP_4103(uint256)
		IRs:
			votingPower_33(uint256) := ϕ(['votingPower_1', 'votingPower_32'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_4104(uint256) = t_1 & 65536
			TMP_4105(bool) = TMP_4104 != 0
			CONDITION TMP_4105
		Expression: votingPower = (votingPower * _expTable16) / _ONE_E18
		IRs:
			TMP_4106(uint256) = votingPower_33 * _expTable16_2
			TMP_4107(uint256) = TMP_4106 / _ONE_E18_2
			votingPower_34(uint256) := TMP_4107(uint256)
		IRs:
			votingPower_35(uint256) := ϕ(['votingPower_1', 'votingPower_34'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_4108(uint256) = t_1 & 131072
			TMP_4109(bool) = TMP_4108 != 0
			CONDITION TMP_4109
		Expression: votingPower = (votingPower * _expTable17) / _ONE_E18
		IRs:
			TMP_4110(uint256) = votingPower_35 * _expTable17_2
			TMP_4111(uint256) = TMP_4110 / _ONE_E18_2
			votingPower_36(uint256) := TMP_4111(uint256)
		IRs:
			votingPower_37(uint256) := ϕ(['votingPower_1', 'votingPower_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_4112(uint256) = t_1 & 262144
			TMP_4113(bool) = TMP_4112 != 0
			CONDITION TMP_4113
		Expression: votingPower = (votingPower * _expTable18) / _ONE_E18
		IRs:
			TMP_4114(uint256) = votingPower_37 * _expTable18_2
			TMP_4115(uint256) = TMP_4114 / _ONE_E18_2
			votingPower_38(uint256) := TMP_4115(uint256)
		IRs:
			votingPower_39(uint256) := ϕ(['votingPower_1', 'votingPower_38'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_4116(uint256) = t_1 & 524288
			TMP_4117(bool) = TMP_4116 != 0
			CONDITION TMP_4117
		Expression: votingPower = (votingPower * _expTable19) / _ONE_E18
		IRs:
			TMP_4118(uint256) = votingPower_39 * _expTable19_2
			TMP_4119(uint256) = TMP_4118 / _ONE_E18_2
			votingPower_40(uint256) := TMP_4119(uint256)
		IRs:
			votingPower_41(uint256) := ϕ(['votingPower_1', 'votingPower_40'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_4120(uint256) = t_1 & 1048576
			TMP_4121(bool) = TMP_4120 != 0
			CONDITION TMP_4121
		Expression: votingPower = (votingPower * _expTable20) / _ONE_E18
		IRs:
			TMP_4122(uint256) = votingPower_41 * _expTable20_2
			TMP_4123(uint256) = TMP_4122 / _ONE_E18_2
			votingPower_42(uint256) := TMP_4123(uint256)
		IRs:
			votingPower_43(uint256) := ϕ(['votingPower_1', 'votingPower_42'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_4124(uint256) = t_1 & 2097152
			TMP_4125(bool) = TMP_4124 != 0
			CONDITION TMP_4125
		Expression: votingPower = (votingPower * _expTable21) / _ONE_E18
		IRs:
			TMP_4126(uint256) = votingPower_43 * _expTable21_2
			TMP_4127(uint256) = TMP_4126 / _ONE_E18_2
			votingPower_44(uint256) := TMP_4127(uint256)
		IRs:
			votingPower_45(uint256) := ϕ(['votingPower_1', 'votingPower_44'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_4128(uint256) = t_1 & 4194304
			TMP_4129(bool) = TMP_4128 != 0
			CONDITION TMP_4129
		Expression: votingPower = (votingPower * _expTable22) / _ONE_E18
		IRs:
			TMP_4130(uint256) = votingPower_45 * _expTable22_2
			TMP_4131(uint256) = TMP_4130 / _ONE_E18_2
			votingPower_46(uint256) := TMP_4131(uint256)
		IRs:
			votingPower_47(uint256) := ϕ(['votingPower_1', 'votingPower_46'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_4132(uint256) = t_1 & 8388608
			TMP_4133(bool) = TMP_4132 != 0
			CONDITION TMP_4133
		Expression: votingPower = (votingPower * _expTable23) / _ONE_E18
		IRs:
			TMP_4134(uint256) = votingPower_47 * _expTable23_2
			TMP_4135(uint256) = TMP_4134 / _ONE_E18_2
			votingPower_48(uint256) := TMP_4135(uint256)
		IRs:
			votingPower_49(uint256) := ϕ(['votingPower_1', 'votingPower_48'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_4136(uint256) = t_1 & 16777216
			TMP_4137(bool) = TMP_4136 != 0
			CONDITION TMP_4137
		Expression: votingPower = (votingPower * _expTable24) / _ONE_E18
		IRs:
			TMP_4138(uint256) = votingPower_49 * _expTable24_2
			TMP_4139(uint256) = TMP_4138 / _ONE_E18_2
			votingPower_50(uint256) := TMP_4139(uint256)
		IRs:
			votingPower_51(uint256) := ϕ(['votingPower_1', 'votingPower_50'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_4140(uint256) = t_1 & 33554432
			TMP_4141(bool) = TMP_4140 != 0
			CONDITION TMP_4141
		Expression: votingPower = (votingPower * _expTable25) / _ONE_E18
		IRs:
			TMP_4142(uint256) = votingPower_51 * _expTable25_2
			TMP_4143(uint256) = TMP_4142 / _ONE_E18_2
			votingPower_52(uint256) := TMP_4143(uint256)
		IRs:
			votingPower_53(uint256) := ϕ(['votingPower_1', 'votingPower_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_4144(uint256) = t_1 & 67108864
			TMP_4145(bool) = TMP_4144 != 0
			CONDITION TMP_4145
		Expression: votingPower = (votingPower * _expTable26) / _ONE_E18
		IRs:
			TMP_4146(uint256) = votingPower_53 * _expTable26_2
			TMP_4147(uint256) = TMP_4146 / _ONE_E18_2
			votingPower_54(uint256) := TMP_4147(uint256)
		IRs:
			votingPower_55(uint256) := ϕ(['votingPower_1', 'votingPower_54'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_4148(uint256) = t_1 & 134217728
			TMP_4149(bool) = TMP_4148 != 0
			CONDITION TMP_4149
		Expression: votingPower = (votingPower * _expTable27) / _ONE_E18
		IRs:
			TMP_4150(uint256) = votingPower_55 * _expTable27_2
			TMP_4151(uint256) = TMP_4150 / _ONE_E18_2
			votingPower_56(uint256) := TMP_4151(uint256)
		IRs:
			votingPower_57(uint256) := ϕ(['votingPower_1', 'votingPower_56'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_4152(uint256) = t_1 & 268435456
			TMP_4153(bool) = TMP_4152 != 0
			CONDITION TMP_4153
		Expression: votingPower = (votingPower * _expTable28) / _ONE_E18
		IRs:
			TMP_4154(uint256) = votingPower_57 * _expTable28_2
			TMP_4155(uint256) = TMP_4154 / _ONE_E18_2
			votingPower_58(uint256) := TMP_4155(uint256)
		IRs:
			votingPower_59(uint256) := ϕ(['votingPower_1', 'votingPower_58'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_4156(uint256) = t_1 & 536870912
			TMP_4157(bool) = TMP_4156 != 0
			CONDITION TMP_4157
		Expression: votingPower = (votingPower * _expTable29) / _ONE_E18
		IRs:
			TMP_4158(uint256) = votingPower_59 * _expTable29_2
			TMP_4159(uint256) = TMP_4158 / _ONE_E18_2
			votingPower_60(uint256) := TMP_4159(uint256)
		IRs:
			votingPower_61(uint256) := ϕ(['votingPower_1', 'votingPower_60'])
		Expression: votingPower
		IRs:
			RETURN votingPower_61
		Expression: timestamp < origin
		IRs:
			TMP_4160(bool) = timestamp_1 < origin_2
			CONDITION TMP_4160
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_2(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: votingPower
	Function VotingPowerCalculator._balanceAt(uint256,uint256)
		IRs:
			votingPower_1(uint256) := ϕ(['TMP_4516'])
			timestamp_1(uint256) := ϕ(['lockedTill_1'])
			_ONE_E18_3(uint256) := ϕ(['_ONE_E18_0'])
			origin_3(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_3(uint256) := ϕ(['_expTable0_1', '_expTable0_0'])
			_expTable1_3(uint256) := ϕ(['_expTable1_1', '_expTable1_0'])
			_expTable2_3(uint256) := ϕ(['_expTable2_1', '_expTable2_0'])
			_expTable3_3(uint256) := ϕ(['_expTable3_1', '_expTable3_0'])
			_expTable4_3(uint256) := ϕ(['_expTable4_1', '_expTable4_0'])
			_expTable5_3(uint256) := ϕ(['_expTable5_0', '_expTable5_1'])
			_expTable6_3(uint256) := ϕ(['_expTable6_1', '_expTable6_0'])
			_expTable7_3(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_3(uint256) := ϕ(['_expTable8_1', '_expTable8_0'])
			_expTable9_3(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_3(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_3(uint256) := ϕ(['_expTable11_1', '_expTable11_0'])
			_expTable12_3(uint256) := ϕ(['_expTable12_1', '_expTable12_0'])
			_expTable13_3(uint256) := ϕ(['_expTable13_0', '_expTable13_1'])
			_expTable14_3(uint256) := ϕ(['_expTable14_1', '_expTable14_0'])
			_expTable15_3(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_3(uint256) := ϕ(['_expTable16_1', '_expTable16_0'])
			_expTable17_3(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_3(uint256) := ϕ(['_expTable18_1', '_expTable18_0'])
			_expTable19_3(uint256) := ϕ(['_expTable19_1', '_expTable19_0'])
			_expTable20_3(uint256) := ϕ(['_expTable20_1', '_expTable20_0'])
			_expTable21_3(uint256) := ϕ(['_expTable21_0', '_expTable21_1'])
			_expTable22_3(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_3(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_3(uint256) := ϕ(['_expTable24_1', '_expTable24_0'])
			_expTable25_3(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_3(uint256) := ϕ(['_expTable26_1', '_expTable26_0'])
			_expTable27_3(uint256) := ϕ(['_expTable27_1', '_expTable27_0'])
			_expTable28_3(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_3(uint256) := ϕ(['_expTable29_0', '_expTable29_1'])
		Expression: t = timestamp - origin
		IRs:
			TMP_4161(uint256) = timestamp_4 - origin_3
			t_1(uint256) := TMP_4161(uint256)
		Expression: balance = votingPower
		IRs:
			balance_1(uint256) := votingPower_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_4162(uint256) = t_1 & 1
			TMP_4163(bool) = TMP_4162 != 0
			CONDITION TMP_4163
		Expression: balance = (balance * _ONE_E18) / _expTable0
		IRs:
			TMP_4164(uint256) = balance_1 * _ONE_E18_3
			TMP_4165(uint256) = TMP_4164 / _expTable0_3
			balance_2(uint256) := TMP_4165(uint256)
		IRs:
			balance_3(uint256) := ϕ(['balance_2', 'balance_1'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_4166(uint256) = t_1 & 2
			TMP_4167(bool) = TMP_4166 != 0
			CONDITION TMP_4167
		Expression: balance = (balance * _ONE_E18) / _expTable1
		IRs:
			TMP_4168(uint256) = balance_3 * _ONE_E18_3
			TMP_4169(uint256) = TMP_4168 / _expTable1_3
			balance_4(uint256) := TMP_4169(uint256)
		IRs:
			balance_5(uint256) := ϕ(['balance_4', 'balance_1'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_4170(uint256) = t_1 & 4
			TMP_4171(bool) = TMP_4170 != 0
			CONDITION TMP_4171
		Expression: balance = (balance * _ONE_E18) / _expTable2
		IRs:
			TMP_4172(uint256) = balance_5 * _ONE_E18_3
			TMP_4173(uint256) = TMP_4172 / _expTable2_3
			balance_6(uint256) := TMP_4173(uint256)
		IRs:
			balance_7(uint256) := ϕ(['balance_6', 'balance_1'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_4174(uint256) = t_1 & 8
			TMP_4175(bool) = TMP_4174 != 0
			CONDITION TMP_4175
		Expression: balance = (balance * _ONE_E18) / _expTable3
		IRs:
			TMP_4176(uint256) = balance_7 * _ONE_E18_3
			TMP_4177(uint256) = TMP_4176 / _expTable3_3
			balance_8(uint256) := TMP_4177(uint256)
		IRs:
			balance_9(uint256) := ϕ(['balance_8', 'balance_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_4178(uint256) = t_1 & 16
			TMP_4179(bool) = TMP_4178 != 0
			CONDITION TMP_4179
		Expression: balance = (balance * _ONE_E18) / _expTable4
		IRs:
			TMP_4180(uint256) = balance_9 * _ONE_E18_3
			TMP_4181(uint256) = TMP_4180 / _expTable4_3
			balance_10(uint256) := TMP_4181(uint256)
		IRs:
			balance_11(uint256) := ϕ(['balance_10', 'balance_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_4182(uint256) = t_1 & 32
			TMP_4183(bool) = TMP_4182 != 0
			CONDITION TMP_4183
		Expression: balance = (balance * _ONE_E18) / _expTable5
		IRs:
			TMP_4184(uint256) = balance_11 * _ONE_E18_3
			TMP_4185(uint256) = TMP_4184 / _expTable5_3
			balance_12(uint256) := TMP_4185(uint256)
		IRs:
			balance_13(uint256) := ϕ(['balance_12', 'balance_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_4186(uint256) = t_1 & 64
			TMP_4187(bool) = TMP_4186 != 0
			CONDITION TMP_4187
		Expression: balance = (balance * _ONE_E18) / _expTable6
		IRs:
			TMP_4188(uint256) = balance_13 * _ONE_E18_3
			TMP_4189(uint256) = TMP_4188 / _expTable6_3
			balance_14(uint256) := TMP_4189(uint256)
		IRs:
			balance_15(uint256) := ϕ(['balance_14', 'balance_1'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_4190(uint256) = t_1 & 128
			TMP_4191(bool) = TMP_4190 != 0
			CONDITION TMP_4191
		Expression: balance = (balance * _ONE_E18) / _expTable7
		IRs:
			TMP_4192(uint256) = balance_15 * _ONE_E18_3
			TMP_4193(uint256) = TMP_4192 / _expTable7_3
			balance_16(uint256) := TMP_4193(uint256)
		IRs:
			balance_17(uint256) := ϕ(['balance_16', 'balance_1'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_4194(uint256) = t_1 & 256
			TMP_4195(bool) = TMP_4194 != 0
			CONDITION TMP_4195
		Expression: balance = (balance * _ONE_E18) / _expTable8
		IRs:
			TMP_4196(uint256) = balance_17 * _ONE_E18_3
			TMP_4197(uint256) = TMP_4196 / _expTable8_3
			balance_18(uint256) := TMP_4197(uint256)
		IRs:
			balance_19(uint256) := ϕ(['balance_18', 'balance_1'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_4198(uint256) = t_1 & 512
			TMP_4199(bool) = TMP_4198 != 0
			CONDITION TMP_4199
		Expression: balance = (balance * _ONE_E18) / _expTable9
		IRs:
			TMP_4200(uint256) = balance_19 * _ONE_E18_3
			TMP_4201(uint256) = TMP_4200 / _expTable9_3
			balance_20(uint256) := TMP_4201(uint256)
		IRs:
			balance_21(uint256) := ϕ(['balance_20', 'balance_1'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_4202(uint256) = t_1 & 1024
			TMP_4203(bool) = TMP_4202 != 0
			CONDITION TMP_4203
		Expression: balance = (balance * _ONE_E18) / _expTable10
		IRs:
			TMP_4204(uint256) = balance_21 * _ONE_E18_3
			TMP_4205(uint256) = TMP_4204 / _expTable10_3
			balance_22(uint256) := TMP_4205(uint256)
		IRs:
			balance_23(uint256) := ϕ(['balance_22', 'balance_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_4206(uint256) = t_1 & 2048
			TMP_4207(bool) = TMP_4206 != 0
			CONDITION TMP_4207
		Expression: balance = (balance * _ONE_E18) / _expTable11
		IRs:
			TMP_4208(uint256) = balance_23 * _ONE_E18_3
			TMP_4209(uint256) = TMP_4208 / _expTable11_3
			balance_24(uint256) := TMP_4209(uint256)
		IRs:
			balance_25(uint256) := ϕ(['balance_24', 'balance_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_4210(uint256) = t_1 & 4096
			TMP_4211(bool) = TMP_4210 != 0
			CONDITION TMP_4211
		Expression: balance = (balance * _ONE_E18) / _expTable12
		IRs:
			TMP_4212(uint256) = balance_25 * _ONE_E18_3
			TMP_4213(uint256) = TMP_4212 / _expTable12_3
			balance_26(uint256) := TMP_4213(uint256)
		IRs:
			balance_27(uint256) := ϕ(['balance_26', 'balance_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_4214(uint256) = t_1 & 8192
			TMP_4215(bool) = TMP_4214 != 0
			CONDITION TMP_4215
		Expression: balance = (balance * _ONE_E18) / _expTable13
		IRs:
			TMP_4216(uint256) = balance_27 * _ONE_E18_3
			TMP_4217(uint256) = TMP_4216 / _expTable13_3
			balance_28(uint256) := TMP_4217(uint256)
		IRs:
			balance_29(uint256) := ϕ(['balance_28', 'balance_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_4218(uint256) = t_1 & 16384
			TMP_4219(bool) = TMP_4218 != 0
			CONDITION TMP_4219
		Expression: balance = (balance * _ONE_E18) / _expTable14
		IRs:
			TMP_4220(uint256) = balance_29 * _ONE_E18_3
			TMP_4221(uint256) = TMP_4220 / _expTable14_3
			balance_30(uint256) := TMP_4221(uint256)
		IRs:
			balance_31(uint256) := ϕ(['balance_30', 'balance_1'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_4222(uint256) = t_1 & 32768
			TMP_4223(bool) = TMP_4222 != 0
			CONDITION TMP_4223
		Expression: balance = (balance * _ONE_E18) / _expTable15
		IRs:
			TMP_4224(uint256) = balance_31 * _ONE_E18_3
			TMP_4225(uint256) = TMP_4224 / _expTable15_3
			balance_32(uint256) := TMP_4225(uint256)
		IRs:
			balance_33(uint256) := ϕ(['balance_32', 'balance_1'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_4226(uint256) = t_1 & 65536
			TMP_4227(bool) = TMP_4226 != 0
			CONDITION TMP_4227
		Expression: balance = (balance * _ONE_E18) / _expTable16
		IRs:
			TMP_4228(uint256) = balance_33 * _ONE_E18_3
			TMP_4229(uint256) = TMP_4228 / _expTable16_3
			balance_34(uint256) := TMP_4229(uint256)
		IRs:
			balance_35(uint256) := ϕ(['balance_34', 'balance_1'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_4230(uint256) = t_1 & 131072
			TMP_4231(bool) = TMP_4230 != 0
			CONDITION TMP_4231
		Expression: balance = (balance * _ONE_E18) / _expTable17
		IRs:
			TMP_4232(uint256) = balance_35 * _ONE_E18_3
			TMP_4233(uint256) = TMP_4232 / _expTable17_3
			balance_36(uint256) := TMP_4233(uint256)
		IRs:
			balance_37(uint256) := ϕ(['balance_36', 'balance_1'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_4234(uint256) = t_1 & 262144
			TMP_4235(bool) = TMP_4234 != 0
			CONDITION TMP_4235
		Expression: balance = (balance * _ONE_E18) / _expTable18
		IRs:
			TMP_4236(uint256) = balance_37 * _ONE_E18_3
			TMP_4237(uint256) = TMP_4236 / _expTable18_3
			balance_38(uint256) := TMP_4237(uint256)
		IRs:
			balance_39(uint256) := ϕ(['balance_38', 'balance_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_4238(uint256) = t_1 & 524288
			TMP_4239(bool) = TMP_4238 != 0
			CONDITION TMP_4239
		Expression: balance = (balance * _ONE_E18) / _expTable19
		IRs:
			TMP_4240(uint256) = balance_39 * _ONE_E18_3
			TMP_4241(uint256) = TMP_4240 / _expTable19_3
			balance_40(uint256) := TMP_4241(uint256)
		IRs:
			balance_41(uint256) := ϕ(['balance_40', 'balance_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_4242(uint256) = t_1 & 1048576
			TMP_4243(bool) = TMP_4242 != 0
			CONDITION TMP_4243
		Expression: balance = (balance * _ONE_E18) / _expTable20
		IRs:
			TMP_4244(uint256) = balance_41 * _ONE_E18_3
			TMP_4245(uint256) = TMP_4244 / _expTable20_3
			balance_42(uint256) := TMP_4245(uint256)
		IRs:
			balance_43(uint256) := ϕ(['balance_42', 'balance_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_4246(uint256) = t_1 & 2097152
			TMP_4247(bool) = TMP_4246 != 0
			CONDITION TMP_4247
		Expression: balance = (balance * _ONE_E18) / _expTable21
		IRs:
			TMP_4248(uint256) = balance_43 * _ONE_E18_3
			TMP_4249(uint256) = TMP_4248 / _expTable21_3
			balance_44(uint256) := TMP_4249(uint256)
		IRs:
			balance_45(uint256) := ϕ(['balance_44', 'balance_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_4250(uint256) = t_1 & 4194304
			TMP_4251(bool) = TMP_4250 != 0
			CONDITION TMP_4251
		Expression: balance = (balance * _ONE_E18) / _expTable22
		IRs:
			TMP_4252(uint256) = balance_45 * _ONE_E18_3
			TMP_4253(uint256) = TMP_4252 / _expTable22_3
			balance_46(uint256) := TMP_4253(uint256)
		IRs:
			balance_47(uint256) := ϕ(['balance_46', 'balance_1'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_4254(uint256) = t_1 & 8388608
			TMP_4255(bool) = TMP_4254 != 0
			CONDITION TMP_4255
		Expression: balance = (balance * _ONE_E18) / _expTable23
		IRs:
			TMP_4256(uint256) = balance_47 * _ONE_E18_3
			TMP_4257(uint256) = TMP_4256 / _expTable23_3
			balance_48(uint256) := TMP_4257(uint256)
		IRs:
			balance_49(uint256) := ϕ(['balance_48', 'balance_1'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_4258(uint256) = t_1 & 16777216
			TMP_4259(bool) = TMP_4258 != 0
			CONDITION TMP_4259
		Expression: balance = (balance * _ONE_E18) / _expTable24
		IRs:
			TMP_4260(uint256) = balance_49 * _ONE_E18_3
			TMP_4261(uint256) = TMP_4260 / _expTable24_3
			balance_50(uint256) := TMP_4261(uint256)
		IRs:
			balance_51(uint256) := ϕ(['balance_50', 'balance_1'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_4262(uint256) = t_1 & 33554432
			TMP_4263(bool) = TMP_4262 != 0
			CONDITION TMP_4263
		Expression: balance = (balance * _ONE_E18) / _expTable25
		IRs:
			TMP_4264(uint256) = balance_51 * _ONE_E18_3
			TMP_4265(uint256) = TMP_4264 / _expTable25_3
			balance_52(uint256) := TMP_4265(uint256)
		IRs:
			balance_53(uint256) := ϕ(['balance_52', 'balance_1'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_4266(uint256) = t_1 & 67108864
			TMP_4267(bool) = TMP_4266 != 0
			CONDITION TMP_4267
		Expression: balance = (balance * _ONE_E18) / _expTable26
		IRs:
			TMP_4268(uint256) = balance_53 * _ONE_E18_3
			TMP_4269(uint256) = TMP_4268 / _expTable26_3
			balance_54(uint256) := TMP_4269(uint256)
		IRs:
			balance_55(uint256) := ϕ(['balance_54', 'balance_1'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_4270(uint256) = t_1 & 134217728
			TMP_4271(bool) = TMP_4270 != 0
			CONDITION TMP_4271
		Expression: balance = (balance * _ONE_E18) / _expTable27
		IRs:
			TMP_4272(uint256) = balance_55 * _ONE_E18_3
			TMP_4273(uint256) = TMP_4272 / _expTable27_3
			balance_56(uint256) := TMP_4273(uint256)
		IRs:
			balance_57(uint256) := ϕ(['balance_56', 'balance_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_4274(uint256) = t_1 & 268435456
			TMP_4275(bool) = TMP_4274 != 0
			CONDITION TMP_4275
		Expression: balance = (balance * _ONE_E18) / _expTable28
		IRs:
			TMP_4276(uint256) = balance_57 * _ONE_E18_3
			TMP_4277(uint256) = TMP_4276 / _expTable28_3
			balance_58(uint256) := TMP_4277(uint256)
		IRs:
			balance_59(uint256) := ϕ(['balance_58', 'balance_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_4278(uint256) = t_1 & 536870912
			TMP_4279(bool) = TMP_4278 != 0
			CONDITION TMP_4279
		Expression: balance = (balance * _ONE_E18) / _expTable29
		IRs:
			TMP_4280(uint256) = balance_59 * _ONE_E18_3
			TMP_4281(uint256) = TMP_4280 / _expTable29_3
			balance_60(uint256) := TMP_4281(uint256)
		IRs:
			balance_61(uint256) := ϕ(['balance_60', 'balance_1'])
		Expression: balance
		IRs:
			RETURN balance_61
		Expression: timestamp < origin
		IRs:
			TMP_4282(bool) = timestamp_1 < origin_3
			CONDITION TMP_4282
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_3(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: balance
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_4283(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_4283)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_4285(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_4286(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_4287(bool) = TMP_4285 == TMP_4286
			TMP_4288(None) = SOLIDITY_CALL require(bool,string)(TMP_4287,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_4289 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_4289)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_4292 = CONVERT 0 to address
			TMP_4293(bool) = newOwner_1 != TMP_4292
			TMP_4294(None) = SOLIDITY_CALL require(bool,string)(TMP_4293,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['TMP_4289', 'newOwner_1', 'TMP_4283'])
			_owner_2(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20Pods.constructor(uint256,uint256)
		IRs:
			_guard_1(ReentrancyGuardLib.Data) := ϕ(['_guard_5', '_guard_0', '_guard_7', '_guard_3'])
		Expression: podsLimit_ == 0
		IRs:
			TMP_4298(bool) = podsLimit__1 == 0
			CONDITION TMP_4298
		Expression: revert ZeroPodsLimit()()
		IRs:
			TMP_4299(None) = SOLIDITY_CALL revert ZeroPodsLimit()()
		Expression: podsLimit = podsLimit_
		IRs:
			podsLimit_1(uint256) := podsLimit__1(uint256)
		Expression: podCallGasLimit = podCallGasLimit_
		IRs:
			podCallGasLimit_1(uint256) := podCallGasLimit__1(uint256)
		Expression: _guard.init()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.init(ReentrancyGuardLib.Data), arguments:['_guard_1'] 
	Function ERC20Pods.hasPod(address,address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			pod_1(address) := ϕ(['defaultFarm_5', 'pod_1'])
			_pods_1(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_0', '_pods_4', '_pods_7', '_pods_6', '_pods_9', '_pods_2', '_pods_3', '_pods_1'])
		Expression: _pods[account].contains(pod)
		IRs:
			REF_1031(AddressSet.Data) -> _pods_1[account_1]
			TMP_4301(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.contains(AddressSet.Data,address), arguments:['REF_1031', 'pod_1'] 
			RETURN TMP_4301
	Function ERC20Pods.podsCount(address)
		IRs:
			_pods_2(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_0', '_pods_4', '_pods_7', '_pods_6', '_pods_9', '_pods_2', '_pods_3', '_pods_1'])
		Expression: _pods[account].length()
		IRs:
			REF_1033(AddressSet.Data) -> _pods_2[account_1]
			TMP_4302(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_1033'] 
			RETURN TMP_4302
	Function ERC20Pods.podAt(address,uint256)
		IRs:
			_pods_3(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_0', '_pods_4', '_pods_7', '_pods_6', '_pods_9', '_pods_2', '_pods_3', '_pods_1'])
		Expression: _pods[account].at(index)
		IRs:
			REF_1035(AddressSet.Data) -> _pods_3[account_1]
			TMP_4303(address) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.at(AddressSet.Data,uint256), arguments:['REF_1035', 'index_1'] 
			RETURN TMP_4303
	Function ERC20Pods.pods(address)
		IRs:
			_pods_4(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_0', '_pods_4', '_pods_7', '_pods_6', '_pods_9', '_pods_2', '_pods_3', '_pods_1'])
		Expression: _pods[account].items.get()
		IRs:
			REF_1037(AddressSet.Data) -> _pods_4[account_1]
			REF_1038(AddressArray.Data) -> REF_1037.items
			TMP_4304(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1038'] 
			RETURN TMP_4304
	Function ERC20Pods.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1', 'account_1', 'account_1', 'account_1', 'account_1', 'account_1', 'msg.sender'])
			_guard_2(ReentrancyGuardLib.Data) := ϕ(['_guard_5', '_guard_0', '_guard_7', '_guard_3'])
		Expression: super.balanceOf(account)
		IRs:
			TMP_4305(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_4305
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_2)
	Function ERC20Pods.podBalanceOf(address,address)
		IRs:
			_guard_4(ReentrancyGuardLib.Data) := ϕ(['_guard_5', '_guard_0', '_guard_7', '_guard_3'])
		Expression: hasPod(account,pod)
		IRs:
			TMP_4307(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,pod_1)
			CONDITION TMP_4307
		Expression: super.balanceOf(account)
		IRs:
			TMP_4308(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_4308
		Expression: 0
		IRs:
			RETURN 0
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_4)
	Function ERC20Pods.addPod(address)
		Expression: _addPod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removePod(address)
		Expression: _removePod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._removePod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removeAllPods()
		Expression: _removeAllPods(msg.sender)
		IRs:
			INTERNAL_CALL, ERC20Pods._removeAllPods(address)(msg.sender)
	Function ERC20Pods._addPod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender', 'account_1'])
			pod_1(address) := ϕ(['defaultFarm_6', 'pod_1'])
			podsLimit_2(uint256) := ϕ(['podsLimit_1', 'podsLimit_0', 'podsLimit_3'])
			_pods_5(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_0', '_pods_4', '_pods_7', '_pods_6', '_pods_9', '_pods_2', '_pods_3', '_pods_1'])
		Expression: pod == address(0)
		IRs:
			TMP_4313 = CONVERT 0 to address
			TMP_4314(bool) = pod_1 == TMP_4313
			CONDITION TMP_4314
		Expression: revert InvalidPodAddress()()
		IRs:
			TMP_4315(None) = SOLIDITY_CALL revert InvalidPodAddress()()
		Expression: IPod(pod).token() != IERC20Pods(address(this))
		IRs:
			TMP_4316 = CONVERT pod_1 to IPod
			TMP_4317(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_4316(IPod), function:token, arguments:[]  
			podsLimit_3(uint256) := ϕ(['podsLimit_2', 'podsLimit_1', 'podsLimit_3'])
			_pods_6(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_4', '_pods_7', '_pods_6', '_pods_9', '_pods_2', '_pods_5', '_pods_3', '_pods_1'])
			TMP_4318 = CONVERT this to address
			TMP_4319 = CONVERT TMP_4318 to IERC20Pods
			TMP_4320(bool) = TMP_4317 != TMP_4319
			CONDITION TMP_4320
		Expression: revert InvalidTokenInPod()()
		IRs:
			TMP_4321(None) = SOLIDITY_CALL revert InvalidTokenInPod()()
		Expression: ! _pods[account].add(pod)
		IRs:
			REF_1041(AddressSet.Data) -> _pods_6[account_1]
			TMP_4322(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.add(AddressSet.Data,address), arguments:['REF_1041', 'pod_1'] 
			TMP_4323 = UnaryType.BANG TMP_4322 
			CONDITION TMP_4323
		Expression: revert PodAlreadyAdded()()
		IRs:
			TMP_4324(None) = SOLIDITY_CALL revert PodAlreadyAdded()()
		Expression: _pods[account].length() > podsLimit
		IRs:
			REF_1043(AddressSet.Data) -> _pods_6[account_1]
			TMP_4325(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_1043'] 
			TMP_4326(bool) = TMP_4325 > podsLimit_3
			CONDITION TMP_4326
		Expression: revert PodsLimitReachedForAccount()()
		IRs:
			TMP_4327(None) = SOLIDITY_CALL revert PodsLimitReachedForAccount()()
		Expression: PodAdded(account,pod)
		IRs:
			Emit PodAdded(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_4329(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_4329(uint256)
		Expression: balance > 0
		IRs:
			TMP_4330(bool) = balance_1 > 0
			CONDITION TMP_4330
		Expression: _updateBalances(pod,address(0),account,balance)
		IRs:
			TMP_4331 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,TMP_4331,account_1,balance_1)
	Function ERC20Pods._removePod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			pod_1(address) := ϕ(['pod_1'])
			_pods_7(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_0', '_pods_4', '_pods_7', '_pods_6', '_pods_9', '_pods_2', '_pods_3', '_pods_1'])
		Expression: ! _pods[account].remove(pod)
		IRs:
			REF_1045(AddressSet.Data) -> _pods_7[account_1]
			TMP_4333(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_1045', 'pod_1'] 
			TMP_4334 = UnaryType.BANG TMP_4333 
			CONDITION TMP_4334
		Expression: revert PodNotFound()()
		IRs:
			TMP_4335(None) = SOLIDITY_CALL revert PodNotFound()()
		Expression: PodRemoved(account,pod)
		IRs:
			Emit PodRemoved(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_4337(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_4337(uint256)
		Expression: balance > 0
		IRs:
			TMP_4338(bool) = balance_1 > 0
			CONDITION TMP_4338
		Expression: _updateBalances(pod,account,address(0),balance)
		IRs:
			TMP_4339 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,account_1,TMP_4339,balance_1)
	Function ERC20Pods._removeAllPods(address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			_pods_8(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_0', '_pods_4', '_pods_7', '_pods_6', '_pods_9', '_pods_2', '_pods_3', '_pods_1'])
		Expression: items = _pods[account].items.get()
		IRs:
			REF_1047(AddressSet.Data) -> _pods_8[account_1]
			REF_1048(AddressArray.Data) -> REF_1047.items
			TMP_4341(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1048'] 
			items_1(address[]) = ['TMP_4341(address[])']
		Expression: balance = balanceOf(account)
		IRs:
			TMP_4342(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_4342(uint256)
		Expression: i = items.length
		IRs:
			REF_1050 -> LENGTH items_1
			i_1(uint256) := REF_1050(uint256)
		Expression: i > 0
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_4343(bool) = i_2 > 0
			CONDITION TMP_4343
		Expression: _pods[account].remove(items[i - 1])
		IRs:
			REF_1051(AddressSet.Data) -> _pods_9[account_1]
			TMP_4344(uint256) = i_2 - 1
			REF_1053(address) -> items_1[TMP_4344]
			TMP_4345(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_1051', 'REF_1053'] 
		Expression: PodRemoved(account,items[i - 1])
		IRs:
			TMP_4346(uint256) = i_2 - 1
			REF_1054(address) -> items_1[TMP_4346]
			Emit PodRemoved(account_1,REF_1054)
		Expression: balance > 0
		IRs:
			TMP_4348(bool) = balance_1 > 0
			CONDITION TMP_4348
		Expression: _updateBalances(items[i - 1],account,address(0),balance)
		IRs:
			TMP_4349(uint256) = i_2 - 1
			REF_1055(address) -> items_1[TMP_4349]
			TMP_4350 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(REF_1055,account_1,TMP_4350,balance_1)
		Expression: i --
		IRs:
			TMP_4352(uint256) := i_2(uint256)
			i_3(uint256) = i_2 - 1
	Function ERC20Pods._updateBalances(address,address,address,uint256)
		IRs:
			pod_1(address) := ϕ(['pod_scope_1_1', 'pod_1', 'REF_1055', 'pod_1', 'pod_1'])
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_4388', 'TMP_4331', 'account_1'])
			to_1(address) := ϕ(['TMP_4339', 'to_1', 'TMP_4350', 'account_1', 'TMP_4382'])
			amount_1(uint256) := ϕ(['balance_1', 'balance_1', 'balance_1', 'amount_1'])
			podCallGasLimit_2(uint256) := ϕ(['podCallGasLimit_1', 'podCallGasLimit_0'])
		Expression: selector = IPod.updateBalances.selector
		IRs:
			REF_1057(bytes4) (->None) := 2048858793(bytes4)
			selector_1(bytes4) := REF_1057(bytes4)
		Expression: exception = revert InsufficientGas().selector
		IRs:
			REF_1058(bytes4) (->None) := 472281420(bytes4)
			exception_1(bytes4) := REF_1058(bytes4)
		Expression: gasLimit = podCallGasLimit
		IRs:
			gasLimit_1(uint256) := podCallGasLimit_2(uint256)
		Expression: ptr__updateBalances_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_4353(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr__updateBalances_asm_0_1(uint256) := TMP_4353(uint256)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0,selector)
		IRs:
			TMP_4354(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr__updateBalances_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x04,from)
		IRs:
			TMP_4355(uint256) = ptr__updateBalances_asm_0_1 + 4
			TMP_4356(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_4355,from_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x24,to)
		IRs:
			TMP_4357(uint256) = ptr__updateBalances_asm_0_1 + 36
			TMP_4358(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_4357,to_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x44,amount)
		IRs:
			TMP_4359(uint256) = ptr__updateBalances_asm_0_1 + 68
			TMP_4360(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_4359,amount_1)
		Expression: gas()() * 63 / 64 < gasLimit
		IRs:
			TMP_4361(uint256) = SOLIDITY_CALL gas()()
			TMP_4362(uint256) = TMP_4361 * 63
			TMP_4363(uint256) = TMP_4362 / 64
			TMP_4364(bool) = TMP_4363 < gasLimit_1
			CONDITION TMP_4364
		Expression: mstore(uint256,uint256)(0,exception)
		IRs:
			TMP_4365(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,exception_1)
		Expression: revert(uint256,uint256)(0,4)
		IRs:
			TMP_4366(None) = SOLIDITY_CALL revert(uint256,uint256)(0,4)
		Expression: pop(uint256)(call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit,pod,0,ptr__updateBalances_asm_0,0x64,0,0))
		IRs:
			TMP_4367(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit_1,pod_1,0,ptr__updateBalances_asm_0_1,100,0,0)
			TMP_4368(None) = SOLIDITY_CALL pop(uint256)(TMP_4367)
	Function ERC20Pods._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_4428'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_4440'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_guard_6(ReentrancyGuardLib.Data) := ϕ(['_guard_5', '_guard_0', '_guard_7', '_guard_3'])
			_pods_11(mapping(address => AddressSet.Data)) := ϕ(['_pods_13', '_pods_0', '_pods_4', '_pods_7', '_pods_6', '_pods_9', '_pods_2', '_pods_3', '_pods_1'])
		Expression: super._afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: amount > 0 && from != to
		IRs:
			TMP_4370(bool) = amount_1 > 0
			TMP_4371(bool) = from_1 != to_1
			TMP_4372(bool) = TMP_4370 && TMP_4371
			CONDITION TMP_4372
		Expression: a = _pods[from].items.get()
		IRs:
			REF_1059(AddressSet.Data) -> _pods_13[from_1]
			REF_1060(AddressArray.Data) -> REF_1059.items
			TMP_4373(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1060'] 
			a_1(address[]) = ['TMP_4373(address[])']
		Expression: b = _pods[to].items.get()
		IRs:
			REF_1062(AddressSet.Data) -> _pods_13[to_1]
			REF_1063(AddressArray.Data) -> REF_1062.items
			TMP_4374(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1063'] 
			b_1(address[]) = ['TMP_4374(address[])']
		Expression: aLength = a.length
		IRs:
			REF_1065 -> LENGTH a_1
			aLength_1(uint256) := REF_1065(uint256)
		Expression: bLength = b.length
		IRs:
			REF_1066 -> LENGTH b_1
			bLength_1(uint256) := REF_1066(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < aLength
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_4375(bool) = i_2 < aLength_1
			CONDITION TMP_4375
		Expression: pod = a[i]
		IRs:
			REF_1067(address) -> a_1[i_2]
			pod_1(address) := REF_1067(address)
		IRs:
			b_3(address[]) := ϕ(['b_2', 'b_1'])
		Expression: j = 0
		IRs:
			j_1(uint256) := 0(uint256)
		Expression: j < bLength
		IRs:
			j_2(uint256) := ϕ(['j_3', 'j_1'])
			TMP_4376(bool) = j_2 < bLength_1
			CONDITION TMP_4376
		Expression: pod == b[j]
		IRs:
			REF_1068(address) -> b_1[j_2]
			TMP_4377(bool) = pod_1 == REF_1068
			CONDITION TMP_4377
		Expression: _updateBalances(pod,from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,to_1,amount_1)
		Expression: b[j] = address(0)
		IRs:
			REF_1069(address) -> b_1[j_2]
			TMP_4379 = CONVERT 0 to address
			b_2(address[]) := ϕ(['b_1'])
			REF_1069(address) (->b_2) := TMP_4379(address)
		Expression: j ++
		IRs:
			TMP_4380(uint256) := j_2(uint256)
			j_3(uint256) = j_2 + 1
		Expression: j == bLength
		IRs:
			TMP_4381(bool) = j_2 == bLength_1
			CONDITION TMP_4381
		Expression: _updateBalances(pod,from,address(0),amount)
		IRs:
			TMP_4382 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,TMP_4382,amount_1)
		Expression: i ++
		IRs:
			TMP_4384(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		Expression: j_scope_0 = 0
		IRs:
			j_scope_0_1(uint256) := 0(uint256)
		Expression: j_scope_0 < bLength
		IRs:
			j_scope_0_2(uint256) := ϕ(['j_scope_0_3', 'j_scope_0_1'])
			TMP_4385(bool) = j_scope_0_2 < bLength_1
			CONDITION TMP_4385
		Expression: pod_scope_1 = b[j_scope_0]
		IRs:
			REF_1070(address) -> b_1[j_scope_0_2]
			pod_scope_1_1(address) := REF_1070(address)
		Expression: pod_scope_1 != address(0)
		IRs:
			TMP_4386 = CONVERT 0 to address
			TMP_4387(bool) = pod_scope_1_1 != TMP_4386
			CONDITION TMP_4387
		Expression: _updateBalances(pod_scope_1,address(0),to,amount)
		IRs:
			TMP_4388 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_scope_1_1,TMP_4388,to_1,amount_1)
		Expression: j_scope_0 ++
		IRs:
			TMP_4390(uint256) := j_scope_0_2(uint256)
			j_scope_0_3(uint256) = j_scope_0_2 + 1
		Expression: nonReentrant(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)(_guard_6)
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_0', '_name_1'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_0', '_balances_11', '_balances_5'])
		Expression: _balances[account]
		IRs:
			REF_1071(uint256) -> _balances_1[account_1]
			RETURN REF_1071
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_4392(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_4392(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1', '_allowances_0', '_allowances_2'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_1072(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_1073(uint256) -> REF_1072[spender_1]
			RETURN REF_1073
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_4394(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_4394(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_4396(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_4396(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_4399(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_4399(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_4400(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_4401(uint256) = TMP_4400 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_4401)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_4403(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_4403(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_4404(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_4404(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_4405(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_4406(None) = SOLIDITY_CALL require(bool,string)(TMP_4405,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_4407(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_4407)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_0', '_balances_11', '_balances_5'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_4409 = CONVERT 0 to address
			TMP_4410(bool) = from_1 != TMP_4409
			TMP_4411(None) = SOLIDITY_CALL require(bool,string)(TMP_4410,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_4412 = CONVERT 0 to address
			TMP_4413(bool) = to_1 != TMP_4412
			TMP_4414(None) = SOLIDITY_CALL require(bool,string)(TMP_4413,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_1074(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_1074(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_4416(bool) = fromBalance_1 >= amount_1
			TMP_4417(None) = SOLIDITY_CALL require(bool,string)(TMP_4416,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_1075(uint256) -> _balances_3[from_1]
			TMP_4418(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_1075(uint256) (->_balances_4) := TMP_4418(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_1076(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_1076(-> _balances_5) = REF_1076 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['balanceDiff_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_0', '_balances_11', '_balances_5'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_4421 = CONVERT 0 to address
			TMP_4422(bool) = account_1 != TMP_4421
			TMP_4423(None) = SOLIDITY_CALL require(bool,string)(TMP_4422,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_4424 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_4424,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_1077(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_1077(-> _balances_8) = REF_1077 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_4426 = CONVERT 0 to address
			Emit Transfer(TMP_4426,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_4428 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(TMP_4428,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			amount_1(uint256) := ϕ(['balance_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_0', '_balances_11', '_balances_5'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_0', '_totalSupply_7'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_4430 = CONVERT 0 to address
			TMP_4431(bool) = account_1 != TMP_4430
			TMP_4432(None) = SOLIDITY_CALL require(bool,string)(TMP_4431,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_4433 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_4433,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_1078(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_1078(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_4435(bool) = accountBalance_1 >= amount_1
			TMP_4436(None) = SOLIDITY_CALL require(bool,string)(TMP_4435,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_1079(uint256) -> _balances_10[account_1]
			TMP_4437(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_1079(uint256) (->_balances_11) := TMP_4437(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_4438 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_4438,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_4440 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(account_1,TMP_4440,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_4455', 'TMP_4407', 'amount_1', 'TMP_4401'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_4442 = CONVERT 0 to address
			TMP_4443(bool) = owner_1 != TMP_4442
			TMP_4444(None) = SOLIDITY_CALL require(bool,string)(TMP_4443,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_4445 = CONVERT 0 to address
			TMP_4446(bool) = spender_1 != TMP_4445
			TMP_4447(None) = SOLIDITY_CALL require(bool,string)(TMP_4446,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_1080(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_1081(uint256) -> REF_1080[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_1081(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_4449(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_4449(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_4451(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_4452(bool) = currentAllowance_1 != TMP_4451
			CONDITION TMP_4452
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_4453(bool) = currentAllowance_1 >= amount_1
			TMP_4454(None) = SOLIDITY_CALL require(bool,string)(TMP_4453,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_4455(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_4455)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'TMP_4424', 'from_1'])
			to_1(address) := ϕ(['account_1', 'TMP_4433', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function St1inch.constructor(IERC20,uint256,address)
		IRs:
			oneInch__1(IERC20) := ϕ(['oneInch__1'])
			expBase__1(uint256) := ϕ(['expBase__1'])
			feeReceiver__1(address) := ϕ(['feeReceiver__1'])
			MAX_LOCK_PERIOD_1(uint256) := ϕ(['MAX_LOCK_PERIOD_0', 'MAX_LOCK_PERIOD_6'])
			_VOTING_POWER_DIVIDER_1(uint256) := ϕ(['_VOTING_POWER_DIVIDER_6', '_VOTING_POWER_DIVIDER_9', '_VOTING_POWER_DIVIDER_11', '_VOTING_POWER_DIVIDER_0'])
			_PODS_LIMIT_1(uint256) := ϕ(['_PODS_LIMIT_2', '_PODS_LIMIT_0'])
			_POD_CALL_GAS_LIMIT_1(uint256) := ϕ(['_POD_CALL_GAS_LIMIT_2', '_POD_CALL_GAS_LIMIT_0'])
		Expression: _votingPowerAt(1e18,block.timestamp + MAX_LOCK_PERIOD) * _VOTING_POWER_DIVIDER < 1e18
		IRs:
			TMP_4457(uint256) = block.timestamp (c)+ MAX_LOCK_PERIOD_4
			TMP_4458(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(1000000000000000000,TMP_4457)
			TMP_4459(uint256) = TMP_4458 (c)* _VOTING_POWER_DIVIDER_5
			TMP_4460(bool) = TMP_4459 < 1000000000000000000
			CONDITION TMP_4460
		Expression: revert ExpBaseTooBig()()
		IRs:
			TMP_4461(None) = SOLIDITY_CALL revert ExpBaseTooBig()()
		Expression: _votingPowerAt(1e18,block.timestamp + MAX_LOCK_PERIOD + 1) * _VOTING_POWER_DIVIDER > 1e18
		IRs:
			TMP_4462(uint256) = block.timestamp (c)+ MAX_LOCK_PERIOD_5
			TMP_4463(uint256) = TMP_4462 (c)+ 1
			TMP_4464(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(1000000000000000000,TMP_4463)
			TMP_4465(uint256) = TMP_4464 (c)* _VOTING_POWER_DIVIDER_6
			TMP_4466(bool) = TMP_4465 > 1000000000000000000
			CONDITION TMP_4466
		Expression: revert ExpBaseTooSmall()()
		IRs:
			TMP_4467(None) = SOLIDITY_CALL revert ExpBaseTooSmall()()
		Expression: setFeeReceiver(feeReceiver_)
		IRs:
			INTERNAL_CALL, St1inch.setFeeReceiver(address)(feeReceiver__1)
		Expression: oneInch = oneInch_
		IRs:
			oneInch_1(IERC20) := oneInch__1(IERC20)
		Expression: ERC20Pods(_PODS_LIMIT,_POD_CALL_GAS_LIMIT)
		IRs:
			INTERNAL_CALL, ERC20Pods.constructor(uint256,uint256)(_PODS_LIMIT_1,_POD_CALL_GAS_LIMIT_1)
		Expression: ERC20(Staking 1INCH v2,st1INCH)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(Staking 1INCH v2,st1INCH)
		Expression: VotingPowerCalculator(expBase_,block.timestamp)
		IRs:
			INTERNAL_CALL, VotingPowerCalculator.constructor(uint256,uint256)(expBase__1,block.timestamp)
	Function St1inch.setFeeReceiver(address)
		IRs:
			feeReceiver__1(address) := ϕ(['feeReceiver__1'])
		Expression: feeReceiver_ == address(0)
		IRs:
			TMP_4472 = CONVERT 0 to address
			TMP_4473(bool) = feeReceiver__1 == TMP_4472
			CONDITION TMP_4473
		Expression: revert ZeroAddress()()
		IRs:
			TMP_4474(None) = SOLIDITY_CALL revert ZeroAddress()()
		Expression: feeReceiver = feeReceiver_
		IRs:
			feeReceiver_1(address) := feeReceiver__1(address)
		Expression: FeeReceiverSet(feeReceiver_)
		IRs:
			Emit FeeReceiverSet(feeReceiver__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.setDefaultFarm(address)
		Expression: defaultFarm_ != address(0) && Pod(defaultFarm_).token() != this
		IRs:
			TMP_4477 = CONVERT 0 to address
			TMP_4478(bool) = defaultFarm__1 != TMP_4477
			TMP_4479 = CONVERT defaultFarm__1 to Pod
			TMP_4480(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_4479(Pod), function:token, arguments:[]  
			TMP_4481(bool) = TMP_4480 != this
			TMP_4482(bool) = TMP_4478 && TMP_4481
			CONDITION TMP_4482
		Expression: revert DefaultFarmTokenMismatch()()
		IRs:
			TMP_4483(None) = SOLIDITY_CALL revert DefaultFarmTokenMismatch()()
		Expression: defaultFarm = defaultFarm_
		IRs:
			defaultFarm_1(address) := defaultFarm__1(address)
		Expression: DefaultFarmSet(defaultFarm_)
		IRs:
			Emit DefaultFarmSet(defaultFarm__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.setMaxLossRatio(uint256)
		IRs:
			_ONE_E9_1(uint256) := ϕ(['_ONE_E9_7', '_ONE_E9_0', '_ONE_E9_10', '_ONE_E9_2', '_ONE_E9_4'])
		Expression: maxLossRatio_ > _ONE_E9
		IRs:
			TMP_4486(bool) = maxLossRatio__1 > _ONE_E9_2
			CONDITION TMP_4486
		Expression: revert MaxLossOverflow()()
		IRs:
			TMP_4487(None) = SOLIDITY_CALL revert MaxLossOverflow()()
		Expression: maxLossRatio = maxLossRatio_
		IRs:
			maxLossRatio_1(uint256) := maxLossRatio__1(uint256)
		Expression: MaxLossRatioSet(maxLossRatio_)
		IRs:
			Emit MaxLossRatioSet(maxLossRatio__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.setMinLockPeriodRatio(uint256)
		IRs:
			_ONE_E9_3(uint256) := ϕ(['_ONE_E9_7', '_ONE_E9_0', '_ONE_E9_10', '_ONE_E9_2', '_ONE_E9_4'])
		Expression: minLockPeriodRatio_ > _ONE_E9
		IRs:
			TMP_4490(bool) = minLockPeriodRatio__1 > _ONE_E9_4
			CONDITION TMP_4490
		Expression: revert MaxLossOverflow()()
		IRs:
			TMP_4491(None) = SOLIDITY_CALL revert MaxLossOverflow()()
		Expression: minLockPeriodRatio = minLockPeriodRatio_
		IRs:
			minLockPeriodRatio_1(uint256) := minLockPeriodRatio__1(uint256)
		Expression: MinLockPeriodRatioSet(minLockPeriodRatio_)
		IRs:
			Emit MinLockPeriodRatioSet(minLockPeriodRatio__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.setEmergencyExit(bool)
		Expression: emergencyExit = emergencyExit_
		IRs:
			emergencyExit_1(bool) := emergencyExit__1(bool)
		Expression: EmergencyExitSet(emergencyExit_)
		IRs:
			Emit EmergencyExitSet(emergencyExit__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.votingPowerOf(address)
		Expression: _votingPowerAt(balanceOf(account),block.timestamp)
		IRs:
			TMP_4496(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			TMP_4497(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(TMP_4496,block.timestamp)
			RETURN TMP_4497
	Function St1inch.votingPowerOfAt(address,uint256)
		Expression: _votingPowerAt(balanceOf(account),timestamp)
		IRs:
			TMP_4498(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			TMP_4499(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(TMP_4498,timestamp_1)
			RETURN TMP_4499
	Function St1inch.votingPower(uint256)
		Expression: _votingPowerAt(balance,block.timestamp)
		IRs:
			TMP_4500(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(balance_1,block.timestamp)
			RETURN TMP_4500
	Function St1inch.votingPowerAt(uint256,uint256)
		Expression: _votingPowerAt(balance,timestamp)
		IRs:
			TMP_4501(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(balance_1,timestamp_1)
			RETURN TMP_4501
	Function St1inch.deposit(uint256,uint256)
		Expression: _deposit(msg.sender,amount,duration)
		IRs:
			INTERNAL_CALL, St1inch._deposit(address,uint256,uint256)(msg.sender,amount_1,duration_1)
	Function St1inch.depositWithPermit(uint256,uint256,bytes)
		IRs:
			oneInch_2(IERC20) := ϕ(['oneInch_14', 'oneInch_16', 'oneInch_7', 'oneInch_11', 'oneInch_1', 'oneInch_0'])
		Expression: oneInch.safePermit(permit)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['oneInch_2', 'permit_1'] 
		Expression: _deposit(msg.sender,amount,duration)
		IRs:
			INTERNAL_CALL, St1inch._deposit(address,uint256,uint256)(msg.sender,amount_1,duration_1)
	Function St1inch.depositFor(address,uint256)
		Expression: _deposit(account,amount,0)
		IRs:
			INTERNAL_CALL, St1inch._deposit(address,uint256,uint256)(account_1,amount_1,0)
	Function St1inch.depositForWithPermit(address,uint256,bytes)
		IRs:
			oneInch_3(IERC20) := ϕ(['oneInch_14', 'oneInch_16', 'oneInch_7', 'oneInch_11', 'oneInch_1', 'oneInch_0'])
		Expression: oneInch.safePermit(permit)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['oneInch_3', 'permit_1'] 
		Expression: _deposit(account,amount,0)
		IRs:
			INTERNAL_CALL, St1inch._deposit(address,uint256,uint256)(account_1,amount_1,0)
	Function St1inch._deposit(address,uint256,uint256)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1', 'msg.sender'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1', 'amount_1'])
			duration_1(uint256) := ϕ(['duration_1', 'duration_1'])
			MIN_LOCK_PERIOD_1(uint256) := ϕ(['MIN_LOCK_PERIOD_0'])
			MAX_LOCK_PERIOD_7(uint256) := ϕ(['MAX_LOCK_PERIOD_0', 'MAX_LOCK_PERIOD_6'])
			_VOTING_POWER_DIVIDER_7(uint256) := ϕ(['_VOTING_POWER_DIVIDER_6', '_VOTING_POWER_DIVIDER_9', '_VOTING_POWER_DIVIDER_11', '_VOTING_POWER_DIVIDER_0'])
			oneInch_4(IERC20) := ϕ(['oneInch_14', 'oneInch_16', 'oneInch_7', 'oneInch_11', 'oneInch_1', 'oneInch_0'])
			depositors_1(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5', 'depositors_3', 'depositors_0', 'depositors_4', 'depositors_6', 'depositors_2'])
			totalDeposits_1(uint256) := ϕ(['totalDeposits_0', 'totalDeposits_8', 'totalDeposits_4', 'totalDeposits_6'])
			emergencyExit_2(bool) := ϕ(['emergencyExit_0', 'emergencyExit_1'])
			defaultFarm_2(address) := ϕ(['defaultFarm_7', 'defaultFarm_6', 'defaultFarm_1', 'defaultFarm_0'])
		Expression: emergencyExit
		IRs:
			CONDITION emergencyExit_2
		Expression: revert DepositsDisabled()()
		IRs:
			TMP_4508(None) = SOLIDITY_CALL revert DepositsDisabled()()
		Expression: depositor = depositors[account]
		IRs:
			REF_1085(St1inch.Depositor) -> depositors_1[account_1]
			depositor_1(St1inch.Depositor) := REF_1085(St1inch.Depositor)
		Expression: lockedTill = Math.max(depositor.unlockTime,block.timestamp) + duration
		IRs:
			REF_1087(uint40) -> depositor_1.unlockTime
			TMP_4509(uint256) = LIBRARY_CALL, dest:Math, function:Math.max(uint256,uint256), arguments:['REF_1087', 'block.timestamp'] 
			TMP_4510(uint256) = TMP_4509 (c)+ duration_1
			lockedTill_1(uint256) := TMP_4510(uint256)
		Expression: lockLeft = lockedTill - block.timestamp
		IRs:
			TMP_4511(uint256) = lockedTill_1 (c)- block.timestamp
			lockLeft_1(uint256) := TMP_4511(uint256)
		Expression: lockLeft < MIN_LOCK_PERIOD
		IRs:
			TMP_4512(bool) = lockLeft_1 < MIN_LOCK_PERIOD_1
			CONDITION TMP_4512
		Expression: revert LockTimeLessMinLock()()
		IRs:
			TMP_4513(None) = SOLIDITY_CALL revert LockTimeLessMinLock()()
		Expression: lockLeft > MAX_LOCK_PERIOD
		IRs:
			TMP_4514(bool) = lockLeft_1 > MAX_LOCK_PERIOD_7
			CONDITION TMP_4514
		Expression: revert LockTimeMoreMaxLock()()
		IRs:
			TMP_4515(None) = SOLIDITY_CALL revert LockTimeMoreMaxLock()()
		Expression: balanceDiff = _balanceAt(depositor.amount + amount,lockedTill) / _VOTING_POWER_DIVIDER - balanceOf(account)
		IRs:
			REF_1088(uint176) -> depositor_1.amount
			TMP_4516(uint176) = REF_1088 (c)+ amount_1
			TMP_4517(uint256) = INTERNAL_CALL, VotingPowerCalculator._balanceAt(uint256,uint256)(TMP_4516,lockedTill_1)
			TMP_4518(uint256) = TMP_4517 (c)/ _VOTING_POWER_DIVIDER_8
			TMP_4519(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			TMP_4520(uint256) = TMP_4518 (c)- TMP_4519
			balanceDiff_1(uint256) := TMP_4520(uint256)
		Expression: depositor.unlockTime = uint40(lockedTill)
		IRs:
			REF_1089(uint40) -> depositor_4.unlockTime
			TMP_4521 = CONVERT lockedTill_1 to uint40
			depositor_5(St1inch.Depositor) := ϕ(['depositor_4'])
			REF_1089(uint40) (->depositor_5) := TMP_4521(uint40)
		Expression: depositor.amount += uint176(amount)
		IRs:
			REF_1090(uint176) -> depositor_5.amount
			TMP_4522 = CONVERT amount_1 to uint176
			depositor_6(St1inch.Depositor) := ϕ(['depositor_5'])
			REF_1090(-> depositor_6) = REF_1090 (c)+ TMP_4522
		Expression: depositors[account] = depositor
		IRs:
			REF_1091(St1inch.Depositor) -> depositors_1[account_1]
			depositors_2(mapping(address => St1inch.Depositor)) := ϕ(['depositors_1'])
			REF_1091(St1inch.Depositor) (->depositors_2) := depositor_6(St1inch.Depositor)
		Expression: totalDeposits += amount
		IRs:
			totalDeposits_4(uint256) = totalDeposits_3 (c)+ amount_1
		Expression: _mint(account,balanceDiff)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account_1,balanceDiff_1)
		Expression: amount > 0
		IRs:
			TMP_4524(bool) = amount_1 > 0
			CONDITION TMP_4524
		Expression: oneInch.safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_4525 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['oneInch_7', 'msg.sender', 'TMP_4525', 'amount_1'] 
		Expression: defaultFarm != address(0) && ! hasPod(account,defaultFarm)
		IRs:
			TMP_4527 = CONVERT 0 to address
			TMP_4528(bool) = defaultFarm_5 != TMP_4527
			TMP_4529(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,defaultFarm_5)
			TMP_4530 = UnaryType.BANG TMP_4529 
			TMP_4531(bool) = TMP_4528 && TMP_4530
			CONDITION TMP_4531
		Expression: _addPod(account,defaultFarm)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(account_1,defaultFarm_6)
		Expression: duration == 0
		IRs:
			TMP_4533(bool) = duration_1 == 0
			CONDITION TMP_4533
		Expression: depositor.lockTime = uint40(depositor.lockTime)
		IRs:
			REF_1093(uint40) -> depositor_1.lockTime
			REF_1094(uint40) -> depositor_1.lockTime
			TMP_4534 = CONVERT REF_1094 to uint40
			depositor_3(St1inch.Depositor) := ϕ(['depositor_1'])
			REF_1093(uint40) (->depositor_3) := TMP_4534(uint40)
		Expression: depositor.lockTime = uint40(block.timestamp)
		IRs:
			REF_1095(uint40) -> depositor_1.lockTime
			TMP_4535 = CONVERT block.timestamp to uint40
			depositor_2(St1inch.Depositor) := ϕ(['depositor_1'])
			REF_1095(uint40) (->depositor_2) := TMP_4535(uint40)
		IRs:
			depositor_4(St1inch.Depositor) := ϕ(['depositor_2', 'depositor_3'])
	Function St1inch.earlyWithdraw(uint256,uint256)
		Expression: earlyWithdrawTo(msg.sender,minReturn,maxLoss)
		IRs:
			INTERNAL_CALL, St1inch.earlyWithdrawTo(address,uint256,uint256)(msg.sender,minReturn_1,maxLoss_1)
	Function St1inch.earlyWithdrawTo(address,uint256,uint256)
		IRs:
			to_1(address) := ϕ(['msg.sender'])
			minReturn_1(uint256) := ϕ(['minReturn_1'])
			maxLoss_1(uint256) := ϕ(['maxLoss_1'])
			_ONE_E9_5(uint256) := ϕ(['_ONE_E9_7', '_ONE_E9_0', '_ONE_E9_10', '_ONE_E9_2', '_ONE_E9_4'])
			oneInch_8(IERC20) := ϕ(['oneInch_14', 'oneInch_16', 'oneInch_7', 'oneInch_11', 'oneInch_1', 'oneInch_0'])
			depositors_3(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5', 'depositors_3', 'depositors_0', 'depositors_4', 'depositors_6', 'depositors_2'])
			emergencyExit_3(bool) := ϕ(['emergencyExit_0', 'emergencyExit_1'])
			maxLossRatio_2(uint256) := ϕ(['maxLossRatio_1', 'maxLossRatio_4', 'maxLossRatio_7', 'maxLossRatio_0'])
			minLockPeriodRatio_2(uint256) := ϕ(['minLockPeriodRatio_0', 'minLockPeriodRatio_1'])
			feeReceiver_2(address) := ϕ(['feeReceiver_5', 'feeReceiver_0', 'feeReceiver_1'])
		Expression: depositor = depositors[msg.sender]
		IRs:
			REF_1096(St1inch.Depositor) -> depositors_3[msg.sender]
			depositor_1(St1inch.Depositor) := REF_1096(St1inch.Depositor)
		Expression: emergencyExit || block.timestamp >= depositor.unlockTime
		IRs:
			REF_1097(uint40) -> depositor_1.unlockTime
			TMP_4537(bool) = block.timestamp >= REF_1097
			TMP_4538(bool) = emergencyExit_3 || TMP_4537
			CONDITION TMP_4538
		Expression: revert StakeUnlocked()()
		IRs:
			TMP_4539(None) = SOLIDITY_CALL revert StakeUnlocked()()
		Expression: allowedExitTime = depositor.lockTime + (depositor.unlockTime - depositor.lockTime) * minLockPeriodRatio / _ONE_E9
		IRs:
			REF_1098(uint40) -> depositor_1.lockTime
			REF_1099(uint40) -> depositor_1.unlockTime
			REF_1100(uint40) -> depositor_1.lockTime
			TMP_4540(uint40) = REF_1099 (c)- REF_1100
			TMP_4541(uint40) = TMP_4540 (c)* minLockPeriodRatio_2
			TMP_4542(uint40) = TMP_4541 (c)/ _ONE_E9_5
			TMP_4543(uint40) = REF_1098 (c)+ TMP_4542
			allowedExitTime_1(uint256) := TMP_4543(uint40)
		Expression: block.timestamp < allowedExitTime
		IRs:
			TMP_4544(bool) = block.timestamp < allowedExitTime_1
			CONDITION TMP_4544
		Expression: revert MinLockPeriodRatioNotReached()()
		IRs:
			TMP_4545(None) = SOLIDITY_CALL revert MinLockPeriodRatioNotReached()()
		Expression: amount = depositor.amount
		IRs:
			REF_1101(uint176) -> depositor_1.amount
			amount_1(uint256) := REF_1101(uint176)
		Expression: amount > 0
		IRs:
			TMP_4546(bool) = amount_1 > 0
			CONDITION TMP_4546
		Expression: balance = balanceOf(msg.sender)
		IRs:
			TMP_4547(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(msg.sender)
			balance_1(uint256) := TMP_4547(uint256)
		Expression: (loss,ret) = _earlyWithdrawLoss(amount,balance)
		IRs:
			TUPLE_70(uint256,uint256) = INTERNAL_CALL, St1inch._earlyWithdrawLoss(uint256,uint256)(amount_1,balance_1)
			loss_1(uint256)= UNPACK TUPLE_70 index: 0 
			ret_1(uint256)= UNPACK TUPLE_70 index: 1 
		Expression: ret < minReturn
		IRs:
			TMP_4548(bool) = ret_1 < minReturn_1
			CONDITION TMP_4548
		Expression: revert MinReturnIsNotMet()()
		IRs:
			TMP_4549(None) = SOLIDITY_CALL revert MinReturnIsNotMet()()
		Expression: loss > maxLoss
		IRs:
			TMP_4550(bool) = loss_1 > maxLoss_1
			CONDITION TMP_4550
		Expression: revert MaxLossIsNotMet()()
		IRs:
			TMP_4551(None) = SOLIDITY_CALL revert MaxLossIsNotMet()()
		Expression: loss > amount * maxLossRatio / _ONE_E9
		IRs:
			TMP_4552(uint256) = amount_1 (c)* maxLossRatio_4
			TMP_4553(uint256) = TMP_4552 (c)/ _ONE_E9_7
			TMP_4554(bool) = loss_1 > TMP_4553
			CONDITION TMP_4554
		Expression: revert LossIsTooBig()()
		IRs:
			TMP_4555(None) = SOLIDITY_CALL revert LossIsTooBig()()
		Expression: _withdraw(depositor,balance)
		IRs:
			INTERNAL_CALL, St1inch._withdraw(St1inch.Depositor,uint256)(depositor_1,balance_1)
		Expression: oneInch.safeTransfer(to,ret)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['oneInch_11', 'to_1', 'ret_1'] 
		Expression: oneInch.safeTransfer(feeReceiver,loss)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['oneInch_11', 'feeReceiver_5', 'loss_1'] 
	Function St1inch.earlyWithdrawLoss(address)
		IRs:
			_ONE_E9_8(uint256) := ϕ(['_ONE_E9_7', '_ONE_E9_0', '_ONE_E9_10', '_ONE_E9_2', '_ONE_E9_4'])
			depositors_4(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5', 'depositors_3', 'depositors_0', 'depositors_4', 'depositors_6', 'depositors_2'])
			maxLossRatio_5(uint256) := ϕ(['maxLossRatio_1', 'maxLossRatio_4', 'maxLossRatio_7', 'maxLossRatio_0'])
		Expression: amount = depositors[account].amount
		IRs:
			REF_1104(St1inch.Depositor) -> depositors_4[account_1]
			REF_1105(uint176) -> REF_1104.amount
			amount_1(uint256) := REF_1105(uint176)
		Expression: (loss,ret) = _earlyWithdrawLoss(amount,balanceOf(account))
		IRs:
			TMP_4559(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			TUPLE_71(uint256,uint256) = INTERNAL_CALL, St1inch._earlyWithdrawLoss(uint256,uint256)(amount_1,TMP_4559)
			loss_1(uint256)= UNPACK TUPLE_71 index: 0 
			ret_1(uint256)= UNPACK TUPLE_71 index: 1 
		Expression: canWithdraw = loss <= amount * maxLossRatio / _ONE_E9
		IRs:
			TMP_4560(uint256) = amount_1 (c)* maxLossRatio_7
			TMP_4561(uint256) = TMP_4560 (c)/ _ONE_E9_10
			TMP_4562(bool) = loss_1 <= TMP_4561
			canWithdraw_1(bool) := TMP_4562(bool)
		Expression: (loss,ret,canWithdraw)
		IRs:
			RETURN loss_1,ret_1,canWithdraw_1
	Function St1inch._earlyWithdrawLoss(uint256,uint256)
		IRs:
			depAmount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			stBalance_1(uint256) := ϕ(['balance_1', 'TMP_4559'])
			_VOTING_POWER_DIVIDER_10(uint256) := ϕ(['_VOTING_POWER_DIVIDER_6', '_VOTING_POWER_DIVIDER_9', '_VOTING_POWER_DIVIDER_11', '_VOTING_POWER_DIVIDER_0'])
		Expression: ret = (depAmount - _votingPowerAt(stBalance,block.timestamp)) * _VOTING_POWER_DIVIDER / (_VOTING_POWER_DIVIDER - 1)
		IRs:
			TMP_4563(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(stBalance_1,block.timestamp)
			TMP_4564(uint256) = depAmount_1 (c)- TMP_4563
			TMP_4565(uint256) = TMP_4564 (c)* _VOTING_POWER_DIVIDER_11
			TMP_4566(uint256) = _VOTING_POWER_DIVIDER_11 (c)- 1
			TMP_4567(uint256) = TMP_4565 (c)/ TMP_4566
			ret_1(uint256) := TMP_4567(uint256)
		Expression: loss = depAmount - ret
		IRs:
			TMP_4568(uint256) = depAmount_1 (c)- ret_1
			loss_1(uint256) := TMP_4568(uint256)
		Expression: (loss,ret)
		IRs:
			RETURN loss_1,ret_1
	Function St1inch.withdraw()
		Expression: withdrawTo(msg.sender)
		IRs:
			INTERNAL_CALL, St1inch.withdrawTo(address)(msg.sender)
	Function St1inch.withdrawTo(address)
		IRs:
			to_1(address) := ϕ(['msg.sender'])
			oneInch_12(IERC20) := ϕ(['oneInch_14', 'oneInch_16', 'oneInch_7', 'oneInch_11', 'oneInch_1', 'oneInch_0'])
			depositors_5(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5', 'depositors_3', 'depositors_0', 'depositors_4', 'depositors_6', 'depositors_2'])
			emergencyExit_4(bool) := ϕ(['emergencyExit_0', 'emergencyExit_1'])
		Expression: depositor = depositors[msg.sender]
		IRs:
			REF_1106(St1inch.Depositor) -> depositors_5[msg.sender]
			depositor_1(St1inch.Depositor) := REF_1106(St1inch.Depositor)
		Expression: ! emergencyExit && block.timestamp < depositor.unlockTime
		IRs:
			TMP_4570 = UnaryType.BANG emergencyExit_4 
			REF_1107(uint40) -> depositor_1.unlockTime
			TMP_4571(bool) = block.timestamp < REF_1107
			TMP_4572(bool) = TMP_4570 && TMP_4571
			CONDITION TMP_4572
		Expression: revert UnlockTimeHasNotCome()()
		IRs:
			TMP_4573(None) = SOLIDITY_CALL revert UnlockTimeHasNotCome()()
		Expression: amount = depositor.amount
		IRs:
			REF_1108(uint176) -> depositor_1.amount
			amount_1(uint256) := REF_1108(uint176)
		Expression: amount > 0
		IRs:
			TMP_4574(bool) = amount_1 > 0
			CONDITION TMP_4574
		Expression: _withdraw(depositor,balanceOf(msg.sender))
		IRs:
			TMP_4575(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(msg.sender)
			INTERNAL_CALL, St1inch._withdraw(St1inch.Depositor,uint256)(depositor_1,TMP_4575)
		Expression: oneInch.safeTransfer(to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['oneInch_14', 'to_1', 'amount_1'] 
	Function St1inch._withdraw(St1inch.Depositor,uint256)
		IRs:
			depositor_1(St1inch.Depositor) := ϕ(['depositor_1', 'depositor_1'])
			balance_1(uint256) := ϕ(['balance_1', 'TMP_4575'])
			totalDeposits_5(uint256) := ϕ(['totalDeposits_0', 'totalDeposits_8', 'totalDeposits_4', 'totalDeposits_6'])
		Expression: totalDeposits -= depositor.amount
		IRs:
			REF_1110(uint176) -> depositor_1.amount
			totalDeposits_6(uint256) = totalDeposits_5 (c)- REF_1110
		Expression: depositor.amount = 0
		IRs:
			REF_1111(uint176) -> depositor_1.amount
			depositor_2(St1inch.Depositor) := ϕ(['depositor_1'])
			REF_1111(uint176) (->depositor_2) := 0(uint256)
		Expression: depositor.unlockTime = uint40(block.timestamp)
		IRs:
			REF_1112(uint40) -> depositor_2.unlockTime
			TMP_4578 = CONVERT block.timestamp to uint40
			depositor_3(St1inch.Depositor) := ϕ(['depositor_2'])
			REF_1112(uint40) (->depositor_3) := TMP_4578(uint40)
		Expression: depositors[msg.sender] = depositor
		IRs:
			REF_1113(St1inch.Depositor) -> depositors_5[msg.sender]
			depositors_6(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5'])
			REF_1113(St1inch.Depositor) (->depositors_6) := depositor_3(St1inch.Depositor)
		Expression: _burn(msg.sender,balance)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(msg.sender,balance_1)
	Function St1inch.rescueFunds(IERC20,uint256)
		IRs:
			oneInch_15(IERC20) := ϕ(['oneInch_14', 'oneInch_16', 'oneInch_7', 'oneInch_11', 'oneInch_1', 'oneInch_0'])
			totalDeposits_7(uint256) := ϕ(['totalDeposits_0', 'totalDeposits_8', 'totalDeposits_4', 'totalDeposits_6'])
		Expression: address(token) == address(0)
		IRs:
			TMP_4580 = CONVERT token_1 to address
			TMP_4581 = CONVERT 0 to address
			TMP_4582(bool) = TMP_4580 == TMP_4581
			CONDITION TMP_4582
		Expression: Address.sendValue(address(msg.sender),amount)
		IRs:
			TMP_4583 = CONVERT msg.sender to address
			LIBRARY_CALL, dest:Address, function:Address.sendValue(address,uint256), arguments:['TMP_4583', 'amount_1'] 
		Expression: token == oneInch
		IRs:
			TMP_4585(bool) = token_1 == oneInch_16
			CONDITION TMP_4585
		Expression: amount > oneInch.balanceOf(address(this)) - totalDeposits
		IRs:
			TMP_4586 = CONVERT this to address
			TMP_4587(uint256) = HIGH_LEVEL_CALL, dest:oneInch_16(IERC20), function:balanceOf, arguments:['TMP_4586']  
			oneInch_17(IERC20) := ϕ(['oneInch_14', 'oneInch_16', 'oneInch_7', 'oneInch_1', 'oneInch_11'])
			totalDeposits_9(uint256) := ϕ(['totalDeposits_8', 'totalDeposits_4', 'totalDeposits_6'])
			TMP_4588(uint256) = TMP_4587 (c)- totalDeposits_9
			TMP_4589(bool) = amount_1 > TMP_4588
			CONDITION TMP_4589
		Expression: revert RescueAmountIsTooLarge()()
		IRs:
			TMP_4590(None) = SOLIDITY_CALL revert RescueAmountIsTooLarge()()
		Expression: token.safeTransfer(msg.sender,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['token_1', 'msg.sender', 'amount_1'] 
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_4593(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function St1inch.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_4594(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function St1inch.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_4595(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function St1inch.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_4596(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function St1inch.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_4597(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function St1inch.slitherConstructorConstantVariables()
		Expression: MIN_LOCK_PERIOD = 2592000
		Expression: MAX_LOCK_PERIOD = 2 * 31536000
		Expression: _VOTING_POWER_DIVIDER = 20
		Expression: _PODS_LIMIT = 5
		Expression: _POD_CALL_GAS_LIMIT = 500_000
		Expression: _ONE_E9 = 1e9
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
	Modifier ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_6'])
EXPRESSION self.enter()
		Expression: self.enter()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.enter(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
_
EXPRESSION self.exit()
		Expression: self.exit()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.exit(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
	Modifier ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard', '_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_2', '_guard_4'])
IF self.check()
		Expression: self.check()
		IRs:
			TMP_4602(bool) = LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.check(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard', '_guard'])"] 
			CONDITION TMP_4602
EXPRESSION ReentrancyGuardLib.ReentrantCall()
		Expression: ReentrancyGuardLib.ReentrantCall()
		IRs:
			TMP_4603(None) = SOLIDITY_CALL revert ReentrantCall()()
END_IF
_
Contract StakingFarmingPod
	Function FarmingPod.constructor(IERC20Pods,IERC20)
		Expression: address(farmableToken_) == address(0)
		IRs:
			TMP_4604 = CONVERT farmableToken__1 to address
			TMP_4605 = CONVERT 0 to address
			TMP_4606(bool) = TMP_4604 == TMP_4605
			CONDITION TMP_4606
		Expression: revert ZeroFarmableTokenAddress()()
		IRs:
			TMP_4607(None) = SOLIDITY_CALL revert ZeroFarmableTokenAddress()()
		Expression: address(rewardsToken_) == address(0)
		IRs:
			TMP_4608 = CONVERT rewardsToken__1 to address
			TMP_4609 = CONVERT 0 to address
			TMP_4610(bool) = TMP_4608 == TMP_4609
			CONDITION TMP_4610
		Expression: revert ZeroRewardsTokenAddress()()
		IRs:
			TMP_4611(None) = SOLIDITY_CALL revert ZeroRewardsTokenAddress()()
		Expression: rewardsToken = rewardsToken_
		IRs:
			rewardsToken_1(IERC20) := rewardsToken__1(IERC20)
		Expression: FarmCreated(address(farmableToken_),address(rewardsToken_))
		IRs:
			TMP_4612 = CONVERT farmableToken__1 to address
			TMP_4613 = CONVERT rewardsToken__1 to address
			Emit FarmCreated(TMP_4612,TMP_4613)
		Expression: Pod(farmableToken_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(farmableToken__1)
	Function FarmingPod.farmInfo()
		IRs:
			_farm_1(FarmingLib.Data) := ϕ(['_farm_1', '_farm_0'])
		Expression: _farm.farmInfo
		IRs:
			REF_1120(FarmAccounting.Info) -> _farm_1.farmInfo
			RETURN REF_1120
	Function FarmingPod.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_3', '_totalSupply_5', '_totalSupply_0', '_totalSupply_4'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function FarmingPod.distributor()
		IRs:
			_distributor_1(address) := ϕ(['_distributor_6', '_distributor_4', '_distributor_0'])
		Expression: _distributor
		IRs:
			RETURN _distributor_1
	Function FarmingPod.setDistributor(address)
		IRs:
			_distributor_2(address) := ϕ(['_distributor_6', '_distributor_4', '_distributor_0'])
		Expression: oldDistributor = _distributor
		IRs:
			oldDistributor_1(address) := _distributor_3(address)
		Expression: distributor_ == oldDistributor
		IRs:
			TMP_4616(bool) = distributor__1 == oldDistributor_1
			CONDITION TMP_4616
		Expression: revert SameDistributor()()
		IRs:
			TMP_4617(None) = SOLIDITY_CALL revert SameDistributor()()
		Expression: DistributorChanged(oldDistributor,distributor_)
		IRs:
			Emit DistributorChanged(oldDistributor_1,distributor__1)
		Expression: _distributor = distributor_
		IRs:
			_distributor_4(address) := distributor__1(address)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function FarmingPod.startFarming(uint256,uint256)
		IRs:
			rewardsToken_2(IERC20) := ϕ(['rewardsToken_4', 'rewardsToken_8', 'rewardsToken_1', 'rewardsToken_7', 'rewardsToken_0'])
		Expression: reward = _makeInfo().startFarming(amount,period)
		IRs:
			TMP_4620(FarmingLib.Info) = INTERNAL_CALL, FarmingPod._makeInfo()()
			TMP_4621(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.startFarming(FarmingLib.Info,uint256,uint256), arguments:['TMP_4620', 'amount_1', 'period_1'] 
			reward_1(uint256) := TMP_4621(uint256)
		Expression: RewardAdded(reward,period)
		IRs:
			Emit RewardAdded(reward_1,period_1)
		Expression: rewardsToken.safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_4623 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['rewardsToken_4', 'msg.sender', 'TMP_4623', 'amount_1'] 
		Expression: onlyDistributor()
		IRs:
			MODIFIER_CALL, FarmingPod.onlyDistributor()()
	Function FarmingPod.farmed(address)
		IRs:
			token_1(IERC20Pods) := ϕ(['token_4', 'token_0', 'token_2', 'token_5'])
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),account)
		IRs:
			TMP_4626 = CONVERT token_1 to IERC20Pods
			TMP_4627 = CONVERT this to address
			TMP_4628(uint256) = HIGH_LEVEL_CALL, dest:TMP_4626(IERC20Pods), function:podBalanceOf, arguments:['TMP_4627', 'account_1']  
			token_2(IERC20Pods) := ϕ(['token_4', 'token_1', 'token_2', 'token_5'])
			balance_1(uint256) := TMP_4628(uint256)
		Expression: _makeInfo().farmed(account,balance)
		IRs:
			TMP_4629(FarmingLib.Info) = INTERNAL_CALL, FarmingPod._makeInfo()()
			TMP_4630(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.farmed(FarmingLib.Info,address,uint256), arguments:['TMP_4629', 'account_1', 'balance_1'] 
			RETURN TMP_4630
	Function FarmingPod.claim()
		IRs:
			rewardsToken_5(IERC20) := ϕ(['rewardsToken_4', 'rewardsToken_8', 'rewardsToken_1', 'rewardsToken_7', 'rewardsToken_0'])
			token_3(IERC20Pods) := ϕ(['token_4', 'token_0', 'token_2', 'token_5'])
		Expression: podBalance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_4631 = CONVERT token_3 to IERC20Pods
			TMP_4632 = CONVERT this to address
			TMP_4633(uint256) = HIGH_LEVEL_CALL, dest:TMP_4631(IERC20Pods), function:podBalanceOf, arguments:['TMP_4632', 'msg.sender']  
			rewardsToken_6(IERC20) := ϕ(['rewardsToken_4', 'rewardsToken_8', 'rewardsToken_1', 'rewardsToken_7', 'rewardsToken_5'])
			token_4(IERC20Pods) := ϕ(['token_4', 'token_2', 'token_5', 'token_3'])
			podBalance_1(uint256) := TMP_4633(uint256)
		Expression: amount = _makeInfo().claim(msg.sender,podBalance)
		IRs:
			TMP_4634(FarmingLib.Info) = INTERNAL_CALL, FarmingPod._makeInfo()()
			TMP_4635(uint256) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.claim(FarmingLib.Info,address,uint256), arguments:['TMP_4634', 'msg.sender', 'podBalance_1'] 
			amount_1(uint256) := TMP_4635(uint256)
		Expression: amount > 0
		IRs:
			TMP_4636(bool) = amount_1 > 0
			CONDITION TMP_4636
		Expression: _transferReward(rewardsToken,msg.sender,amount)
		IRs:
			INTERNAL_CALL, StakingFarmingPod._transferReward(IERC20,address,uint256)(rewardsToken_7,msg.sender,amount_1)
	Function FarmingPod._transferReward(IERC20,address,uint256)
		Expression: reward.safeTransfer(to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['reward_1', 'to_1', 'amount_1'] 
	Function FarmingPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_3', '_totalSupply_5', '_totalSupply_0', '_totalSupply_4'])
		Expression: _makeInfo().updateBalances(from,to,amount)
		IRs:
			TMP_4639(FarmingLib.Info) = INTERNAL_CALL, FarmingPod._makeInfo()()
			LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.updateBalances(FarmingLib.Info,address,address,uint256), arguments:['TMP_4639', 'from_1', 'to_1', 'amount_1'] 
		Expression: from == address(0)
		IRs:
			TMP_4641 = CONVERT 0 to address
			TMP_4642(bool) = from_1 == TMP_4641
			CONDITION TMP_4642
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: to == address(0)
		IRs:
			TMP_4643 = CONVERT 0 to address
			TMP_4644(bool) = to_1 == TMP_4643
			CONDITION TMP_4644
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_5(uint256) = _totalSupply_4 (c)- amount_1
	Function FarmingPod.rescueFunds(IERC20,uint256)
		IRs:
			_distributor_5(address) := ϕ(['_distributor_6', '_distributor_4', '_distributor_0'])
		Expression: token == IERC20(address(0))
		IRs:
			TMP_4645 = CONVERT 0 to address
			TMP_4646 = CONVERT TMP_4645 to IERC20
			TMP_4647(bool) = token_1 == TMP_4646
			CONDITION TMP_4647
		Expression: address(_distributor).sendValue(amount)
		IRs:
			TMP_4648 = CONVERT _distributor_6 to address
			LIBRARY_CALL, dest:Address, function:Address.sendValue(address,uint256), arguments:['TMP_4648', 'amount_1'] 
		Expression: token.safeTransfer(_distributor,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['token_1', '_distributor_6', 'amount_1'] 
		Expression: onlyDistributor()
		IRs:
			MODIFIER_CALL, FarmingPod.onlyDistributor()()
	Function FarmingPod._makeInfo()
		IRs:
			_farm_2(FarmingLib.Data) := ϕ(['_farm_1', '_farm_0'])
		Expression: FarmingLib.makeInfo(totalSupply,_farm)
		IRs:
			TMP_4652(FarmingLib.Info) = LIBRARY_CALL, dest:FarmingLib, function:FarmingLib.makeInfo(function() returns(uint256),FarmingLib.Data), arguments:['totalSupply', '_farm_2'] 
			RETURN TMP_4652
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_4653(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_4653)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_4655(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_4656(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_4657(bool) = TMP_4655 == TMP_4656
			TMP_4658(None) = SOLIDITY_CALL require(bool,string)(TMP_4657,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_4659 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_4659)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_4662 = CONVERT 0 to address
			TMP_4663(bool) = newOwner_1 != TMP_4662
			TMP_4664(None) = SOLIDITY_CALL require(bool,string)(TMP_4663,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['TMP_4653', 'newOwner_1', 'TMP_4659'])
			_owner_2(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function IFarmingPod.totalSupply()
	Function IFarmingPod.distributor()
	Function IFarmingPod.farmInfo()
	Function IFarmingPod.farmed(address)
	Function IFarmingPod.claim()
	Function IFarmingPod.setDistributor(address)
	Function IFarmingPod.startFarming(uint256,uint256)
	Function IFarmingPod.rescueFunds(IERC20,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_5(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, FarmingPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function StakingFarmingPod.constructor(ISt1inch)
		Expression: st1inch = st1inch_
		IRs:
			st1inch_1(ISt1inch) := st1inch__1(ISt1inch)
		Expression: FarmingPod(st1inch_,st1inch_.oneInch())
		IRs:
			TMP_4670(IERC20) = HIGH_LEVEL_CALL, dest:st1inch__1(ISt1inch), function:oneInch, arguments:[]  
			INTERNAL_CALL, FarmingPod.constructor(IERC20Pods,IERC20)(st1inch__1,TMP_4670)
	Function StakingFarmingPod._transferReward(IERC20,address,uint256)
		IRs:
			reward_1(IERC20) := ϕ(['rewardsToken_7'])
			to_1(address) := ϕ(['msg.sender'])
			amount_1(uint256) := ϕ(['amount_1'])
			st1inch_2(ISt1inch) := ϕ(['st1inch_1', 'st1inch_0', 'st1inch_4', 'st1inch_3'])
		Expression: st1inch.emergencyExit()
		IRs:
			TMP_4672(bool) = HIGH_LEVEL_CALL, dest:st1inch_2(ISt1inch), function:emergencyExit, arguments:[]  
			st1inch_3(ISt1inch) := ϕ(['st1inch_1', 'st1inch_4', 'st1inch_3', 'st1inch_2'])
			CONDITION TMP_4672
		Expression: reward.safeTransfer(to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['reward_1', 'to_1', 'amount_1'] 
		Expression: st1inch.depositFor(to,amount)
		IRs:
			HIGH_LEVEL_CALL, dest:st1inch_3(ISt1inch), function:depositFor, arguments:['to_1', 'amount_1']  
			st1inch_4(ISt1inch) := ϕ(['st1inch_1', 'st1inch_4', 'st1inch_3'])
	Modifier FarmingPod.onlyDistributor()
ENTRY_POINT
		IRs:
			_distributor_7(address) := ϕ(['_distributor_6', '_distributor_4', '_distributor_0'])
IF msg.sender != _distributor
		Expression: msg.sender != _distributor
		IRs:
			TMP_4675(bool) = msg.sender != _distributor_7
			CONDITION TMP_4675
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_4676(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_6(IERC20Pods) := ϕ(['token_4', 'token_0', 'token_2', 'token_5'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_4678 = CONVERT token_6 to address
			TMP_4679(bool) = msg.sender != TMP_4678
			CONDITION TMP_4679
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_4680(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract WhitelistRegistry
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_4681(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_4681)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_4683(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_4684(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_4685(bool) = TMP_4683 == TMP_4684
			TMP_4686(None) = SOLIDITY_CALL require(bool,string)(TMP_4685,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_4687 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_4687)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_4690 = CONVERT 0 to address
			TMP_4691(bool) = newOwner_1 != TMP_4690
			TMP_4692(None) = SOLIDITY_CALL require(bool,string)(TMP_4691,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['newOwner_1', 'TMP_4687', 'TMP_4681'])
			_owner_2(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function WhitelistRegistry.constructor(IVotable,uint256,uint256)
		Expression: token = token_
		IRs:
			token_1(IVotable) := token__1(IVotable)
		Expression: _setResolverThreshold(resolverThreshold_)
		IRs:
			INTERNAL_CALL, WhitelistRegistry._setResolverThreshold(uint256)(resolverThreshold__1)
		Expression: _setWhitelistLimit(whitelistLimit_)
		IRs:
			INTERNAL_CALL, WhitelistRegistry._setWhitelistLimit(uint256)(whitelistLimit__1)
		Expression: whitelistLimitNew = whitelistLimit_
		IRs:
			whitelistLimitNew_1(uint256) := whitelistLimit__1(uint256)
	Function WhitelistRegistry.rescueFunds(IERC20,uint256)
		Expression: token_.uniTransfer(address(msg.sender),amount)
		IRs:
			TMP_4698 = CONVERT msg.sender to address
			LIBRARY_CALL, dest:UniERC20, function:UniERC20.uniTransfer(IERC20,address,uint256), arguments:['token__1', 'TMP_4698', 'amount_1'] 
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function WhitelistRegistry.setResolverThreshold(uint256)
		Expression: _setResolverThreshold(resolverThreshold_)
		IRs:
			INTERNAL_CALL, WhitelistRegistry._setResolverThreshold(uint256)(resolverThreshold__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function WhitelistRegistry.setWhitelistLimit(uint256)
		IRs:
			whitelistLimit_1(uint256) := ϕ(['whitelistLimit_5', 'whitelistLimit_2', 'whitelistLimit_6', 'whitelistLimit_0'])
			_whitelist_1(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_0', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
		Expression: whitelistLimit == whitelistLimit_
		IRs:
			TMP_4703(bool) = whitelistLimit_2 == whitelistLimit__1
			CONDITION TMP_4703
		Expression: revert SameWhitelistSize()()
		IRs:
			TMP_4704(None) = SOLIDITY_CALL revert SameWhitelistSize()()
		Expression: whitelistLimitNew = whitelistLimit_
		IRs:
			whitelistLimitNew_2(uint256) := whitelistLimit__1(uint256)
		Expression: whitelistLimitNew > _whitelist.length()
		IRs:
			TMP_4705(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['_whitelist_2'] 
			TMP_4706(bool) = whitelistLimitNew_2 > TMP_4705
			CONDITION TMP_4706
		Expression: _setWhitelistLimit(whitelistLimitNew)
		IRs:
			INTERNAL_CALL, WhitelistRegistry._setWhitelistLimit(uint256)(whitelistLimitNew_2)
		Expression: WhitelistLimitDecreaseRequest(whitelistLimitNew)
		IRs:
			Emit WhitelistLimitDecreaseRequest(whitelistLimitNew_2)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function WhitelistRegistry.shrinkWhitelist(uint256)
		IRs:
			token_2(IVotable) := ϕ(['token_1', 'token_0', 'token_11', 'token_3', 'token_6', 'token_10', 'token_4'])
			whitelistLimit_3(uint256) := ϕ(['whitelistLimit_5', 'whitelistLimit_2', 'whitelistLimit_6', 'whitelistLimit_0'])
			whitelistLimitNew_4(uint256) := ϕ(['whitelistLimitNew_1', 'whitelistLimitNew_2', 'whitelistLimitNew_5', 'whitelistLimitNew_0', 'whitelistLimitNew_3'])
			_whitelist_3(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_0', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
		Expression: whitelistLimit == whitelistLimitNew
		IRs:
			TMP_4710(bool) = whitelistLimit_3 == whitelistLimitNew_4
			CONDITION TMP_4710
		Expression: revert SameWhitelistSize()()
		IRs:
			TMP_4711(None) = SOLIDITY_CALL revert SameWhitelistSize()()
		Expression: whitelistLength = _whitelist.length()
		IRs:
			TMP_4712(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['_whitelist_3'] 
			whitelistLength_1(uint256) := TMP_4712(uint256)
		Expression: whitelistLimitNew < whitelistLength
		IRs:
			TMP_4713(bool) = whitelistLimitNew_4 < whitelistLength_1
			CONDITION TMP_4713
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < whitelistLength
		IRs:
			TMP_4714(bool) = i_1 < whitelistLength_1
			CONDITION TMP_4714
		Expression: curWhitelisted = _whitelist.at(i)
		IRs:
			TMP_4715(address) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.at(AddressSet.Data,uint256), arguments:['_whitelist_3', 'i_1'] 
			curWhitelisted_1(address) := TMP_4715(address)
		Expression: token.balanceOf(curWhitelisted) <= partition
		IRs:
			TMP_4716(uint256) = HIGH_LEVEL_CALL, dest:token_2(IVotable), function:balanceOf, arguments:['curWhitelisted_1']  
			token_3(IVotable) := ϕ(['token_1', 'token_11', 'token_2', 'token_3', 'token_6', 'token_10', 'token_4'])
			whitelistLimitNew_6(uint256) := ϕ(['whitelistLimitNew_1', 'whitelistLimitNew_3', 'whitelistLimitNew_2', 'whitelistLimitNew_5'])
			_whitelist_4(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_15', '_whitelist_3', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
			TMP_4717(bool) = TMP_4716 <= partition_1
			CONDITION TMP_4717
		Expression: _removeFromWhitelist(curWhitelisted)
		IRs:
			INTERNAL_CALL, WhitelistRegistry._removeFromWhitelist(address)(curWhitelisted_1)
		Expression: whitelistLength --
		IRs:
			TMP_4719(uint256) := whitelistLength_1(uint256)
			whitelistLength_2(uint256) = whitelistLength_1 - 1
		Expression: i ++
		IRs:
			TMP_4720(uint256) := i_1(uint256)
			i_2(uint256) = i_1 + 1
		IRs:
			whitelistLength_3(uint256) := ϕ(['whitelistLength_1', 'whitelistLength_2'])
			i_3(uint256) := ϕ(['i_2', 'i_1'])
		Expression: whitelistLength != whitelistLimitNew
		IRs:
			TMP_4721(bool) = whitelistLength_1 != whitelistLimitNew_4
			CONDITION TMP_4721
		Expression: revert WrongPartition()()
		IRs:
			TMP_4722(None) = SOLIDITY_CALL revert WrongPartition()()
		Expression: _setWhitelistLimit(whitelistLimitNew)
		IRs:
			INTERNAL_CALL, WhitelistRegistry._setWhitelistLimit(uint256)(whitelistLimitNew_4)
	Function WhitelistRegistry.register()
		IRs:
			token_5(IVotable) := ϕ(['token_1', 'token_0', 'token_11', 'token_3', 'token_6', 'token_10', 'token_4'])
			resolverThreshold_1(uint256) := ϕ(['resolverThreshold_4', 'resolverThreshold_6', 'resolverThreshold_5', 'resolverThreshold_2', 'resolverThreshold_0'])
			whitelistLimit_4(uint256) := ϕ(['whitelistLimit_5', 'whitelistLimit_2', 'whitelistLimit_6', 'whitelistLimit_0'])
			_whitelist_6(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_0', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
		Expression: token.votingPowerOf(msg.sender) < resolverThreshold
		IRs:
			TMP_4724(uint256) = HIGH_LEVEL_CALL, dest:token_5(IVotable), function:votingPowerOf, arguments:['msg.sender']  
			token_6(IVotable) := ϕ(['token_1', 'token_11', 'token_5', 'token_3', 'token_6', 'token_10', 'token_4'])
			resolverThreshold_2(uint256) := ϕ(['resolverThreshold_1', 'resolverThreshold_4', 'resolverThreshold_6', 'resolverThreshold_5', 'resolverThreshold_2'])
			whitelistLimit_5(uint256) := ϕ(['whitelistLimit_5', 'whitelistLimit_2', 'whitelistLimit_6', 'whitelistLimit_4'])
			_whitelist_7(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_6', '_whitelist_13', '_whitelist_4', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
			TMP_4725(bool) = TMP_4724 < resolverThreshold_2
			CONDITION TMP_4725
		Expression: revert BalanceLessThanThreshold()()
		IRs:
			TMP_4726(None) = SOLIDITY_CALL revert BalanceLessThanThreshold()()
		Expression: whitelistLength = _whitelist.length()
		IRs:
			TMP_4727(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['_whitelist_7'] 
			whitelistLength_1(uint256) := TMP_4727(uint256)
		Expression: whitelistLength == whitelistLimit
		IRs:
			TMP_4728(bool) = whitelistLength_1 == whitelistLimit_5
			CONDITION TMP_4728
		Expression: minResolver = msg.sender
		IRs:
			minResolver_1(address) := msg.sender(address)
		Expression: minBalance = token.balanceOf(msg.sender)
		IRs:
			TMP_4729(uint256) = HIGH_LEVEL_CALL, dest:token_6(IVotable), function:balanceOf, arguments:['msg.sender']  
			token_7(IVotable) := ϕ(['token_1', 'token_11', 'token_3', 'token_6', 'token_10', 'token_4'])
			_whitelist_8(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
			minBalance_1(uint256) := TMP_4729(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < whitelistLength
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_4730(bool) = i_2 < whitelistLength_1
			CONDITION TMP_4730
		Expression: curWhitelisted = _whitelist.at(i)
		IRs:
			TMP_4731(address) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.at(AddressSet.Data,uint256), arguments:['_whitelist_8', 'i_2'] 
			curWhitelisted_1(address) := TMP_4731(address)
		Expression: balance = token.balanceOf(curWhitelisted)
		IRs:
			TMP_4732(uint256) = HIGH_LEVEL_CALL, dest:token_7(IVotable), function:balanceOf, arguments:['curWhitelisted_1']  
			token_8(IVotable) := ϕ(['token_1', 'token_11', 'token_7', 'token_3', 'token_6', 'token_10', 'token_4'])
			_whitelist_9(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_15', '_whitelist_8', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
			balance_1(uint256) := TMP_4732(uint256)
		Expression: balance < minBalance
		IRs:
			TMP_4733(bool) = balance_1 < minBalance_1
			CONDITION TMP_4733
		Expression: minResolver = curWhitelisted
		IRs:
			minResolver_2(address) := curWhitelisted_1(address)
		Expression: minBalance = balance
		IRs:
			minBalance_2(uint256) := balance_1(uint256)
		IRs:
			minResolver_3(address) := ϕ(['minResolver_2', 'minResolver_1'])
			minBalance_3(uint256) := ϕ(['minBalance_1', 'minBalance_2'])
		Expression: ++ i
		IRs:
			i_3(uint256) = i_2 + 1
		Expression: minResolver == msg.sender
		IRs:
			TMP_4734(bool) = minResolver_1 == msg.sender
			CONDITION TMP_4734
		Expression: revert NotEnoughBalance()()
		IRs:
			TMP_4735(None) = SOLIDITY_CALL revert NotEnoughBalance()()
		Expression: _removeFromWhitelist(minResolver)
		IRs:
			INTERNAL_CALL, WhitelistRegistry._removeFromWhitelist(address)(minResolver_1)
		Expression: ! _whitelist.add(msg.sender)
		IRs:
			TMP_4737(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.add(AddressSet.Data,address), arguments:['_whitelist_10', 'msg.sender'] 
			TMP_4738 = UnaryType.BANG TMP_4737 
			CONDITION TMP_4738
		Expression: revert AlreadyRegistered()()
		IRs:
			TMP_4739(None) = SOLIDITY_CALL revert AlreadyRegistered()()
		Expression: Registered(msg.sender)
		IRs:
			Emit Registered(msg.sender)
	Function WhitelistRegistry.promote(uint256,address)
		IRs:
			promotions_1(mapping(address => mapping(uint256 => address))) := ϕ(['promotions_0', 'promotions_3', 'promotions_2'])
		Expression: promotions[msg.sender][chainId] == promotee
		IRs:
			REF_1147(mapping(uint256 => address)) -> promotions_1[msg.sender]
			REF_1148(address) -> REF_1147[chainId_1]
			TMP_4741(bool) = REF_1148 == promotee_1
			CONDITION TMP_4741
		Expression: revert SamePromotee()()
		IRs:
			TMP_4742(None) = SOLIDITY_CALL revert SamePromotee()()
		Expression: promotions[msg.sender][chainId] = promotee
		IRs:
			REF_1149(mapping(uint256 => address)) -> promotions_1[msg.sender]
			REF_1150(address) -> REF_1149[chainId_1]
			promotions_2(mapping(address => mapping(uint256 => address))) := ϕ(['promotions_1'])
			REF_1150(address) (->promotions_2) := promotee_1(address)
		Expression: Promotion(msg.sender,chainId,promotee)
		IRs:
			Emit Promotion(msg.sender,chainId_1,promotee_1)
	Function WhitelistRegistry.clean()
		IRs:
			token_9(IVotable) := ϕ(['token_1', 'token_0', 'token_11', 'token_3', 'token_6', 'token_10', 'token_4'])
			resolverThreshold_3(uint256) := ϕ(['resolverThreshold_4', 'resolverThreshold_6', 'resolverThreshold_5', 'resolverThreshold_2', 'resolverThreshold_0'])
			_whitelist_11(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_0', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
		Expression: whitelistLength = _whitelist.length()
		IRs:
			TMP_4744(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['_whitelist_11'] 
			whitelistLength_1(uint256) := TMP_4744(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < whitelistLength
		IRs:
			TMP_4745(bool) = i_1 < whitelistLength_1
			CONDITION TMP_4745
		Expression: curWhitelisted = _whitelist.at(i)
		IRs:
			TMP_4746(address) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.at(AddressSet.Data,uint256), arguments:['_whitelist_11', 'i_1'] 
			curWhitelisted_1(address) := TMP_4746(address)
		Expression: token.votingPowerOf(curWhitelisted) < resolverThreshold
		IRs:
			TMP_4747(uint256) = HIGH_LEVEL_CALL, dest:token_9(IVotable), function:votingPowerOf, arguments:['curWhitelisted_1']  
			token_10(IVotable) := ϕ(['token_1', 'token_11', 'token_9', 'token_3', 'token_6', 'token_10', 'token_4'])
			resolverThreshold_4(uint256) := ϕ(['resolverThreshold_4', 'resolverThreshold_6', 'resolverThreshold_3', 'resolverThreshold_5', 'resolverThreshold_2'])
			_whitelist_12(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_11', '_whitelist_13', '_whitelist_4', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
			TMP_4748(bool) = TMP_4747 < resolverThreshold_4
			CONDITION TMP_4748
		Expression: _removeFromWhitelist(curWhitelisted)
		IRs:
			INTERNAL_CALL, WhitelistRegistry._removeFromWhitelist(address)(curWhitelisted_1)
		Expression: whitelistLength --
		IRs:
			TMP_4750(uint256) := whitelistLength_1(uint256)
			whitelistLength_2(uint256) = whitelistLength_1 - 1
		Expression: i ++
		IRs:
			TMP_4751(uint256) := i_1(uint256)
			i_2(uint256) = i_1 + 1
		IRs:
			whitelistLength_3(uint256) := ϕ(['whitelistLength_1', 'whitelistLength_2'])
			i_3(uint256) := ϕ(['i_2', 'i_1'])
	Function WhitelistRegistry.getWhitelist()
		IRs:
			_whitelist_14(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_0', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
		Expression: _whitelist.items.get()
		IRs:
			REF_1154(AddressArray.Data) -> _whitelist_14.items
			TMP_4752(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1154'] 
			RETURN TMP_4752
	Function WhitelistRegistry.getPromotees(uint256)
		IRs:
			promotions_3(mapping(address => mapping(uint256 => address))) := ϕ(['promotions_0', 'promotions_3', 'promotions_2'])
			_whitelist_15(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_0', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
		Expression: promotees = _whitelist.items.get()
		IRs:
			REF_1156(AddressArray.Data) -> _whitelist_15.items
			TMP_4753(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1156'] 
			promotees_1(address[]) = ['TMP_4753(address[])']
		Expression: len = promotees.length
		IRs:
			REF_1158 -> LENGTH promotees_1
			len_1(uint256) := REF_1158(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < len
		IRs:
			promotees_2(address[]) := ϕ(['promotees_3', 'promotees_1'])
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_4754(bool) = i_2 < len_1
			CONDITION TMP_4754
		Expression: promotees[i] = promotions[promotees[i]][chainId]
		IRs:
			REF_1159(address) -> promotees_2[i_2]
			REF_1160(address) -> promotees_2[i_2]
			REF_1161(mapping(uint256 => address)) -> promotions_3[REF_1160]
			REF_1162(address) -> REF_1161[chainId_1]
			promotees_3(address[]) := ϕ(['promotees_2'])
			REF_1159(address) (->promotees_3) := REF_1162(address)
		Expression: ++ i
		IRs:
			i_3(uint256) = i_2 + 1
		Expression: promotees
		IRs:
			RETURN promotees_2
	Function WhitelistRegistry._setResolverThreshold(uint256)
		IRs:
			resolverThreshold__1(uint256) := ϕ(['resolverThreshold__1', 'resolverThreshold__1'])
		Expression: resolverThreshold = resolverThreshold_
		IRs:
			resolverThreshold_6(uint256) := resolverThreshold__1(uint256)
		Expression: ResolverThresholdSet(resolverThreshold_)
		IRs:
			Emit ResolverThresholdSet(resolverThreshold__1)
	Function WhitelistRegistry._setWhitelistLimit(uint256)
		IRs:
			whitelistLimit__1(uint256) := ϕ(['whitelistLimit__1', 'whitelistLimitNew_4', 'whitelistLimitNew_2'])
		Expression: whitelistLimit = whitelistLimit_
		IRs:
			whitelistLimit_6(uint256) := whitelistLimit__1(uint256)
		Expression: WhitelistLimitSet(whitelistLimit_)
		IRs:
			Emit WhitelistLimitSet(whitelistLimit__1)
	Function WhitelistRegistry._removeFromWhitelist(address)
		IRs:
			account_1(address) := ϕ(['curWhitelisted_1', 'curWhitelisted_1', 'minResolver_1'])
			_whitelist_16(AddressSet.Data) := ϕ(['_whitelist_14', '_whitelist_13', '_whitelist_4', '_whitelist_0', '_whitelist_15', '_whitelist_12', '_whitelist_5', '_whitelist_7', '_whitelist_2'])
		Expression: _whitelist.remove(account)
		IRs:
			TMP_4757(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['_whitelist_16', 'account_1'] 
		Expression: Unregistered(account)
		IRs:
			Emit Unregistered(account_1)
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
Contract ResolverMetadata
	Function ResolverMetadata.constructor(ITokenizedDelegationPod)
		Expression: delegation = delegation_
		IRs:
			delegation_1(ITokenizedDelegationPod) := delegation__1(ITokenizedDelegationPod)
	Function ResolverMetadata.setResolverUrl(string)
		Expression: getUrl[msg.sender] = url
		IRs:
			REF_1164(string) -> getUrl_0[msg.sender]
			getUrl_1(mapping(address => string)) := ϕ(['getUrl_0'])
			REF_1164(string) (->getUrl_1) := url_1(string)
		Expression: onlyRegistered()
		IRs:
			MODIFIER_CALL, ResolverMetadata.onlyRegistered()()
	Modifier ResolverMetadata.onlyRegistered()
ENTRY_POINT
		IRs:
			delegation_2(ITokenizedDelegationPod) := ϕ(['delegation_1', 'delegation_3', 'delegation_0'])
IF address(delegation.registration(msg.sender)) == address(0)
		Expression: address(delegation.registration(msg.sender)) == address(0)
		IRs:
			TMP_4761(IDelegatedShare) = HIGH_LEVEL_CALL, dest:delegation_2(ITokenizedDelegationPod), function:registration, arguments:['msg.sender']  
			delegation_3(ITokenizedDelegationPod) := ϕ(['delegation_1', 'delegation_2', 'delegation_3'])
			TMP_4762 = CONVERT TMP_4761 to address
			TMP_4763 = CONVERT 0 to address
			TMP_4764(bool) = TMP_4762 == TMP_4763
			CONDITION TMP_4764
EXPRESSION revert NotRegisteredDelegatee()()
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_4765(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
END_IF
_
Contract St1inchPreview
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_4766(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_4766)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_4768(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_4769(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_4770(bool) = TMP_4768 == TMP_4769
			TMP_4771(None) = SOLIDITY_CALL require(bool,string)(TMP_4770,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_4772 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_4772)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_4775 = CONVERT 0 to address
			TMP_4776(bool) = newOwner_1 != TMP_4775
			TMP_4777(None) = SOLIDITY_CALL require(bool,string)(TMP_4776,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['newOwner_1', 'TMP_4772', 'TMP_4766'])
			_owner_2(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function VotingPowerCalculator.constructor(uint256,uint256)
		IRs:
			_ONE_E18_1(uint256) := ϕ(['_ONE_E18_0'])
		Expression: origin_ > block.timestamp
		IRs:
			TMP_4781(bool) = origin__1 > block.timestamp
			CONDITION TMP_4781
		Expression: revert OriginInTheFuture()()
		IRs:
			TMP_4782(None) = SOLIDITY_CALL revert OriginInTheFuture()()
		Expression: origin = origin_
		IRs:
			origin_1(uint256) := origin__1(uint256)
		Expression: expBase = expBase_
		IRs:
			expBase_1(uint256) := expBase__1(uint256)
		Expression: _expTable0 = expBase_
		IRs:
			_expTable0_1(uint256) := expBase__1(uint256)
		Expression: _expTable1 = (_expTable0 * _expTable0) / _ONE_E18
		IRs:
			TMP_4783(uint256) = _expTable0_1 (c)* _expTable0_1
			TMP_4784(uint256) = TMP_4783 (c)/ _ONE_E18_1
			_expTable1_1(uint256) := TMP_4784(uint256)
		Expression: _expTable2 = (_expTable1 * _expTable1) / _ONE_E18
		IRs:
			TMP_4785(uint256) = _expTable1_1 (c)* _expTable1_1
			TMP_4786(uint256) = TMP_4785 (c)/ _ONE_E18_1
			_expTable2_1(uint256) := TMP_4786(uint256)
		Expression: _expTable3 = (_expTable2 * _expTable2) / _ONE_E18
		IRs:
			TMP_4787(uint256) = _expTable2_1 (c)* _expTable2_1
			TMP_4788(uint256) = TMP_4787 (c)/ _ONE_E18_1
			_expTable3_1(uint256) := TMP_4788(uint256)
		Expression: _expTable4 = (_expTable3 * _expTable3) / _ONE_E18
		IRs:
			TMP_4789(uint256) = _expTable3_1 (c)* _expTable3_1
			TMP_4790(uint256) = TMP_4789 (c)/ _ONE_E18_1
			_expTable4_1(uint256) := TMP_4790(uint256)
		Expression: _expTable5 = (_expTable4 * _expTable4) / _ONE_E18
		IRs:
			TMP_4791(uint256) = _expTable4_1 (c)* _expTable4_1
			TMP_4792(uint256) = TMP_4791 (c)/ _ONE_E18_1
			_expTable5_1(uint256) := TMP_4792(uint256)
		Expression: _expTable6 = (_expTable5 * _expTable5) / _ONE_E18
		IRs:
			TMP_4793(uint256) = _expTable5_1 (c)* _expTable5_1
			TMP_4794(uint256) = TMP_4793 (c)/ _ONE_E18_1
			_expTable6_1(uint256) := TMP_4794(uint256)
		Expression: _expTable7 = (_expTable6 * _expTable6) / _ONE_E18
		IRs:
			TMP_4795(uint256) = _expTable6_1 (c)* _expTable6_1
			TMP_4796(uint256) = TMP_4795 (c)/ _ONE_E18_1
			_expTable7_1(uint256) := TMP_4796(uint256)
		Expression: _expTable8 = (_expTable7 * _expTable7) / _ONE_E18
		IRs:
			TMP_4797(uint256) = _expTable7_1 (c)* _expTable7_1
			TMP_4798(uint256) = TMP_4797 (c)/ _ONE_E18_1
			_expTable8_1(uint256) := TMP_4798(uint256)
		Expression: _expTable9 = (_expTable8 * _expTable8) / _ONE_E18
		IRs:
			TMP_4799(uint256) = _expTable8_1 (c)* _expTable8_1
			TMP_4800(uint256) = TMP_4799 (c)/ _ONE_E18_1
			_expTable9_1(uint256) := TMP_4800(uint256)
		Expression: _expTable10 = (_expTable9 * _expTable9) / _ONE_E18
		IRs:
			TMP_4801(uint256) = _expTable9_1 (c)* _expTable9_1
			TMP_4802(uint256) = TMP_4801 (c)/ _ONE_E18_1
			_expTable10_1(uint256) := TMP_4802(uint256)
		Expression: _expTable11 = (_expTable10 * _expTable10) / _ONE_E18
		IRs:
			TMP_4803(uint256) = _expTable10_1 (c)* _expTable10_1
			TMP_4804(uint256) = TMP_4803 (c)/ _ONE_E18_1
			_expTable11_1(uint256) := TMP_4804(uint256)
		Expression: _expTable12 = (_expTable11 * _expTable11) / _ONE_E18
		IRs:
			TMP_4805(uint256) = _expTable11_1 (c)* _expTable11_1
			TMP_4806(uint256) = TMP_4805 (c)/ _ONE_E18_1
			_expTable12_1(uint256) := TMP_4806(uint256)
		Expression: _expTable13 = (_expTable12 * _expTable12) / _ONE_E18
		IRs:
			TMP_4807(uint256) = _expTable12_1 (c)* _expTable12_1
			TMP_4808(uint256) = TMP_4807 (c)/ _ONE_E18_1
			_expTable13_1(uint256) := TMP_4808(uint256)
		Expression: _expTable14 = (_expTable13 * _expTable13) / _ONE_E18
		IRs:
			TMP_4809(uint256) = _expTable13_1 (c)* _expTable13_1
			TMP_4810(uint256) = TMP_4809 (c)/ _ONE_E18_1
			_expTable14_1(uint256) := TMP_4810(uint256)
		Expression: _expTable15 = (_expTable14 * _expTable14) / _ONE_E18
		IRs:
			TMP_4811(uint256) = _expTable14_1 (c)* _expTable14_1
			TMP_4812(uint256) = TMP_4811 (c)/ _ONE_E18_1
			_expTable15_1(uint256) := TMP_4812(uint256)
		Expression: _expTable16 = (_expTable15 * _expTable15) / _ONE_E18
		IRs:
			TMP_4813(uint256) = _expTable15_1 (c)* _expTable15_1
			TMP_4814(uint256) = TMP_4813 (c)/ _ONE_E18_1
			_expTable16_1(uint256) := TMP_4814(uint256)
		Expression: _expTable17 = (_expTable16 * _expTable16) / _ONE_E18
		IRs:
			TMP_4815(uint256) = _expTable16_1 (c)* _expTable16_1
			TMP_4816(uint256) = TMP_4815 (c)/ _ONE_E18_1
			_expTable17_1(uint256) := TMP_4816(uint256)
		Expression: _expTable18 = (_expTable17 * _expTable17) / _ONE_E18
		IRs:
			TMP_4817(uint256) = _expTable17_1 (c)* _expTable17_1
			TMP_4818(uint256) = TMP_4817 (c)/ _ONE_E18_1
			_expTable18_1(uint256) := TMP_4818(uint256)
		Expression: _expTable19 = (_expTable18 * _expTable18) / _ONE_E18
		IRs:
			TMP_4819(uint256) = _expTable18_1 (c)* _expTable18_1
			TMP_4820(uint256) = TMP_4819 (c)/ _ONE_E18_1
			_expTable19_1(uint256) := TMP_4820(uint256)
		Expression: _expTable20 = (_expTable19 * _expTable19) / _ONE_E18
		IRs:
			TMP_4821(uint256) = _expTable19_1 (c)* _expTable19_1
			TMP_4822(uint256) = TMP_4821 (c)/ _ONE_E18_1
			_expTable20_1(uint256) := TMP_4822(uint256)
		Expression: _expTable21 = (_expTable20 * _expTable20) / _ONE_E18
		IRs:
			TMP_4823(uint256) = _expTable20_1 (c)* _expTable20_1
			TMP_4824(uint256) = TMP_4823 (c)/ _ONE_E18_1
			_expTable21_1(uint256) := TMP_4824(uint256)
		Expression: _expTable22 = (_expTable21 * _expTable21) / _ONE_E18
		IRs:
			TMP_4825(uint256) = _expTable21_1 (c)* _expTable21_1
			TMP_4826(uint256) = TMP_4825 (c)/ _ONE_E18_1
			_expTable22_1(uint256) := TMP_4826(uint256)
		Expression: _expTable23 = (_expTable22 * _expTable22) / _ONE_E18
		IRs:
			TMP_4827(uint256) = _expTable22_1 (c)* _expTable22_1
			TMP_4828(uint256) = TMP_4827 (c)/ _ONE_E18_1
			_expTable23_1(uint256) := TMP_4828(uint256)
		Expression: _expTable24 = (_expTable23 * _expTable23) / _ONE_E18
		IRs:
			TMP_4829(uint256) = _expTable23_1 (c)* _expTable23_1
			TMP_4830(uint256) = TMP_4829 (c)/ _ONE_E18_1
			_expTable24_1(uint256) := TMP_4830(uint256)
		Expression: _expTable25 = (_expTable24 * _expTable24) / _ONE_E18
		IRs:
			TMP_4831(uint256) = _expTable24_1 (c)* _expTable24_1
			TMP_4832(uint256) = TMP_4831 (c)/ _ONE_E18_1
			_expTable25_1(uint256) := TMP_4832(uint256)
		Expression: _expTable26 = (_expTable25 * _expTable25) / _ONE_E18
		IRs:
			TMP_4833(uint256) = _expTable25_1 (c)* _expTable25_1
			TMP_4834(uint256) = TMP_4833 (c)/ _ONE_E18_1
			_expTable26_1(uint256) := TMP_4834(uint256)
		Expression: _expTable27 = (_expTable26 * _expTable26) / _ONE_E18
		IRs:
			TMP_4835(uint256) = _expTable26_1 (c)* _expTable26_1
			TMP_4836(uint256) = TMP_4835 (c)/ _ONE_E18_1
			_expTable27_1(uint256) := TMP_4836(uint256)
		Expression: _expTable28 = (_expTable27 * _expTable27) / _ONE_E18
		IRs:
			TMP_4837(uint256) = _expTable27_1 (c)* _expTable27_1
			TMP_4838(uint256) = TMP_4837 (c)/ _ONE_E18_1
			_expTable28_1(uint256) := TMP_4838(uint256)
		Expression: _expTable29 = (_expTable28 * _expTable28) / _ONE_E18
		IRs:
			TMP_4839(uint256) = _expTable28_1 (c)* _expTable28_1
			TMP_4840(uint256) = TMP_4839 (c)/ _ONE_E18_1
			_expTable29_1(uint256) := TMP_4840(uint256)
	Function VotingPowerCalculator._votingPowerAt(uint256,uint256)
		IRs:
			balance_1(uint256) := ϕ(['TMP_5098'])
			timestamp_1(uint256) := ϕ(['timestamp_1'])
			_ONE_E18_2(uint256) := ϕ(['_ONE_E18_0'])
			origin_2(uint256) := ϕ(['origin_0', 'origin_1'])
			_expTable0_2(uint256) := ϕ(['_expTable0_1', '_expTable0_0'])
			_expTable1_2(uint256) := ϕ(['_expTable1_1', '_expTable1_0'])
			_expTable2_2(uint256) := ϕ(['_expTable2_0', '_expTable2_1'])
			_expTable3_2(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_2(uint256) := ϕ(['_expTable4_0', '_expTable4_1'])
			_expTable5_2(uint256) := ϕ(['_expTable5_0', '_expTable5_1'])
			_expTable6_2(uint256) := ϕ(['_expTable6_0', '_expTable6_1'])
			_expTable7_2(uint256) := ϕ(['_expTable7_0', '_expTable7_1'])
			_expTable8_2(uint256) := ϕ(['_expTable8_1', '_expTable8_0'])
			_expTable9_2(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_2(uint256) := ϕ(['_expTable10_0', '_expTable10_1'])
			_expTable11_2(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_2(uint256) := ϕ(['_expTable12_0', '_expTable12_1'])
			_expTable13_2(uint256) := ϕ(['_expTable13_0', '_expTable13_1'])
			_expTable14_2(uint256) := ϕ(['_expTable14_0', '_expTable14_1'])
			_expTable15_2(uint256) := ϕ(['_expTable15_0', '_expTable15_1'])
			_expTable16_2(uint256) := ϕ(['_expTable16_1', '_expTable16_0'])
			_expTable17_2(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_2(uint256) := ϕ(['_expTable18_0', '_expTable18_1'])
			_expTable19_2(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_2(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_2(uint256) := ϕ(['_expTable21_0', '_expTable21_1'])
			_expTable22_2(uint256) := ϕ(['_expTable22_0', '_expTable22_1'])
			_expTable23_2(uint256) := ϕ(['_expTable23_0', '_expTable23_1'])
			_expTable24_2(uint256) := ϕ(['_expTable24_1', '_expTable24_0'])
			_expTable25_2(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_2(uint256) := ϕ(['_expTable26_0', '_expTable26_1'])
			_expTable27_2(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_2(uint256) := ϕ(['_expTable28_0', '_expTable28_1'])
			_expTable29_2(uint256) := ϕ(['_expTable29_0', '_expTable29_1'])
		Expression: t = timestamp - origin
		IRs:
			TMP_4841(uint256) = timestamp_4 - origin_2
			t_1(uint256) := TMP_4841(uint256)
		Expression: votingPower = balance
		IRs:
			votingPower_1(uint256) := balance_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_4842(uint256) = t_1 & 1
			TMP_4843(bool) = TMP_4842 != 0
			CONDITION TMP_4843
		Expression: votingPower = (votingPower * _expTable0) / _ONE_E18
		IRs:
			TMP_4844(uint256) = votingPower_1 * _expTable0_2
			TMP_4845(uint256) = TMP_4844 / _ONE_E18_2
			votingPower_2(uint256) := TMP_4845(uint256)
		IRs:
			votingPower_3(uint256) := ϕ(['votingPower_1', 'votingPower_2'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_4846(uint256) = t_1 & 2
			TMP_4847(bool) = TMP_4846 != 0
			CONDITION TMP_4847
		Expression: votingPower = (votingPower * _expTable1) / _ONE_E18
		IRs:
			TMP_4848(uint256) = votingPower_3 * _expTable1_2
			TMP_4849(uint256) = TMP_4848 / _ONE_E18_2
			votingPower_4(uint256) := TMP_4849(uint256)
		IRs:
			votingPower_5(uint256) := ϕ(['votingPower_1', 'votingPower_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_4850(uint256) = t_1 & 4
			TMP_4851(bool) = TMP_4850 != 0
			CONDITION TMP_4851
		Expression: votingPower = (votingPower * _expTable2) / _ONE_E18
		IRs:
			TMP_4852(uint256) = votingPower_5 * _expTable2_2
			TMP_4853(uint256) = TMP_4852 / _ONE_E18_2
			votingPower_6(uint256) := TMP_4853(uint256)
		IRs:
			votingPower_7(uint256) := ϕ(['votingPower_1', 'votingPower_6'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_4854(uint256) = t_1 & 8
			TMP_4855(bool) = TMP_4854 != 0
			CONDITION TMP_4855
		Expression: votingPower = (votingPower * _expTable3) / _ONE_E18
		IRs:
			TMP_4856(uint256) = votingPower_7 * _expTable3_2
			TMP_4857(uint256) = TMP_4856 / _ONE_E18_2
			votingPower_8(uint256) := TMP_4857(uint256)
		IRs:
			votingPower_9(uint256) := ϕ(['votingPower_1', 'votingPower_8'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_4858(uint256) = t_1 & 16
			TMP_4859(bool) = TMP_4858 != 0
			CONDITION TMP_4859
		Expression: votingPower = (votingPower * _expTable4) / _ONE_E18
		IRs:
			TMP_4860(uint256) = votingPower_9 * _expTable4_2
			TMP_4861(uint256) = TMP_4860 / _ONE_E18_2
			votingPower_10(uint256) := TMP_4861(uint256)
		IRs:
			votingPower_11(uint256) := ϕ(['votingPower_1', 'votingPower_10'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_4862(uint256) = t_1 & 32
			TMP_4863(bool) = TMP_4862 != 0
			CONDITION TMP_4863
		Expression: votingPower = (votingPower * _expTable5) / _ONE_E18
		IRs:
			TMP_4864(uint256) = votingPower_11 * _expTable5_2
			TMP_4865(uint256) = TMP_4864 / _ONE_E18_2
			votingPower_12(uint256) := TMP_4865(uint256)
		IRs:
			votingPower_13(uint256) := ϕ(['votingPower_1', 'votingPower_12'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_4866(uint256) = t_1 & 64
			TMP_4867(bool) = TMP_4866 != 0
			CONDITION TMP_4867
		Expression: votingPower = (votingPower * _expTable6) / _ONE_E18
		IRs:
			TMP_4868(uint256) = votingPower_13 * _expTable6_2
			TMP_4869(uint256) = TMP_4868 / _ONE_E18_2
			votingPower_14(uint256) := TMP_4869(uint256)
		IRs:
			votingPower_15(uint256) := ϕ(['votingPower_1', 'votingPower_14'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_4870(uint256) = t_1 & 128
			TMP_4871(bool) = TMP_4870 != 0
			CONDITION TMP_4871
		Expression: votingPower = (votingPower * _expTable7) / _ONE_E18
		IRs:
			TMP_4872(uint256) = votingPower_15 * _expTable7_2
			TMP_4873(uint256) = TMP_4872 / _ONE_E18_2
			votingPower_16(uint256) := TMP_4873(uint256)
		IRs:
			votingPower_17(uint256) := ϕ(['votingPower_1', 'votingPower_16'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_4874(uint256) = t_1 & 256
			TMP_4875(bool) = TMP_4874 != 0
			CONDITION TMP_4875
		Expression: votingPower = (votingPower * _expTable8) / _ONE_E18
		IRs:
			TMP_4876(uint256) = votingPower_17 * _expTable8_2
			TMP_4877(uint256) = TMP_4876 / _ONE_E18_2
			votingPower_18(uint256) := TMP_4877(uint256)
		IRs:
			votingPower_19(uint256) := ϕ(['votingPower_1', 'votingPower_18'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_4878(uint256) = t_1 & 512
			TMP_4879(bool) = TMP_4878 != 0
			CONDITION TMP_4879
		Expression: votingPower = (votingPower * _expTable9) / _ONE_E18
		IRs:
			TMP_4880(uint256) = votingPower_19 * _expTable9_2
			TMP_4881(uint256) = TMP_4880 / _ONE_E18_2
			votingPower_20(uint256) := TMP_4881(uint256)
		IRs:
			votingPower_21(uint256) := ϕ(['votingPower_1', 'votingPower_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_4882(uint256) = t_1 & 1024
			TMP_4883(bool) = TMP_4882 != 0
			CONDITION TMP_4883
		Expression: votingPower = (votingPower * _expTable10) / _ONE_E18
		IRs:
			TMP_4884(uint256) = votingPower_21 * _expTable10_2
			TMP_4885(uint256) = TMP_4884 / _ONE_E18_2
			votingPower_22(uint256) := TMP_4885(uint256)
		IRs:
			votingPower_23(uint256) := ϕ(['votingPower_1', 'votingPower_22'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_4886(uint256) = t_1 & 2048
			TMP_4887(bool) = TMP_4886 != 0
			CONDITION TMP_4887
		Expression: votingPower = (votingPower * _expTable11) / _ONE_E18
		IRs:
			TMP_4888(uint256) = votingPower_23 * _expTable11_2
			TMP_4889(uint256) = TMP_4888 / _ONE_E18_2
			votingPower_24(uint256) := TMP_4889(uint256)
		IRs:
			votingPower_25(uint256) := ϕ(['votingPower_1', 'votingPower_24'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_4890(uint256) = t_1 & 4096
			TMP_4891(bool) = TMP_4890 != 0
			CONDITION TMP_4891
		Expression: votingPower = (votingPower * _expTable12) / _ONE_E18
		IRs:
			TMP_4892(uint256) = votingPower_25 * _expTable12_2
			TMP_4893(uint256) = TMP_4892 / _ONE_E18_2
			votingPower_26(uint256) := TMP_4893(uint256)
		IRs:
			votingPower_27(uint256) := ϕ(['votingPower_1', 'votingPower_26'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_4894(uint256) = t_1 & 8192
			TMP_4895(bool) = TMP_4894 != 0
			CONDITION TMP_4895
		Expression: votingPower = (votingPower * _expTable13) / _ONE_E18
		IRs:
			TMP_4896(uint256) = votingPower_27 * _expTable13_2
			TMP_4897(uint256) = TMP_4896 / _ONE_E18_2
			votingPower_28(uint256) := TMP_4897(uint256)
		IRs:
			votingPower_29(uint256) := ϕ(['votingPower_1', 'votingPower_28'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_4898(uint256) = t_1 & 16384
			TMP_4899(bool) = TMP_4898 != 0
			CONDITION TMP_4899
		Expression: votingPower = (votingPower * _expTable14) / _ONE_E18
		IRs:
			TMP_4900(uint256) = votingPower_29 * _expTable14_2
			TMP_4901(uint256) = TMP_4900 / _ONE_E18_2
			votingPower_30(uint256) := TMP_4901(uint256)
		IRs:
			votingPower_31(uint256) := ϕ(['votingPower_1', 'votingPower_30'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_4902(uint256) = t_1 & 32768
			TMP_4903(bool) = TMP_4902 != 0
			CONDITION TMP_4903
		Expression: votingPower = (votingPower * _expTable15) / _ONE_E18
		IRs:
			TMP_4904(uint256) = votingPower_31 * _expTable15_2
			TMP_4905(uint256) = TMP_4904 / _ONE_E18_2
			votingPower_32(uint256) := TMP_4905(uint256)
		IRs:
			votingPower_33(uint256) := ϕ(['votingPower_1', 'votingPower_32'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_4906(uint256) = t_1 & 65536
			TMP_4907(bool) = TMP_4906 != 0
			CONDITION TMP_4907
		Expression: votingPower = (votingPower * _expTable16) / _ONE_E18
		IRs:
			TMP_4908(uint256) = votingPower_33 * _expTable16_2
			TMP_4909(uint256) = TMP_4908 / _ONE_E18_2
			votingPower_34(uint256) := TMP_4909(uint256)
		IRs:
			votingPower_35(uint256) := ϕ(['votingPower_1', 'votingPower_34'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_4910(uint256) = t_1 & 131072
			TMP_4911(bool) = TMP_4910 != 0
			CONDITION TMP_4911
		Expression: votingPower = (votingPower * _expTable17) / _ONE_E18
		IRs:
			TMP_4912(uint256) = votingPower_35 * _expTable17_2
			TMP_4913(uint256) = TMP_4912 / _ONE_E18_2
			votingPower_36(uint256) := TMP_4913(uint256)
		IRs:
			votingPower_37(uint256) := ϕ(['votingPower_1', 'votingPower_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_4914(uint256) = t_1 & 262144
			TMP_4915(bool) = TMP_4914 != 0
			CONDITION TMP_4915
		Expression: votingPower = (votingPower * _expTable18) / _ONE_E18
		IRs:
			TMP_4916(uint256) = votingPower_37 * _expTable18_2
			TMP_4917(uint256) = TMP_4916 / _ONE_E18_2
			votingPower_38(uint256) := TMP_4917(uint256)
		IRs:
			votingPower_39(uint256) := ϕ(['votingPower_1', 'votingPower_38'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_4918(uint256) = t_1 & 524288
			TMP_4919(bool) = TMP_4918 != 0
			CONDITION TMP_4919
		Expression: votingPower = (votingPower * _expTable19) / _ONE_E18
		IRs:
			TMP_4920(uint256) = votingPower_39 * _expTable19_2
			TMP_4921(uint256) = TMP_4920 / _ONE_E18_2
			votingPower_40(uint256) := TMP_4921(uint256)
		IRs:
			votingPower_41(uint256) := ϕ(['votingPower_1', 'votingPower_40'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_4922(uint256) = t_1 & 1048576
			TMP_4923(bool) = TMP_4922 != 0
			CONDITION TMP_4923
		Expression: votingPower = (votingPower * _expTable20) / _ONE_E18
		IRs:
			TMP_4924(uint256) = votingPower_41 * _expTable20_2
			TMP_4925(uint256) = TMP_4924 / _ONE_E18_2
			votingPower_42(uint256) := TMP_4925(uint256)
		IRs:
			votingPower_43(uint256) := ϕ(['votingPower_1', 'votingPower_42'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_4926(uint256) = t_1 & 2097152
			TMP_4927(bool) = TMP_4926 != 0
			CONDITION TMP_4927
		Expression: votingPower = (votingPower * _expTable21) / _ONE_E18
		IRs:
			TMP_4928(uint256) = votingPower_43 * _expTable21_2
			TMP_4929(uint256) = TMP_4928 / _ONE_E18_2
			votingPower_44(uint256) := TMP_4929(uint256)
		IRs:
			votingPower_45(uint256) := ϕ(['votingPower_1', 'votingPower_44'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_4930(uint256) = t_1 & 4194304
			TMP_4931(bool) = TMP_4930 != 0
			CONDITION TMP_4931
		Expression: votingPower = (votingPower * _expTable22) / _ONE_E18
		IRs:
			TMP_4932(uint256) = votingPower_45 * _expTable22_2
			TMP_4933(uint256) = TMP_4932 / _ONE_E18_2
			votingPower_46(uint256) := TMP_4933(uint256)
		IRs:
			votingPower_47(uint256) := ϕ(['votingPower_1', 'votingPower_46'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_4934(uint256) = t_1 & 8388608
			TMP_4935(bool) = TMP_4934 != 0
			CONDITION TMP_4935
		Expression: votingPower = (votingPower * _expTable23) / _ONE_E18
		IRs:
			TMP_4936(uint256) = votingPower_47 * _expTable23_2
			TMP_4937(uint256) = TMP_4936 / _ONE_E18_2
			votingPower_48(uint256) := TMP_4937(uint256)
		IRs:
			votingPower_49(uint256) := ϕ(['votingPower_1', 'votingPower_48'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_4938(uint256) = t_1 & 16777216
			TMP_4939(bool) = TMP_4938 != 0
			CONDITION TMP_4939
		Expression: votingPower = (votingPower * _expTable24) / _ONE_E18
		IRs:
			TMP_4940(uint256) = votingPower_49 * _expTable24_2
			TMP_4941(uint256) = TMP_4940 / _ONE_E18_2
			votingPower_50(uint256) := TMP_4941(uint256)
		IRs:
			votingPower_51(uint256) := ϕ(['votingPower_1', 'votingPower_50'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_4942(uint256) = t_1 & 33554432
			TMP_4943(bool) = TMP_4942 != 0
			CONDITION TMP_4943
		Expression: votingPower = (votingPower * _expTable25) / _ONE_E18
		IRs:
			TMP_4944(uint256) = votingPower_51 * _expTable25_2
			TMP_4945(uint256) = TMP_4944 / _ONE_E18_2
			votingPower_52(uint256) := TMP_4945(uint256)
		IRs:
			votingPower_53(uint256) := ϕ(['votingPower_1', 'votingPower_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_4946(uint256) = t_1 & 67108864
			TMP_4947(bool) = TMP_4946 != 0
			CONDITION TMP_4947
		Expression: votingPower = (votingPower * _expTable26) / _ONE_E18
		IRs:
			TMP_4948(uint256) = votingPower_53 * _expTable26_2
			TMP_4949(uint256) = TMP_4948 / _ONE_E18_2
			votingPower_54(uint256) := TMP_4949(uint256)
		IRs:
			votingPower_55(uint256) := ϕ(['votingPower_1', 'votingPower_54'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_4950(uint256) = t_1 & 134217728
			TMP_4951(bool) = TMP_4950 != 0
			CONDITION TMP_4951
		Expression: votingPower = (votingPower * _expTable27) / _ONE_E18
		IRs:
			TMP_4952(uint256) = votingPower_55 * _expTable27_2
			TMP_4953(uint256) = TMP_4952 / _ONE_E18_2
			votingPower_56(uint256) := TMP_4953(uint256)
		IRs:
			votingPower_57(uint256) := ϕ(['votingPower_1', 'votingPower_56'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_4954(uint256) = t_1 & 268435456
			TMP_4955(bool) = TMP_4954 != 0
			CONDITION TMP_4955
		Expression: votingPower = (votingPower * _expTable28) / _ONE_E18
		IRs:
			TMP_4956(uint256) = votingPower_57 * _expTable28_2
			TMP_4957(uint256) = TMP_4956 / _ONE_E18_2
			votingPower_58(uint256) := TMP_4957(uint256)
		IRs:
			votingPower_59(uint256) := ϕ(['votingPower_1', 'votingPower_58'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_4958(uint256) = t_1 & 536870912
			TMP_4959(bool) = TMP_4958 != 0
			CONDITION TMP_4959
		Expression: votingPower = (votingPower * _expTable29) / _ONE_E18
		IRs:
			TMP_4960(uint256) = votingPower_59 * _expTable29_2
			TMP_4961(uint256) = TMP_4960 / _ONE_E18_2
			votingPower_60(uint256) := TMP_4961(uint256)
		IRs:
			votingPower_61(uint256) := ϕ(['votingPower_1', 'votingPower_60'])
		Expression: votingPower
		IRs:
			RETURN votingPower_61
		Expression: timestamp < origin
		IRs:
			TMP_4962(bool) = timestamp_1 < origin_2
			CONDITION TMP_4962
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_2(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: votingPower
	Function VotingPowerCalculator._balanceAt(uint256,uint256)
		IRs:
			votingPower_1(uint256) := ϕ(['TMP_5096', 'TMP_5090'])
			timestamp_1(uint256) := ϕ(['lockedTill_1', 'lockedTill_1'])
			_ONE_E18_3(uint256) := ϕ(['_ONE_E18_0'])
			origin_3(uint256) := ϕ(['origin_0', 'origin_1'])
			_expTable0_3(uint256) := ϕ(['_expTable0_1', '_expTable0_0'])
			_expTable1_3(uint256) := ϕ(['_expTable1_1', '_expTable1_0'])
			_expTable2_3(uint256) := ϕ(['_expTable2_0', '_expTable2_1'])
			_expTable3_3(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_3(uint256) := ϕ(['_expTable4_0', '_expTable4_1'])
			_expTable5_3(uint256) := ϕ(['_expTable5_0', '_expTable5_1'])
			_expTable6_3(uint256) := ϕ(['_expTable6_0', '_expTable6_1'])
			_expTable7_3(uint256) := ϕ(['_expTable7_0', '_expTable7_1'])
			_expTable8_3(uint256) := ϕ(['_expTable8_1', '_expTable8_0'])
			_expTable9_3(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_3(uint256) := ϕ(['_expTable10_0', '_expTable10_1'])
			_expTable11_3(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_3(uint256) := ϕ(['_expTable12_0', '_expTable12_1'])
			_expTable13_3(uint256) := ϕ(['_expTable13_0', '_expTable13_1'])
			_expTable14_3(uint256) := ϕ(['_expTable14_0', '_expTable14_1'])
			_expTable15_3(uint256) := ϕ(['_expTable15_0', '_expTable15_1'])
			_expTable16_3(uint256) := ϕ(['_expTable16_1', '_expTable16_0'])
			_expTable17_3(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_3(uint256) := ϕ(['_expTable18_0', '_expTable18_1'])
			_expTable19_3(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_3(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_3(uint256) := ϕ(['_expTable21_0', '_expTable21_1'])
			_expTable22_3(uint256) := ϕ(['_expTable22_0', '_expTable22_1'])
			_expTable23_3(uint256) := ϕ(['_expTable23_0', '_expTable23_1'])
			_expTable24_3(uint256) := ϕ(['_expTable24_1', '_expTable24_0'])
			_expTable25_3(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_3(uint256) := ϕ(['_expTable26_0', '_expTable26_1'])
			_expTable27_3(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_3(uint256) := ϕ(['_expTable28_0', '_expTable28_1'])
			_expTable29_3(uint256) := ϕ(['_expTable29_0', '_expTable29_1'])
		Expression: t = timestamp - origin
		IRs:
			TMP_4963(uint256) = timestamp_4 - origin_3
			t_1(uint256) := TMP_4963(uint256)
		Expression: balance = votingPower
		IRs:
			balance_1(uint256) := votingPower_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_4964(uint256) = t_1 & 1
			TMP_4965(bool) = TMP_4964 != 0
			CONDITION TMP_4965
		Expression: balance = (balance * _ONE_E18) / _expTable0
		IRs:
			TMP_4966(uint256) = balance_1 * _ONE_E18_3
			TMP_4967(uint256) = TMP_4966 / _expTable0_3
			balance_2(uint256) := TMP_4967(uint256)
		IRs:
			balance_3(uint256) := ϕ(['balance_2', 'balance_1'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_4968(uint256) = t_1 & 2
			TMP_4969(bool) = TMP_4968 != 0
			CONDITION TMP_4969
		Expression: balance = (balance * _ONE_E18) / _expTable1
		IRs:
			TMP_4970(uint256) = balance_3 * _ONE_E18_3
			TMP_4971(uint256) = TMP_4970 / _expTable1_3
			balance_4(uint256) := TMP_4971(uint256)
		IRs:
			balance_5(uint256) := ϕ(['balance_4', 'balance_1'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_4972(uint256) = t_1 & 4
			TMP_4973(bool) = TMP_4972 != 0
			CONDITION TMP_4973
		Expression: balance = (balance * _ONE_E18) / _expTable2
		IRs:
			TMP_4974(uint256) = balance_5 * _ONE_E18_3
			TMP_4975(uint256) = TMP_4974 / _expTable2_3
			balance_6(uint256) := TMP_4975(uint256)
		IRs:
			balance_7(uint256) := ϕ(['balance_6', 'balance_1'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_4976(uint256) = t_1 & 8
			TMP_4977(bool) = TMP_4976 != 0
			CONDITION TMP_4977
		Expression: balance = (balance * _ONE_E18) / _expTable3
		IRs:
			TMP_4978(uint256) = balance_7 * _ONE_E18_3
			TMP_4979(uint256) = TMP_4978 / _expTable3_3
			balance_8(uint256) := TMP_4979(uint256)
		IRs:
			balance_9(uint256) := ϕ(['balance_8', 'balance_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_4980(uint256) = t_1 & 16
			TMP_4981(bool) = TMP_4980 != 0
			CONDITION TMP_4981
		Expression: balance = (balance * _ONE_E18) / _expTable4
		IRs:
			TMP_4982(uint256) = balance_9 * _ONE_E18_3
			TMP_4983(uint256) = TMP_4982 / _expTable4_3
			balance_10(uint256) := TMP_4983(uint256)
		IRs:
			balance_11(uint256) := ϕ(['balance_10', 'balance_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_4984(uint256) = t_1 & 32
			TMP_4985(bool) = TMP_4984 != 0
			CONDITION TMP_4985
		Expression: balance = (balance * _ONE_E18) / _expTable5
		IRs:
			TMP_4986(uint256) = balance_11 * _ONE_E18_3
			TMP_4987(uint256) = TMP_4986 / _expTable5_3
			balance_12(uint256) := TMP_4987(uint256)
		IRs:
			balance_13(uint256) := ϕ(['balance_12', 'balance_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_4988(uint256) = t_1 & 64
			TMP_4989(bool) = TMP_4988 != 0
			CONDITION TMP_4989
		Expression: balance = (balance * _ONE_E18) / _expTable6
		IRs:
			TMP_4990(uint256) = balance_13 * _ONE_E18_3
			TMP_4991(uint256) = TMP_4990 / _expTable6_3
			balance_14(uint256) := TMP_4991(uint256)
		IRs:
			balance_15(uint256) := ϕ(['balance_14', 'balance_1'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_4992(uint256) = t_1 & 128
			TMP_4993(bool) = TMP_4992 != 0
			CONDITION TMP_4993
		Expression: balance = (balance * _ONE_E18) / _expTable7
		IRs:
			TMP_4994(uint256) = balance_15 * _ONE_E18_3
			TMP_4995(uint256) = TMP_4994 / _expTable7_3
			balance_16(uint256) := TMP_4995(uint256)
		IRs:
			balance_17(uint256) := ϕ(['balance_16', 'balance_1'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_4996(uint256) = t_1 & 256
			TMP_4997(bool) = TMP_4996 != 0
			CONDITION TMP_4997
		Expression: balance = (balance * _ONE_E18) / _expTable8
		IRs:
			TMP_4998(uint256) = balance_17 * _ONE_E18_3
			TMP_4999(uint256) = TMP_4998 / _expTable8_3
			balance_18(uint256) := TMP_4999(uint256)
		IRs:
			balance_19(uint256) := ϕ(['balance_18', 'balance_1'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_5000(uint256) = t_1 & 512
			TMP_5001(bool) = TMP_5000 != 0
			CONDITION TMP_5001
		Expression: balance = (balance * _ONE_E18) / _expTable9
		IRs:
			TMP_5002(uint256) = balance_19 * _ONE_E18_3
			TMP_5003(uint256) = TMP_5002 / _expTable9_3
			balance_20(uint256) := TMP_5003(uint256)
		IRs:
			balance_21(uint256) := ϕ(['balance_20', 'balance_1'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_5004(uint256) = t_1 & 1024
			TMP_5005(bool) = TMP_5004 != 0
			CONDITION TMP_5005
		Expression: balance = (balance * _ONE_E18) / _expTable10
		IRs:
			TMP_5006(uint256) = balance_21 * _ONE_E18_3
			TMP_5007(uint256) = TMP_5006 / _expTable10_3
			balance_22(uint256) := TMP_5007(uint256)
		IRs:
			balance_23(uint256) := ϕ(['balance_22', 'balance_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_5008(uint256) = t_1 & 2048
			TMP_5009(bool) = TMP_5008 != 0
			CONDITION TMP_5009
		Expression: balance = (balance * _ONE_E18) / _expTable11
		IRs:
			TMP_5010(uint256) = balance_23 * _ONE_E18_3
			TMP_5011(uint256) = TMP_5010 / _expTable11_3
			balance_24(uint256) := TMP_5011(uint256)
		IRs:
			balance_25(uint256) := ϕ(['balance_24', 'balance_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_5012(uint256) = t_1 & 4096
			TMP_5013(bool) = TMP_5012 != 0
			CONDITION TMP_5013
		Expression: balance = (balance * _ONE_E18) / _expTable12
		IRs:
			TMP_5014(uint256) = balance_25 * _ONE_E18_3
			TMP_5015(uint256) = TMP_5014 / _expTable12_3
			balance_26(uint256) := TMP_5015(uint256)
		IRs:
			balance_27(uint256) := ϕ(['balance_26', 'balance_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_5016(uint256) = t_1 & 8192
			TMP_5017(bool) = TMP_5016 != 0
			CONDITION TMP_5017
		Expression: balance = (balance * _ONE_E18) / _expTable13
		IRs:
			TMP_5018(uint256) = balance_27 * _ONE_E18_3
			TMP_5019(uint256) = TMP_5018 / _expTable13_3
			balance_28(uint256) := TMP_5019(uint256)
		IRs:
			balance_29(uint256) := ϕ(['balance_28', 'balance_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_5020(uint256) = t_1 & 16384
			TMP_5021(bool) = TMP_5020 != 0
			CONDITION TMP_5021
		Expression: balance = (balance * _ONE_E18) / _expTable14
		IRs:
			TMP_5022(uint256) = balance_29 * _ONE_E18_3
			TMP_5023(uint256) = TMP_5022 / _expTable14_3
			balance_30(uint256) := TMP_5023(uint256)
		IRs:
			balance_31(uint256) := ϕ(['balance_30', 'balance_1'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_5024(uint256) = t_1 & 32768
			TMP_5025(bool) = TMP_5024 != 0
			CONDITION TMP_5025
		Expression: balance = (balance * _ONE_E18) / _expTable15
		IRs:
			TMP_5026(uint256) = balance_31 * _ONE_E18_3
			TMP_5027(uint256) = TMP_5026 / _expTable15_3
			balance_32(uint256) := TMP_5027(uint256)
		IRs:
			balance_33(uint256) := ϕ(['balance_32', 'balance_1'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_5028(uint256) = t_1 & 65536
			TMP_5029(bool) = TMP_5028 != 0
			CONDITION TMP_5029
		Expression: balance = (balance * _ONE_E18) / _expTable16
		IRs:
			TMP_5030(uint256) = balance_33 * _ONE_E18_3
			TMP_5031(uint256) = TMP_5030 / _expTable16_3
			balance_34(uint256) := TMP_5031(uint256)
		IRs:
			balance_35(uint256) := ϕ(['balance_34', 'balance_1'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_5032(uint256) = t_1 & 131072
			TMP_5033(bool) = TMP_5032 != 0
			CONDITION TMP_5033
		Expression: balance = (balance * _ONE_E18) / _expTable17
		IRs:
			TMP_5034(uint256) = balance_35 * _ONE_E18_3
			TMP_5035(uint256) = TMP_5034 / _expTable17_3
			balance_36(uint256) := TMP_5035(uint256)
		IRs:
			balance_37(uint256) := ϕ(['balance_36', 'balance_1'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_5036(uint256) = t_1 & 262144
			TMP_5037(bool) = TMP_5036 != 0
			CONDITION TMP_5037
		Expression: balance = (balance * _ONE_E18) / _expTable18
		IRs:
			TMP_5038(uint256) = balance_37 * _ONE_E18_3
			TMP_5039(uint256) = TMP_5038 / _expTable18_3
			balance_38(uint256) := TMP_5039(uint256)
		IRs:
			balance_39(uint256) := ϕ(['balance_38', 'balance_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_5040(uint256) = t_1 & 524288
			TMP_5041(bool) = TMP_5040 != 0
			CONDITION TMP_5041
		Expression: balance = (balance * _ONE_E18) / _expTable19
		IRs:
			TMP_5042(uint256) = balance_39 * _ONE_E18_3
			TMP_5043(uint256) = TMP_5042 / _expTable19_3
			balance_40(uint256) := TMP_5043(uint256)
		IRs:
			balance_41(uint256) := ϕ(['balance_40', 'balance_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_5044(uint256) = t_1 & 1048576
			TMP_5045(bool) = TMP_5044 != 0
			CONDITION TMP_5045
		Expression: balance = (balance * _ONE_E18) / _expTable20
		IRs:
			TMP_5046(uint256) = balance_41 * _ONE_E18_3
			TMP_5047(uint256) = TMP_5046 / _expTable20_3
			balance_42(uint256) := TMP_5047(uint256)
		IRs:
			balance_43(uint256) := ϕ(['balance_42', 'balance_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_5048(uint256) = t_1 & 2097152
			TMP_5049(bool) = TMP_5048 != 0
			CONDITION TMP_5049
		Expression: balance = (balance * _ONE_E18) / _expTable21
		IRs:
			TMP_5050(uint256) = balance_43 * _ONE_E18_3
			TMP_5051(uint256) = TMP_5050 / _expTable21_3
			balance_44(uint256) := TMP_5051(uint256)
		IRs:
			balance_45(uint256) := ϕ(['balance_44', 'balance_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_5052(uint256) = t_1 & 4194304
			TMP_5053(bool) = TMP_5052 != 0
			CONDITION TMP_5053
		Expression: balance = (balance * _ONE_E18) / _expTable22
		IRs:
			TMP_5054(uint256) = balance_45 * _ONE_E18_3
			TMP_5055(uint256) = TMP_5054 / _expTable22_3
			balance_46(uint256) := TMP_5055(uint256)
		IRs:
			balance_47(uint256) := ϕ(['balance_46', 'balance_1'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_5056(uint256) = t_1 & 8388608
			TMP_5057(bool) = TMP_5056 != 0
			CONDITION TMP_5057
		Expression: balance = (balance * _ONE_E18) / _expTable23
		IRs:
			TMP_5058(uint256) = balance_47 * _ONE_E18_3
			TMP_5059(uint256) = TMP_5058 / _expTable23_3
			balance_48(uint256) := TMP_5059(uint256)
		IRs:
			balance_49(uint256) := ϕ(['balance_48', 'balance_1'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_5060(uint256) = t_1 & 16777216
			TMP_5061(bool) = TMP_5060 != 0
			CONDITION TMP_5061
		Expression: balance = (balance * _ONE_E18) / _expTable24
		IRs:
			TMP_5062(uint256) = balance_49 * _ONE_E18_3
			TMP_5063(uint256) = TMP_5062 / _expTable24_3
			balance_50(uint256) := TMP_5063(uint256)
		IRs:
			balance_51(uint256) := ϕ(['balance_50', 'balance_1'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_5064(uint256) = t_1 & 33554432
			TMP_5065(bool) = TMP_5064 != 0
			CONDITION TMP_5065
		Expression: balance = (balance * _ONE_E18) / _expTable25
		IRs:
			TMP_5066(uint256) = balance_51 * _ONE_E18_3
			TMP_5067(uint256) = TMP_5066 / _expTable25_3
			balance_52(uint256) := TMP_5067(uint256)
		IRs:
			balance_53(uint256) := ϕ(['balance_52', 'balance_1'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_5068(uint256) = t_1 & 67108864
			TMP_5069(bool) = TMP_5068 != 0
			CONDITION TMP_5069
		Expression: balance = (balance * _ONE_E18) / _expTable26
		IRs:
			TMP_5070(uint256) = balance_53 * _ONE_E18_3
			TMP_5071(uint256) = TMP_5070 / _expTable26_3
			balance_54(uint256) := TMP_5071(uint256)
		IRs:
			balance_55(uint256) := ϕ(['balance_54', 'balance_1'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_5072(uint256) = t_1 & 134217728
			TMP_5073(bool) = TMP_5072 != 0
			CONDITION TMP_5073
		Expression: balance = (balance * _ONE_E18) / _expTable27
		IRs:
			TMP_5074(uint256) = balance_55 * _ONE_E18_3
			TMP_5075(uint256) = TMP_5074 / _expTable27_3
			balance_56(uint256) := TMP_5075(uint256)
		IRs:
			balance_57(uint256) := ϕ(['balance_56', 'balance_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_5076(uint256) = t_1 & 268435456
			TMP_5077(bool) = TMP_5076 != 0
			CONDITION TMP_5077
		Expression: balance = (balance * _ONE_E18) / _expTable28
		IRs:
			TMP_5078(uint256) = balance_57 * _ONE_E18_3
			TMP_5079(uint256) = TMP_5078 / _expTable28_3
			balance_58(uint256) := TMP_5079(uint256)
		IRs:
			balance_59(uint256) := ϕ(['balance_58', 'balance_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_5080(uint256) = t_1 & 536870912
			TMP_5081(bool) = TMP_5080 != 0
			CONDITION TMP_5081
		Expression: balance = (balance * _ONE_E18) / _expTable29
		IRs:
			TMP_5082(uint256) = balance_59 * _ONE_E18_3
			TMP_5083(uint256) = TMP_5082 / _expTable29_3
			balance_60(uint256) := TMP_5083(uint256)
		IRs:
			balance_61(uint256) := ϕ(['balance_60', 'balance_1'])
		Expression: balance
		IRs:
			RETURN balance_61
		Expression: timestamp < origin
		IRs:
			TMP_5084(bool) = timestamp_1 < origin_3
			CONDITION TMP_5084
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_3(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: balance
	Function St1inchPreview.constructor(St1inch)
		Expression: st1INCH = st1INCH_
		IRs:
			st1INCH_1(St1inch) := st1INCH__1(St1inch)
		Expression: VotingPowerCalculator(st1INCH_.expBase(),st1INCH_.origin())
		IRs:
			TMP_5085(uint256) = HIGH_LEVEL_CALL, dest:st1INCH__1(St1inch), function:expBase, arguments:[]  
			TMP_5086(uint256) = HIGH_LEVEL_CALL, dest:st1INCH__1(St1inch), function:origin, arguments:[]  
			INTERNAL_CALL, VotingPowerCalculator.constructor(uint256,uint256)(TMP_5085,TMP_5086)
	Function St1inchPreview.previewBalance(address,uint256,uint256)
		IRs:
			st1INCH_2(St1inch) := ϕ(['st1INCH_1', 'st1INCH_3', 'st1INCH_0', 'st1INCH_5', 'st1INCH_9'])
			_VOTING_POWER_DIVIDER_1(uint256) := ϕ(['_VOTING_POWER_DIVIDER_0', '_VOTING_POWER_DIVIDER_7', '_VOTING_POWER_DIVIDER_3'])
		Expression: (None,unlockTime,balance) = st1INCH.depositors(account)
		IRs:
			TUPLE_72(uint40,uint40,uint176) = HIGH_LEVEL_CALL, dest:st1INCH_2(St1inch), function:depositors, arguments:['account_1']  
			st1INCH_3(St1inch) := ϕ(['st1INCH_1', 'st1INCH_3', 'st1INCH_2', 'st1INCH_5', 'st1INCH_9'])
			_VOTING_POWER_DIVIDER_2(uint256) := ϕ(['_VOTING_POWER_DIVIDER_7', '_VOTING_POWER_DIVIDER_1', '_VOTING_POWER_DIVIDER_3'])
			unlockTime_1(uint40)= UNPACK TUPLE_72 index: 1 
			balance_1(uint176)= UNPACK TUPLE_72 index: 2 
		Expression: lockedTill = Math.max(unlockTime,block.timestamp) + duration
		IRs:
			TMP_5088(uint256) = LIBRARY_CALL, dest:Math, function:Math.max(uint256,uint256), arguments:['unlockTime_1', 'block.timestamp'] 
			TMP_5089(uint256) = TMP_5088 (c)+ duration_1
			lockedTill_1(uint256) := TMP_5089(uint256)
		Expression: _balanceAt(balance + amount,lockedTill) / _VOTING_POWER_DIVIDER
		IRs:
			TMP_5090(uint176) = balance_1 (c)+ amount_1
			TMP_5091(uint256) = INTERNAL_CALL, VotingPowerCalculator._balanceAt(uint256,uint256)(TMP_5090,lockedTill_1)
			TMP_5092(uint256) = TMP_5091 (c)/ _VOTING_POWER_DIVIDER_3
			RETURN TMP_5092
	Function St1inchPreview.previewPowerOf(address,uint256,uint256)
		Expression: previewPowerOfAtTime(account,amount,duration,block.timestamp)
		IRs:
			TMP_5093(uint256) = INTERNAL_CALL, St1inchPreview.previewPowerOfAtTime(address,uint256,uint256,uint256)(account_1,amount_1,duration_1,block.timestamp)
			RETURN TMP_5093
	Function St1inchPreview.previewPowerOfAtTime(address,uint256,uint256,uint256)
		IRs:
			account_1(address) := ϕ(['account_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			duration_1(uint256) := ϕ(['duration_1'])
			timestamp_1(uint256) := ϕ(['block.timestamp'])
			st1INCH_4(St1inch) := ϕ(['st1INCH_1', 'st1INCH_3', 'st1INCH_0', 'st1INCH_5', 'st1INCH_9'])
			_VOTING_POWER_DIVIDER_4(uint256) := ϕ(['_VOTING_POWER_DIVIDER_0', '_VOTING_POWER_DIVIDER_7', '_VOTING_POWER_DIVIDER_3'])
		Expression: (None,unlockTime,balance) = st1INCH.depositors(account)
		IRs:
			TUPLE_73(uint40,uint40,uint176) = HIGH_LEVEL_CALL, dest:st1INCH_4(St1inch), function:depositors, arguments:['account_1']  
			st1INCH_5(St1inch) := ϕ(['st1INCH_1', 'st1INCH_3', 'st1INCH_5', 'st1INCH_4', 'st1INCH_9'])
			_VOTING_POWER_DIVIDER_5(uint256) := ϕ(['_VOTING_POWER_DIVIDER_7', '_VOTING_POWER_DIVIDER_4', '_VOTING_POWER_DIVIDER_3'])
			unlockTime_1(uint40)= UNPACK TUPLE_73 index: 1 
			balance_1(uint176)= UNPACK TUPLE_73 index: 2 
		Expression: lockedTill = Math.max(unlockTime,block.timestamp) + duration
		IRs:
			TMP_5094(uint256) = LIBRARY_CALL, dest:Math, function:Math.max(uint256,uint256), arguments:['unlockTime_1', 'block.timestamp'] 
			TMP_5095(uint256) = TMP_5094 (c)+ duration_1
			lockedTill_1(uint256) := TMP_5095(uint256)
		Expression: _votingPowerAt(_balanceAt(balance + amount,lockedTill) / _VOTING_POWER_DIVIDER,timestamp)
		IRs:
			TMP_5096(uint176) = balance_1 (c)+ amount_1
			TMP_5097(uint256) = INTERNAL_CALL, VotingPowerCalculator._balanceAt(uint256,uint256)(TMP_5096,lockedTill_1)
			TMP_5098(uint256) = TMP_5097 (c)/ _VOTING_POWER_DIVIDER_6
			TMP_5099(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(TMP_5098,timestamp_1)
			RETURN TMP_5099
	Function St1inchPreview.previewUnlockTime(address)
		IRs:
			st1INCH_6(St1inch) := ϕ(['st1INCH_1', 'st1INCH_3', 'st1INCH_0', 'st1INCH_5', 'st1INCH_9'])
			_ONE_E9_1(uint256) := ϕ(['_ONE_E9_3', '_ONE_E9_0'])
			durationUntilMaxAllowedLoss_1(uint256) := ϕ(['durationUntilMaxAllowedLoss_4', 'durationUntilMaxAllowedLoss_5', 'durationUntilMaxAllowedLoss_0'])
		Expression: (lockTime,unlockTime,None) = st1INCH.depositors(account)
		IRs:
			TUPLE_74(uint40,uint40,uint176) = HIGH_LEVEL_CALL, dest:st1INCH_6(St1inch), function:depositors, arguments:['account_1']  
			st1INCH_7(St1inch) := ϕ(['st1INCH_1', 'st1INCH_3', 'st1INCH_6', 'st1INCH_5', 'st1INCH_9'])
			_ONE_E9_2(uint256) := ϕ(['_ONE_E9_1', '_ONE_E9_3'])
			durationUntilMaxAllowedLoss_2(uint256) := ϕ(['durationUntilMaxAllowedLoss_4', 'durationUntilMaxAllowedLoss_1', 'durationUntilMaxAllowedLoss_5'])
			lockTime_1(uint40)= UNPACK TUPLE_74 index: 0 
			unlockTime_1(uint40)= UNPACK TUPLE_74 index: 1 
		Expression: allowedExitTime = lockTime + (unlockTime - lockTime) * st1INCH.minLockPeriodRatio() / _ONE_E9
		IRs:
			TMP_5100(uint40) = unlockTime_1 (c)- lockTime_1
			TMP_5101(uint256) = HIGH_LEVEL_CALL, dest:st1INCH_7(St1inch), function:minLockPeriodRatio, arguments:[]  
			st1INCH_8(St1inch) := ϕ(['st1INCH_1', 'st1INCH_7', 'st1INCH_3', 'st1INCH_5', 'st1INCH_9'])
			_ONE_E9_3(uint256) := ϕ(['_ONE_E9_2', '_ONE_E9_3'])
			durationUntilMaxAllowedLoss_3(uint256) := ϕ(['durationUntilMaxAllowedLoss_4', 'durationUntilMaxAllowedLoss_5', 'durationUntilMaxAllowedLoss_2'])
			TMP_5102(uint40) = TMP_5100 (c)* TMP_5101
			TMP_5103(uint40) = TMP_5102 (c)/ _ONE_E9_3
			TMP_5104(uint40) = lockTime_1 (c)+ TMP_5103
			allowedExitTime_1(uint256) := TMP_5104(uint40)
		Expression: allowedExitTime = Math.max(allowedExitTime,unlockTime - st1INCH.MAX_LOCK_PERIOD() + durationUntilMaxAllowedLoss)
		IRs:
			TMP_5105(uint256) = HIGH_LEVEL_CALL, dest:st1INCH_8(St1inch), function:MAX_LOCK_PERIOD, arguments:[]  
			st1INCH_9(St1inch) := ϕ(['st1INCH_1', 'st1INCH_3', 'st1INCH_5', 'st1INCH_9', 'st1INCH_8'])
			durationUntilMaxAllowedLoss_4(uint256) := ϕ(['durationUntilMaxAllowedLoss_3', 'durationUntilMaxAllowedLoss_4', 'durationUntilMaxAllowedLoss_5'])
			TMP_5106(uint40) = unlockTime_1 (c)- TMP_5105
			TMP_5107(uint40) = TMP_5106 (c)+ durationUntilMaxAllowedLoss_4
			TMP_5108(uint256) = LIBRARY_CALL, dest:Math, function:Math.max(uint256,uint256), arguments:['allowedExitTime_1', 'TMP_5107'] 
			allowedExitTime_2(uint256) := TMP_5108(uint256)
		Expression: allowedExitTime
		IRs:
			RETURN allowedExitTime_2
	Function St1inchPreview.setDurationUntilMaxAllowedLoss(uint256)
		Expression: durationUntilMaxAllowedLoss = duration
		IRs:
			durationUntilMaxAllowedLoss_5(uint256) := duration_1(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inchPreview.slitherConstructorConstantVariables()
		Expression: _VOTING_POWER_DIVIDER = 20
		Expression: _ONE_E9 = 1e9
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
Contract VotingPowerCalculator
	Function VotingPowerCalculator.constructor(uint256,uint256)
		IRs:
			expBase__1(uint256) := ϕ(['TMP_3840', 'expBase__1', 'TMP_5085', 'expBase__1', 'TMP_5613'])
			origin__1(uint256) := ϕ(['block.timestamp', 'TMP_3841', 'TMP_5614', 'TMP_5086'])
			_ONE_E18_1(uint256) := ϕ(['_ONE_E18_0'])
		Expression: origin_ > block.timestamp
		IRs:
			TMP_5111(bool) = origin__1 > block.timestamp
			CONDITION TMP_5111
		Expression: revert OriginInTheFuture()()
		IRs:
			TMP_5112(None) = SOLIDITY_CALL revert OriginInTheFuture()()
		Expression: origin = origin_
		IRs:
			origin_1(uint256) := origin__1(uint256)
		Expression: expBase = expBase_
		IRs:
			expBase_1(uint256) := expBase__1(uint256)
		Expression: _expTable0 = expBase_
		IRs:
			_expTable0_1(uint256) := expBase__1(uint256)
		Expression: _expTable1 = (_expTable0 * _expTable0) / _ONE_E18
		IRs:
			TMP_5113(uint256) = _expTable0_1 (c)* _expTable0_1
			TMP_5114(uint256) = TMP_5113 (c)/ _ONE_E18_1
			_expTable1_1(uint256) := TMP_5114(uint256)
		Expression: _expTable2 = (_expTable1 * _expTable1) / _ONE_E18
		IRs:
			TMP_5115(uint256) = _expTable1_1 (c)* _expTable1_1
			TMP_5116(uint256) = TMP_5115 (c)/ _ONE_E18_1
			_expTable2_1(uint256) := TMP_5116(uint256)
		Expression: _expTable3 = (_expTable2 * _expTable2) / _ONE_E18
		IRs:
			TMP_5117(uint256) = _expTable2_1 (c)* _expTable2_1
			TMP_5118(uint256) = TMP_5117 (c)/ _ONE_E18_1
			_expTable3_1(uint256) := TMP_5118(uint256)
		Expression: _expTable4 = (_expTable3 * _expTable3) / _ONE_E18
		IRs:
			TMP_5119(uint256) = _expTable3_1 (c)* _expTable3_1
			TMP_5120(uint256) = TMP_5119 (c)/ _ONE_E18_1
			_expTable4_1(uint256) := TMP_5120(uint256)
		Expression: _expTable5 = (_expTable4 * _expTable4) / _ONE_E18
		IRs:
			TMP_5121(uint256) = _expTable4_1 (c)* _expTable4_1
			TMP_5122(uint256) = TMP_5121 (c)/ _ONE_E18_1
			_expTable5_1(uint256) := TMP_5122(uint256)
		Expression: _expTable6 = (_expTable5 * _expTable5) / _ONE_E18
		IRs:
			TMP_5123(uint256) = _expTable5_1 (c)* _expTable5_1
			TMP_5124(uint256) = TMP_5123 (c)/ _ONE_E18_1
			_expTable6_1(uint256) := TMP_5124(uint256)
		Expression: _expTable7 = (_expTable6 * _expTable6) / _ONE_E18
		IRs:
			TMP_5125(uint256) = _expTable6_1 (c)* _expTable6_1
			TMP_5126(uint256) = TMP_5125 (c)/ _ONE_E18_1
			_expTable7_1(uint256) := TMP_5126(uint256)
		Expression: _expTable8 = (_expTable7 * _expTable7) / _ONE_E18
		IRs:
			TMP_5127(uint256) = _expTable7_1 (c)* _expTable7_1
			TMP_5128(uint256) = TMP_5127 (c)/ _ONE_E18_1
			_expTable8_1(uint256) := TMP_5128(uint256)
		Expression: _expTable9 = (_expTable8 * _expTable8) / _ONE_E18
		IRs:
			TMP_5129(uint256) = _expTable8_1 (c)* _expTable8_1
			TMP_5130(uint256) = TMP_5129 (c)/ _ONE_E18_1
			_expTable9_1(uint256) := TMP_5130(uint256)
		Expression: _expTable10 = (_expTable9 * _expTable9) / _ONE_E18
		IRs:
			TMP_5131(uint256) = _expTable9_1 (c)* _expTable9_1
			TMP_5132(uint256) = TMP_5131 (c)/ _ONE_E18_1
			_expTable10_1(uint256) := TMP_5132(uint256)
		Expression: _expTable11 = (_expTable10 * _expTable10) / _ONE_E18
		IRs:
			TMP_5133(uint256) = _expTable10_1 (c)* _expTable10_1
			TMP_5134(uint256) = TMP_5133 (c)/ _ONE_E18_1
			_expTable11_1(uint256) := TMP_5134(uint256)
		Expression: _expTable12 = (_expTable11 * _expTable11) / _ONE_E18
		IRs:
			TMP_5135(uint256) = _expTable11_1 (c)* _expTable11_1
			TMP_5136(uint256) = TMP_5135 (c)/ _ONE_E18_1
			_expTable12_1(uint256) := TMP_5136(uint256)
		Expression: _expTable13 = (_expTable12 * _expTable12) / _ONE_E18
		IRs:
			TMP_5137(uint256) = _expTable12_1 (c)* _expTable12_1
			TMP_5138(uint256) = TMP_5137 (c)/ _ONE_E18_1
			_expTable13_1(uint256) := TMP_5138(uint256)
		Expression: _expTable14 = (_expTable13 * _expTable13) / _ONE_E18
		IRs:
			TMP_5139(uint256) = _expTable13_1 (c)* _expTable13_1
			TMP_5140(uint256) = TMP_5139 (c)/ _ONE_E18_1
			_expTable14_1(uint256) := TMP_5140(uint256)
		Expression: _expTable15 = (_expTable14 * _expTable14) / _ONE_E18
		IRs:
			TMP_5141(uint256) = _expTable14_1 (c)* _expTable14_1
			TMP_5142(uint256) = TMP_5141 (c)/ _ONE_E18_1
			_expTable15_1(uint256) := TMP_5142(uint256)
		Expression: _expTable16 = (_expTable15 * _expTable15) / _ONE_E18
		IRs:
			TMP_5143(uint256) = _expTable15_1 (c)* _expTable15_1
			TMP_5144(uint256) = TMP_5143 (c)/ _ONE_E18_1
			_expTable16_1(uint256) := TMP_5144(uint256)
		Expression: _expTable17 = (_expTable16 * _expTable16) / _ONE_E18
		IRs:
			TMP_5145(uint256) = _expTable16_1 (c)* _expTable16_1
			TMP_5146(uint256) = TMP_5145 (c)/ _ONE_E18_1
			_expTable17_1(uint256) := TMP_5146(uint256)
		Expression: _expTable18 = (_expTable17 * _expTable17) / _ONE_E18
		IRs:
			TMP_5147(uint256) = _expTable17_1 (c)* _expTable17_1
			TMP_5148(uint256) = TMP_5147 (c)/ _ONE_E18_1
			_expTable18_1(uint256) := TMP_5148(uint256)
		Expression: _expTable19 = (_expTable18 * _expTable18) / _ONE_E18
		IRs:
			TMP_5149(uint256) = _expTable18_1 (c)* _expTable18_1
			TMP_5150(uint256) = TMP_5149 (c)/ _ONE_E18_1
			_expTable19_1(uint256) := TMP_5150(uint256)
		Expression: _expTable20 = (_expTable19 * _expTable19) / _ONE_E18
		IRs:
			TMP_5151(uint256) = _expTable19_1 (c)* _expTable19_1
			TMP_5152(uint256) = TMP_5151 (c)/ _ONE_E18_1
			_expTable20_1(uint256) := TMP_5152(uint256)
		Expression: _expTable21 = (_expTable20 * _expTable20) / _ONE_E18
		IRs:
			TMP_5153(uint256) = _expTable20_1 (c)* _expTable20_1
			TMP_5154(uint256) = TMP_5153 (c)/ _ONE_E18_1
			_expTable21_1(uint256) := TMP_5154(uint256)
		Expression: _expTable22 = (_expTable21 * _expTable21) / _ONE_E18
		IRs:
			TMP_5155(uint256) = _expTable21_1 (c)* _expTable21_1
			TMP_5156(uint256) = TMP_5155 (c)/ _ONE_E18_1
			_expTable22_1(uint256) := TMP_5156(uint256)
		Expression: _expTable23 = (_expTable22 * _expTable22) / _ONE_E18
		IRs:
			TMP_5157(uint256) = _expTable22_1 (c)* _expTable22_1
			TMP_5158(uint256) = TMP_5157 (c)/ _ONE_E18_1
			_expTable23_1(uint256) := TMP_5158(uint256)
		Expression: _expTable24 = (_expTable23 * _expTable23) / _ONE_E18
		IRs:
			TMP_5159(uint256) = _expTable23_1 (c)* _expTable23_1
			TMP_5160(uint256) = TMP_5159 (c)/ _ONE_E18_1
			_expTable24_1(uint256) := TMP_5160(uint256)
		Expression: _expTable25 = (_expTable24 * _expTable24) / _ONE_E18
		IRs:
			TMP_5161(uint256) = _expTable24_1 (c)* _expTable24_1
			TMP_5162(uint256) = TMP_5161 (c)/ _ONE_E18_1
			_expTable25_1(uint256) := TMP_5162(uint256)
		Expression: _expTable26 = (_expTable25 * _expTable25) / _ONE_E18
		IRs:
			TMP_5163(uint256) = _expTable25_1 (c)* _expTable25_1
			TMP_5164(uint256) = TMP_5163 (c)/ _ONE_E18_1
			_expTable26_1(uint256) := TMP_5164(uint256)
		Expression: _expTable27 = (_expTable26 * _expTable26) / _ONE_E18
		IRs:
			TMP_5165(uint256) = _expTable26_1 (c)* _expTable26_1
			TMP_5166(uint256) = TMP_5165 (c)/ _ONE_E18_1
			_expTable27_1(uint256) := TMP_5166(uint256)
		Expression: _expTable28 = (_expTable27 * _expTable27) / _ONE_E18
		IRs:
			TMP_5167(uint256) = _expTable27_1 (c)* _expTable27_1
			TMP_5168(uint256) = TMP_5167 (c)/ _ONE_E18_1
			_expTable28_1(uint256) := TMP_5168(uint256)
		Expression: _expTable29 = (_expTable28 * _expTable28) / _ONE_E18
		IRs:
			TMP_5169(uint256) = _expTable28_1 (c)* _expTable28_1
			TMP_5170(uint256) = TMP_5169 (c)/ _ONE_E18_1
			_expTable29_1(uint256) := TMP_5170(uint256)
	Function VotingPowerCalculator._votingPowerAt(uint256,uint256)
		IRs:
			_ONE_E18_2(uint256) := ϕ(['_ONE_E18_0'])
			origin_2(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_2(uint256) := ϕ(['_expTable0_1', '_expTable0_0'])
			_expTable1_2(uint256) := ϕ(['_expTable1_1', '_expTable1_0'])
			_expTable2_2(uint256) := ϕ(['_expTable2_1', '_expTable2_0'])
			_expTable3_2(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_2(uint256) := ϕ(['_expTable4_1', '_expTable4_0'])
			_expTable5_2(uint256) := ϕ(['_expTable5_1', '_expTable5_0'])
			_expTable6_2(uint256) := ϕ(['_expTable6_1', '_expTable6_0'])
			_expTable7_2(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_2(uint256) := ϕ(['_expTable8_1', '_expTable8_0'])
			_expTable9_2(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_2(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_2(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_2(uint256) := ϕ(['_expTable12_1', '_expTable12_0'])
			_expTable13_2(uint256) := ϕ(['_expTable13_1', '_expTable13_0'])
			_expTable14_2(uint256) := ϕ(['_expTable14_1', '_expTable14_0'])
			_expTable15_2(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_2(uint256) := ϕ(['_expTable16_1', '_expTable16_0'])
			_expTable17_2(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_2(uint256) := ϕ(['_expTable18_1', '_expTable18_0'])
			_expTable19_2(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_2(uint256) := ϕ(['_expTable20_1', '_expTable20_0'])
			_expTable21_2(uint256) := ϕ(['_expTable21_1', '_expTable21_0'])
			_expTable22_2(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_2(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_2(uint256) := ϕ(['_expTable24_1', '_expTable24_0'])
			_expTable25_2(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_2(uint256) := ϕ(['_expTable26_1', '_expTable26_0'])
			_expTable27_2(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_2(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_2(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_5171(uint256) = timestamp_4 - origin_2
			t_1(uint256) := TMP_5171(uint256)
		Expression: votingPower = balance
		IRs:
			votingPower_1(uint256) := balance_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_5172(uint256) = t_1 & 1
			TMP_5173(bool) = TMP_5172 != 0
			CONDITION TMP_5173
		Expression: votingPower = (votingPower * _expTable0) / _ONE_E18
		IRs:
			TMP_5174(uint256) = votingPower_1 * _expTable0_2
			TMP_5175(uint256) = TMP_5174 / _ONE_E18_2
			votingPower_2(uint256) := TMP_5175(uint256)
		IRs:
			votingPower_3(uint256) := ϕ(['votingPower_1', 'votingPower_2'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_5176(uint256) = t_1 & 2
			TMP_5177(bool) = TMP_5176 != 0
			CONDITION TMP_5177
		Expression: votingPower = (votingPower * _expTable1) / _ONE_E18
		IRs:
			TMP_5178(uint256) = votingPower_3 * _expTable1_2
			TMP_5179(uint256) = TMP_5178 / _ONE_E18_2
			votingPower_4(uint256) := TMP_5179(uint256)
		IRs:
			votingPower_5(uint256) := ϕ(['votingPower_1', 'votingPower_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_5180(uint256) = t_1 & 4
			TMP_5181(bool) = TMP_5180 != 0
			CONDITION TMP_5181
		Expression: votingPower = (votingPower * _expTable2) / _ONE_E18
		IRs:
			TMP_5182(uint256) = votingPower_5 * _expTable2_2
			TMP_5183(uint256) = TMP_5182 / _ONE_E18_2
			votingPower_6(uint256) := TMP_5183(uint256)
		IRs:
			votingPower_7(uint256) := ϕ(['votingPower_1', 'votingPower_6'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_5184(uint256) = t_1 & 8
			TMP_5185(bool) = TMP_5184 != 0
			CONDITION TMP_5185
		Expression: votingPower = (votingPower * _expTable3) / _ONE_E18
		IRs:
			TMP_5186(uint256) = votingPower_7 * _expTable3_2
			TMP_5187(uint256) = TMP_5186 / _ONE_E18_2
			votingPower_8(uint256) := TMP_5187(uint256)
		IRs:
			votingPower_9(uint256) := ϕ(['votingPower_1', 'votingPower_8'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_5188(uint256) = t_1 & 16
			TMP_5189(bool) = TMP_5188 != 0
			CONDITION TMP_5189
		Expression: votingPower = (votingPower * _expTable4) / _ONE_E18
		IRs:
			TMP_5190(uint256) = votingPower_9 * _expTable4_2
			TMP_5191(uint256) = TMP_5190 / _ONE_E18_2
			votingPower_10(uint256) := TMP_5191(uint256)
		IRs:
			votingPower_11(uint256) := ϕ(['votingPower_1', 'votingPower_10'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_5192(uint256) = t_1 & 32
			TMP_5193(bool) = TMP_5192 != 0
			CONDITION TMP_5193
		Expression: votingPower = (votingPower * _expTable5) / _ONE_E18
		IRs:
			TMP_5194(uint256) = votingPower_11 * _expTable5_2
			TMP_5195(uint256) = TMP_5194 / _ONE_E18_2
			votingPower_12(uint256) := TMP_5195(uint256)
		IRs:
			votingPower_13(uint256) := ϕ(['votingPower_1', 'votingPower_12'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_5196(uint256) = t_1 & 64
			TMP_5197(bool) = TMP_5196 != 0
			CONDITION TMP_5197
		Expression: votingPower = (votingPower * _expTable6) / _ONE_E18
		IRs:
			TMP_5198(uint256) = votingPower_13 * _expTable6_2
			TMP_5199(uint256) = TMP_5198 / _ONE_E18_2
			votingPower_14(uint256) := TMP_5199(uint256)
		IRs:
			votingPower_15(uint256) := ϕ(['votingPower_1', 'votingPower_14'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_5200(uint256) = t_1 & 128
			TMP_5201(bool) = TMP_5200 != 0
			CONDITION TMP_5201
		Expression: votingPower = (votingPower * _expTable7) / _ONE_E18
		IRs:
			TMP_5202(uint256) = votingPower_15 * _expTable7_2
			TMP_5203(uint256) = TMP_5202 / _ONE_E18_2
			votingPower_16(uint256) := TMP_5203(uint256)
		IRs:
			votingPower_17(uint256) := ϕ(['votingPower_1', 'votingPower_16'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_5204(uint256) = t_1 & 256
			TMP_5205(bool) = TMP_5204 != 0
			CONDITION TMP_5205
		Expression: votingPower = (votingPower * _expTable8) / _ONE_E18
		IRs:
			TMP_5206(uint256) = votingPower_17 * _expTable8_2
			TMP_5207(uint256) = TMP_5206 / _ONE_E18_2
			votingPower_18(uint256) := TMP_5207(uint256)
		IRs:
			votingPower_19(uint256) := ϕ(['votingPower_1', 'votingPower_18'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_5208(uint256) = t_1 & 512
			TMP_5209(bool) = TMP_5208 != 0
			CONDITION TMP_5209
		Expression: votingPower = (votingPower * _expTable9) / _ONE_E18
		IRs:
			TMP_5210(uint256) = votingPower_19 * _expTable9_2
			TMP_5211(uint256) = TMP_5210 / _ONE_E18_2
			votingPower_20(uint256) := TMP_5211(uint256)
		IRs:
			votingPower_21(uint256) := ϕ(['votingPower_1', 'votingPower_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_5212(uint256) = t_1 & 1024
			TMP_5213(bool) = TMP_5212 != 0
			CONDITION TMP_5213
		Expression: votingPower = (votingPower * _expTable10) / _ONE_E18
		IRs:
			TMP_5214(uint256) = votingPower_21 * _expTable10_2
			TMP_5215(uint256) = TMP_5214 / _ONE_E18_2
			votingPower_22(uint256) := TMP_5215(uint256)
		IRs:
			votingPower_23(uint256) := ϕ(['votingPower_1', 'votingPower_22'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_5216(uint256) = t_1 & 2048
			TMP_5217(bool) = TMP_5216 != 0
			CONDITION TMP_5217
		Expression: votingPower = (votingPower * _expTable11) / _ONE_E18
		IRs:
			TMP_5218(uint256) = votingPower_23 * _expTable11_2
			TMP_5219(uint256) = TMP_5218 / _ONE_E18_2
			votingPower_24(uint256) := TMP_5219(uint256)
		IRs:
			votingPower_25(uint256) := ϕ(['votingPower_1', 'votingPower_24'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_5220(uint256) = t_1 & 4096
			TMP_5221(bool) = TMP_5220 != 0
			CONDITION TMP_5221
		Expression: votingPower = (votingPower * _expTable12) / _ONE_E18
		IRs:
			TMP_5222(uint256) = votingPower_25 * _expTable12_2
			TMP_5223(uint256) = TMP_5222 / _ONE_E18_2
			votingPower_26(uint256) := TMP_5223(uint256)
		IRs:
			votingPower_27(uint256) := ϕ(['votingPower_1', 'votingPower_26'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_5224(uint256) = t_1 & 8192
			TMP_5225(bool) = TMP_5224 != 0
			CONDITION TMP_5225
		Expression: votingPower = (votingPower * _expTable13) / _ONE_E18
		IRs:
			TMP_5226(uint256) = votingPower_27 * _expTable13_2
			TMP_5227(uint256) = TMP_5226 / _ONE_E18_2
			votingPower_28(uint256) := TMP_5227(uint256)
		IRs:
			votingPower_29(uint256) := ϕ(['votingPower_1', 'votingPower_28'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_5228(uint256) = t_1 & 16384
			TMP_5229(bool) = TMP_5228 != 0
			CONDITION TMP_5229
		Expression: votingPower = (votingPower * _expTable14) / _ONE_E18
		IRs:
			TMP_5230(uint256) = votingPower_29 * _expTable14_2
			TMP_5231(uint256) = TMP_5230 / _ONE_E18_2
			votingPower_30(uint256) := TMP_5231(uint256)
		IRs:
			votingPower_31(uint256) := ϕ(['votingPower_1', 'votingPower_30'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_5232(uint256) = t_1 & 32768
			TMP_5233(bool) = TMP_5232 != 0
			CONDITION TMP_5233
		Expression: votingPower = (votingPower * _expTable15) / _ONE_E18
		IRs:
			TMP_5234(uint256) = votingPower_31 * _expTable15_2
			TMP_5235(uint256) = TMP_5234 / _ONE_E18_2
			votingPower_32(uint256) := TMP_5235(uint256)
		IRs:
			votingPower_33(uint256) := ϕ(['votingPower_1', 'votingPower_32'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_5236(uint256) = t_1 & 65536
			TMP_5237(bool) = TMP_5236 != 0
			CONDITION TMP_5237
		Expression: votingPower = (votingPower * _expTable16) / _ONE_E18
		IRs:
			TMP_5238(uint256) = votingPower_33 * _expTable16_2
			TMP_5239(uint256) = TMP_5238 / _ONE_E18_2
			votingPower_34(uint256) := TMP_5239(uint256)
		IRs:
			votingPower_35(uint256) := ϕ(['votingPower_1', 'votingPower_34'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_5240(uint256) = t_1 & 131072
			TMP_5241(bool) = TMP_5240 != 0
			CONDITION TMP_5241
		Expression: votingPower = (votingPower * _expTable17) / _ONE_E18
		IRs:
			TMP_5242(uint256) = votingPower_35 * _expTable17_2
			TMP_5243(uint256) = TMP_5242 / _ONE_E18_2
			votingPower_36(uint256) := TMP_5243(uint256)
		IRs:
			votingPower_37(uint256) := ϕ(['votingPower_1', 'votingPower_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_5244(uint256) = t_1 & 262144
			TMP_5245(bool) = TMP_5244 != 0
			CONDITION TMP_5245
		Expression: votingPower = (votingPower * _expTable18) / _ONE_E18
		IRs:
			TMP_5246(uint256) = votingPower_37 * _expTable18_2
			TMP_5247(uint256) = TMP_5246 / _ONE_E18_2
			votingPower_38(uint256) := TMP_5247(uint256)
		IRs:
			votingPower_39(uint256) := ϕ(['votingPower_1', 'votingPower_38'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_5248(uint256) = t_1 & 524288
			TMP_5249(bool) = TMP_5248 != 0
			CONDITION TMP_5249
		Expression: votingPower = (votingPower * _expTable19) / _ONE_E18
		IRs:
			TMP_5250(uint256) = votingPower_39 * _expTable19_2
			TMP_5251(uint256) = TMP_5250 / _ONE_E18_2
			votingPower_40(uint256) := TMP_5251(uint256)
		IRs:
			votingPower_41(uint256) := ϕ(['votingPower_1', 'votingPower_40'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_5252(uint256) = t_1 & 1048576
			TMP_5253(bool) = TMP_5252 != 0
			CONDITION TMP_5253
		Expression: votingPower = (votingPower * _expTable20) / _ONE_E18
		IRs:
			TMP_5254(uint256) = votingPower_41 * _expTable20_2
			TMP_5255(uint256) = TMP_5254 / _ONE_E18_2
			votingPower_42(uint256) := TMP_5255(uint256)
		IRs:
			votingPower_43(uint256) := ϕ(['votingPower_1', 'votingPower_42'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_5256(uint256) = t_1 & 2097152
			TMP_5257(bool) = TMP_5256 != 0
			CONDITION TMP_5257
		Expression: votingPower = (votingPower * _expTable21) / _ONE_E18
		IRs:
			TMP_5258(uint256) = votingPower_43 * _expTable21_2
			TMP_5259(uint256) = TMP_5258 / _ONE_E18_2
			votingPower_44(uint256) := TMP_5259(uint256)
		IRs:
			votingPower_45(uint256) := ϕ(['votingPower_1', 'votingPower_44'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_5260(uint256) = t_1 & 4194304
			TMP_5261(bool) = TMP_5260 != 0
			CONDITION TMP_5261
		Expression: votingPower = (votingPower * _expTable22) / _ONE_E18
		IRs:
			TMP_5262(uint256) = votingPower_45 * _expTable22_2
			TMP_5263(uint256) = TMP_5262 / _ONE_E18_2
			votingPower_46(uint256) := TMP_5263(uint256)
		IRs:
			votingPower_47(uint256) := ϕ(['votingPower_1', 'votingPower_46'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_5264(uint256) = t_1 & 8388608
			TMP_5265(bool) = TMP_5264 != 0
			CONDITION TMP_5265
		Expression: votingPower = (votingPower * _expTable23) / _ONE_E18
		IRs:
			TMP_5266(uint256) = votingPower_47 * _expTable23_2
			TMP_5267(uint256) = TMP_5266 / _ONE_E18_2
			votingPower_48(uint256) := TMP_5267(uint256)
		IRs:
			votingPower_49(uint256) := ϕ(['votingPower_1', 'votingPower_48'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_5268(uint256) = t_1 & 16777216
			TMP_5269(bool) = TMP_5268 != 0
			CONDITION TMP_5269
		Expression: votingPower = (votingPower * _expTable24) / _ONE_E18
		IRs:
			TMP_5270(uint256) = votingPower_49 * _expTable24_2
			TMP_5271(uint256) = TMP_5270 / _ONE_E18_2
			votingPower_50(uint256) := TMP_5271(uint256)
		IRs:
			votingPower_51(uint256) := ϕ(['votingPower_1', 'votingPower_50'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_5272(uint256) = t_1 & 33554432
			TMP_5273(bool) = TMP_5272 != 0
			CONDITION TMP_5273
		Expression: votingPower = (votingPower * _expTable25) / _ONE_E18
		IRs:
			TMP_5274(uint256) = votingPower_51 * _expTable25_2
			TMP_5275(uint256) = TMP_5274 / _ONE_E18_2
			votingPower_52(uint256) := TMP_5275(uint256)
		IRs:
			votingPower_53(uint256) := ϕ(['votingPower_1', 'votingPower_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_5276(uint256) = t_1 & 67108864
			TMP_5277(bool) = TMP_5276 != 0
			CONDITION TMP_5277
		Expression: votingPower = (votingPower * _expTable26) / _ONE_E18
		IRs:
			TMP_5278(uint256) = votingPower_53 * _expTable26_2
			TMP_5279(uint256) = TMP_5278 / _ONE_E18_2
			votingPower_54(uint256) := TMP_5279(uint256)
		IRs:
			votingPower_55(uint256) := ϕ(['votingPower_1', 'votingPower_54'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_5280(uint256) = t_1 & 134217728
			TMP_5281(bool) = TMP_5280 != 0
			CONDITION TMP_5281
		Expression: votingPower = (votingPower * _expTable27) / _ONE_E18
		IRs:
			TMP_5282(uint256) = votingPower_55 * _expTable27_2
			TMP_5283(uint256) = TMP_5282 / _ONE_E18_2
			votingPower_56(uint256) := TMP_5283(uint256)
		IRs:
			votingPower_57(uint256) := ϕ(['votingPower_1', 'votingPower_56'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_5284(uint256) = t_1 & 268435456
			TMP_5285(bool) = TMP_5284 != 0
			CONDITION TMP_5285
		Expression: votingPower = (votingPower * _expTable28) / _ONE_E18
		IRs:
			TMP_5286(uint256) = votingPower_57 * _expTable28_2
			TMP_5287(uint256) = TMP_5286 / _ONE_E18_2
			votingPower_58(uint256) := TMP_5287(uint256)
		IRs:
			votingPower_59(uint256) := ϕ(['votingPower_1', 'votingPower_58'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_5288(uint256) = t_1 & 536870912
			TMP_5289(bool) = TMP_5288 != 0
			CONDITION TMP_5289
		Expression: votingPower = (votingPower * _expTable29) / _ONE_E18
		IRs:
			TMP_5290(uint256) = votingPower_59 * _expTable29_2
			TMP_5291(uint256) = TMP_5290 / _ONE_E18_2
			votingPower_60(uint256) := TMP_5291(uint256)
		IRs:
			votingPower_61(uint256) := ϕ(['votingPower_1', 'votingPower_60'])
		Expression: votingPower
		IRs:
			RETURN votingPower_61
		Expression: timestamp < origin
		IRs:
			TMP_5292(bool) = timestamp_1 < origin_2
			CONDITION TMP_5292
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_2(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: votingPower
	Function VotingPowerCalculator._balanceAt(uint256,uint256)
		IRs:
			_ONE_E18_3(uint256) := ϕ(['_ONE_E18_0'])
			origin_3(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_3(uint256) := ϕ(['_expTable0_1', '_expTable0_0'])
			_expTable1_3(uint256) := ϕ(['_expTable1_1', '_expTable1_0'])
			_expTable2_3(uint256) := ϕ(['_expTable2_1', '_expTable2_0'])
			_expTable3_3(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_3(uint256) := ϕ(['_expTable4_1', '_expTable4_0'])
			_expTable5_3(uint256) := ϕ(['_expTable5_1', '_expTable5_0'])
			_expTable6_3(uint256) := ϕ(['_expTable6_1', '_expTable6_0'])
			_expTable7_3(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_3(uint256) := ϕ(['_expTable8_1', '_expTable8_0'])
			_expTable9_3(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_3(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_3(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_3(uint256) := ϕ(['_expTable12_1', '_expTable12_0'])
			_expTable13_3(uint256) := ϕ(['_expTable13_1', '_expTable13_0'])
			_expTable14_3(uint256) := ϕ(['_expTable14_1', '_expTable14_0'])
			_expTable15_3(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_3(uint256) := ϕ(['_expTable16_1', '_expTable16_0'])
			_expTable17_3(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_3(uint256) := ϕ(['_expTable18_1', '_expTable18_0'])
			_expTable19_3(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_3(uint256) := ϕ(['_expTable20_1', '_expTable20_0'])
			_expTable21_3(uint256) := ϕ(['_expTable21_1', '_expTable21_0'])
			_expTable22_3(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_3(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_3(uint256) := ϕ(['_expTable24_1', '_expTable24_0'])
			_expTable25_3(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_3(uint256) := ϕ(['_expTable26_1', '_expTable26_0'])
			_expTable27_3(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_3(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_3(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_5293(uint256) = timestamp_4 - origin_3
			t_1(uint256) := TMP_5293(uint256)
		Expression: balance = votingPower
		IRs:
			balance_1(uint256) := votingPower_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_5294(uint256) = t_1 & 1
			TMP_5295(bool) = TMP_5294 != 0
			CONDITION TMP_5295
		Expression: balance = (balance * _ONE_E18) / _expTable0
		IRs:
			TMP_5296(uint256) = balance_1 * _ONE_E18_3
			TMP_5297(uint256) = TMP_5296 / _expTable0_3
			balance_2(uint256) := TMP_5297(uint256)
		IRs:
			balance_3(uint256) := ϕ(['balance_2', 'balance_1'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_5298(uint256) = t_1 & 2
			TMP_5299(bool) = TMP_5298 != 0
			CONDITION TMP_5299
		Expression: balance = (balance * _ONE_E18) / _expTable1
		IRs:
			TMP_5300(uint256) = balance_3 * _ONE_E18_3
			TMP_5301(uint256) = TMP_5300 / _expTable1_3
			balance_4(uint256) := TMP_5301(uint256)
		IRs:
			balance_5(uint256) := ϕ(['balance_4', 'balance_1'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_5302(uint256) = t_1 & 4
			TMP_5303(bool) = TMP_5302 != 0
			CONDITION TMP_5303
		Expression: balance = (balance * _ONE_E18) / _expTable2
		IRs:
			TMP_5304(uint256) = balance_5 * _ONE_E18_3
			TMP_5305(uint256) = TMP_5304 / _expTable2_3
			balance_6(uint256) := TMP_5305(uint256)
		IRs:
			balance_7(uint256) := ϕ(['balance_6', 'balance_1'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_5306(uint256) = t_1 & 8
			TMP_5307(bool) = TMP_5306 != 0
			CONDITION TMP_5307
		Expression: balance = (balance * _ONE_E18) / _expTable3
		IRs:
			TMP_5308(uint256) = balance_7 * _ONE_E18_3
			TMP_5309(uint256) = TMP_5308 / _expTable3_3
			balance_8(uint256) := TMP_5309(uint256)
		IRs:
			balance_9(uint256) := ϕ(['balance_8', 'balance_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_5310(uint256) = t_1 & 16
			TMP_5311(bool) = TMP_5310 != 0
			CONDITION TMP_5311
		Expression: balance = (balance * _ONE_E18) / _expTable4
		IRs:
			TMP_5312(uint256) = balance_9 * _ONE_E18_3
			TMP_5313(uint256) = TMP_5312 / _expTable4_3
			balance_10(uint256) := TMP_5313(uint256)
		IRs:
			balance_11(uint256) := ϕ(['balance_10', 'balance_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_5314(uint256) = t_1 & 32
			TMP_5315(bool) = TMP_5314 != 0
			CONDITION TMP_5315
		Expression: balance = (balance * _ONE_E18) / _expTable5
		IRs:
			TMP_5316(uint256) = balance_11 * _ONE_E18_3
			TMP_5317(uint256) = TMP_5316 / _expTable5_3
			balance_12(uint256) := TMP_5317(uint256)
		IRs:
			balance_13(uint256) := ϕ(['balance_12', 'balance_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_5318(uint256) = t_1 & 64
			TMP_5319(bool) = TMP_5318 != 0
			CONDITION TMP_5319
		Expression: balance = (balance * _ONE_E18) / _expTable6
		IRs:
			TMP_5320(uint256) = balance_13 * _ONE_E18_3
			TMP_5321(uint256) = TMP_5320 / _expTable6_3
			balance_14(uint256) := TMP_5321(uint256)
		IRs:
			balance_15(uint256) := ϕ(['balance_14', 'balance_1'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_5322(uint256) = t_1 & 128
			TMP_5323(bool) = TMP_5322 != 0
			CONDITION TMP_5323
		Expression: balance = (balance * _ONE_E18) / _expTable7
		IRs:
			TMP_5324(uint256) = balance_15 * _ONE_E18_3
			TMP_5325(uint256) = TMP_5324 / _expTable7_3
			balance_16(uint256) := TMP_5325(uint256)
		IRs:
			balance_17(uint256) := ϕ(['balance_16', 'balance_1'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_5326(uint256) = t_1 & 256
			TMP_5327(bool) = TMP_5326 != 0
			CONDITION TMP_5327
		Expression: balance = (balance * _ONE_E18) / _expTable8
		IRs:
			TMP_5328(uint256) = balance_17 * _ONE_E18_3
			TMP_5329(uint256) = TMP_5328 / _expTable8_3
			balance_18(uint256) := TMP_5329(uint256)
		IRs:
			balance_19(uint256) := ϕ(['balance_18', 'balance_1'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_5330(uint256) = t_1 & 512
			TMP_5331(bool) = TMP_5330 != 0
			CONDITION TMP_5331
		Expression: balance = (balance * _ONE_E18) / _expTable9
		IRs:
			TMP_5332(uint256) = balance_19 * _ONE_E18_3
			TMP_5333(uint256) = TMP_5332 / _expTable9_3
			balance_20(uint256) := TMP_5333(uint256)
		IRs:
			balance_21(uint256) := ϕ(['balance_20', 'balance_1'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_5334(uint256) = t_1 & 1024
			TMP_5335(bool) = TMP_5334 != 0
			CONDITION TMP_5335
		Expression: balance = (balance * _ONE_E18) / _expTable10
		IRs:
			TMP_5336(uint256) = balance_21 * _ONE_E18_3
			TMP_5337(uint256) = TMP_5336 / _expTable10_3
			balance_22(uint256) := TMP_5337(uint256)
		IRs:
			balance_23(uint256) := ϕ(['balance_22', 'balance_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_5338(uint256) = t_1 & 2048
			TMP_5339(bool) = TMP_5338 != 0
			CONDITION TMP_5339
		Expression: balance = (balance * _ONE_E18) / _expTable11
		IRs:
			TMP_5340(uint256) = balance_23 * _ONE_E18_3
			TMP_5341(uint256) = TMP_5340 / _expTable11_3
			balance_24(uint256) := TMP_5341(uint256)
		IRs:
			balance_25(uint256) := ϕ(['balance_24', 'balance_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_5342(uint256) = t_1 & 4096
			TMP_5343(bool) = TMP_5342 != 0
			CONDITION TMP_5343
		Expression: balance = (balance * _ONE_E18) / _expTable12
		IRs:
			TMP_5344(uint256) = balance_25 * _ONE_E18_3
			TMP_5345(uint256) = TMP_5344 / _expTable12_3
			balance_26(uint256) := TMP_5345(uint256)
		IRs:
			balance_27(uint256) := ϕ(['balance_26', 'balance_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_5346(uint256) = t_1 & 8192
			TMP_5347(bool) = TMP_5346 != 0
			CONDITION TMP_5347
		Expression: balance = (balance * _ONE_E18) / _expTable13
		IRs:
			TMP_5348(uint256) = balance_27 * _ONE_E18_3
			TMP_5349(uint256) = TMP_5348 / _expTable13_3
			balance_28(uint256) := TMP_5349(uint256)
		IRs:
			balance_29(uint256) := ϕ(['balance_28', 'balance_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_5350(uint256) = t_1 & 16384
			TMP_5351(bool) = TMP_5350 != 0
			CONDITION TMP_5351
		Expression: balance = (balance * _ONE_E18) / _expTable14
		IRs:
			TMP_5352(uint256) = balance_29 * _ONE_E18_3
			TMP_5353(uint256) = TMP_5352 / _expTable14_3
			balance_30(uint256) := TMP_5353(uint256)
		IRs:
			balance_31(uint256) := ϕ(['balance_30', 'balance_1'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_5354(uint256) = t_1 & 32768
			TMP_5355(bool) = TMP_5354 != 0
			CONDITION TMP_5355
		Expression: balance = (balance * _ONE_E18) / _expTable15
		IRs:
			TMP_5356(uint256) = balance_31 * _ONE_E18_3
			TMP_5357(uint256) = TMP_5356 / _expTable15_3
			balance_32(uint256) := TMP_5357(uint256)
		IRs:
			balance_33(uint256) := ϕ(['balance_32', 'balance_1'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_5358(uint256) = t_1 & 65536
			TMP_5359(bool) = TMP_5358 != 0
			CONDITION TMP_5359
		Expression: balance = (balance * _ONE_E18) / _expTable16
		IRs:
			TMP_5360(uint256) = balance_33 * _ONE_E18_3
			TMP_5361(uint256) = TMP_5360 / _expTable16_3
			balance_34(uint256) := TMP_5361(uint256)
		IRs:
			balance_35(uint256) := ϕ(['balance_34', 'balance_1'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_5362(uint256) = t_1 & 131072
			TMP_5363(bool) = TMP_5362 != 0
			CONDITION TMP_5363
		Expression: balance = (balance * _ONE_E18) / _expTable17
		IRs:
			TMP_5364(uint256) = balance_35 * _ONE_E18_3
			TMP_5365(uint256) = TMP_5364 / _expTable17_3
			balance_36(uint256) := TMP_5365(uint256)
		IRs:
			balance_37(uint256) := ϕ(['balance_36', 'balance_1'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_5366(uint256) = t_1 & 262144
			TMP_5367(bool) = TMP_5366 != 0
			CONDITION TMP_5367
		Expression: balance = (balance * _ONE_E18) / _expTable18
		IRs:
			TMP_5368(uint256) = balance_37 * _ONE_E18_3
			TMP_5369(uint256) = TMP_5368 / _expTable18_3
			balance_38(uint256) := TMP_5369(uint256)
		IRs:
			balance_39(uint256) := ϕ(['balance_38', 'balance_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_5370(uint256) = t_1 & 524288
			TMP_5371(bool) = TMP_5370 != 0
			CONDITION TMP_5371
		Expression: balance = (balance * _ONE_E18) / _expTable19
		IRs:
			TMP_5372(uint256) = balance_39 * _ONE_E18_3
			TMP_5373(uint256) = TMP_5372 / _expTable19_3
			balance_40(uint256) := TMP_5373(uint256)
		IRs:
			balance_41(uint256) := ϕ(['balance_40', 'balance_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_5374(uint256) = t_1 & 1048576
			TMP_5375(bool) = TMP_5374 != 0
			CONDITION TMP_5375
		Expression: balance = (balance * _ONE_E18) / _expTable20
		IRs:
			TMP_5376(uint256) = balance_41 * _ONE_E18_3
			TMP_5377(uint256) = TMP_5376 / _expTable20_3
			balance_42(uint256) := TMP_5377(uint256)
		IRs:
			balance_43(uint256) := ϕ(['balance_42', 'balance_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_5378(uint256) = t_1 & 2097152
			TMP_5379(bool) = TMP_5378 != 0
			CONDITION TMP_5379
		Expression: balance = (balance * _ONE_E18) / _expTable21
		IRs:
			TMP_5380(uint256) = balance_43 * _ONE_E18_3
			TMP_5381(uint256) = TMP_5380 / _expTable21_3
			balance_44(uint256) := TMP_5381(uint256)
		IRs:
			balance_45(uint256) := ϕ(['balance_44', 'balance_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_5382(uint256) = t_1 & 4194304
			TMP_5383(bool) = TMP_5382 != 0
			CONDITION TMP_5383
		Expression: balance = (balance * _ONE_E18) / _expTable22
		IRs:
			TMP_5384(uint256) = balance_45 * _ONE_E18_3
			TMP_5385(uint256) = TMP_5384 / _expTable22_3
			balance_46(uint256) := TMP_5385(uint256)
		IRs:
			balance_47(uint256) := ϕ(['balance_46', 'balance_1'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_5386(uint256) = t_1 & 8388608
			TMP_5387(bool) = TMP_5386 != 0
			CONDITION TMP_5387
		Expression: balance = (balance * _ONE_E18) / _expTable23
		IRs:
			TMP_5388(uint256) = balance_47 * _ONE_E18_3
			TMP_5389(uint256) = TMP_5388 / _expTable23_3
			balance_48(uint256) := TMP_5389(uint256)
		IRs:
			balance_49(uint256) := ϕ(['balance_48', 'balance_1'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_5390(uint256) = t_1 & 16777216
			TMP_5391(bool) = TMP_5390 != 0
			CONDITION TMP_5391
		Expression: balance = (balance * _ONE_E18) / _expTable24
		IRs:
			TMP_5392(uint256) = balance_49 * _ONE_E18_3
			TMP_5393(uint256) = TMP_5392 / _expTable24_3
			balance_50(uint256) := TMP_5393(uint256)
		IRs:
			balance_51(uint256) := ϕ(['balance_50', 'balance_1'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_5394(uint256) = t_1 & 33554432
			TMP_5395(bool) = TMP_5394 != 0
			CONDITION TMP_5395
		Expression: balance = (balance * _ONE_E18) / _expTable25
		IRs:
			TMP_5396(uint256) = balance_51 * _ONE_E18_3
			TMP_5397(uint256) = TMP_5396 / _expTable25_3
			balance_52(uint256) := TMP_5397(uint256)
		IRs:
			balance_53(uint256) := ϕ(['balance_52', 'balance_1'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_5398(uint256) = t_1 & 67108864
			TMP_5399(bool) = TMP_5398 != 0
			CONDITION TMP_5399
		Expression: balance = (balance * _ONE_E18) / _expTable26
		IRs:
			TMP_5400(uint256) = balance_53 * _ONE_E18_3
			TMP_5401(uint256) = TMP_5400 / _expTable26_3
			balance_54(uint256) := TMP_5401(uint256)
		IRs:
			balance_55(uint256) := ϕ(['balance_54', 'balance_1'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_5402(uint256) = t_1 & 134217728
			TMP_5403(bool) = TMP_5402 != 0
			CONDITION TMP_5403
		Expression: balance = (balance * _ONE_E18) / _expTable27
		IRs:
			TMP_5404(uint256) = balance_55 * _ONE_E18_3
			TMP_5405(uint256) = TMP_5404 / _expTable27_3
			balance_56(uint256) := TMP_5405(uint256)
		IRs:
			balance_57(uint256) := ϕ(['balance_56', 'balance_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_5406(uint256) = t_1 & 268435456
			TMP_5407(bool) = TMP_5406 != 0
			CONDITION TMP_5407
		Expression: balance = (balance * _ONE_E18) / _expTable28
		IRs:
			TMP_5408(uint256) = balance_57 * _ONE_E18_3
			TMP_5409(uint256) = TMP_5408 / _expTable28_3
			balance_58(uint256) := TMP_5409(uint256)
		IRs:
			balance_59(uint256) := ϕ(['balance_58', 'balance_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_5410(uint256) = t_1 & 536870912
			TMP_5411(bool) = TMP_5410 != 0
			CONDITION TMP_5411
		Expression: balance = (balance * _ONE_E18) / _expTable29
		IRs:
			TMP_5412(uint256) = balance_59 * _ONE_E18_3
			TMP_5413(uint256) = TMP_5412 / _expTable29_3
			balance_60(uint256) := TMP_5413(uint256)
		IRs:
			balance_61(uint256) := ϕ(['balance_60', 'balance_1'])
		Expression: balance
		IRs:
			RETURN balance_61
		Expression: timestamp < origin
		IRs:
			TMP_5414(bool) = timestamp_1 < origin_3
			CONDITION TMP_5414
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_3(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: balance
	Function VotingPowerCalculator.slitherConstructorConstantVariables()
		Expression: _ONE_E18 = 1e18
Contract WhitelistHelper
	Function WhitelistHelper.constructor(WhitelistRegistry)
		Expression: whitelistRegistry = whitelistRegistry_
		IRs:
			whitelistRegistry_1(WhitelistRegistry) := whitelistRegistry__1(WhitelistRegistry)
		Expression: delegation = IERC20(whitelistRegistry.token())
		IRs:
			TMP_5415(IVotable) = HIGH_LEVEL_CALL, dest:whitelistRegistry_1(WhitelistRegistry), function:token, arguments:[]  
			whitelistRegistry_2(WhitelistRegistry) := ϕ(['whitelistRegistry_1', 'whitelistRegistry_6', 'whitelistRegistry_2'])
			TMP_5416 = CONVERT TMP_5415 to IERC20
			delegation_1(IERC20) := TMP_5416(IERC20)
	Function WhitelistHelper.getMinAmountForWhitelisted()
		IRs:
			whitelistRegistry_3(WhitelistRegistry) := ϕ(['whitelistRegistry_6', 'whitelistRegistry_2', 'whitelistRegistry_0'])
			delegation_2(IERC20) := ϕ(['delegation_6', 'delegation_0', 'delegation_5', 'delegation_1'])
		Expression: whitelist = whitelistRegistry.getWhitelist()
		IRs:
			TMP_5417(address[]) = HIGH_LEVEL_CALL, dest:whitelistRegistry_3(WhitelistRegistry), function:getWhitelist, arguments:[]  
			whitelistRegistry_4(WhitelistRegistry) := ϕ(['whitelistRegistry_3', 'whitelistRegistry_6', 'whitelistRegistry_2'])
			delegation_3(IERC20) := ϕ(['delegation_6', 'delegation_5', 'delegation_2', 'delegation_1'])
			whitelist_1(address[]) = ['TMP_5417(address[])']
		Expression: whitelistLength = whitelist.length
		IRs:
			REF_1178 -> LENGTH whitelist_1
			whitelistLength_1(uint256) := REF_1178(uint256)
		Expression: threshold = whitelistRegistry.resolverThreshold()
		IRs:
			TMP_5418(uint256) = HIGH_LEVEL_CALL, dest:whitelistRegistry_4(WhitelistRegistry), function:resolverThreshold, arguments:[]  
			whitelistRegistry_5(WhitelistRegistry) := ϕ(['whitelistRegistry_6', 'whitelistRegistry_2', 'whitelistRegistry_4'])
			delegation_4(IERC20) := ϕ(['delegation_6', 'delegation_5', 'delegation_3', 'delegation_1'])
			threshold_1(uint256) := TMP_5418(uint256)
		Expression: whitelistLength < whitelistRegistry.whitelistLimit()
		IRs:
			TMP_5419(uint256) = HIGH_LEVEL_CALL, dest:whitelistRegistry_5(WhitelistRegistry), function:whitelistLimit, arguments:[]  
			whitelistRegistry_6(WhitelistRegistry) := ϕ(['whitelistRegistry_6', 'whitelistRegistry_5', 'whitelistRegistry_2'])
			delegation_5(IERC20) := ϕ(['delegation_6', 'delegation_5', 'delegation_1', 'delegation_4'])
			TMP_5420(bool) = whitelistLength_1 < TMP_5419
			CONDITION TMP_5420
		Expression: threshold
		IRs:
			RETURN threshold_1
		Expression: minBalance = delegation.balanceOf(whitelist[0])
		IRs:
			REF_1182(address) -> whitelist_1[0]
			TMP_5421(uint256) = HIGH_LEVEL_CALL, dest:delegation_5(IERC20), function:balanceOf, arguments:['REF_1182']  
			delegation_6(IERC20) := ϕ(['delegation_6', 'delegation_5', 'delegation_1'])
			minBalance_1(uint256) := TMP_5421(uint256)
		Expression: i = 1
		IRs:
			i_1(uint256) := 1(uint256)
		Expression: i < whitelistLength
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_5422(bool) = i_2 < whitelistLength_1
			CONDITION TMP_5422
		Expression: balance = delegation.balanceOf(whitelist[i])
		IRs:
			REF_1184(address) -> whitelist_1[i_2]
			TMP_5423(uint256) = HIGH_LEVEL_CALL, dest:delegation_6(IERC20), function:balanceOf, arguments:['REF_1184']  
			delegation_7(IERC20) := ϕ(['delegation_6', 'delegation_5', 'delegation_1'])
			balance_1(uint256) := TMP_5423(uint256)
		Expression: balance < minBalance
		IRs:
			TMP_5424(bool) = balance_1 < minBalance_1
			CONDITION TMP_5424
		Expression: minBalance = balance
		IRs:
			minBalance_2(uint256) := balance_1(uint256)
		IRs:
			minBalance_3(uint256) := ϕ(['minBalance_1', 'minBalance_2'])
		Expression: ++ i
		IRs:
			i_3(uint256) = i_2 (c)+ 1
		Expression: minBalance < threshold
		IRs:
			TMP_5425(bool) = minBalance_1 < threshold_1
			CONDITION TMP_5425
		Expression: threshold
		IRs:
			RETURN threshold_1
		Expression: minBalance + 1
		IRs:
			TMP_5426(uint256) = minBalance_1 (c)+ 1
			RETURN TMP_5426
Contract IFeeBank
	Function IFeeBank.availableCredit(address)
	Function IFeeBank.deposit(uint256)
	Function IFeeBank.depositFor(address,uint256)
	Function IFeeBank.depositWithPermit(uint256,bytes)
	Function IFeeBank.depositForWithPermit(address,uint256,bytes)
	Function IFeeBank.withdraw(uint256)
	Function IFeeBank.withdrawTo(address,uint256)
Contract IFeeBankCharger
	Function IFeeBankCharger.feeBank()
	Function IFeeBankCharger.availableCredit(address)
	Function IFeeBankCharger.increaseAvailableCredit(address,uint256)
	Function IFeeBankCharger.decreaseAvailableCredit(address,uint256)
Contract IResolver
	Function IResolver.resolveOrders(address,bytes,bytes)
Contract ISettlement
	Function IFeeBankCharger.feeBank()
	Function IFeeBankCharger.availableCredit(address)
	Function IFeeBankCharger.increaseAvailableCredit(address,uint256)
	Function IFeeBankCharger.decreaseAvailableCredit(address,uint256)
	Function IInteractionNotificationReceiver.fillOrderInteraction(address,uint256,uint256,bytes)
	Function ISettlement.settleOrders(bytes)
Contract ISt1inch
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function ISt1inch.expBase()
	Function ISt1inch.origin()
	Function ISt1inch.oneInch()
	Function ISt1inch.emergencyExit()
	Function ISt1inch.depositFor(address,uint256)
Contract IVotable
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function IVotable.votingPowerOf(address)
Contract DynamicSuffix
	Function DynamicSuffix.decodeSuffix(bytes)
		IRs:
			_STATIC_DATA_SIZE_1(uint256) := ϕ(['_STATIC_DATA_SIZE_0'])
		Expression: lengthOffset_decodeSuffix_asm_0 = cd + cd - 0x20
		IRs:
			TMP_5427(bytes) = cd_1 + cd_1
			TMP_5428(bytes) = TMP_5427 - 32
			lengthOffset_decodeSuffix_asm_0_1(uint256) := TMP_5428(bytes)
		Expression: tokensAndAmounts = calldataload(uint256)(lengthOffset_decodeSuffix_asm_0)
		IRs:
			TMP_5429(uint256) = SOLIDITY_CALL calldataload(uint256)(lengthOffset_decodeSuffix_asm_0_1)
			tokensAndAmounts_1(bytes) := TMP_5429(uint256)
		Expression: tokensAndAmounts = lengthOffset_decodeSuffix_asm_0 - tokensAndAmounts
		IRs:
			TMP_5430(uint256) = lengthOffset_decodeSuffix_asm_0_1 - tokensAndAmounts_1
			tokensAndAmounts_2(bytes) := TMP_5430(uint256)
		Expression: suffix = tokensAndAmounts - _STATIC_DATA_SIZE
		IRs:
			TMP_5431(bytes) = tokensAndAmounts_2 - _STATIC_DATA_SIZE_1
			suffix_1(DynamicSuffix.Data) := TMP_5431(bytes)
		Expression: interaction = cd + 1
		IRs:
			TMP_5432(bytes) = cd_1 + 1
			interaction_1(bytes) := TMP_5432(bytes)
		Expression: interaction = suffix - interaction
		IRs:
			TMP_5433(DynamicSuffix.Data) = suffix_1 - interaction_1
			interaction_2(bytes) := TMP_5433(DynamicSuffix.Data)
		Expression: (suffix,tokensAndAmounts,interaction)
		IRs:
			RETURN suffix_1,tokensAndAmounts_2,interaction_2
	Function DynamicSuffix.slitherConstructorConstantVariables()
		Expression: _STATIC_DATA_SIZE = 0xa0
Contract OrderSaltParser
	Function OrderSaltParser.getStartTime(uint256)
		IRs:
			_TIME_START_MASK_1(uint256) := ϕ(['_TIME_START_MASK_0'])
			_TIME_START_SHIFT_1(uint256) := ϕ(['_TIME_START_SHIFT_0'])
		Expression: (salt & _TIME_START_MASK) >> _TIME_START_SHIFT
		IRs:
			TMP_5434(uint256) = salt_1 & _TIME_START_MASK_1
			TMP_5435(uint256) = TMP_5434 >> _TIME_START_SHIFT_1
			RETURN TMP_5435
	Function OrderSaltParser.getDuration(uint256)
		IRs:
			_DURATION_MASK_1(uint256) := ϕ(['_DURATION_MASK_0'])
			_DURATION_SHIFT_1(uint256) := ϕ(['_DURATION_SHIFT_0'])
		Expression: (salt & _DURATION_MASK) >> _DURATION_SHIFT
		IRs:
			TMP_5436(uint256) = salt_1 & _DURATION_MASK_1
			TMP_5437(uint256) = TMP_5436 >> _DURATION_SHIFT_1
			RETURN TMP_5437
	Function OrderSaltParser.getInitialRateBump(uint256)
		IRs:
			_INITIAL_RATE_BUMP_MASK_1(uint256) := ϕ(['_INITIAL_RATE_BUMP_MASK_0'])
			_INITIAL_RATE_BUMP_SHIFT_1(uint256) := ϕ(['_INITIAL_RATE_BUMP_SHIFT_0'])
		Expression: (salt & _INITIAL_RATE_BUMP_MASK) >> _INITIAL_RATE_BUMP_SHIFT
		IRs:
			TMP_5438(uint256) = salt_1 & _INITIAL_RATE_BUMP_MASK_1
			TMP_5439(uint256) = TMP_5438 >> _INITIAL_RATE_BUMP_SHIFT_1
			RETURN TMP_5439
	Function OrderSaltParser.getFee(uint256)
		IRs:
			_FEE_MASK_1(uint256) := ϕ(['_FEE_MASK_0'])
			_FEE_SHIFT_1(uint256) := ϕ(['_FEE_SHIFT_0'])
		Expression: (salt & _FEE_MASK) >> _FEE_SHIFT
		IRs:
			TMP_5440(uint256) = salt_1 & _FEE_MASK_1
			TMP_5441(uint256) = TMP_5440 >> _FEE_SHIFT_1
			RETURN TMP_5441
	Function OrderSaltParser.getSalt(uint256)
		IRs:
			_SALT_MASK_1(uint256) := ϕ(['_SALT_MASK_0'])
		Expression: salt & _SALT_MASK
		IRs:
			TMP_5442(uint256) = salt_1 & _SALT_MASK_1
			RETURN TMP_5442
	Function OrderSaltParser.slitherConstructorConstantVariables()
		Expression: _TIME_START_MASK = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000
		Expression: _DURATION_MASK = 0x00000000FFFFFF00000000000000000000000000000000000000000000000000
		Expression: _INITIAL_RATE_BUMP_MASK = 0x00000000000000FFFFFF00000000000000000000000000000000000000000000
		Expression: _FEE_MASK = 0x00000000000000000000FFFFFFFF000000000000000000000000000000000000
		Expression: _SALT_MASK = 0x0000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
		Expression: _TIME_START_SHIFT = 224
		Expression: _DURATION_SHIFT = 200
		Expression: _INITIAL_RATE_BUMP_SHIFT = 176
		Expression: _FEE_SHIFT = 144
Contract OrderSuffix
	Function OrderSuffix.takingFee(OrderLib.Order)
		IRs:
			_HAS_TAKING_FEE_FLAG_1(uint256) := ϕ(['_HAS_TAKING_FEE_FLAG_0'])
			_TAKING_FEE_BYTES_SIZE_1(uint256) := ϕ(['_TAKING_FEE_BYTES_SIZE_0'])
		Expression: interactions = order.interactions
		IRs:
			REF_1185(bytes) -> order_1.interactions
			interactions_1(bytes) := REF_1185(bytes)
		Expression: ptr_takingFee_asm_0 = interactions + interactions - 1
		IRs:
			TMP_5443(bytes) = interactions_1 + interactions_1
			TMP_5444(bytes) = TMP_5443 - 1
			ptr_takingFee_asm_0_1(uint256) := TMP_5444(bytes)
		Expression: _HAS_TAKING_FEE_FLAG & byte(uint256,uint256)(0,calldataload(uint256)(ptr_takingFee_asm_0))
		IRs:
			TMP_5445(uint256) = SOLIDITY_CALL calldataload(uint256)(ptr_takingFee_asm_0_1)
			TMP_5446(uint256) = SOLIDITY_CALL byte(uint256,uint256)(0,TMP_5445)
			TMP_5447(uint256) = _HAS_TAKING_FEE_FLAG_1 & TMP_5446
			CONDITION TMP_5447
		IRs:
			ret_2(TakingFee.Data) := ϕ(['ret_0', 'ret_1'])
		Expression: ret = calldataload(uint256)(ptr_takingFee_asm_0 - _TAKING_FEE_BYTES_SIZE)
		IRs:
			TMP_5448(uint256) = ptr_takingFee_asm_0_1 - _TAKING_FEE_BYTES_SIZE_1
			TMP_5449(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5448)
			ret_1(TakingFee.Data) := TMP_5449(uint256)
		Expression: ret
		IRs:
			RETURN ret_2
	Function OrderSuffix.checkResolver(OrderLib.Order,address)
		IRs:
			_HAS_TAKING_FEE_FLAG_2(uint256) := ϕ(['_HAS_TAKING_FEE_FLAG_0'])
			_RESOLVERS_LENGTH_MASK_1(uint256) := ϕ(['_RESOLVERS_LENGTH_MASK_0'])
			_RESOLVERS_LENGTH_BIT_SHIFT_1(uint256) := ϕ(['_RESOLVERS_LENGTH_BIT_SHIFT_0'])
			_TAKING_FEE_BYTES_SIZE_2(uint256) := ϕ(['_TAKING_FEE_BYTES_SIZE_0'])
			_PUBLIC_TIME_LIMIT_BYTES_SIZE_1(uint256) := ϕ(['_PUBLIC_TIME_LIMIT_BYTES_SIZE_0'])
			_PUBLIC_TIME_LIMIT_BIT_SHIFT_1(uint256) := ϕ(['_PUBLIC_TIME_LIMIT_BIT_SHIFT_0'])
			_RESOLVER_TIME_LIMIT_BYTES_SIZE_1(uint256) := ϕ(['_RESOLVER_TIME_LIMIT_BYTES_SIZE_0'])
			_RESOLVER_ADDRESS_BYTES_SIZE_1(uint256) := ϕ(['_RESOLVER_ADDRESS_BYTES_SIZE_0'])
			_RESOLVER_BYTES_SIZE_1(uint256) := ϕ(['_RESOLVER_BYTES_SIZE_0'])
			_RESOLVER_TIME_LIMIT_BIT_SHIFT_1(uint256) := ϕ(['_RESOLVER_TIME_LIMIT_BIT_SHIFT_0'])
			_RESOLVER_ADDRESS_BIT_SHIFT_1(uint256) := ϕ(['_RESOLVER_ADDRESS_BIT_SHIFT_0'])
		Expression: interactions = order.interactions
		IRs:
			REF_1186(bytes) -> order_1.interactions
			interactions_1(bytes) := REF_1186(bytes)
		Expression: ptr_checkResolver_asm_0 = interactions + interactions - 1
		IRs:
			TMP_5450(bytes) = interactions_1 + interactions_1
			TMP_5451(bytes) = TMP_5450 - 1
			ptr_checkResolver_asm_0_1(uint256) := TMP_5451(bytes)
		Expression: flags_checkResolver_asm_0 = byte(uint256,uint256)(0,calldataload(uint256)(ptr_checkResolver_asm_0))
		IRs:
			TMP_5452(uint256) = SOLIDITY_CALL calldataload(uint256)(ptr_checkResolver_asm_0_1)
			TMP_5453(uint256) = SOLIDITY_CALL byte(uint256,uint256)(0,TMP_5452)
			flags_checkResolver_asm_0_1(uint256) := TMP_5453(uint256)
		Expression: ptr_checkResolver_asm_0 = ptr_checkResolver_asm_0 - _PUBLIC_TIME_LIMIT_BYTES_SIZE
		IRs:
			TMP_5454(uint256) = ptr_checkResolver_asm_0_1 - _PUBLIC_TIME_LIMIT_BYTES_SIZE_1
			ptr_checkResolver_asm_0_2(uint256) := TMP_5454(uint256)
		Expression: flags_checkResolver_asm_0 & _HAS_TAKING_FEE_FLAG
		IRs:
			TMP_5455(uint256) = flags_checkResolver_asm_0_1 & _HAS_TAKING_FEE_FLAG_2
			CONDITION TMP_5455
		IRs:
			ptr_checkResolver_asm_0_4(uint256) := ϕ(['ptr_checkResolver_asm_0_3', 'ptr_checkResolver_asm_0_2'])
		Expression: ptr_checkResolver_asm_0 = ptr_checkResolver_asm_0 - _TAKING_FEE_BYTES_SIZE
		IRs:
			TMP_5456(uint256) = ptr_checkResolver_asm_0_2 - _TAKING_FEE_BYTES_SIZE_2
			ptr_checkResolver_asm_0_3(uint256) := TMP_5456(uint256)
		Expression: resolversCount_checkResolver_asm_0 = flags_checkResolver_asm_0 & _RESOLVERS_LENGTH_MASK >> _RESOLVERS_LENGTH_BIT_SHIFT
		IRs:
			TMP_5457(uint256) = flags_checkResolver_asm_0_1 & _RESOLVERS_LENGTH_MASK_1
			TMP_5458(uint256) = TMP_5457 >> _RESOLVERS_LENGTH_BIT_SHIFT_1
			resolversCount_checkResolver_asm_0_1(uint256) := TMP_5458(uint256)
		Expression: publicLimit_checkResolver_asm_0 = calldataload(uint256)(ptr_checkResolver_asm_0) >> _PUBLIC_TIME_LIMIT_BIT_SHIFT
		IRs:
			TMP_5459(uint256) = SOLIDITY_CALL calldataload(uint256)(ptr_checkResolver_asm_0_4)
			TMP_5460(uint256) = TMP_5459 >> _PUBLIC_TIME_LIMIT_BIT_SHIFT_1
			publicLimit_checkResolver_asm_0_1(uint256) := TMP_5460(uint256)
		Expression: valid = timestamp()() > publicLimit_checkResolver_asm_0
		IRs:
			TMP_5461(uint256) = SOLIDITY_CALL timestamp()()
			TMP_5462(bool) = TMP_5461 > publicLimit_checkResolver_asm_0_1
			valid_1(bool) := TMP_5462(bool)
		Expression: ! valid
		IRs:
			TMP_5463 = UnaryType.BANG valid_1 
			CONDITION TMP_5463
		Expression: end_checkResolver_asm_0 = ptr_checkResolver_asm_0 - _RESOLVER_BYTES_SIZE * resolversCount_checkResolver_asm_0
		IRs:
			TMP_5464(uint256) = _RESOLVER_BYTES_SIZE_1 * resolversCount_checkResolver_asm_0_1
			TMP_5465(uint256) = ptr_checkResolver_asm_0_4 - TMP_5464
			end_checkResolver_asm_0_1(uint256) := TMP_5465(uint256)
		Expression: ptr_checkResolver_asm_0 > end_checkResolver_asm_0
		IRs:
			ptr_checkResolver_asm_0_5(uint256) := ϕ(['ptr_checkResolver_asm_0_7', 'ptr_checkResolver_asm_0_2'])
			TMP_5466(bool) = ptr_checkResolver_asm_0_5 > end_checkResolver_asm_0_1
			CONDITION TMP_5466
		Expression: ptr_checkResolver_asm_0 = ptr_checkResolver_asm_0 - _RESOLVER_ADDRESS_BYTES_SIZE
		IRs:
			TMP_5467(uint256) = ptr_checkResolver_asm_0_5 - _RESOLVER_ADDRESS_BYTES_SIZE_1
			ptr_checkResolver_asm_0_6(uint256) := TMP_5467(uint256)
		Expression: account_checkResolver_asm_0 = calldataload(uint256)(ptr_checkResolver_asm_0) >> _RESOLVER_ADDRESS_BIT_SHIFT
		IRs:
			TMP_5468(uint256) = SOLIDITY_CALL calldataload(uint256)(ptr_checkResolver_asm_0_6)
			TMP_5469(uint256) = TMP_5468 >> _RESOLVER_ADDRESS_BIT_SHIFT_1
			account_checkResolver_asm_0_1(uint256) := TMP_5469(uint256)
		Expression: ptr_checkResolver_asm_0 = ptr_checkResolver_asm_0 - _RESOLVER_TIME_LIMIT_BYTES_SIZE
		IRs:
			TMP_5470(uint256) = ptr_checkResolver_asm_0_6 - _RESOLVER_TIME_LIMIT_BYTES_SIZE_1
			ptr_checkResolver_asm_0_7(uint256) := TMP_5470(uint256)
		Expression: limit_checkResolver_asm_0 = calldataload(uint256)(ptr_checkResolver_asm_0) >> _RESOLVER_TIME_LIMIT_BIT_SHIFT
		IRs:
			TMP_5471(uint256) = SOLIDITY_CALL calldataload(uint256)(ptr_checkResolver_asm_0_7)
			TMP_5472(uint256) = TMP_5471 >> _RESOLVER_TIME_LIMIT_BIT_SHIFT_1
			limit_checkResolver_asm_0_1(uint256) := TMP_5472(uint256)
		Expression: account_checkResolver_asm_0 == resolver
		IRs:
			TMP_5473(bool) = account_checkResolver_asm_0_1 == resolver_1
			CONDITION TMP_5473
		IRs:
			valid_3(bool) := ϕ(['valid_2', 'valid_1'])
		Expression: valid = ! timestamp()() < limit_checkResolver_asm_0
		IRs:
			TMP_5474(uint256) = SOLIDITY_CALL timestamp()()
			TMP_5475(bool) = TMP_5474 < limit_checkResolver_asm_0_1
			TMP_5476 = UnaryType.BANG TMP_5475 
			valid_2(bool) := TMP_5476(bool)
		Expression: valid
		IRs:
			RETURN valid_1
	Function OrderSuffix.rateBump(OrderLib.Order)
		IRs:
			_HAS_TAKING_FEE_FLAG_3(uint256) := ϕ(['_HAS_TAKING_FEE_FLAG_0'])
			_RESOLVERS_LENGTH_MASK_2(uint256) := ϕ(['_RESOLVERS_LENGTH_MASK_0'])
			_RESOLVERS_LENGTH_BIT_SHIFT_2(uint256) := ϕ(['_RESOLVERS_LENGTH_BIT_SHIFT_0'])
			_POINTS_LENGTH_MASK_1(uint256) := ϕ(['_POINTS_LENGTH_MASK_0'])
			_TAKING_FEE_BYTES_SIZE_3(uint256) := ϕ(['_TAKING_FEE_BYTES_SIZE_0'])
			_PUBLIC_TIME_LIMIT_BYTES_SIZE_2(uint256) := ϕ(['_PUBLIC_TIME_LIMIT_BYTES_SIZE_0'])
			_AUCTION_POINT_DELAY_BYTES_SIZE_1(uint256) := ϕ(['_AUCTION_POINT_DELAY_BYTES_SIZE_2', '_AUCTION_POINT_DELAY_BYTES_SIZE_0'])
			_AUCTION_POINT_BUMP_BYTES_SIZE_1(uint256) := ϕ(['_AUCTION_POINT_BUMP_BYTES_SIZE_2', '_AUCTION_POINT_BUMP_BYTES_SIZE_0'])
			_AUCTION_POINT_BYTES_SIZE_1(uint256) := ϕ(['_AUCTION_POINT_BYTES_SIZE_0'])
			_AUCTION_POINT_DELAY_BIT_SHIFT_1(uint256) := ϕ(['_AUCTION_POINT_DELAY_BIT_SHIFT_0', '_AUCTION_POINT_DELAY_BIT_SHIFT_2'])
			_AUCTION_POINT_BUMP_BIT_SHIFT_1(uint256) := ϕ(['_AUCTION_POINT_BUMP_BIT_SHIFT_0', '_AUCTION_POINT_BUMP_BIT_SHIFT_2'])
			_RESOLVER_BYTES_SIZE_2(uint256) := ϕ(['_RESOLVER_BYTES_SIZE_0'])
		Expression: startBump = order.salt.getInitialRateBump()
		IRs:
			REF_1187(uint256) -> order_1.salt
			TMP_5477(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getInitialRateBump(uint256), arguments:['REF_1187'] 
			startBump_1(uint256) := TMP_5477(uint256)
		Expression: cumulativeTime = order.salt.getStartTime()
		IRs:
			REF_1189(uint256) -> order_1.salt
			TMP_5478(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getStartTime(uint256), arguments:['REF_1189'] 
			cumulativeTime_1(uint256) := TMP_5478(uint256)
		Expression: lastTime = cumulativeTime + order.salt.getDuration()
		IRs:
			REF_1191(uint256) -> order_1.salt
			TMP_5479(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getDuration(uint256), arguments:['REF_1191'] 
			TMP_5480(uint256) = cumulativeTime_1 (c)+ TMP_5479
			lastTime_1(uint256) := TMP_5480(uint256)
		Expression: block.timestamp <= cumulativeTime
		IRs:
			TMP_5481(bool) = block.timestamp <= cumulativeTime_1
			CONDITION TMP_5481
		Expression: startBump
		IRs:
			RETURN startBump_1
		Expression: block.timestamp >= lastTime
		IRs:
			TMP_5482(bool) = block.timestamp >= lastTime_1
			CONDITION TMP_5482
		Expression: 0
		IRs:
			RETURN 0
		Expression: interactions = order.interactions
		IRs:
			REF_1193(bytes) -> order_1.interactions
			interactions_1(bytes) := REF_1193(bytes)
		Expression: ptr_rateBump_asm_0 = interactions + interactions - 1
		IRs:
			TMP_5483(bytes) = interactions_1 + interactions_1
			TMP_5484(bytes) = TMP_5483 - 1
			ptr_rateBump_asm_0_1(uint256) := TMP_5484(bytes)
		Expression: flags_rateBump_asm_0 = byte(uint256,uint256)(0,calldataload(uint256)(ptr_rateBump_asm_0))
		IRs:
			TMP_5485(uint256) = SOLIDITY_CALL calldataload(uint256)(ptr_rateBump_asm_0_1)
			TMP_5486(uint256) = SOLIDITY_CALL byte(uint256,uint256)(0,TMP_5485)
			flags_rateBump_asm_0_1(uint256) := TMP_5486(uint256)
		Expression: resolversCount_rateBump_asm_0 = flags_rateBump_asm_0 & _RESOLVERS_LENGTH_MASK >> _RESOLVERS_LENGTH_BIT_SHIFT
		IRs:
			TMP_5487(uint256) = flags_rateBump_asm_0_1 & _RESOLVERS_LENGTH_MASK_2
			TMP_5488(uint256) = TMP_5487 >> _RESOLVERS_LENGTH_BIT_SHIFT_2
			resolversCount_rateBump_asm_0_1(uint256) := TMP_5488(uint256)
		Expression: pointsCount_rateBump_asm_0 = flags_rateBump_asm_0 & _POINTS_LENGTH_MASK
		IRs:
			TMP_5489(uint256) = flags_rateBump_asm_0_1 & _POINTS_LENGTH_MASK_1
			pointsCount_rateBump_asm_0_1(uint256) := TMP_5489(uint256)
		Expression: flags_rateBump_asm_0 & _HAS_TAKING_FEE_FLAG
		IRs:
			TMP_5490(uint256) = flags_rateBump_asm_0_1 & _HAS_TAKING_FEE_FLAG_3
			CONDITION TMP_5490
		IRs:
			ptr_rateBump_asm_0_3(uint256) := ϕ(['ptr_rateBump_asm_0_1', 'ptr_rateBump_asm_0_2'])
		Expression: ptr_rateBump_asm_0 = ptr_rateBump_asm_0 - _TAKING_FEE_BYTES_SIZE
		IRs:
			TMP_5491(uint256) = ptr_rateBump_asm_0_1 - _TAKING_FEE_BYTES_SIZE_3
			ptr_rateBump_asm_0_2(uint256) := TMP_5491(uint256)
		Expression: ptr_rateBump_asm_0 = ptr_rateBump_asm_0 - _RESOLVER_BYTES_SIZE * resolversCount_rateBump_asm_0 + _PUBLIC_TIME_LIMIT_BYTES_SIZE
		IRs:
			TMP_5492(uint256) = _RESOLVER_BYTES_SIZE_2 * resolversCount_rateBump_asm_0_1
			TMP_5493(uint256) = TMP_5492 + _PUBLIC_TIME_LIMIT_BYTES_SIZE_2
			TMP_5494(uint256) = ptr_rateBump_asm_0_3 - TMP_5493
			ptr_rateBump_asm_0_4(uint256) := TMP_5494(uint256)
		Expression: prevCoefficient_rateBump_asm_0 = startBump
		IRs:
			prevCoefficient_rateBump_asm_0_1(uint256) := startBump_1(uint256)
		Expression: prevCumulativeTime_rateBump_asm_0 = cumulativeTime
		IRs:
			prevCumulativeTime_rateBump_asm_0_1(uint256) := cumulativeTime_1(uint256)
		Expression: end_rateBump_asm_0 = ptr_rateBump_asm_0 - _AUCTION_POINT_BYTES_SIZE * pointsCount_rateBump_asm_0
		IRs:
			TMP_5495(uint256) = _AUCTION_POINT_BYTES_SIZE_1 * pointsCount_rateBump_asm_0_1
			TMP_5496(uint256) = ptr_rateBump_asm_0_4 - TMP_5495
			end_rateBump_asm_0_1(uint256) := TMP_5496(uint256)
		Expression: ptr_rateBump_asm_0 > end_rateBump_asm_0
		IRs:
			cumulativeTime_2(uint256) := ϕ(['cumulativeTime_3', 'cumulativeTime_1'])
			ptr_rateBump_asm_0_5(uint256) := ϕ(['ptr_rateBump_asm_0_4', 'ptr_rateBump_asm_0_7'])
			prevCoefficient_rateBump_asm_0_2(uint256) := ϕ(['prevCoefficient_rateBump_asm_0_1', 'prevCoefficient_rateBump_asm_0_3'])
			prevCumulativeTime_rateBump_asm_0_2(uint256) := ϕ(['prevCumulativeTime_rateBump_asm_0_3', 'prevCumulativeTime_rateBump_asm_0_1'])
			TMP_5497(bool) = ptr_rateBump_asm_0_5 > end_rateBump_asm_0_1
			CONDITION TMP_5497
		Expression: ptr_rateBump_asm_0 = ptr_rateBump_asm_0 - _AUCTION_POINT_BUMP_BYTES_SIZE
		IRs:
			TMP_5498(uint256) = ptr_rateBump_asm_0_5 - _AUCTION_POINT_BUMP_BYTES_SIZE_1
			ptr_rateBump_asm_0_6(uint256) := TMP_5498(uint256)
		Expression: coefficient_rateBump_asm_0 = calldataload(uint256)(ptr_rateBump_asm_0) >> _AUCTION_POINT_BUMP_BIT_SHIFT
		IRs:
			TMP_5499(uint256) = SOLIDITY_CALL calldataload(uint256)(ptr_rateBump_asm_0_6)
			TMP_5500(uint256) = TMP_5499 >> _AUCTION_POINT_BUMP_BIT_SHIFT_1
			coefficient_rateBump_asm_0_1(uint256) := TMP_5500(uint256)
		Expression: ptr_rateBump_asm_0 = ptr_rateBump_asm_0 - _AUCTION_POINT_DELAY_BYTES_SIZE
		IRs:
			TMP_5501(uint256) = ptr_rateBump_asm_0_6 - _AUCTION_POINT_DELAY_BYTES_SIZE_1
			ptr_rateBump_asm_0_7(uint256) := TMP_5501(uint256)
		Expression: delay_rateBump_asm_0 = calldataload(uint256)(ptr_rateBump_asm_0) >> _AUCTION_POINT_DELAY_BIT_SHIFT
		IRs:
			TMP_5502(uint256) = SOLIDITY_CALL calldataload(uint256)(ptr_rateBump_asm_0_7)
			TMP_5503(uint256) = TMP_5502 >> _AUCTION_POINT_DELAY_BIT_SHIFT_1
			delay_rateBump_asm_0_1(uint256) := TMP_5503(uint256)
		Expression: cumulativeTime = cumulativeTime + delay_rateBump_asm_0
		IRs:
			TMP_5504(uint256) = cumulativeTime_2 + delay_rateBump_asm_0_1
			cumulativeTime_3(uint256) := TMP_5504(uint256)
		Expression: cumulativeTime > timestamp()()
		IRs:
			TMP_5505(uint256) = SOLIDITY_CALL timestamp()()
			TMP_5506(bool) = cumulativeTime_3 > TMP_5505
			CONDITION TMP_5506
		IRs:
			bump_2(uint256) := ϕ(['bump_0', 'bump_1'])
		Expression: bump = linearInterpolation(prevCumulativeTime_rateBump_asm_0,cumulativeTime,prevCoefficient_rateBump_asm_0,coefficient_rateBump_asm_0,timestamp()())
		IRs:
			TMP_5507(uint256) = SOLIDITY_CALL timestamp()()
			TMP_5508(uint256) = INTERNAL_CALL, OrderSuffix.rateBump.asm_0.linearInterpolation()(prevCumulativeTime_rateBump_asm_0_2,cumulativeTime_3,prevCoefficient_rateBump_asm_0_2,coefficient_rateBump_asm_0_1,TMP_5507)
			bump_1(uint256) := TMP_5508(uint256)
		Expression: prevCumulativeTime_rateBump_asm_0 = cumulativeTime
		IRs:
			prevCumulativeTime_rateBump_asm_0_3(uint256) := cumulativeTime_3(uint256)
		Expression: prevCoefficient_rateBump_asm_0 = coefficient_rateBump_asm_0
		IRs:
			prevCoefficient_rateBump_asm_0_3(uint256) := coefficient_rateBump_asm_0_1(uint256)
		Expression: ! bump
		IRs:
			TMP_5509 = UnaryType.BANG bump_0 
			CONDITION TMP_5509
		IRs:
			bump_4(uint256) := ϕ(['bump_0', 'bump_3'])
		Expression: bump = linearInterpolation(prevCumulativeTime_rateBump_asm_0,lastTime,prevCoefficient_rateBump_asm_0,0,timestamp()())
		IRs:
			TMP_5510(uint256) = SOLIDITY_CALL timestamp()()
			TMP_5511(uint256) = INTERNAL_CALL, OrderSuffix.rateBump.asm_0.linearInterpolation()(prevCumulativeTime_rateBump_asm_0_2,lastTime_1,prevCoefficient_rateBump_asm_0_2,0,TMP_5510)
			bump_3(uint256) := TMP_5511(uint256)
		Expression: bump
		IRs:
			RETURN bump_4
	Function OrderSuffix.rateBump.asm_0.linearInterpolation()
		IRs:
			t1_rateBump_asm_0_linearInterpolation_2(uint256) := ϕ(['prevCumulativeTime_rateBump_asm_0_2'])
			t2_rateBump_asm_0_linearInterpolation_2(uint256) := ϕ(['lastTime_1', 'cumulativeTime_3'])
			v1_rateBump_asm_0_linearInterpolation_2(uint256) := ϕ(['prevCoefficient_rateBump_asm_0_2'])
			v2_rateBump_asm_0_linearInterpolation_2(uint256) := ϕ(['coefficient_rateBump_asm_0_1'])
			t_rateBump_asm_0_linearInterpolation_2(uint256) := ϕ(['TMP_5510', 'TMP_5507'])
		Expression: v_rateBump_asm_0_linearInterpolation = t_rateBump_asm_0_linearInterpolation - t1_rateBump_asm_0_linearInterpolation * v2_rateBump_asm_0_linearInterpolation + t2_rateBump_asm_0_linearInterpolation - t_rateBump_asm_0_linearInterpolation * v1_rateBump_asm_0_linearInterpolation / t2_rateBump_asm_0_linearInterpolation - t1_rateBump_asm_0_linearInterpolation
	Function OrderSuffix.slitherConstructorConstantVariables()
		Expression: _HAS_TAKING_FEE_FLAG = 0x80
		Expression: _RESOLVERS_LENGTH_MASK = 0x78
		Expression: _RESOLVERS_LENGTH_BIT_SHIFT = 3
		Expression: _POINTS_LENGTH_MASK = 0x07
		Expression: _POINTS_LENGTH_BIT_SHIFT = 0
		Expression: _TAKING_FEE_BYTES_SIZE = 32
		Expression: _PUBLIC_TIME_LIMIT_BYTES_SIZE = 4
		Expression: _PUBLIC_TIME_LIMIT_BIT_SHIFT = 224
		Expression: _AUCTION_POINT_DELAY_BYTES_SIZE = 2
		Expression: _AUCTION_POINT_BUMP_BYTES_SIZE = 3
		Expression: _AUCTION_POINT_BYTES_SIZE = 5
		Expression: _AUCTION_POINT_DELAY_BIT_SHIFT = 240
		Expression: _AUCTION_POINT_BUMP_BIT_SHIFT = 232
		Expression: _RESOLVER_TIME_LIMIT_BYTES_SIZE = 4
		Expression: _RESOLVER_ADDRESS_BYTES_SIZE = 20
		Expression: _RESOLVER_BYTES_SIZE = 24
		Expression: _RESOLVER_TIME_LIMIT_BIT_SHIFT = 224
		Expression: _RESOLVER_ADDRESS_BIT_SHIFT = 96
Contract TakingFee
	Function TakingFee.enabled(TakingFee.Data)
		Expression: ratio(self) != 0
		IRs:
			TMP_5519(uint256) = INTERNAL_CALL, TakingFee.ratio(TakingFee.Data)(self_1)
			TMP_5520(bool) = TMP_5519 != 0
			RETURN TMP_5520
	Function TakingFee.ratio(TakingFee.Data)
		IRs:
			self_1(TakingFee.Data) := ϕ(['self_1'])
			_TAKING_FEE_RATIO_OFFSET_1(uint256) := ϕ(['_TAKING_FEE_RATIO_OFFSET_0'])
		Expression: uint32(TakingFee.Data.unwrap(self) >> _TAKING_FEE_RATIO_OFFSET)
		IRs:
			TMP_5521 = CONVERT self_1 to uint256
			TMP_5522(uint256) = TMP_5521 >> _TAKING_FEE_RATIO_OFFSET_1
			TMP_5523 = CONVERT TMP_5522 to uint32
			RETURN TMP_5523
	Function TakingFee.receiver(TakingFee.Data)
		Expression: address(uint160(TakingFee.Data.unwrap(self)))
		IRs:
			TMP_5524 = CONVERT self_1 to uint256
			TMP_5525 = CONVERT TMP_5524 to uint160
			TMP_5526 = CONVERT TMP_5525 to address
			RETURN TMP_5526
	Function TakingFee.slitherConstructorConstantVariables()
		Expression: _TAKING_FEE_BASE = 1e9
		Expression: _TAKING_FEE_RATIO_OFFSET = 160
Contract TokensAndAmounts
	Function TokensAndAmounts.decode(bytes)
		Expression: decoded = cd
		IRs:
			decoded_1(TokensAndAmounts.Data[]) = ['cd_1(bytes)']
		Expression: decoded = cd / 0x40
		IRs:
			TMP_5527(bytes) = cd_1 / 64
			decoded_2(TokensAndAmounts.Data[]) = ['TMP_5527(bytes)']
		Expression: decoded
		IRs:
			RETURN decoded_2
Contract GovernanceMothership
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_5', '_balances_11', '_balances_0'])
		Expression: _balances[account]
		IRs:
			REF_1194(uint256) -> _balances_1[account_1]
			RETURN REF_1194
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_5528(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_5528(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_1', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_1195(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_1196(uint256) -> REF_1195[spender_1]
			RETURN REF_1196
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_5530(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_5530(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_5532(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_5532(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_5535(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_5535(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_5536(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_5537(uint256) = TMP_5536 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_5537)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_5539(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_5539(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_5540(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_5540(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_5541(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_5542(None) = SOLIDITY_CALL require(bool,string)(TMP_5541,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_5543(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_5543)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['owner_1', 'from_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_5', '_balances_11', '_balances_0'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_5545 = CONVERT 0 to address
			TMP_5546(bool) = from_1 != TMP_5545
			TMP_5547(None) = SOLIDITY_CALL require(bool,string)(TMP_5546,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_5548 = CONVERT 0 to address
			TMP_5549(bool) = to_1 != TMP_5548
			TMP_5550(None) = SOLIDITY_CALL require(bool,string)(TMP_5549,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_1197(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_1197(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_5552(bool) = fromBalance_1 >= amount_1
			TMP_5553(None) = SOLIDITY_CALL require(bool,string)(TMP_5552,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_1198(uint256) -> _balances_3[from_1]
			TMP_5554(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_1198(uint256) (->_balances_4) := TMP_5554(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_1199(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_1199(-> _balances_5) = REF_1199 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_5', '_balances_11', '_balances_0'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_5557 = CONVERT 0 to address
			TMP_5558(bool) = account_1 != TMP_5557
			TMP_5559(None) = SOLIDITY_CALL require(bool,string)(TMP_5558,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_5560 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_5560,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_1200(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_1200(-> _balances_8) = REF_1200 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_5562 = CONVERT 0 to address
			Emit Transfer(TMP_5562,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_5564 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_5564,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			amount_1(uint256) := ϕ(['amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_5', '_balances_11', '_balances_0'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_4', '_totalSupply_7', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_5566 = CONVERT 0 to address
			TMP_5567(bool) = account_1 != TMP_5566
			TMP_5568(None) = SOLIDITY_CALL require(bool,string)(TMP_5567,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_5569 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_5569,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_1201(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_1201(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_5571(bool) = accountBalance_1 >= amount_1
			TMP_5572(None) = SOLIDITY_CALL require(bool,string)(TMP_5571,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_1202(uint256) -> _balances_10[account_1]
			TMP_5573(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_1202(uint256) (->_balances_11) := TMP_5573(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_5574 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_5574,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_5576 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_5576,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_5543', 'amount_1', 'TMP_5591', 'TMP_5537'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_5578 = CONVERT 0 to address
			TMP_5579(bool) = owner_1 != TMP_5578
			TMP_5580(None) = SOLIDITY_CALL require(bool,string)(TMP_5579,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_5581 = CONVERT 0 to address
			TMP_5582(bool) = spender_1 != TMP_5581
			TMP_5583(None) = SOLIDITY_CALL require(bool,string)(TMP_5582,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_1203(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_1204(uint256) -> REF_1203[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_1204(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_5585(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_5585(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_5587(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_5588(bool) = currentAllowance_1 != TMP_5587
			CONDITION TMP_5588
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_5589(bool) = currentAllowance_1 >= amount_1
			TMP_5590(None) = SOLIDITY_CALL require(bool,string)(TMP_5589,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_5591(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_5591)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_5560', 'account_1', 'from_1'])
			to_1(address) := ϕ(['account_1', 'to_1', 'TMP_5569'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_5564'])
			to_1(address) := ϕ(['to_1', 'account_1', 'TMP_5576'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function GovernanceMothership.constructor(IERC20)
		Expression: inchToken = inchToken_
		IRs:
			inchToken_1(IERC20) := inchToken__1(IERC20)
		Expression: ERC20(1INCH Token (Staked),st1INCH)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(1INCH Token (Staked),st1INCH)
	Function GovernanceMothership.stake(uint256)
		IRs:
			inchToken_2(IERC20) := ϕ(['inchToken_0', 'inchToken_3', 'inchToken_1', 'inchToken_6'])
		Expression: require(bool,string)(amount > 0,Empty stake is not allowed)
		IRs:
			TMP_5594(bool) = amount_1 > 0
			TMP_5595(None) = SOLIDITY_CALL require(bool,string)(TMP_5594,Empty stake is not allowed)
		Expression: inchToken.transferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_5596 = CONVERT this to address
			TMP_5597(bool) = HIGH_LEVEL_CALL, dest:inchToken_2(IERC20), function:transferFrom, arguments:['msg.sender', 'TMP_5596', 'amount_1']  
			inchToken_3(IERC20) := ϕ(['inchToken_2', 'inchToken_3', 'inchToken_1', 'inchToken_6'])
		Expression: _mint(msg.sender,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(msg.sender,amount_1)
		Expression: Transfer(address(0),msg.sender,amount)
		IRs:
			TMP_5599 = CONVERT 0 to address
			Emit Transfer(TMP_5599,msg.sender,amount_1)
	Function GovernanceMothership.unstake(uint256)
		IRs:
			inchToken_4(IERC20) := ϕ(['inchToken_0', 'inchToken_3', 'inchToken_1', 'inchToken_6'])
		Expression: require(bool,string)(amount > 0,Empty unstake is not allowed)
		IRs:
			TMP_5601(bool) = amount_1 > 0
			TMP_5602(None) = SOLIDITY_CALL require(bool,string)(TMP_5601,Empty unstake is not allowed)
		Expression: _burn(msg.sender,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(msg.sender,amount_1)
		Expression: inchToken.transfer(msg.sender,amount)
		IRs:
			TMP_5604(bool) = HIGH_LEVEL_CALL, dest:inchToken_5(IERC20), function:transfer, arguments:['msg.sender', 'amount_1']  
			inchToken_6(IERC20) := ϕ(['inchToken_5', 'inchToken_3', 'inchToken_1', 'inchToken_6'])
		Expression: Transfer(msg.sender,address(0),amount)
		IRs:
			TMP_5605 = CONVERT 0 to address
			Emit Transfer(msg.sender,TMP_5605,amount_1)
Contract OrderSaltParserMock
	Function OrderSaltParserMock.getStartTime(uint256)
		Expression: orderSalt_.getStartTime()
		IRs:
			TMP_5607(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getStartTime(uint256), arguments:['orderSalt__1'] 
			RETURN TMP_5607
	Function OrderSaltParserMock.getDuration(uint256)
		Expression: orderSalt_.getDuration()
		IRs:
			TMP_5608(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getDuration(uint256), arguments:['orderSalt__1'] 
			RETURN TMP_5608
	Function OrderSaltParserMock.getInitialRateBump(uint256)
		Expression: orderSalt_.getInitialRateBump()
		IRs:
			TMP_5609(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getInitialRateBump(uint256), arguments:['orderSalt__1'] 
			RETURN TMP_5609
	Function OrderSaltParserMock.getFee(uint256)
		Expression: orderSalt_.getFee()
		IRs:
			TMP_5610(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getFee(uint256), arguments:['orderSalt__1'] 
			RETURN TMP_5610
	Function OrderSaltParserMock.getSalt(uint256)
		Expression: orderSalt_.getSalt()
		IRs:
			TMP_5611(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getSalt(uint256), arguments:['orderSalt__1'] 
			RETURN TMP_5611
Contract PowerPodMock
	Function PowerPod.constructor(string,string,ISt1inch)
		IRs:
			_MAX_SHARE_PODS_1(uint256) := ϕ(['_MAX_SHARE_PODS_2', '_MAX_SHARE_PODS_0'])
			_SHARE_POD_GAS_LIMIT_1(uint256) := ϕ(['_SHARE_POD_GAS_LIMIT_2', '_SHARE_POD_GAS_LIMIT_0'])
		Expression: FarmingDelegationPod(name_,symbol_,st1inch,_MAX_SHARE_PODS,_SHARE_POD_GAS_LIMIT)
		IRs:
			INTERNAL_CALL, FarmingDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)(name__1,symbol__1,st1inch_1,_MAX_SHARE_PODS_1,_SHARE_POD_GAS_LIMIT_1)
		Expression: VotingPowerCalculator(st1inch.expBase(),st1inch.origin())
		IRs:
			TMP_5613(uint256) = HIGH_LEVEL_CALL, dest:st1inch_1(ISt1inch), function:expBase, arguments:[]  
			TMP_5614(uint256) = HIGH_LEVEL_CALL, dest:st1inch_1(ISt1inch), function:origin, arguments:[]  
			INTERNAL_CALL, VotingPowerCalculator.constructor(uint256,uint256)(TMP_5613,TMP_5614)
	Function PowerPod.votingPowerOf(address)
		Expression: _votingPowerAt(balanceOf(account),block.timestamp)
		IRs:
			TMP_5616(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			TMP_5617(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(TMP_5616,block.timestamp)
			RETURN TMP_5617
	Function IVotable.votingPowerOf(address)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function VotingPowerCalculator.constructor(uint256,uint256)
		IRs:
			_ONE_E18_1(uint256) := ϕ(['_ONE_E18_0'])
		Expression: origin_ > block.timestamp
		IRs:
			TMP_5618(bool) = origin__1 > block.timestamp
			CONDITION TMP_5618
		Expression: revert OriginInTheFuture()()
		IRs:
			TMP_5619(None) = SOLIDITY_CALL revert OriginInTheFuture()()
		Expression: origin = origin_
		IRs:
			origin_1(uint256) := origin__1(uint256)
		Expression: expBase = expBase_
		IRs:
			expBase_1(uint256) := expBase__1(uint256)
		Expression: _expTable0 = expBase_
		IRs:
			_expTable0_1(uint256) := expBase__1(uint256)
		Expression: _expTable1 = (_expTable0 * _expTable0) / _ONE_E18
		IRs:
			TMP_5620(uint256) = _expTable0_1 (c)* _expTable0_1
			TMP_5621(uint256) = TMP_5620 (c)/ _ONE_E18_1
			_expTable1_1(uint256) := TMP_5621(uint256)
		Expression: _expTable2 = (_expTable1 * _expTable1) / _ONE_E18
		IRs:
			TMP_5622(uint256) = _expTable1_1 (c)* _expTable1_1
			TMP_5623(uint256) = TMP_5622 (c)/ _ONE_E18_1
			_expTable2_1(uint256) := TMP_5623(uint256)
		Expression: _expTable3 = (_expTable2 * _expTable2) / _ONE_E18
		IRs:
			TMP_5624(uint256) = _expTable2_1 (c)* _expTable2_1
			TMP_5625(uint256) = TMP_5624 (c)/ _ONE_E18_1
			_expTable3_1(uint256) := TMP_5625(uint256)
		Expression: _expTable4 = (_expTable3 * _expTable3) / _ONE_E18
		IRs:
			TMP_5626(uint256) = _expTable3_1 (c)* _expTable3_1
			TMP_5627(uint256) = TMP_5626 (c)/ _ONE_E18_1
			_expTable4_1(uint256) := TMP_5627(uint256)
		Expression: _expTable5 = (_expTable4 * _expTable4) / _ONE_E18
		IRs:
			TMP_5628(uint256) = _expTable4_1 (c)* _expTable4_1
			TMP_5629(uint256) = TMP_5628 (c)/ _ONE_E18_1
			_expTable5_1(uint256) := TMP_5629(uint256)
		Expression: _expTable6 = (_expTable5 * _expTable5) / _ONE_E18
		IRs:
			TMP_5630(uint256) = _expTable5_1 (c)* _expTable5_1
			TMP_5631(uint256) = TMP_5630 (c)/ _ONE_E18_1
			_expTable6_1(uint256) := TMP_5631(uint256)
		Expression: _expTable7 = (_expTable6 * _expTable6) / _ONE_E18
		IRs:
			TMP_5632(uint256) = _expTable6_1 (c)* _expTable6_1
			TMP_5633(uint256) = TMP_5632 (c)/ _ONE_E18_1
			_expTable7_1(uint256) := TMP_5633(uint256)
		Expression: _expTable8 = (_expTable7 * _expTable7) / _ONE_E18
		IRs:
			TMP_5634(uint256) = _expTable7_1 (c)* _expTable7_1
			TMP_5635(uint256) = TMP_5634 (c)/ _ONE_E18_1
			_expTable8_1(uint256) := TMP_5635(uint256)
		Expression: _expTable9 = (_expTable8 * _expTable8) / _ONE_E18
		IRs:
			TMP_5636(uint256) = _expTable8_1 (c)* _expTable8_1
			TMP_5637(uint256) = TMP_5636 (c)/ _ONE_E18_1
			_expTable9_1(uint256) := TMP_5637(uint256)
		Expression: _expTable10 = (_expTable9 * _expTable9) / _ONE_E18
		IRs:
			TMP_5638(uint256) = _expTable9_1 (c)* _expTable9_1
			TMP_5639(uint256) = TMP_5638 (c)/ _ONE_E18_1
			_expTable10_1(uint256) := TMP_5639(uint256)
		Expression: _expTable11 = (_expTable10 * _expTable10) / _ONE_E18
		IRs:
			TMP_5640(uint256) = _expTable10_1 (c)* _expTable10_1
			TMP_5641(uint256) = TMP_5640 (c)/ _ONE_E18_1
			_expTable11_1(uint256) := TMP_5641(uint256)
		Expression: _expTable12 = (_expTable11 * _expTable11) / _ONE_E18
		IRs:
			TMP_5642(uint256) = _expTable11_1 (c)* _expTable11_1
			TMP_5643(uint256) = TMP_5642 (c)/ _ONE_E18_1
			_expTable12_1(uint256) := TMP_5643(uint256)
		Expression: _expTable13 = (_expTable12 * _expTable12) / _ONE_E18
		IRs:
			TMP_5644(uint256) = _expTable12_1 (c)* _expTable12_1
			TMP_5645(uint256) = TMP_5644 (c)/ _ONE_E18_1
			_expTable13_1(uint256) := TMP_5645(uint256)
		Expression: _expTable14 = (_expTable13 * _expTable13) / _ONE_E18
		IRs:
			TMP_5646(uint256) = _expTable13_1 (c)* _expTable13_1
			TMP_5647(uint256) = TMP_5646 (c)/ _ONE_E18_1
			_expTable14_1(uint256) := TMP_5647(uint256)
		Expression: _expTable15 = (_expTable14 * _expTable14) / _ONE_E18
		IRs:
			TMP_5648(uint256) = _expTable14_1 (c)* _expTable14_1
			TMP_5649(uint256) = TMP_5648 (c)/ _ONE_E18_1
			_expTable15_1(uint256) := TMP_5649(uint256)
		Expression: _expTable16 = (_expTable15 * _expTable15) / _ONE_E18
		IRs:
			TMP_5650(uint256) = _expTable15_1 (c)* _expTable15_1
			TMP_5651(uint256) = TMP_5650 (c)/ _ONE_E18_1
			_expTable16_1(uint256) := TMP_5651(uint256)
		Expression: _expTable17 = (_expTable16 * _expTable16) / _ONE_E18
		IRs:
			TMP_5652(uint256) = _expTable16_1 (c)* _expTable16_1
			TMP_5653(uint256) = TMP_5652 (c)/ _ONE_E18_1
			_expTable17_1(uint256) := TMP_5653(uint256)
		Expression: _expTable18 = (_expTable17 * _expTable17) / _ONE_E18
		IRs:
			TMP_5654(uint256) = _expTable17_1 (c)* _expTable17_1
			TMP_5655(uint256) = TMP_5654 (c)/ _ONE_E18_1
			_expTable18_1(uint256) := TMP_5655(uint256)
		Expression: _expTable19 = (_expTable18 * _expTable18) / _ONE_E18
		IRs:
			TMP_5656(uint256) = _expTable18_1 (c)* _expTable18_1
			TMP_5657(uint256) = TMP_5656 (c)/ _ONE_E18_1
			_expTable19_1(uint256) := TMP_5657(uint256)
		Expression: _expTable20 = (_expTable19 * _expTable19) / _ONE_E18
		IRs:
			TMP_5658(uint256) = _expTable19_1 (c)* _expTable19_1
			TMP_5659(uint256) = TMP_5658 (c)/ _ONE_E18_1
			_expTable20_1(uint256) := TMP_5659(uint256)
		Expression: _expTable21 = (_expTable20 * _expTable20) / _ONE_E18
		IRs:
			TMP_5660(uint256) = _expTable20_1 (c)* _expTable20_1
			TMP_5661(uint256) = TMP_5660 (c)/ _ONE_E18_1
			_expTable21_1(uint256) := TMP_5661(uint256)
		Expression: _expTable22 = (_expTable21 * _expTable21) / _ONE_E18
		IRs:
			TMP_5662(uint256) = _expTable21_1 (c)* _expTable21_1
			TMP_5663(uint256) = TMP_5662 (c)/ _ONE_E18_1
			_expTable22_1(uint256) := TMP_5663(uint256)
		Expression: _expTable23 = (_expTable22 * _expTable22) / _ONE_E18
		IRs:
			TMP_5664(uint256) = _expTable22_1 (c)* _expTable22_1
			TMP_5665(uint256) = TMP_5664 (c)/ _ONE_E18_1
			_expTable23_1(uint256) := TMP_5665(uint256)
		Expression: _expTable24 = (_expTable23 * _expTable23) / _ONE_E18
		IRs:
			TMP_5666(uint256) = _expTable23_1 (c)* _expTable23_1
			TMP_5667(uint256) = TMP_5666 (c)/ _ONE_E18_1
			_expTable24_1(uint256) := TMP_5667(uint256)
		Expression: _expTable25 = (_expTable24 * _expTable24) / _ONE_E18
		IRs:
			TMP_5668(uint256) = _expTable24_1 (c)* _expTable24_1
			TMP_5669(uint256) = TMP_5668 (c)/ _ONE_E18_1
			_expTable25_1(uint256) := TMP_5669(uint256)
		Expression: _expTable26 = (_expTable25 * _expTable25) / _ONE_E18
		IRs:
			TMP_5670(uint256) = _expTable25_1 (c)* _expTable25_1
			TMP_5671(uint256) = TMP_5670 (c)/ _ONE_E18_1
			_expTable26_1(uint256) := TMP_5671(uint256)
		Expression: _expTable27 = (_expTable26 * _expTable26) / _ONE_E18
		IRs:
			TMP_5672(uint256) = _expTable26_1 (c)* _expTable26_1
			TMP_5673(uint256) = TMP_5672 (c)/ _ONE_E18_1
			_expTable27_1(uint256) := TMP_5673(uint256)
		Expression: _expTable28 = (_expTable27 * _expTable27) / _ONE_E18
		IRs:
			TMP_5674(uint256) = _expTable27_1 (c)* _expTable27_1
			TMP_5675(uint256) = TMP_5674 (c)/ _ONE_E18_1
			_expTable28_1(uint256) := TMP_5675(uint256)
		Expression: _expTable29 = (_expTable28 * _expTable28) / _ONE_E18
		IRs:
			TMP_5676(uint256) = _expTable28_1 (c)* _expTable28_1
			TMP_5677(uint256) = TMP_5676 (c)/ _ONE_E18_1
			_expTable29_1(uint256) := TMP_5677(uint256)
	Function VotingPowerCalculator._votingPowerAt(uint256,uint256)
		IRs:
			balance_1(uint256) := ϕ(['TMP_5616'])
			timestamp_1(uint256) := ϕ(['block.timestamp'])
			_ONE_E18_2(uint256) := ϕ(['_ONE_E18_0'])
			origin_2(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_2(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_2(uint256) := ϕ(['_expTable1_0', '_expTable1_1'])
			_expTable2_2(uint256) := ϕ(['_expTable2_0', '_expTable2_1'])
			_expTable3_2(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_2(uint256) := ϕ(['_expTable4_1', '_expTable4_0'])
			_expTable5_2(uint256) := ϕ(['_expTable5_1', '_expTable5_0'])
			_expTable6_2(uint256) := ϕ(['_expTable6_1', '_expTable6_0'])
			_expTable7_2(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_2(uint256) := ϕ(['_expTable8_1', '_expTable8_0'])
			_expTable9_2(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_2(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_2(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_2(uint256) := ϕ(['_expTable12_1', '_expTable12_0'])
			_expTable13_2(uint256) := ϕ(['_expTable13_1', '_expTable13_0'])
			_expTable14_2(uint256) := ϕ(['_expTable14_1', '_expTable14_0'])
			_expTable15_2(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_2(uint256) := ϕ(['_expTable16_1', '_expTable16_0'])
			_expTable17_2(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_2(uint256) := ϕ(['_expTable18_1', '_expTable18_0'])
			_expTable19_2(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_2(uint256) := ϕ(['_expTable20_1', '_expTable20_0'])
			_expTable21_2(uint256) := ϕ(['_expTable21_1', '_expTable21_0'])
			_expTable22_2(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_2(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_2(uint256) := ϕ(['_expTable24_1', '_expTable24_0'])
			_expTable25_2(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_2(uint256) := ϕ(['_expTable26_1', '_expTable26_0'])
			_expTable27_2(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_2(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_2(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_5678(uint256) = timestamp_4 - origin_2
			t_1(uint256) := TMP_5678(uint256)
		Expression: votingPower = balance
		IRs:
			votingPower_1(uint256) := balance_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_5679(uint256) = t_1 & 1
			TMP_5680(bool) = TMP_5679 != 0
			CONDITION TMP_5680
		Expression: votingPower = (votingPower * _expTable0) / _ONE_E18
		IRs:
			TMP_5681(uint256) = votingPower_1 * _expTable0_2
			TMP_5682(uint256) = TMP_5681 / _ONE_E18_2
			votingPower_2(uint256) := TMP_5682(uint256)
		IRs:
			votingPower_3(uint256) := ϕ(['votingPower_1', 'votingPower_2'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_5683(uint256) = t_1 & 2
			TMP_5684(bool) = TMP_5683 != 0
			CONDITION TMP_5684
		Expression: votingPower = (votingPower * _expTable1) / _ONE_E18
		IRs:
			TMP_5685(uint256) = votingPower_3 * _expTable1_2
			TMP_5686(uint256) = TMP_5685 / _ONE_E18_2
			votingPower_4(uint256) := TMP_5686(uint256)
		IRs:
			votingPower_5(uint256) := ϕ(['votingPower_1', 'votingPower_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_5687(uint256) = t_1 & 4
			TMP_5688(bool) = TMP_5687 != 0
			CONDITION TMP_5688
		Expression: votingPower = (votingPower * _expTable2) / _ONE_E18
		IRs:
			TMP_5689(uint256) = votingPower_5 * _expTable2_2
			TMP_5690(uint256) = TMP_5689 / _ONE_E18_2
			votingPower_6(uint256) := TMP_5690(uint256)
		IRs:
			votingPower_7(uint256) := ϕ(['votingPower_6', 'votingPower_1'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_5691(uint256) = t_1 & 8
			TMP_5692(bool) = TMP_5691 != 0
			CONDITION TMP_5692
		Expression: votingPower = (votingPower * _expTable3) / _ONE_E18
		IRs:
			TMP_5693(uint256) = votingPower_7 * _expTable3_2
			TMP_5694(uint256) = TMP_5693 / _ONE_E18_2
			votingPower_8(uint256) := TMP_5694(uint256)
		IRs:
			votingPower_9(uint256) := ϕ(['votingPower_8', 'votingPower_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_5695(uint256) = t_1 & 16
			TMP_5696(bool) = TMP_5695 != 0
			CONDITION TMP_5696
		Expression: votingPower = (votingPower * _expTable4) / _ONE_E18
		IRs:
			TMP_5697(uint256) = votingPower_9 * _expTable4_2
			TMP_5698(uint256) = TMP_5697 / _ONE_E18_2
			votingPower_10(uint256) := TMP_5698(uint256)
		IRs:
			votingPower_11(uint256) := ϕ(['votingPower_1', 'votingPower_10'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_5699(uint256) = t_1 & 32
			TMP_5700(bool) = TMP_5699 != 0
			CONDITION TMP_5700
		Expression: votingPower = (votingPower * _expTable5) / _ONE_E18
		IRs:
			TMP_5701(uint256) = votingPower_11 * _expTable5_2
			TMP_5702(uint256) = TMP_5701 / _ONE_E18_2
			votingPower_12(uint256) := TMP_5702(uint256)
		IRs:
			votingPower_13(uint256) := ϕ(['votingPower_1', 'votingPower_12'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_5703(uint256) = t_1 & 64
			TMP_5704(bool) = TMP_5703 != 0
			CONDITION TMP_5704
		Expression: votingPower = (votingPower * _expTable6) / _ONE_E18
		IRs:
			TMP_5705(uint256) = votingPower_13 * _expTable6_2
			TMP_5706(uint256) = TMP_5705 / _ONE_E18_2
			votingPower_14(uint256) := TMP_5706(uint256)
		IRs:
			votingPower_15(uint256) := ϕ(['votingPower_1', 'votingPower_14'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_5707(uint256) = t_1 & 128
			TMP_5708(bool) = TMP_5707 != 0
			CONDITION TMP_5708
		Expression: votingPower = (votingPower * _expTable7) / _ONE_E18
		IRs:
			TMP_5709(uint256) = votingPower_15 * _expTable7_2
			TMP_5710(uint256) = TMP_5709 / _ONE_E18_2
			votingPower_16(uint256) := TMP_5710(uint256)
		IRs:
			votingPower_17(uint256) := ϕ(['votingPower_1', 'votingPower_16'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_5711(uint256) = t_1 & 256
			TMP_5712(bool) = TMP_5711 != 0
			CONDITION TMP_5712
		Expression: votingPower = (votingPower * _expTable8) / _ONE_E18
		IRs:
			TMP_5713(uint256) = votingPower_17 * _expTable8_2
			TMP_5714(uint256) = TMP_5713 / _ONE_E18_2
			votingPower_18(uint256) := TMP_5714(uint256)
		IRs:
			votingPower_19(uint256) := ϕ(['votingPower_1', 'votingPower_18'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_5715(uint256) = t_1 & 512
			TMP_5716(bool) = TMP_5715 != 0
			CONDITION TMP_5716
		Expression: votingPower = (votingPower * _expTable9) / _ONE_E18
		IRs:
			TMP_5717(uint256) = votingPower_19 * _expTable9_2
			TMP_5718(uint256) = TMP_5717 / _ONE_E18_2
			votingPower_20(uint256) := TMP_5718(uint256)
		IRs:
			votingPower_21(uint256) := ϕ(['votingPower_1', 'votingPower_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_5719(uint256) = t_1 & 1024
			TMP_5720(bool) = TMP_5719 != 0
			CONDITION TMP_5720
		Expression: votingPower = (votingPower * _expTable10) / _ONE_E18
		IRs:
			TMP_5721(uint256) = votingPower_21 * _expTable10_2
			TMP_5722(uint256) = TMP_5721 / _ONE_E18_2
			votingPower_22(uint256) := TMP_5722(uint256)
		IRs:
			votingPower_23(uint256) := ϕ(['votingPower_22', 'votingPower_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_5723(uint256) = t_1 & 2048
			TMP_5724(bool) = TMP_5723 != 0
			CONDITION TMP_5724
		Expression: votingPower = (votingPower * _expTable11) / _ONE_E18
		IRs:
			TMP_5725(uint256) = votingPower_23 * _expTable11_2
			TMP_5726(uint256) = TMP_5725 / _ONE_E18_2
			votingPower_24(uint256) := TMP_5726(uint256)
		IRs:
			votingPower_25(uint256) := ϕ(['votingPower_24', 'votingPower_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_5727(uint256) = t_1 & 4096
			TMP_5728(bool) = TMP_5727 != 0
			CONDITION TMP_5728
		Expression: votingPower = (votingPower * _expTable12) / _ONE_E18
		IRs:
			TMP_5729(uint256) = votingPower_25 * _expTable12_2
			TMP_5730(uint256) = TMP_5729 / _ONE_E18_2
			votingPower_26(uint256) := TMP_5730(uint256)
		IRs:
			votingPower_27(uint256) := ϕ(['votingPower_1', 'votingPower_26'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_5731(uint256) = t_1 & 8192
			TMP_5732(bool) = TMP_5731 != 0
			CONDITION TMP_5732
		Expression: votingPower = (votingPower * _expTable13) / _ONE_E18
		IRs:
			TMP_5733(uint256) = votingPower_27 * _expTable13_2
			TMP_5734(uint256) = TMP_5733 / _ONE_E18_2
			votingPower_28(uint256) := TMP_5734(uint256)
		IRs:
			votingPower_29(uint256) := ϕ(['votingPower_1', 'votingPower_28'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_5735(uint256) = t_1 & 16384
			TMP_5736(bool) = TMP_5735 != 0
			CONDITION TMP_5736
		Expression: votingPower = (votingPower * _expTable14) / _ONE_E18
		IRs:
			TMP_5737(uint256) = votingPower_29 * _expTable14_2
			TMP_5738(uint256) = TMP_5737 / _ONE_E18_2
			votingPower_30(uint256) := TMP_5738(uint256)
		IRs:
			votingPower_31(uint256) := ϕ(['votingPower_1', 'votingPower_30'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_5739(uint256) = t_1 & 32768
			TMP_5740(bool) = TMP_5739 != 0
			CONDITION TMP_5740
		Expression: votingPower = (votingPower * _expTable15) / _ONE_E18
		IRs:
			TMP_5741(uint256) = votingPower_31 * _expTable15_2
			TMP_5742(uint256) = TMP_5741 / _ONE_E18_2
			votingPower_32(uint256) := TMP_5742(uint256)
		IRs:
			votingPower_33(uint256) := ϕ(['votingPower_1', 'votingPower_32'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_5743(uint256) = t_1 & 65536
			TMP_5744(bool) = TMP_5743 != 0
			CONDITION TMP_5744
		Expression: votingPower = (votingPower * _expTable16) / _ONE_E18
		IRs:
			TMP_5745(uint256) = votingPower_33 * _expTable16_2
			TMP_5746(uint256) = TMP_5745 / _ONE_E18_2
			votingPower_34(uint256) := TMP_5746(uint256)
		IRs:
			votingPower_35(uint256) := ϕ(['votingPower_1', 'votingPower_34'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_5747(uint256) = t_1 & 131072
			TMP_5748(bool) = TMP_5747 != 0
			CONDITION TMP_5748
		Expression: votingPower = (votingPower * _expTable17) / _ONE_E18
		IRs:
			TMP_5749(uint256) = votingPower_35 * _expTable17_2
			TMP_5750(uint256) = TMP_5749 / _ONE_E18_2
			votingPower_36(uint256) := TMP_5750(uint256)
		IRs:
			votingPower_37(uint256) := ϕ(['votingPower_1', 'votingPower_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_5751(uint256) = t_1 & 262144
			TMP_5752(bool) = TMP_5751 != 0
			CONDITION TMP_5752
		Expression: votingPower = (votingPower * _expTable18) / _ONE_E18
		IRs:
			TMP_5753(uint256) = votingPower_37 * _expTable18_2
			TMP_5754(uint256) = TMP_5753 / _ONE_E18_2
			votingPower_38(uint256) := TMP_5754(uint256)
		IRs:
			votingPower_39(uint256) := ϕ(['votingPower_38', 'votingPower_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_5755(uint256) = t_1 & 524288
			TMP_5756(bool) = TMP_5755 != 0
			CONDITION TMP_5756
		Expression: votingPower = (votingPower * _expTable19) / _ONE_E18
		IRs:
			TMP_5757(uint256) = votingPower_39 * _expTable19_2
			TMP_5758(uint256) = TMP_5757 / _ONE_E18_2
			votingPower_40(uint256) := TMP_5758(uint256)
		IRs:
			votingPower_41(uint256) := ϕ(['votingPower_40', 'votingPower_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_5759(uint256) = t_1 & 1048576
			TMP_5760(bool) = TMP_5759 != 0
			CONDITION TMP_5760
		Expression: votingPower = (votingPower * _expTable20) / _ONE_E18
		IRs:
			TMP_5761(uint256) = votingPower_41 * _expTable20_2
			TMP_5762(uint256) = TMP_5761 / _ONE_E18_2
			votingPower_42(uint256) := TMP_5762(uint256)
		IRs:
			votingPower_43(uint256) := ϕ(['votingPower_1', 'votingPower_42'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_5763(uint256) = t_1 & 2097152
			TMP_5764(bool) = TMP_5763 != 0
			CONDITION TMP_5764
		Expression: votingPower = (votingPower * _expTable21) / _ONE_E18
		IRs:
			TMP_5765(uint256) = votingPower_43 * _expTable21_2
			TMP_5766(uint256) = TMP_5765 / _ONE_E18_2
			votingPower_44(uint256) := TMP_5766(uint256)
		IRs:
			votingPower_45(uint256) := ϕ(['votingPower_1', 'votingPower_44'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_5767(uint256) = t_1 & 4194304
			TMP_5768(bool) = TMP_5767 != 0
			CONDITION TMP_5768
		Expression: votingPower = (votingPower * _expTable22) / _ONE_E18
		IRs:
			TMP_5769(uint256) = votingPower_45 * _expTable22_2
			TMP_5770(uint256) = TMP_5769 / _ONE_E18_2
			votingPower_46(uint256) := TMP_5770(uint256)
		IRs:
			votingPower_47(uint256) := ϕ(['votingPower_1', 'votingPower_46'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_5771(uint256) = t_1 & 8388608
			TMP_5772(bool) = TMP_5771 != 0
			CONDITION TMP_5772
		Expression: votingPower = (votingPower * _expTable23) / _ONE_E18
		IRs:
			TMP_5773(uint256) = votingPower_47 * _expTable23_2
			TMP_5774(uint256) = TMP_5773 / _ONE_E18_2
			votingPower_48(uint256) := TMP_5774(uint256)
		IRs:
			votingPower_49(uint256) := ϕ(['votingPower_1', 'votingPower_48'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_5775(uint256) = t_1 & 16777216
			TMP_5776(bool) = TMP_5775 != 0
			CONDITION TMP_5776
		Expression: votingPower = (votingPower * _expTable24) / _ONE_E18
		IRs:
			TMP_5777(uint256) = votingPower_49 * _expTable24_2
			TMP_5778(uint256) = TMP_5777 / _ONE_E18_2
			votingPower_50(uint256) := TMP_5778(uint256)
		IRs:
			votingPower_51(uint256) := ϕ(['votingPower_1', 'votingPower_50'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_5779(uint256) = t_1 & 33554432
			TMP_5780(bool) = TMP_5779 != 0
			CONDITION TMP_5780
		Expression: votingPower = (votingPower * _expTable25) / _ONE_E18
		IRs:
			TMP_5781(uint256) = votingPower_51 * _expTable25_2
			TMP_5782(uint256) = TMP_5781 / _ONE_E18_2
			votingPower_52(uint256) := TMP_5782(uint256)
		IRs:
			votingPower_53(uint256) := ϕ(['votingPower_1', 'votingPower_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_5783(uint256) = t_1 & 67108864
			TMP_5784(bool) = TMP_5783 != 0
			CONDITION TMP_5784
		Expression: votingPower = (votingPower * _expTable26) / _ONE_E18
		IRs:
			TMP_5785(uint256) = votingPower_53 * _expTable26_2
			TMP_5786(uint256) = TMP_5785 / _ONE_E18_2
			votingPower_54(uint256) := TMP_5786(uint256)
		IRs:
			votingPower_55(uint256) := ϕ(['votingPower_54', 'votingPower_1'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_5787(uint256) = t_1 & 134217728
			TMP_5788(bool) = TMP_5787 != 0
			CONDITION TMP_5788
		Expression: votingPower = (votingPower * _expTable27) / _ONE_E18
		IRs:
			TMP_5789(uint256) = votingPower_55 * _expTable27_2
			TMP_5790(uint256) = TMP_5789 / _ONE_E18_2
			votingPower_56(uint256) := TMP_5790(uint256)
		IRs:
			votingPower_57(uint256) := ϕ(['votingPower_56', 'votingPower_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_5791(uint256) = t_1 & 268435456
			TMP_5792(bool) = TMP_5791 != 0
			CONDITION TMP_5792
		Expression: votingPower = (votingPower * _expTable28) / _ONE_E18
		IRs:
			TMP_5793(uint256) = votingPower_57 * _expTable28_2
			TMP_5794(uint256) = TMP_5793 / _ONE_E18_2
			votingPower_58(uint256) := TMP_5794(uint256)
		IRs:
			votingPower_59(uint256) := ϕ(['votingPower_1', 'votingPower_58'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_5795(uint256) = t_1 & 536870912
			TMP_5796(bool) = TMP_5795 != 0
			CONDITION TMP_5796
		Expression: votingPower = (votingPower * _expTable29) / _ONE_E18
		IRs:
			TMP_5797(uint256) = votingPower_59 * _expTable29_2
			TMP_5798(uint256) = TMP_5797 / _ONE_E18_2
			votingPower_60(uint256) := TMP_5798(uint256)
		IRs:
			votingPower_61(uint256) := ϕ(['votingPower_1', 'votingPower_60'])
		Expression: votingPower
		IRs:
			RETURN votingPower_61
		Expression: timestamp < origin
		IRs:
			TMP_5799(bool) = timestamp_1 < origin_2
			CONDITION TMP_5799
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_2(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: votingPower
	Function VotingPowerCalculator._balanceAt(uint256,uint256)
		IRs:
			_ONE_E18_3(uint256) := ϕ(['_ONE_E18_0'])
			origin_3(uint256) := ϕ(['origin_1', 'origin_0'])
			_expTable0_3(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_3(uint256) := ϕ(['_expTable1_0', '_expTable1_1'])
			_expTable2_3(uint256) := ϕ(['_expTable2_0', '_expTable2_1'])
			_expTable3_3(uint256) := ϕ(['_expTable3_0', '_expTable3_1'])
			_expTable4_3(uint256) := ϕ(['_expTable4_1', '_expTable4_0'])
			_expTable5_3(uint256) := ϕ(['_expTable5_1', '_expTable5_0'])
			_expTable6_3(uint256) := ϕ(['_expTable6_1', '_expTable6_0'])
			_expTable7_3(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_3(uint256) := ϕ(['_expTable8_1', '_expTable8_0'])
			_expTable9_3(uint256) := ϕ(['_expTable9_1', '_expTable9_0'])
			_expTable10_3(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_3(uint256) := ϕ(['_expTable11_0', '_expTable11_1'])
			_expTable12_3(uint256) := ϕ(['_expTable12_1', '_expTable12_0'])
			_expTable13_3(uint256) := ϕ(['_expTable13_1', '_expTable13_0'])
			_expTable14_3(uint256) := ϕ(['_expTable14_1', '_expTable14_0'])
			_expTable15_3(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_3(uint256) := ϕ(['_expTable16_1', '_expTable16_0'])
			_expTable17_3(uint256) := ϕ(['_expTable17_1', '_expTable17_0'])
			_expTable18_3(uint256) := ϕ(['_expTable18_1', '_expTable18_0'])
			_expTable19_3(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_3(uint256) := ϕ(['_expTable20_1', '_expTable20_0'])
			_expTable21_3(uint256) := ϕ(['_expTable21_1', '_expTable21_0'])
			_expTable22_3(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_3(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_3(uint256) := ϕ(['_expTable24_1', '_expTable24_0'])
			_expTable25_3(uint256) := ϕ(['_expTable25_1', '_expTable25_0'])
			_expTable26_3(uint256) := ϕ(['_expTable26_1', '_expTable26_0'])
			_expTable27_3(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_3(uint256) := ϕ(['_expTable28_1', '_expTable28_0'])
			_expTable29_3(uint256) := ϕ(['_expTable29_1', '_expTable29_0'])
		Expression: t = timestamp - origin
		IRs:
			TMP_5800(uint256) = timestamp_4 - origin_3
			t_1(uint256) := TMP_5800(uint256)
		Expression: balance = votingPower
		IRs:
			balance_1(uint256) := votingPower_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_5801(uint256) = t_1 & 1
			TMP_5802(bool) = TMP_5801 != 0
			CONDITION TMP_5802
		Expression: balance = (balance * _ONE_E18) / _expTable0
		IRs:
			TMP_5803(uint256) = balance_1 * _ONE_E18_3
			TMP_5804(uint256) = TMP_5803 / _expTable0_3
			balance_2(uint256) := TMP_5804(uint256)
		IRs:
			balance_3(uint256) := ϕ(['balance_1', 'balance_2'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_5805(uint256) = t_1 & 2
			TMP_5806(bool) = TMP_5805 != 0
			CONDITION TMP_5806
		Expression: balance = (balance * _ONE_E18) / _expTable1
		IRs:
			TMP_5807(uint256) = balance_3 * _ONE_E18_3
			TMP_5808(uint256) = TMP_5807 / _expTable1_3
			balance_4(uint256) := TMP_5808(uint256)
		IRs:
			balance_5(uint256) := ϕ(['balance_1', 'balance_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_5809(uint256) = t_1 & 4
			TMP_5810(bool) = TMP_5809 != 0
			CONDITION TMP_5810
		Expression: balance = (balance * _ONE_E18) / _expTable2
		IRs:
			TMP_5811(uint256) = balance_5 * _ONE_E18_3
			TMP_5812(uint256) = TMP_5811 / _expTable2_3
			balance_6(uint256) := TMP_5812(uint256)
		IRs:
			balance_7(uint256) := ϕ(['balance_1', 'balance_6'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_5813(uint256) = t_1 & 8
			TMP_5814(bool) = TMP_5813 != 0
			CONDITION TMP_5814
		Expression: balance = (balance * _ONE_E18) / _expTable3
		IRs:
			TMP_5815(uint256) = balance_7 * _ONE_E18_3
			TMP_5816(uint256) = TMP_5815 / _expTable3_3
			balance_8(uint256) := TMP_5816(uint256)
		IRs:
			balance_9(uint256) := ϕ(['balance_1', 'balance_8'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_5817(uint256) = t_1 & 16
			TMP_5818(bool) = TMP_5817 != 0
			CONDITION TMP_5818
		Expression: balance = (balance * _ONE_E18) / _expTable4
		IRs:
			TMP_5819(uint256) = balance_9 * _ONE_E18_3
			TMP_5820(uint256) = TMP_5819 / _expTable4_3
			balance_10(uint256) := TMP_5820(uint256)
		IRs:
			balance_11(uint256) := ϕ(['balance_1', 'balance_10'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_5821(uint256) = t_1 & 32
			TMP_5822(bool) = TMP_5821 != 0
			CONDITION TMP_5822
		Expression: balance = (balance * _ONE_E18) / _expTable5
		IRs:
			TMP_5823(uint256) = balance_11 * _ONE_E18_3
			TMP_5824(uint256) = TMP_5823 / _expTable5_3
			balance_12(uint256) := TMP_5824(uint256)
		IRs:
			balance_13(uint256) := ϕ(['balance_1', 'balance_12'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_5825(uint256) = t_1 & 64
			TMP_5826(bool) = TMP_5825 != 0
			CONDITION TMP_5826
		Expression: balance = (balance * _ONE_E18) / _expTable6
		IRs:
			TMP_5827(uint256) = balance_13 * _ONE_E18_3
			TMP_5828(uint256) = TMP_5827 / _expTable6_3
			balance_14(uint256) := TMP_5828(uint256)
		IRs:
			balance_15(uint256) := ϕ(['balance_1', 'balance_14'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_5829(uint256) = t_1 & 128
			TMP_5830(bool) = TMP_5829 != 0
			CONDITION TMP_5830
		Expression: balance = (balance * _ONE_E18) / _expTable7
		IRs:
			TMP_5831(uint256) = balance_15 * _ONE_E18_3
			TMP_5832(uint256) = TMP_5831 / _expTable7_3
			balance_16(uint256) := TMP_5832(uint256)
		IRs:
			balance_17(uint256) := ϕ(['balance_1', 'balance_16'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_5833(uint256) = t_1 & 256
			TMP_5834(bool) = TMP_5833 != 0
			CONDITION TMP_5834
		Expression: balance = (balance * _ONE_E18) / _expTable8
		IRs:
			TMP_5835(uint256) = balance_17 * _ONE_E18_3
			TMP_5836(uint256) = TMP_5835 / _expTable8_3
			balance_18(uint256) := TMP_5836(uint256)
		IRs:
			balance_19(uint256) := ϕ(['balance_1', 'balance_18'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_5837(uint256) = t_1 & 512
			TMP_5838(bool) = TMP_5837 != 0
			CONDITION TMP_5838
		Expression: balance = (balance * _ONE_E18) / _expTable9
		IRs:
			TMP_5839(uint256) = balance_19 * _ONE_E18_3
			TMP_5840(uint256) = TMP_5839 / _expTable9_3
			balance_20(uint256) := TMP_5840(uint256)
		IRs:
			balance_21(uint256) := ϕ(['balance_1', 'balance_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_5841(uint256) = t_1 & 1024
			TMP_5842(bool) = TMP_5841 != 0
			CONDITION TMP_5842
		Expression: balance = (balance * _ONE_E18) / _expTable10
		IRs:
			TMP_5843(uint256) = balance_21 * _ONE_E18_3
			TMP_5844(uint256) = TMP_5843 / _expTable10_3
			balance_22(uint256) := TMP_5844(uint256)
		IRs:
			balance_23(uint256) := ϕ(['balance_1', 'balance_22'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_5845(uint256) = t_1 & 2048
			TMP_5846(bool) = TMP_5845 != 0
			CONDITION TMP_5846
		Expression: balance = (balance * _ONE_E18) / _expTable11
		IRs:
			TMP_5847(uint256) = balance_23 * _ONE_E18_3
			TMP_5848(uint256) = TMP_5847 / _expTable11_3
			balance_24(uint256) := TMP_5848(uint256)
		IRs:
			balance_25(uint256) := ϕ(['balance_1', 'balance_24'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_5849(uint256) = t_1 & 4096
			TMP_5850(bool) = TMP_5849 != 0
			CONDITION TMP_5850
		Expression: balance = (balance * _ONE_E18) / _expTable12
		IRs:
			TMP_5851(uint256) = balance_25 * _ONE_E18_3
			TMP_5852(uint256) = TMP_5851 / _expTable12_3
			balance_26(uint256) := TMP_5852(uint256)
		IRs:
			balance_27(uint256) := ϕ(['balance_1', 'balance_26'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_5853(uint256) = t_1 & 8192
			TMP_5854(bool) = TMP_5853 != 0
			CONDITION TMP_5854
		Expression: balance = (balance * _ONE_E18) / _expTable13
		IRs:
			TMP_5855(uint256) = balance_27 * _ONE_E18_3
			TMP_5856(uint256) = TMP_5855 / _expTable13_3
			balance_28(uint256) := TMP_5856(uint256)
		IRs:
			balance_29(uint256) := ϕ(['balance_1', 'balance_28'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_5857(uint256) = t_1 & 16384
			TMP_5858(bool) = TMP_5857 != 0
			CONDITION TMP_5858
		Expression: balance = (balance * _ONE_E18) / _expTable14
		IRs:
			TMP_5859(uint256) = balance_29 * _ONE_E18_3
			TMP_5860(uint256) = TMP_5859 / _expTable14_3
			balance_30(uint256) := TMP_5860(uint256)
		IRs:
			balance_31(uint256) := ϕ(['balance_1', 'balance_30'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_5861(uint256) = t_1 & 32768
			TMP_5862(bool) = TMP_5861 != 0
			CONDITION TMP_5862
		Expression: balance = (balance * _ONE_E18) / _expTable15
		IRs:
			TMP_5863(uint256) = balance_31 * _ONE_E18_3
			TMP_5864(uint256) = TMP_5863 / _expTable15_3
			balance_32(uint256) := TMP_5864(uint256)
		IRs:
			balance_33(uint256) := ϕ(['balance_1', 'balance_32'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_5865(uint256) = t_1 & 65536
			TMP_5866(bool) = TMP_5865 != 0
			CONDITION TMP_5866
		Expression: balance = (balance * _ONE_E18) / _expTable16
		IRs:
			TMP_5867(uint256) = balance_33 * _ONE_E18_3
			TMP_5868(uint256) = TMP_5867 / _expTable16_3
			balance_34(uint256) := TMP_5868(uint256)
		IRs:
			balance_35(uint256) := ϕ(['balance_1', 'balance_34'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_5869(uint256) = t_1 & 131072
			TMP_5870(bool) = TMP_5869 != 0
			CONDITION TMP_5870
		Expression: balance = (balance * _ONE_E18) / _expTable17
		IRs:
			TMP_5871(uint256) = balance_35 * _ONE_E18_3
			TMP_5872(uint256) = TMP_5871 / _expTable17_3
			balance_36(uint256) := TMP_5872(uint256)
		IRs:
			balance_37(uint256) := ϕ(['balance_1', 'balance_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_5873(uint256) = t_1 & 262144
			TMP_5874(bool) = TMP_5873 != 0
			CONDITION TMP_5874
		Expression: balance = (balance * _ONE_E18) / _expTable18
		IRs:
			TMP_5875(uint256) = balance_37 * _ONE_E18_3
			TMP_5876(uint256) = TMP_5875 / _expTable18_3
			balance_38(uint256) := TMP_5876(uint256)
		IRs:
			balance_39(uint256) := ϕ(['balance_1', 'balance_38'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_5877(uint256) = t_1 & 524288
			TMP_5878(bool) = TMP_5877 != 0
			CONDITION TMP_5878
		Expression: balance = (balance * _ONE_E18) / _expTable19
		IRs:
			TMP_5879(uint256) = balance_39 * _ONE_E18_3
			TMP_5880(uint256) = TMP_5879 / _expTable19_3
			balance_40(uint256) := TMP_5880(uint256)
		IRs:
			balance_41(uint256) := ϕ(['balance_1', 'balance_40'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_5881(uint256) = t_1 & 1048576
			TMP_5882(bool) = TMP_5881 != 0
			CONDITION TMP_5882
		Expression: balance = (balance * _ONE_E18) / _expTable20
		IRs:
			TMP_5883(uint256) = balance_41 * _ONE_E18_3
			TMP_5884(uint256) = TMP_5883 / _expTable20_3
			balance_42(uint256) := TMP_5884(uint256)
		IRs:
			balance_43(uint256) := ϕ(['balance_1', 'balance_42'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_5885(uint256) = t_1 & 2097152
			TMP_5886(bool) = TMP_5885 != 0
			CONDITION TMP_5886
		Expression: balance = (balance * _ONE_E18) / _expTable21
		IRs:
			TMP_5887(uint256) = balance_43 * _ONE_E18_3
			TMP_5888(uint256) = TMP_5887 / _expTable21_3
			balance_44(uint256) := TMP_5888(uint256)
		IRs:
			balance_45(uint256) := ϕ(['balance_1', 'balance_44'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_5889(uint256) = t_1 & 4194304
			TMP_5890(bool) = TMP_5889 != 0
			CONDITION TMP_5890
		Expression: balance = (balance * _ONE_E18) / _expTable22
		IRs:
			TMP_5891(uint256) = balance_45 * _ONE_E18_3
			TMP_5892(uint256) = TMP_5891 / _expTable22_3
			balance_46(uint256) := TMP_5892(uint256)
		IRs:
			balance_47(uint256) := ϕ(['balance_1', 'balance_46'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_5893(uint256) = t_1 & 8388608
			TMP_5894(bool) = TMP_5893 != 0
			CONDITION TMP_5894
		Expression: balance = (balance * _ONE_E18) / _expTable23
		IRs:
			TMP_5895(uint256) = balance_47 * _ONE_E18_3
			TMP_5896(uint256) = TMP_5895 / _expTable23_3
			balance_48(uint256) := TMP_5896(uint256)
		IRs:
			balance_49(uint256) := ϕ(['balance_1', 'balance_48'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_5897(uint256) = t_1 & 16777216
			TMP_5898(bool) = TMP_5897 != 0
			CONDITION TMP_5898
		Expression: balance = (balance * _ONE_E18) / _expTable24
		IRs:
			TMP_5899(uint256) = balance_49 * _ONE_E18_3
			TMP_5900(uint256) = TMP_5899 / _expTable24_3
			balance_50(uint256) := TMP_5900(uint256)
		IRs:
			balance_51(uint256) := ϕ(['balance_1', 'balance_50'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_5901(uint256) = t_1 & 33554432
			TMP_5902(bool) = TMP_5901 != 0
			CONDITION TMP_5902
		Expression: balance = (balance * _ONE_E18) / _expTable25
		IRs:
			TMP_5903(uint256) = balance_51 * _ONE_E18_3
			TMP_5904(uint256) = TMP_5903 / _expTable25_3
			balance_52(uint256) := TMP_5904(uint256)
		IRs:
			balance_53(uint256) := ϕ(['balance_1', 'balance_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_5905(uint256) = t_1 & 67108864
			TMP_5906(bool) = TMP_5905 != 0
			CONDITION TMP_5906
		Expression: balance = (balance * _ONE_E18) / _expTable26
		IRs:
			TMP_5907(uint256) = balance_53 * _ONE_E18_3
			TMP_5908(uint256) = TMP_5907 / _expTable26_3
			balance_54(uint256) := TMP_5908(uint256)
		IRs:
			balance_55(uint256) := ϕ(['balance_1', 'balance_54'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_5909(uint256) = t_1 & 134217728
			TMP_5910(bool) = TMP_5909 != 0
			CONDITION TMP_5910
		Expression: balance = (balance * _ONE_E18) / _expTable27
		IRs:
			TMP_5911(uint256) = balance_55 * _ONE_E18_3
			TMP_5912(uint256) = TMP_5911 / _expTable27_3
			balance_56(uint256) := TMP_5912(uint256)
		IRs:
			balance_57(uint256) := ϕ(['balance_1', 'balance_56'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_5913(uint256) = t_1 & 268435456
			TMP_5914(bool) = TMP_5913 != 0
			CONDITION TMP_5914
		Expression: balance = (balance * _ONE_E18) / _expTable28
		IRs:
			TMP_5915(uint256) = balance_57 * _ONE_E18_3
			TMP_5916(uint256) = TMP_5915 / _expTable28_3
			balance_58(uint256) := TMP_5916(uint256)
		IRs:
			balance_59(uint256) := ϕ(['balance_1', 'balance_58'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_5917(uint256) = t_1 & 536870912
			TMP_5918(bool) = TMP_5917 != 0
			CONDITION TMP_5918
		Expression: balance = (balance * _ONE_E18) / _expTable29
		IRs:
			TMP_5919(uint256) = balance_59 * _ONE_E18_3
			TMP_5920(uint256) = TMP_5919 / _expTable29_3
			balance_60(uint256) := TMP_5920(uint256)
		IRs:
			balance_61(uint256) := ϕ(['balance_1', 'balance_60'])
		Expression: balance
		IRs:
			RETURN balance_61
		Expression: timestamp < origin
		IRs:
			TMP_5921(bool) = timestamp_1 < origin_3
			CONDITION TMP_5921
		Expression: timestamp = origin
		IRs:
			timestamp_2(uint256) := origin_3(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_3(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: balance
	Function FarmingDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		Expression: TokenizedDelegationPod(name_,symbol_,token_,maxSharePods_,sharePodGasLimit_)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)(name__1,symbol__1,token__1,maxSharePods__1,sharePodGasLimit__1)
	Function FarmingDelegationPod.register(string,string)
		IRs:
			_MAX_FARM_REWARDS_1(uint256) := ϕ(['_MAX_FARM_REWARDS_0', '_MAX_FARM_REWARDS_2'])
		Expression: shareToken = super.register(name,symbol)
		IRs:
			TMP_5923(IDelegatedShare) = INTERNAL_CALL, TokenizedDelegationPod.register(string,string)(name_1,symbol_1)
			shareToken_1(IDelegatedShare) := TMP_5923(IDelegatedShare)
		Expression: farm = new MultiFarmingPod(shareToken,_MAX_FARM_REWARDS)
		IRs:
			TMP_5925(MultiFarmingPod) = new MultiFarmingPod(shareToken_1,_MAX_FARM_REWARDS_2) 
			farm_1(MultiFarmingPod) := TMP_5925(MultiFarmingPod)
		Expression: farm.transferOwnership(msg.sender)
		IRs:
			HIGH_LEVEL_CALL, dest:farm_1(MultiFarmingPod), function:transferOwnership, arguments:['msg.sender']  
		Expression: defaultFarms[msg.sender] = address(farm)
		IRs:
			REF_1215(address) -> defaultFarms_0[msg.sender]
			TMP_5927 = CONVERT farm_1 to address
			defaultFarms_1(mapping(address => address)) := ϕ(['defaultFarms_0'])
			REF_1215(address) (->defaultFarms_1) := TMP_5927(address)
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function FarmingDelegationPod.delegate(address)
		IRs:
			defaultFarms_2(mapping(address => address)) := ϕ(['defaultFarms_3', 'defaultFarms_0', 'defaultFarms_1', 'defaultFarms_4'])
			registration_1(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod.delegate(address)(delegatee_1)
			registration_2(mapping(address => IDelegatedShare)) := ϕ(['registration_7'])
		Expression: defaultFarm = defaultFarms[delegatee]
		IRs:
			REF_1216(address) -> defaultFarms_3[delegatee_1]
			defaultFarm_1(address) := REF_1216(address)
		Expression: defaultFarm != address(0)
		IRs:
			TMP_5929 = CONVERT 0 to address
			TMP_5930(bool) = defaultFarm_1 != TMP_5929
			CONDITION TMP_5930
		Expression: registration[delegatee].addDefaultFarmIfNeeded(msg.sender,defaultFarm)
		IRs:
			REF_1217(IDelegatedShare) -> registration_2[delegatee_1]
			HIGH_LEVEL_CALL, dest:REF_1217(IDelegatedShare), function:addDefaultFarmIfNeeded, arguments:['msg.sender', 'defaultFarm_1']  
			registration_3(mapping(address => IDelegatedShare)) := ϕ(['registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
	Function FarmingDelegationPod.setDefaultFarm(address)
		IRs:
			registration_4(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
		Expression: farm != address(0) && Pod(farm).token() != registration[msg.sender]
		IRs:
			TMP_5932 = CONVERT 0 to address
			TMP_5933(bool) = farm_1 != TMP_5932
			TMP_5934 = CONVERT farm_1 to Pod
			TMP_5935(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_5934(Pod), function:token, arguments:[]  
			registration_6(mapping(address => IDelegatedShare)) := ϕ(['registration_12', 'registration_14', 'registration_10', 'registration_5', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
			REF_1220(IDelegatedShare) -> registration_6[msg.sender]
			TMP_5936(bool) = TMP_5935 != REF_1220
			TMP_5937(bool) = TMP_5933 && TMP_5936
			CONDITION TMP_5937
		Expression: revert DefaultFarmTokenMismatch()()
		IRs:
			TMP_5938(None) = SOLIDITY_CALL revert DefaultFarmTokenMismatch()()
		Expression: defaultFarms[msg.sender] = farm
		IRs:
			REF_1221(address) -> defaultFarms_3[msg.sender]
			defaultFarms_4(mapping(address => address)) := ϕ(['defaultFarms_3'])
			REF_1221(address) (->defaultFarms_4) := farm_1(address)
		Expression: DefaultFarmSet(farm)
		IRs:
			Emit DefaultFarmSet(farm_1)
		Expression: onlyRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyRegistered()()
			registration_5(mapping(address => IDelegatedShare)) := ϕ(['registration_13'])
	Function TokenizedDelegationPod.constructor(string,string,IERC20Pods,uint256,uint256)
		Expression: maxSharePods = maxSharePods_
		IRs:
			maxSharePods_1(uint256) := maxSharePods__1(uint256)
		Expression: sharePodGasLimit = sharePodGasLimit_
		IRs:
			sharePodGasLimit_1(uint256) := sharePodGasLimit__1(uint256)
		Expression: DelegationPod(name_,symbol_,token_)
		IRs:
			INTERNAL_CALL, DelegationPod.constructor(string,string,IERC20Pods)(name__1,symbol__1,token__1)
	Function TokenizedDelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			registration_7(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
		Expression: delegatee != address(0) && address(registration[delegatee]) == address(0)
		IRs:
			TMP_5942 = CONVERT 0 to address
			TMP_5943(bool) = delegatee_1 != TMP_5942
			REF_1222(IDelegatedShare) -> registration_7[delegatee_1]
			TMP_5944 = CONVERT REF_1222 to address
			TMP_5945 = CONVERT 0 to address
			TMP_5946(bool) = TMP_5944 == TMP_5945
			TMP_5947(bool) = TMP_5943 && TMP_5946
			CONDITION TMP_5947
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_5948(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
		Expression: super.delegate(delegatee)
		IRs:
			INTERNAL_CALL, DelegationPod.delegate(address)(delegatee_1)
	Function TokenizedDelegationPod.register(string,string)
		IRs:
			name_1(string) := ϕ(['name_1'])
			symbol_1(string) := ϕ(['symbol_1'])
			maxSharePods_2(uint256) := ϕ(['maxSharePods_3', 'maxSharePods_1', 'maxSharePods_0'])
			sharePodGasLimit_2(uint256) := ϕ(['sharePodGasLimit_0', 'sharePodGasLimit_3', 'sharePodGasLimit_1'])
		Expression: shareToken = new DelegatedShare(name,symbol,maxSharePods,sharePodGasLimit)
		IRs:
			TMP_5951(DelegatedShare) = new DelegatedShare(name_1,symbol_1,maxSharePods_3,sharePodGasLimit_3) 
			shareToken_1(IDelegatedShare) := TMP_5951(DelegatedShare)
		Expression: registration[msg.sender] = shareToken
		IRs:
			REF_1223(IDelegatedShare) -> registration_7[msg.sender]
			registration_8(mapping(address => IDelegatedShare)) := ϕ(['registration_7'])
			REF_1223(IDelegatedShare) (->registration_8) := shareToken_1(IDelegatedShare)
		Expression: RegisterDelegatee(msg.sender)
		IRs:
			Emit RegisterDelegatee(msg.sender)
		Expression: onlyNotRegistered()
		IRs:
			MODIFIER_CALL, TokenizedDelegationPod.onlyNotRegistered()()
		Expression: shareToken
		IRs:
			RETURN shareToken_1
	Function TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'msg.sender'])
			to_1(address) := ϕ(['to_1', 'msg.sender'])
			fromDelegatee_1(address) := ϕ(['TMP_5972', 'prevDelegatee_1', 'REF_1231'])
			toDelegatee_1(address) := ϕ(['REF_1232', 'delegatee_1', 'TMP_5973'])
			amount_1(uint256) := ϕ(['amount_1', 'balance_1'])
			registration_9(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
		Expression: super._updateBalances(from,to,fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,fromDelegatee_1,toDelegatee_1,amount_1)
		Expression: fromDelegatee != address(0)
		IRs:
			TMP_5955 = CONVERT 0 to address
			TMP_5956(bool) = fromDelegatee_1 != TMP_5955
			CONDITION TMP_5956
		Expression: registration[fromDelegatee].burn(from,amount)
		IRs:
			REF_1224(IDelegatedShare) -> registration_10[fromDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_1224(IDelegatedShare), function:burn, arguments:['from_1', 'amount_1']  
			registration_11(mapping(address => IDelegatedShare)) := ϕ(['registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
		Expression: toDelegatee != address(0)
		IRs:
			TMP_5958 = CONVERT 0 to address
			TMP_5959(bool) = toDelegatee_1 != TMP_5958
			CONDITION TMP_5959
		Expression: registration[toDelegatee].mint(to,amount)
		IRs:
			REF_1226(IDelegatedShare) -> registration_11[toDelegatee_1]
			HIGH_LEVEL_CALL, dest:REF_1226(IDelegatedShare), function:mint, arguments:['to_1', 'amount_1']  
			registration_12(mapping(address => IDelegatedShare)) := ϕ(['registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
	Function DelegationPod.constructor(string,string,IERC20Pods)
		Expression: ERC20(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name__1,symbol__1)
		Expression: Pod(token_)
		IRs:
			INTERNAL_CALL, Pod.constructor(IERC20Pods)(token__1)
	Function DelegationPod.delegate(address)
		IRs:
			delegatee_1(address) := ϕ(['delegatee_1'])
			delegated_1(mapping(address => address)) := ϕ(['delegated_0', 'delegated_1', 'delegated_2', 'delegated_4'])
			token_1(IERC20Pods) := ϕ(['token_3', 'token_0', 'token_2'])
		Expression: prevDelegatee = delegated[msg.sender]
		IRs:
			REF_1228(address) -> delegated_1[msg.sender]
			prevDelegatee_1(address) := REF_1228(address)
		Expression: prevDelegatee != delegatee
		IRs:
			TMP_5963(bool) = prevDelegatee_1 != delegatee_1
			CONDITION TMP_5963
		Expression: delegated[msg.sender] = delegatee
		IRs:
			REF_1229(address) -> delegated_1[msg.sender]
			delegated_2(mapping(address => address)) := ϕ(['delegated_1'])
			REF_1229(address) (->delegated_2) := delegatee_1(address)
		Expression: Delegated(msg.sender,delegatee)
		IRs:
			Emit Delegated(msg.sender,delegatee_1)
		Expression: balance = IERC20Pods(token).podBalanceOf(address(this),msg.sender)
		IRs:
			TMP_5965 = CONVERT token_1 to IERC20Pods
			TMP_5966 = CONVERT this to address
			TMP_5967(uint256) = HIGH_LEVEL_CALL, dest:TMP_5965(IERC20Pods), function:podBalanceOf, arguments:['TMP_5966', 'msg.sender']  
			token_2(IERC20Pods) := ϕ(['token_3', 'token_1', 'token_2'])
			balance_1(uint256) := TMP_5967(uint256)
		Expression: balance > 0
		IRs:
			TMP_5968(bool) = balance_1 > 0
			CONDITION TMP_5968
		Expression: _updateBalances(msg.sender,msg.sender,prevDelegatee,delegatee,balance)
		IRs:
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(msg.sender,msg.sender,prevDelegatee_1,delegatee_1,balance_1)
	Function DelegationPod._updateBalances(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
			delegated_3(mapping(address => address)) := ϕ(['delegated_0', 'delegated_1', 'delegated_2', 'delegated_4'])
		Expression: to == address(0)
		IRs:
			TMP_5970 = CONVERT 0 to address
			TMP_5971(bool) = to_1 == TMP_5970
			CONDITION TMP_5971
		Expression: _updateBalances(from,to,address(0),address(0),amount)
		IRs:
			TMP_5972 = CONVERT 0 to address
			TMP_5973 = CONVERT 0 to address
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,TMP_5972,TMP_5973,amount_1)
		Expression: _updateBalances(from,to,delegated[from],delegated[to],amount)
		IRs:
			REF_1231(address) -> delegated_3[from_1]
			REF_1232(address) -> delegated_3[to_1]
			INTERNAL_CALL, TokenizedDelegationPod._updateBalances(address,address,address,address,uint256)(from_1,to_1,REF_1231,REF_1232,amount_1)
	Function DelegationPod._updateBalances(address,address,address,address,uint256)
		IRs:
			fromDelegatee_1(address) := ϕ(['fromDelegatee_1'])
			toDelegatee_1(address) := ϕ(['toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: fromDelegatee != toDelegatee && amount > 0
		IRs:
			TMP_5976(bool) = fromDelegatee_1 != toDelegatee_1
			TMP_5977(bool) = amount_1 > 0
			TMP_5978(bool) = TMP_5976 && TMP_5977
			CONDITION TMP_5978
		Expression: fromDelegatee == address(0)
		IRs:
			TMP_5979 = CONVERT 0 to address
			TMP_5980(bool) = fromDelegatee_1 == TMP_5979
			CONDITION TMP_5980
		Expression: _mint(toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(toDelegatee_1,amount_1)
		Expression: toDelegatee == address(0)
		IRs:
			TMP_5982 = CONVERT 0 to address
			TMP_5983(bool) = toDelegatee_1 == TMP_5982
			CONDITION TMP_5983
		Expression: _burn(fromDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(fromDelegatee_1,amount_1)
		Expression: _transfer(fromDelegatee,toDelegatee,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(fromDelegatee_1,toDelegatee_1,amount_1)
	Function DelegationPod.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_5986(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_5987(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function DelegationPod.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_5988(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_5989(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function DelegationPod.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_5990(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_7', '_totalSupply_4', '_totalSupply_0'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: _balances[account]
		IRs:
			REF_1233(uint256) -> _balances_1[account_1]
			RETURN REF_1233
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_5991(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_5991(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_2', '_allowances_1', '_allowances_0'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_1234(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_1235(uint256) -> REF_1234[spender_1]
			RETURN REF_1235
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_5993(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_5993(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_5995(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_5995(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_5998(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_5998(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_5999(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_6000(uint256) = TMP_5999 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_6000)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_6002(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_6002(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_6003(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_6003(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_6004(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_6005(None) = SOLIDITY_CALL require(bool,string)(TMP_6004,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_6006(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_6006)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'owner_1', 'fromDelegatee_1'])
			to_1(address) := ϕ(['toDelegatee_1', 'to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_6008 = CONVERT 0 to address
			TMP_6009(bool) = from_1 != TMP_6008
			TMP_6010(None) = SOLIDITY_CALL require(bool,string)(TMP_6009,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_6011 = CONVERT 0 to address
			TMP_6012(bool) = to_1 != TMP_6011
			TMP_6013(None) = SOLIDITY_CALL require(bool,string)(TMP_6012,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_1236(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_1236(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_6015(bool) = fromBalance_1 >= amount_1
			TMP_6016(None) = SOLIDITY_CALL require(bool,string)(TMP_6015,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_1237(uint256) -> _balances_3[from_1]
			TMP_6017(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_1237(uint256) (->_balances_4) := TMP_6017(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_1238(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_1238(-> _balances_5) = REF_1238 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1', 'toDelegatee_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_7', '_totalSupply_4', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_6020 = CONVERT 0 to address
			TMP_6021(bool) = account_1 != TMP_6020
			TMP_6022(None) = SOLIDITY_CALL require(bool,string)(TMP_6021,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_6023 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_6023,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_1239(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_1239(-> _balances_8) = REF_1239 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_6025 = CONVERT 0 to address
			Emit Transfer(TMP_6025,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_6027 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_6027,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['fromDelegatee_1', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_1', '_balances_8', '_balances_11', '_balances_5', '_balances_0'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_7', '_totalSupply_4', '_totalSupply_0'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_6029 = CONVERT 0 to address
			TMP_6030(bool) = account_1 != TMP_6029
			TMP_6031(None) = SOLIDITY_CALL require(bool,string)(TMP_6030,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_6032 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_6032,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_1240(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_1240(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_6034(bool) = accountBalance_1 >= amount_1
			TMP_6035(None) = SOLIDITY_CALL require(bool,string)(TMP_6034,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_1241(uint256) -> _balances_10[account_1]
			TMP_6036(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_1241(uint256) (->_balances_11) := TMP_6036(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_6037 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_6037,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_6039 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account_1,TMP_6039,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['TMP_6054', 'TMP_6000', 'amount_1', 'TMP_6006'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_6041 = CONVERT 0 to address
			TMP_6042(bool) = owner_1 != TMP_6041
			TMP_6043(None) = SOLIDITY_CALL require(bool,string)(TMP_6042,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_6044 = CONVERT 0 to address
			TMP_6045(bool) = spender_1 != TMP_6044
			TMP_6046(None) = SOLIDITY_CALL require(bool,string)(TMP_6045,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_1242(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_1243(uint256) -> REF_1242[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_1243(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_6048(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_6048(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_6050(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_6051(bool) = currentAllowance_1 != TMP_6050
			CONDITION TMP_6051
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_6052(bool) = currentAllowance_1 >= amount_1
			TMP_6053(None) = SOLIDITY_CALL require(bool,string)(TMP_6052,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_6054(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_6054)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_6023'])
			to_1(address) := ϕ(['TMP_6032', 'account_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['TMP_6027', 'account_1', 'from_1'])
			to_1(address) := ϕ(['TMP_6039', 'account_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Pod.constructor(IERC20Pods)
		Expression: token = token_
		IRs:
			token_3(IERC20Pods) := token__1(IERC20Pods)
	Function Pod.updateBalances(address,address,uint256)
		Expression: _updateBalances(from,to,amount)
		IRs:
			INTERNAL_CALL, DelegationPod._updateBalances(address,address,uint256)(from_1,to_1,amount_1)
		Expression: onlyToken()
		IRs:
			MODIFIER_CALL, Pod.onlyToken()()
	Function Pod._updateBalances(address,address,uint256)
	Function IPod.token()
	Function IPod.updateBalances(address,address,uint256)
	Function IDelegationPod.delegated(address)
	Function IDelegationPod.delegate(address)
	Function ITokenizedDelegationPod.register(string,string)
	Function ITokenizedDelegationPod.registration(address)
	Function IFarmingDelegationPod.setDefaultFarm(address)
	Function PowerPodMock.constructor(string,string,ISt1inch)
		Expression: PowerPod(name,symbol,st1inch)
		IRs:
			INTERNAL_CALL, PowerPod.constructor(string,string,ISt1inch)(name_1,symbol_1,st1inch_1)
	Function PowerPodMock.mint(address,uint256)
		Expression: _mint(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account_1,amount_1)
	Function PowerPodMock.burn(address,uint256)
		Expression: _burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account_1,amount_1)
	Function PowerPodMock.votingPowerOf(address)
		Expression: balanceOf(account) / 2
		IRs:
			TMP_6061(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			TMP_6062(uint256) = TMP_6061 (c)/ 2
			RETURN TMP_6062
	Modifier TokenizedDelegationPod.onlyRegistered()
ENTRY_POINT
		IRs:
			registration_13(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
IF address(registration[msg.sender]) == address(0)
		Expression: address(registration[msg.sender]) == address(0)
		IRs:
			REF_1244(IDelegatedShare) -> registration_13[msg.sender]
			TMP_6063 = CONVERT REF_1244 to address
			TMP_6064 = CONVERT 0 to address
			TMP_6065(bool) = TMP_6063 == TMP_6064
			CONDITION TMP_6065
EXPRESSION revert NotRegisteredDelegatee()()
		Expression: revert NotRegisteredDelegatee()()
		IRs:
			TMP_6066(None) = SOLIDITY_CALL revert NotRegisteredDelegatee()()
END_IF
_
	Modifier TokenizedDelegationPod.onlyNotRegistered()
ENTRY_POINT
		IRs:
			registration_14(mapping(address => IDelegatedShare)) := ϕ(['registration_0', 'registration_12', 'registration_14', 'registration_10', 'registration_3', 'registration_7', 'registration_2', 'registration_8', 'registration_13', 'registration_11', 'registration_6'])
IF address(registration[msg.sender]) != address(0)
		Expression: address(registration[msg.sender]) != address(0)
		IRs:
			REF_1245(IDelegatedShare) -> registration_14[msg.sender]
			TMP_6067 = CONVERT REF_1245 to address
			TMP_6068 = CONVERT 0 to address
			TMP_6069(bool) = TMP_6067 != TMP_6068
			CONDITION TMP_6069
EXPRESSION revert AlreadyRegistered()()
		Expression: revert AlreadyRegistered()()
		IRs:
			TMP_6070(None) = SOLIDITY_CALL revert AlreadyRegistered()()
END_IF
_
	Modifier Pod.onlyToken()
ENTRY_POINT
		IRs:
			token_4(IERC20Pods) := ϕ(['token_3', 'token_0', 'token_2'])
IF msg.sender != address(token)
		Expression: msg.sender != address(token)
		IRs:
			TMP_6071 = CONVERT token_4 to address
			TMP_6072(bool) = msg.sender != TMP_6071
			CONDITION TMP_6072
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_6073(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
Contract ResolverMock
	Function IResolver.resolveOrders(address,bytes,bytes)
	Function ResolverMock.constructor(address)
		Expression: _settlement = settlement
		IRs:
			_settlement_1(address) := settlement_1(address)
		Expression: _owner = msg.sender
		IRs:
			_owner_1(address) := msg.sender(address)
	Function ResolverMock.resolveOrders(address,bytes,bytes)
		IRs:
			_settlement_2(address) := ϕ(['_settlement_0', '_settlement_1'])
			_owner_2(address) := ϕ(['_owner_0', '_owner_1'])
		Expression: msg.sender != _settlement
		IRs:
			TMP_6074(bool) = msg.sender != _settlement_2
			CONDITION TMP_6074
		Expression: revert OnlySettlement()()
		IRs:
			TMP_6075(None) = SOLIDITY_CALL revert OnlySettlement()()
		Expression: resolver != _owner
		IRs:
			TMP_6076(bool) = resolver_1 != _owner_2
			CONDITION TMP_6076
		Expression: revert OnlyOwner()()
		IRs:
			TMP_6077(None) = SOLIDITY_CALL revert OnlyOwner()()
		Expression: data.length > 0
		IRs:
			REF_1246 -> LENGTH data_1
			TMP_6078(bool) = REF_1246 > 0
			CONDITION TMP_6078
		Expression: (targets,calldatas) = abi.decode(data,(Address,bytes[]))
		IRs:
			TUPLE_75(Address,bytes[]) = SOLIDITY_CALL abi.decode()(data_1(Address,bytes[]))
			targets_1(Address[])= UNPACK TUPLE_75 index: 0 
			calldatas_1(bytes[])= UNPACK TUPLE_75 index: 1 
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			REF_1248 -> LENGTH targets_1
			TMP_6079(bool) = i_2 < REF_1248
			CONDITION TMP_6079
		Expression: (success,reason) = targets[i].get().call(calldatas[i])
		IRs:
			REF_1249(Address) -> targets_1[i_2]
			TMP_6080(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1249'] 
			REF_1252(bytes) -> calldatas_1[i_2]
			TUPLE_76(bool,bytes) = LOW_LEVEL_CALL, dest:TMP_6080, function:call, arguments:['REF_1252']  
			success_1(bool)= UNPACK TUPLE_76 index: 0 
			reason_1(bytes)= UNPACK TUPLE_76 index: 1 
		Expression: ! success
		IRs:
			TMP_6081 = UnaryType.BANG success_1 
			CONDITION TMP_6081
		Expression: revert FailedExternalCall(uint256,bytes)(i,reason)
		IRs:
			TMP_6082(None) = SOLIDITY_CALL revert FailedExternalCall(uint256,bytes)(i_2,reason_1)
		Expression: ++ i
		IRs:
			i_3(uint256) = i_2 (c)+ 1
		Expression: items = tokensAndAmounts.decode()
		IRs:
			TMP_6083(TokensAndAmounts.Data[]) = LIBRARY_CALL, dest:TokensAndAmounts, function:TokensAndAmounts.decode(bytes), arguments:['tokensAndAmounts_1'] 
			items_1(TokensAndAmounts.Data[]) = ['TMP_6083(TokensAndAmounts.Data[])']
		Expression: i_scope_0 = 0
		IRs:
			i_scope_0_1(uint256) := 0(uint256)
		Expression: i_scope_0 < items.length
		IRs:
			i_scope_0_2(uint256) := ϕ(['i_scope_0_3', 'i_scope_0_1'])
			REF_1254 -> LENGTH items_1
			TMP_6084(bool) = i_scope_0_2 < REF_1254
			CONDITION TMP_6084
		Expression: IERC20(items[i_scope_0].token.get()).safeTransfer(msg.sender,items[i_scope_0].amount)
		IRs:
			REF_1255(TokensAndAmounts.Data) -> items_1[i_scope_0_2]
			REF_1256(Address) -> REF_1255.token
			TMP_6085(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1256'] 
			TMP_6086 = CONVERT TMP_6085 to IERC20
			REF_1259(TokensAndAmounts.Data) -> items_1[i_scope_0_2]
			REF_1260(uint256) -> REF_1259.amount
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_6086', 'msg.sender', 'REF_1260'] 
		Expression: i_scope_0 ++
		IRs:
			TMP_6088(uint256) := i_scope_0_2(uint256)
			i_scope_0_3(uint256) = i_scope_0_2 (c)+ 1
Contract SettlementMock
	Function Settlement.constructor(IOrderMixin,IERC20)
		Expression: _limitOrderProtocol = limitOrderProtocol
		IRs:
			_limitOrderProtocol_1(IOrderMixin) := limitOrderProtocol_1(IOrderMixin)
		Expression: FeeBankCharger(token)
		IRs:
			INTERNAL_CALL, FeeBankCharger.constructor(IERC20)(token_1)
	Function Settlement.settleOrders(bytes)
		Expression: _settleOrder(data,msg.sender,0,new bytes(0))
		IRs:
			TMP_6091 = new bytes(0)
			INTERNAL_CALL, Settlement._settleOrder(bytes,address,uint256,bytes)(data_1,msg.sender,0,TMP_6091)
	Function Settlement.fillOrderInteraction(address,uint256,uint256,bytes)
		IRs:
			_FINALIZE_INTERACTION_1(bytes1) := ϕ(['_FINALIZE_INTERACTION_3', '_FINALIZE_INTERACTION_0'])
			_BASE_POINTS_1(uint256) := ϕ(['_BASE_POINTS_0', '_BASE_POINTS_3'])
			_limitOrderProtocol_2(IOrderMixin) := ϕ(['_limitOrderProtocol_5', '_limitOrderProtocol_0', '_limitOrderProtocol_7', '_limitOrderProtocol_1'])
		Expression: (suffix,tokensAndAmounts,interaction) = interactiveData.decodeSuffix()
		IRs:
			TUPLE_77(DynamicSuffix.Data,bytes,bytes) = LIBRARY_CALL, dest:DynamicSuffix, function:DynamicSuffix.decodeSuffix(bytes), arguments:['interactiveData_1'] 
			suffix_1(DynamicSuffix.Data)= UNPACK TUPLE_77 index: 0 
			tokensAndAmounts_1(bytes)= UNPACK TUPLE_77 index: 1 
			interaction_1(bytes)= UNPACK TUPLE_77 index: 2 
		Expression: token = IERC20(suffix.token.get())
		IRs:
			REF_1262(Address) -> suffix_1.token
			TMP_6093(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1262'] 
			TMP_6094 = CONVERT TMP_6093 to IERC20
			token_1(IERC20) := TMP_6094(IERC20)
		Expression: result = takingAmount * (_BASE_POINTS + suffix.rateBump) / _BASE_POINTS
		IRs:
			REF_1264(uint256) -> suffix_1.rateBump
			TMP_6095(uint256) = _BASE_POINTS_3 (c)+ REF_1264
			TMP_6096(uint256) = takingAmount_1 (c)* TMP_6095
			TMP_6097(uint256) = TMP_6096 (c)/ _BASE_POINTS_3
			result_1(uint256) := TMP_6097(uint256)
		Expression: takingFee = result * suffix.takingFee.ratio() / TakingFee._TAKING_FEE_BASE
		IRs:
			REF_1265(TakingFee.Data) -> suffix_1.takingFee
			TMP_6098(uint256) = LIBRARY_CALL, dest:TakingFee, function:TakingFee.ratio(TakingFee.Data), arguments:['REF_1265'] 
			TMP_6099(uint256) = result_1 (c)* TMP_6098
			REF_1267(uint256) -> TakingFee._TAKING_FEE_BASE
			TMP_6100(uint256) = TMP_6099 (c)/ REF_1267
			takingFee_1(uint256) := TMP_6100(uint256)
		Expression: allTokensAndAmounts = new bytes(tokensAndAmounts.length + 0x40)
		IRs:
			REF_1268 -> LENGTH tokensAndAmounts_1
			TMP_6102(uint256) = REF_1268 (c)+ 64
			TMP_6103 = new bytes(TMP_6102)
			allTokensAndAmounts_1(bytes) := TMP_6103(bytes)
		Expression: ptr_fillOrderInteraction_asm_0 = allTokensAndAmounts + 0x20
		IRs:
			TMP_6104(bytes) = allTokensAndAmounts_1 + 32
			ptr_fillOrderInteraction_asm_0_1(uint256) := TMP_6104(bytes)
		Expression: calldatacopy(uint256,uint256,uint256)(ptr_fillOrderInteraction_asm_0,tokensAndAmounts,tokensAndAmounts)
		IRs:
			TMP_6105(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(ptr_fillOrderInteraction_asm_0_1,tokensAndAmounts_1,tokensAndAmounts_1)
		Expression: ptr_fillOrderInteraction_asm_0 = ptr_fillOrderInteraction_asm_0 + tokensAndAmounts
		IRs:
			TMP_6106(uint256) = ptr_fillOrderInteraction_asm_0_1 + tokensAndAmounts_1
			ptr_fillOrderInteraction_asm_0_2(uint256) := TMP_6106(uint256)
		Expression: mstore(uint256,uint256)(ptr_fillOrderInteraction_asm_0,token)
		IRs:
			TMP_6107(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_fillOrderInteraction_asm_0_2,token_1)
		Expression: mstore(uint256,uint256)(ptr_fillOrderInteraction_asm_0 + 0x20,result + takingFee)
		IRs:
			TMP_6108(uint256) = ptr_fillOrderInteraction_asm_0_2 + 32
			TMP_6109(uint256) = result_1 + takingFee_1
			TMP_6110(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6108,TMP_6109)
		Expression: interactiveData[0] == _FINALIZE_INTERACTION
		IRs:
			REF_1269(None) -> interactiveData_1[0]
			TMP_6111(bool) = REF_1269 == _FINALIZE_INTERACTION_3
			CONDITION TMP_6111
		Expression: _chargeFee(suffix.resolver.get(),suffix.totalFee)
		IRs:
			REF_1270(Address) -> suffix_1.resolver
			TMP_6112(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1270'] 
			REF_1272(uint256) -> suffix_1.totalFee
			INTERNAL_CALL, FeeBankCharger._chargeFee(address,uint256)(TMP_6112,REF_1272)
		Expression: target = address(bytes20(interaction))
		IRs:
			TMP_6114 = CONVERT interaction_1 to bytes20
			TMP_6115 = CONVERT TMP_6114 to address
			target_1(address) := TMP_6115(address)
		Expression: data = interaction
		IRs:
			data_1(bytes) := interaction_1(bytes)
		Expression: IResolver(target).resolveOrders(suffix.resolver.get(),allTokensAndAmounts,data)
		IRs:
			TMP_6116 = CONVERT target_1 to IResolver
			REF_1274(Address) -> suffix_1.resolver
			TMP_6117(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1274'] 
			HIGH_LEVEL_CALL, dest:TMP_6116(IResolver), function:resolveOrders, arguments:['TMP_6117', 'allTokensAndAmounts_1', 'data_1']  
			_limitOrderProtocol_7(IOrderMixin) := ϕ(['_limitOrderProtocol_6', '_limitOrderProtocol_5', '_limitOrderProtocol_7', '_limitOrderProtocol_1'])
		Expression: _settleOrder(interaction,suffix.resolver.get(),suffix.totalFee,allTokensAndAmounts)
		IRs:
			REF_1276(Address) -> suffix_1.resolver
			TMP_6119(address) = LIBRARY_CALL, dest:AddressLib, function:AddressLib.get(Address), arguments:['REF_1276'] 
			REF_1278(uint256) -> suffix_1.totalFee
			INTERNAL_CALL, Settlement._settleOrder(bytes,address,uint256,bytes)(interaction_1,TMP_6119,REF_1278,allTokensAndAmounts_1)
		Expression: takingFee > 0
		IRs:
			TMP_6121(bool) = takingFee_1 > 0
			CONDITION TMP_6121
		Expression: token.safeTransfer(suffix.takingFee.receiver(),takingFee)
		IRs:
			REF_1280(TakingFee.Data) -> suffix_1.takingFee
			TMP_6122(address) = LIBRARY_CALL, dest:TakingFee, function:TakingFee.receiver(TakingFee.Data), arguments:['REF_1280'] 
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['token_1', 'TMP_6122', 'takingFee_1'] 
		Expression: token.forceApprove(address(_limitOrderProtocol),result)
		IRs:
			TMP_6124 = CONVERT _limitOrderProtocol_7 to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.forceApprove(IERC20,address,uint256), arguments:['token_1', 'TMP_6124', 'result_1'] 
		Expression: onlyThis(taker)
		IRs:
			MODIFIER_CALL, Settlement.onlyThis(address)(taker_1)
		Expression: onlyLimitOrderProtocol()
		IRs:
			MODIFIER_CALL, Settlement.onlyLimitOrderProtocol()()
		Expression: result
		IRs:
			RETURN result_1
	Function Settlement._settleOrder(bytes,address,uint256,bytes)
		IRs:
			data_1(bytes) := ϕ(['interaction_1', 'data_1'])
			resolver_1(address) := ϕ(['TMP_6119', 'msg.sender'])
			totalFee_1(uint256) := ϕ(['REF_1278'])
			tokensAndAmounts_1(bytes) := ϕ(['allTokensAndAmounts_1', 'TMP_6091'])
			_ORDER_FEE_BASE_POINTS_1(uint256) := ϕ(['_ORDER_FEE_BASE_POINTS_0'])
			_limitOrderProtocol_8(IOrderMixin) := ϕ(['_limitOrderProtocol_5', '_limitOrderProtocol_0', '_limitOrderProtocol_7', '_limitOrderProtocol_1'])
			_FILL_ORDER_TO_SELECTOR_1(bytes4) := ϕ(['_FILL_ORDER_TO_SELECTOR_0'])
			_WRONG_INTERACTION_TARGET_SELECTOR_1(bytes4) := ϕ(['_WRONG_INTERACTION_TARGET_SELECTOR_0'])
		Expression: order = data + calldataload(uint256)(data)
		IRs:
			TMP_6128(uint256) = SOLIDITY_CALL calldataload(uint256)(data_1)
			TMP_6129(bytes) = data_1 + TMP_6128
			order_1(OrderLib.Order) := TMP_6129(bytes)
		Expression: ! order.checkResolver(resolver)
		IRs:
			TMP_6130(bool) = LIBRARY_CALL, dest:OrderSuffix, function:OrderSuffix.checkResolver(OrderLib.Order,address), arguments:['order_1', 'resolver_1'] 
			TMP_6131 = UnaryType.BANG TMP_6130 
			CONDITION TMP_6131
		Expression: revert ResolverIsNotWhitelisted()()
		IRs:
			TMP_6132(None) = SOLIDITY_CALL revert ResolverIsNotWhitelisted()()
		Expression: takingFeeData = order.takingFee()
		IRs:
			TMP_6133(TakingFee.Data) = LIBRARY_CALL, dest:OrderSuffix, function:OrderSuffix.takingFee(OrderLib.Order), arguments:['order_1'] 
			takingFeeData_1(TakingFee.Data) := TMP_6133(TakingFee.Data)
		Expression: totalFee += order.salt.getFee() * _ORDER_FEE_BASE_POINTS
		IRs:
			REF_1285(uint256) -> order_1.salt
			TMP_6134(uint256) = LIBRARY_CALL, dest:OrderSaltParser, function:OrderSaltParser.getFee(uint256), arguments:['REF_1285'] 
			TMP_6135(uint256) = TMP_6134 (c)* _ORDER_FEE_BASE_POINTS_1
			totalFee_2(uint256) = totalFee_1 (c)+ TMP_6135
		Expression: rateBump = order.rateBump()
		IRs:
			TMP_6136(uint256) = LIBRARY_CALL, dest:OrderSuffix, function:OrderSuffix.rateBump(OrderLib.Order), arguments:['order_1'] 
			rateBump_1(uint256) := TMP_6136(uint256)
		Expression: suffixLength = DynamicSuffix._STATIC_DATA_SIZE + tokensAndAmounts.length + 0x20
		IRs:
			REF_1288(uint256) -> DynamicSuffix._STATIC_DATA_SIZE
			REF_1289 -> LENGTH tokensAndAmounts_1
			TMP_6137(uint256) = REF_1288 (c)+ REF_1289
			TMP_6138(uint256) = TMP_6137 (c)+ 32
			suffixLength_1(uint256) := TMP_6138(uint256)
		Expression: limitOrderProtocol = _limitOrderProtocol
		IRs:
			limitOrderProtocol_1(IOrderMixin) := _limitOrderProtocol_8(IOrderMixin)
		Expression: interactionLengthOffset__settleOrder_asm_1 = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_6139(bytes) = data_1 + 64
			TMP_6140(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_6139)
			interactionLengthOffset__settleOrder_asm_1_1(uint256) := TMP_6140(uint256)
		Expression: interactionOffset__settleOrder_asm_1 = interactionLengthOffset__settleOrder_asm_1 + 0x20
		IRs:
			TMP_6141(uint256) = interactionLengthOffset__settleOrder_asm_1_1 + 32
			interactionOffset__settleOrder_asm_1_1(uint256) := TMP_6141(uint256)
		Expression: interactionLength__settleOrder_asm_1 = calldataload(uint256)(data + interactionLengthOffset__settleOrder_asm_1)
		IRs:
			TMP_6142(bytes) = data_1 + interactionLengthOffset__settleOrder_asm_1_1
			TMP_6143(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_6142)
			interactionLength__settleOrder_asm_1_1(uint256) := TMP_6143(uint256)
		Expression: target__settleOrder_asm_1 = calldataload(uint256)(data + interactionOffset__settleOrder_asm_1) >> 96
		IRs:
			TMP_6144(bytes) = data_1 + interactionOffset__settleOrder_asm_1_1
			TMP_6145(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_6144)
			TMP_6146(uint256) = TMP_6145 >> 96
			target__settleOrder_asm_1_1(uint256) := TMP_6146(uint256)
		Expression: interactionLength__settleOrder_asm_1 < 20 | ! target__settleOrder_asm_1 == address()()
		IRs:
			TMP_6147(bool) = interactionLength__settleOrder_asm_1_1 < 20
			TMP_6148 = CONVERT this to address
			TMP_6149(bool) = target__settleOrder_asm_1_1 == TMP_6148
			TMP_6150 = UnaryType.BANG TMP_6149 
			TMP_6151(bool) = TMP_6147 | TMP_6150
			CONDITION TMP_6151
		Expression: mstore(uint256,uint256)(0,_WRONG_INTERACTION_TARGET_SELECTOR)
		IRs:
			TMP_6152(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,_WRONG_INTERACTION_TARGET_SELECTOR_1)
		Expression: revert(uint256,uint256)(0,4)
		IRs:
			TMP_6153(None) = SOLIDITY_CALL revert(uint256,uint256)(0,4)
		Expression: ptr__settleOrder_asm_1 = mload(uint256)(0x40)
		IRs:
			TMP_6154(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr__settleOrder_asm_1_1(uint256) := TMP_6154(uint256)
		Expression: mstore(uint256,uint256)(ptr__settleOrder_asm_1,_FILL_ORDER_TO_SELECTOR)
		IRs:
			TMP_6155(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr__settleOrder_asm_1_1,_FILL_ORDER_TO_SELECTOR_1)
		Expression: calldatacopy(uint256,uint256,uint256)(ptr__settleOrder_asm_1 + 4,data,data)
		IRs:
			TMP_6156(uint256) = ptr__settleOrder_asm_1_1 + 4
			TMP_6157(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(TMP_6156,data_1,data_1)
		Expression: mstore(uint256,uint256)(ptr__settleOrder_asm_1 + interactionLengthOffset__settleOrder_asm_1 + 4,interactionLength__settleOrder_asm_1 + suffixLength)
		IRs:
			TMP_6158(uint256) = ptr__settleOrder_asm_1_1 + interactionLengthOffset__settleOrder_asm_1_1
			TMP_6159(uint256) = TMP_6158 + 4
			TMP_6160(uint256) = interactionLength__settleOrder_asm_1_1 + suffixLength_1
			TMP_6161(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6159,TMP_6160)
		Expression: offset__settleOrder_asm_1 = ptr__settleOrder_asm_1 + interactionOffset__settleOrder_asm_1 + interactionLength__settleOrder_asm_1
		IRs:
			TMP_6162(uint256) = ptr__settleOrder_asm_1_1 + interactionOffset__settleOrder_asm_1_1
			TMP_6163(uint256) = TMP_6162 + interactionLength__settleOrder_asm_1_1
			offset__settleOrder_asm_1_1(uint256) := TMP_6163(uint256)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x04,totalFee)
		IRs:
			TMP_6164(uint256) = offset__settleOrder_asm_1_1 + 4
			TMP_6165(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6164,totalFee_2)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x24,resolver)
		IRs:
			TMP_6166(uint256) = offset__settleOrder_asm_1_1 + 36
			TMP_6167(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6166,resolver_1)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x44,calldataload(uint256)(order + 0x40))
		IRs:
			TMP_6168(uint256) = offset__settleOrder_asm_1_1 + 68
			TMP_6169(OrderLib.Order) = order_1 + 64
			TMP_6170(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_6169)
			TMP_6171(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6168,TMP_6170)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x64,rateBump)
		IRs:
			TMP_6172(uint256) = offset__settleOrder_asm_1_1 + 100
			TMP_6173(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6172,rateBump_1)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0x84,takingFeeData)
		IRs:
			TMP_6174(uint256) = offset__settleOrder_asm_1_1 + 132
			TMP_6175(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6174,takingFeeData_1)
		Expression: tokensAndAmountsLength__settleOrder_asm_1 = mload(uint256)(tokensAndAmounts)
		IRs:
			TMP_6176(uint256) = SOLIDITY_CALL mload(uint256)(tokensAndAmounts_1)
			tokensAndAmountsLength__settleOrder_asm_1_1(uint256) := TMP_6176(uint256)
		Expression: memcpy(offset__settleOrder_asm_1 + 0xa4,tokensAndAmounts + 0x20,tokensAndAmountsLength__settleOrder_asm_1)
		IRs:
			TMP_6177(uint256) = offset__settleOrder_asm_1_1 + 164
			TMP_6178(bytes) = tokensAndAmounts_1 + 32
			INTERNAL_CALL, SettlementMock._settleOrder.asm_1.memcpy()(TMP_6177,TMP_6178,tokensAndAmountsLength__settleOrder_asm_1_1)
		Expression: mstore(uint256,uint256)(offset__settleOrder_asm_1 + 0xa4 + tokensAndAmountsLength__settleOrder_asm_1,tokensAndAmountsLength__settleOrder_asm_1)
		IRs:
			TMP_6180(uint256) = 164 + tokensAndAmountsLength__settleOrder_asm_1_1
			TMP_6181(uint256) = offset__settleOrder_asm_1_1 + TMP_6180
			TMP_6182(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6181,tokensAndAmountsLength__settleOrder_asm_1_1)
		Expression: ! call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),limitOrderProtocol,0,ptr__settleOrder_asm_1,4 + suffixLength + data,ptr__settleOrder_asm_1,0)
		IRs:
			TMP_6183(uint256) = SOLIDITY_CALL gas()()
			TMP_6184(uint256) = 4 + suffixLength_1
			TMP_6185(uint256) = TMP_6184 + data_1
			TMP_6186(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_6183,limitOrderProtocol_1,0,ptr__settleOrder_asm_1_1,TMP_6185,ptr__settleOrder_asm_1_1,0)
			TMP_6187 = UnaryType.BANG TMP_6186 
			CONDITION TMP_6187
		Expression: returndatacopy(uint256,uint256,uint256)(ptr__settleOrder_asm_1,0,returndatasize()())
		IRs:
			TMP_6188(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_6189(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(ptr__settleOrder_asm_1_1,0,TMP_6188)
		Expression: revert(uint256,uint256)(ptr__settleOrder_asm_1,returndatasize()())
		IRs:
			TMP_6190(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_6191(None) = SOLIDITY_CALL revert(uint256,uint256)(ptr__settleOrder_asm_1_1,TMP_6190)
	Function FeeBankCharger.constructor(IERC20)
		Expression: feeBank = new FeeBank(this,token,msg.sender)
		IRs:
			TMP_6193(FeeBank) = new FeeBank(this,token_1,msg.sender) 
			feeBank_1(IFeeBank) := TMP_6193(FeeBank)
	Function FeeBankCharger.availableCredit(address)
		IRs:
			_creditAllowance_1(mapping(address => uint256)) := ϕ(['_creditAllowance_0', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9', '_creditAllowance_7'])
		Expression: _creditAllowance[account]
		IRs:
			REF_1290(uint256) -> _creditAllowance_1[account_1]
			RETURN REF_1290
	Function FeeBankCharger.increaseAvailableCredit(address,uint256)
		IRs:
			_creditAllowance_2(mapping(address => uint256)) := ϕ(['_creditAllowance_0', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9', '_creditAllowance_7'])
		Expression: allowance = _creditAllowance[account]
		IRs:
			REF_1291(uint256) -> _creditAllowance_3[account_1]
			allowance_1(uint256) := REF_1291(uint256)
		Expression: allowance += amount
		IRs:
			allowance_2(uint256) = allowance_1 + amount_1
		Expression: _creditAllowance[account] = allowance
		IRs:
			REF_1292(uint256) -> _creditAllowance_3[account_1]
			_creditAllowance_4(mapping(address => uint256)) := ϕ(['_creditAllowance_3'])
			REF_1292(uint256) (->_creditAllowance_4) := allowance_2(uint256)
		Expression: onlyFeeBank()
		IRs:
			MODIFIER_CALL, FeeBankCharger.onlyFeeBank()()
		Expression: allowance
		IRs:
			RETURN allowance_2
	Function FeeBankCharger.decreaseAvailableCredit(address,uint256)
		IRs:
			_creditAllowance_5(mapping(address => uint256)) := ϕ(['_creditAllowance_0', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9', '_creditAllowance_7'])
		Expression: allowance = _creditAllowance[account]
		IRs:
			REF_1293(uint256) -> _creditAllowance_6[account_1]
			allowance_1(uint256) := REF_1293(uint256)
		Expression: allowance -= amount
		IRs:
			allowance_2(uint256) = allowance_1 (c)- amount_1
		Expression: _creditAllowance[account] = allowance
		IRs:
			REF_1294(uint256) -> _creditAllowance_6[account_1]
			_creditAllowance_7(mapping(address => uint256)) := ϕ(['_creditAllowance_6'])
			REF_1294(uint256) (->_creditAllowance_7) := allowance_2(uint256)
		Expression: onlyFeeBank()
		IRs:
			MODIFIER_CALL, FeeBankCharger.onlyFeeBank()()
		Expression: allowance
		IRs:
			RETURN allowance_2
	Function FeeBankCharger._chargeFee(address,uint256)
		IRs:
			account_1(address) := ϕ(['TMP_6112', 'account_1'])
			fee_1(uint256) := ϕ(['amount_1', 'REF_1272'])
			_creditAllowance_8(mapping(address => uint256)) := ϕ(['_creditAllowance_0', '_creditAllowance_4', '_creditAllowance_1', '_creditAllowance_9', '_creditAllowance_7'])
		Expression: fee > 0
		IRs:
			TMP_6196(bool) = fee_1 > 0
			CONDITION TMP_6196
		Expression: currentAllowance = _creditAllowance[account]
		IRs:
			REF_1295(uint256) -> _creditAllowance_8[account_1]
			currentAllowance_1(uint256) := REF_1295(uint256)
		Expression: currentAllowance < fee
		IRs:
			TMP_6197(bool) = currentAllowance_1 < fee_1
			CONDITION TMP_6197
		Expression: revert NotEnoughCredit()()
		IRs:
			TMP_6198(None) = SOLIDITY_CALL revert NotEnoughCredit()()
		Expression: _creditAllowance[account] = currentAllowance - fee
		IRs:
			REF_1296(uint256) -> _creditAllowance_8[account_1]
			TMP_6199(uint256) = currentAllowance_1 - fee_1
			_creditAllowance_9(mapping(address => uint256)) := ϕ(['_creditAllowance_8'])
			REF_1296(uint256) (->_creditAllowance_9) := TMP_6199(uint256)
	Function IFeeBankCharger.feeBank()
	Function IFeeBankCharger.availableCredit(address)
	Function IFeeBankCharger.increaseAvailableCredit(address,uint256)
	Function IFeeBankCharger.decreaseAvailableCredit(address,uint256)
	Function ISettlement.settleOrders(bytes)
	Function IInteractionNotificationReceiver.fillOrderInteraction(address,uint256,uint256,bytes)
	Function SettlementMock.constructor(IOrderMixin,IERC20)
		Expression: Settlement(limitOrderProtocol,token)
		IRs:
			INTERNAL_CALL, Settlement.constructor(IOrderMixin,IERC20)(limitOrderProtocol_1,token_1)
	Function SettlementMock.decreaseAvailableCreditMock(address,uint256)
		Expression: _chargeFee(account,amount)
		IRs:
			INTERNAL_CALL, FeeBankCharger._chargeFee(address,uint256)(account_1,amount_1)
	Function SettlementMock._settleOrder.asm_1.memcpy()
		IRs:
			dst__settleOrder_asm_1_memcpy_2(uint256) := ϕ(['TMP_6177'])
			src__settleOrder_asm_1_memcpy_2(uint256) := ϕ(['TMP_6178'])
			len__settleOrder_asm_1_memcpy_2(uint256) := ϕ(['tokensAndAmountsLength__settleOrder_asm_1_1'])
		Expression: pop(uint256)(staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),0x4,src__settleOrder_asm_1_memcpy,len__settleOrder_asm_1_memcpy,.dst__settleOrder_asm_1_memcpy.dst__settleOrder_asm_1_memcpy.dst__settleOrder_asm_1_memcpydst__settleOrder_asm_1_memcpy,len__settleOrder_asm_1_memcpy))
	Modifier Settlement.onlyThis(address)
ENTRY_POINT
		IRs:
			account_1(address) := ϕ(['taker_1'])
IF account != address(this)
		Expression: account != address(this)
		IRs:
			TMP_6205 = CONVERT this to address
			TMP_6206(bool) = account_1 != TMP_6205
			CONDITION TMP_6206
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_6207(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
	Modifier Settlement.onlyLimitOrderProtocol()
ENTRY_POINT
		IRs:
			_limitOrderProtocol_9(IOrderMixin) := ϕ(['_limitOrderProtocol_5', '_limitOrderProtocol_0', '_limitOrderProtocol_7', '_limitOrderProtocol_1'])
IF msg.sender != address(_limitOrderProtocol)
		Expression: msg.sender != address(_limitOrderProtocol)
		IRs:
			TMP_6208 = CONVERT _limitOrderProtocol_9 to address
			TMP_6209(bool) = msg.sender != TMP_6208
			CONDITION TMP_6209
EXPRESSION revert AccessDenied()()
		Expression: revert AccessDenied()()
		IRs:
			TMP_6210(None) = SOLIDITY_CALL revert AccessDenied()()
END_IF
_
	Modifier FeeBankCharger.onlyFeeBank()
ENTRY_POINT
		IRs:
			feeBank_2(IFeeBank) := ϕ(['feeBank_0', 'feeBank_1'])
IF msg.sender != address(feeBank)
		Expression: msg.sender != address(feeBank)
		IRs:
			TMP_6211 = CONVERT feeBank_2 to address
			TMP_6212(bool) = msg.sender != TMP_6211
			CONDITION TMP_6212
EXPRESSION revert OnlyFeeBankAccess()()
		Expression: revert OnlyFeeBankAccess()()
		IRs:
			TMP_6213(None) = SOLIDITY_CALL revert OnlyFeeBankAccess()()
END_IF
_
Contract St1inchMock
	Function St1inch.constructor(IERC20,uint256,address)
		IRs:
			MAX_LOCK_PERIOD_1(uint256) := ϕ(['MAX_LOCK_PERIOD_0', 'MAX_LOCK_PERIOD_6'])
			_VOTING_POWER_DIVIDER_1(uint256) := ϕ(['_VOTING_POWER_DIVIDER_0', '_VOTING_POWER_DIVIDER_9', '_VOTING_POWER_DIVIDER_11', '_VOTING_POWER_DIVIDER_6'])
			_PODS_LIMIT_1(uint256) := ϕ(['_PODS_LIMIT_2', '_PODS_LIMIT_0'])
			_POD_CALL_GAS_LIMIT_1(uint256) := ϕ(['_POD_CALL_GAS_LIMIT_2', '_POD_CALL_GAS_LIMIT_0'])
		Expression: _votingPowerAt(1e18,block.timestamp + MAX_LOCK_PERIOD) * _VOTING_POWER_DIVIDER < 1e18
		IRs:
			TMP_6214(uint256) = block.timestamp (c)+ MAX_LOCK_PERIOD_4
			TMP_6215(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(1000000000000000000,TMP_6214)
			TMP_6216(uint256) = TMP_6215 (c)* _VOTING_POWER_DIVIDER_5
			TMP_6217(bool) = TMP_6216 < 1000000000000000000
			CONDITION TMP_6217
		Expression: revert ExpBaseTooBig()()
		IRs:
			TMP_6218(None) = SOLIDITY_CALL revert ExpBaseTooBig()()
		Expression: _votingPowerAt(1e18,block.timestamp + MAX_LOCK_PERIOD + 1) * _VOTING_POWER_DIVIDER > 1e18
		IRs:
			TMP_6219(uint256) = block.timestamp (c)+ MAX_LOCK_PERIOD_5
			TMP_6220(uint256) = TMP_6219 (c)+ 1
			TMP_6221(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(1000000000000000000,TMP_6220)
			TMP_6222(uint256) = TMP_6221 (c)* _VOTING_POWER_DIVIDER_6
			TMP_6223(bool) = TMP_6222 > 1000000000000000000
			CONDITION TMP_6223
		Expression: revert ExpBaseTooSmall()()
		IRs:
			TMP_6224(None) = SOLIDITY_CALL revert ExpBaseTooSmall()()
		Expression: setFeeReceiver(feeReceiver_)
		IRs:
			INTERNAL_CALL, St1inch.setFeeReceiver(address)(feeReceiver__1)
		Expression: oneInch = oneInch_
		IRs:
			oneInch_1(IERC20) := oneInch__1(IERC20)
		Expression: ERC20Pods(_PODS_LIMIT,_POD_CALL_GAS_LIMIT)
		IRs:
			INTERNAL_CALL, ERC20Pods.constructor(uint256,uint256)(_PODS_LIMIT_1,_POD_CALL_GAS_LIMIT_1)
		Expression: ERC20(Staking 1INCH v2,st1INCH)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(Staking 1INCH v2,st1INCH)
		Expression: VotingPowerCalculator(expBase_,block.timestamp)
		IRs:
			INTERNAL_CALL, VotingPowerCalculator.constructor(uint256,uint256)(expBase__1,block.timestamp)
	Function St1inch.setFeeReceiver(address)
		IRs:
			feeReceiver__1(address) := ϕ(['feeReceiver__1'])
		Expression: feeReceiver_ == address(0)
		IRs:
			TMP_6229 = CONVERT 0 to address
			TMP_6230(bool) = feeReceiver__1 == TMP_6229
			CONDITION TMP_6230
		Expression: revert ZeroAddress()()
		IRs:
			TMP_6231(None) = SOLIDITY_CALL revert ZeroAddress()()
		Expression: feeReceiver = feeReceiver_
		IRs:
			feeReceiver_1(address) := feeReceiver__1(address)
		Expression: FeeReceiverSet(feeReceiver_)
		IRs:
			Emit FeeReceiverSet(feeReceiver__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.setDefaultFarm(address)
		Expression: defaultFarm_ != address(0) && Pod(defaultFarm_).token() != this
		IRs:
			TMP_6234 = CONVERT 0 to address
			TMP_6235(bool) = defaultFarm__1 != TMP_6234
			TMP_6236 = CONVERT defaultFarm__1 to Pod
			TMP_6237(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_6236(Pod), function:token, arguments:[]  
			TMP_6238(bool) = TMP_6237 != this
			TMP_6239(bool) = TMP_6235 && TMP_6238
			CONDITION TMP_6239
		Expression: revert DefaultFarmTokenMismatch()()
		IRs:
			TMP_6240(None) = SOLIDITY_CALL revert DefaultFarmTokenMismatch()()
		Expression: defaultFarm = defaultFarm_
		IRs:
			defaultFarm_1(address) := defaultFarm__1(address)
		Expression: DefaultFarmSet(defaultFarm_)
		IRs:
			Emit DefaultFarmSet(defaultFarm__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.setMaxLossRatio(uint256)
		IRs:
			_ONE_E9_1(uint256) := ϕ(['_ONE_E9_7', '_ONE_E9_10', '_ONE_E9_2', '_ONE_E9_4', '_ONE_E9_0'])
		Expression: maxLossRatio_ > _ONE_E9
		IRs:
			TMP_6243(bool) = maxLossRatio__1 > _ONE_E9_2
			CONDITION TMP_6243
		Expression: revert MaxLossOverflow()()
		IRs:
			TMP_6244(None) = SOLIDITY_CALL revert MaxLossOverflow()()
		Expression: maxLossRatio = maxLossRatio_
		IRs:
			maxLossRatio_1(uint256) := maxLossRatio__1(uint256)
		Expression: MaxLossRatioSet(maxLossRatio_)
		IRs:
			Emit MaxLossRatioSet(maxLossRatio__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.setMinLockPeriodRatio(uint256)
		IRs:
			_ONE_E9_3(uint256) := ϕ(['_ONE_E9_7', '_ONE_E9_10', '_ONE_E9_2', '_ONE_E9_4', '_ONE_E9_0'])
		Expression: minLockPeriodRatio_ > _ONE_E9
		IRs:
			TMP_6247(bool) = minLockPeriodRatio__1 > _ONE_E9_4
			CONDITION TMP_6247
		Expression: revert MaxLossOverflow()()
		IRs:
			TMP_6248(None) = SOLIDITY_CALL revert MaxLossOverflow()()
		Expression: minLockPeriodRatio = minLockPeriodRatio_
		IRs:
			minLockPeriodRatio_1(uint256) := minLockPeriodRatio__1(uint256)
		Expression: MinLockPeriodRatioSet(minLockPeriodRatio_)
		IRs:
			Emit MinLockPeriodRatioSet(minLockPeriodRatio__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.setEmergencyExit(bool)
		Expression: emergencyExit = emergencyExit_
		IRs:
			emergencyExit_1(bool) := emergencyExit__1(bool)
		Expression: EmergencyExitSet(emergencyExit_)
		IRs:
			Emit EmergencyExitSet(emergencyExit__1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.votingPowerOf(address)
		Expression: _votingPowerAt(balanceOf(account),block.timestamp)
		IRs:
			TMP_6253(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			TMP_6254(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(TMP_6253,block.timestamp)
			RETURN TMP_6254
	Function St1inch.votingPowerOfAt(address,uint256)
		Expression: _votingPowerAt(balanceOf(account),timestamp)
		IRs:
			TMP_6255(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			TMP_6256(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(TMP_6255,timestamp_1)
			RETURN TMP_6256
	Function St1inch.votingPower(uint256)
		Expression: _votingPowerAt(balance,block.timestamp)
		IRs:
			TMP_6257(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(balance_1,block.timestamp)
			RETURN TMP_6257
	Function St1inch.votingPowerAt(uint256,uint256)
		Expression: _votingPowerAt(balance,timestamp)
		IRs:
			TMP_6258(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(balance_1,timestamp_1)
			RETURN TMP_6258
	Function St1inch.deposit(uint256,uint256)
		Expression: _deposit(msg.sender,amount,duration)
		IRs:
			INTERNAL_CALL, St1inch._deposit(address,uint256,uint256)(msg.sender,amount_1,duration_1)
	Function St1inch.depositWithPermit(uint256,uint256,bytes)
		IRs:
			oneInch_2(IERC20) := ϕ(['oneInch_14', 'oneInch_0', 'oneInch_16', 'oneInch_7', 'oneInch_1', 'oneInch_11'])
		Expression: oneInch.safePermit(permit)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['oneInch_2', 'permit_1'] 
		Expression: _deposit(msg.sender,amount,duration)
		IRs:
			INTERNAL_CALL, St1inch._deposit(address,uint256,uint256)(msg.sender,amount_1,duration_1)
	Function St1inch.depositFor(address,uint256)
		Expression: _deposit(account,amount,0)
		IRs:
			INTERNAL_CALL, St1inch._deposit(address,uint256,uint256)(account_1,amount_1,0)
	Function St1inch.depositForWithPermit(address,uint256,bytes)
		IRs:
			oneInch_3(IERC20) := ϕ(['oneInch_14', 'oneInch_0', 'oneInch_16', 'oneInch_7', 'oneInch_1', 'oneInch_11'])
		Expression: oneInch.safePermit(permit)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safePermit(IERC20,bytes), arguments:['oneInch_3', 'permit_1'] 
		Expression: _deposit(account,amount,0)
		IRs:
			INTERNAL_CALL, St1inch._deposit(address,uint256,uint256)(account_1,amount_1,0)
	Function St1inch._deposit(address,uint256,uint256)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1', 'msg.sender'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1', 'amount_1'])
			duration_1(uint256) := ϕ(['duration_1', 'duration_1'])
			MIN_LOCK_PERIOD_1(uint256) := ϕ(['MIN_LOCK_PERIOD_0'])
			MAX_LOCK_PERIOD_7(uint256) := ϕ(['MAX_LOCK_PERIOD_0', 'MAX_LOCK_PERIOD_6'])
			_VOTING_POWER_DIVIDER_7(uint256) := ϕ(['_VOTING_POWER_DIVIDER_0', '_VOTING_POWER_DIVIDER_9', '_VOTING_POWER_DIVIDER_11', '_VOTING_POWER_DIVIDER_6'])
			oneInch_4(IERC20) := ϕ(['oneInch_14', 'oneInch_0', 'oneInch_16', 'oneInch_7', 'oneInch_1', 'oneInch_11'])
			depositors_1(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5', 'depositors_3', 'depositors_4', 'depositors_6', 'depositors_2', 'depositors_0'])
			totalDeposits_1(uint256) := ϕ(['totalDeposits_8', 'totalDeposits_0', 'totalDeposits_4', 'totalDeposits_6'])
			emergencyExit_2(bool) := ϕ(['emergencyExit_0', 'emergencyExit_1'])
			defaultFarm_2(address) := ϕ(['defaultFarm_7', 'defaultFarm_6', 'defaultFarm_1', 'defaultFarm_0'])
		Expression: emergencyExit
		IRs:
			CONDITION emergencyExit_2
		Expression: revert DepositsDisabled()()
		IRs:
			TMP_6265(None) = SOLIDITY_CALL revert DepositsDisabled()()
		Expression: depositor = depositors[account]
		IRs:
			REF_1300(St1inch.Depositor) -> depositors_1[account_1]
			depositor_1(St1inch.Depositor) := REF_1300(St1inch.Depositor)
		Expression: lockedTill = Math.max(depositor.unlockTime,block.timestamp) + duration
		IRs:
			REF_1302(uint40) -> depositor_1.unlockTime
			TMP_6266(uint256) = LIBRARY_CALL, dest:Math, function:Math.max(uint256,uint256), arguments:['REF_1302', 'block.timestamp'] 
			TMP_6267(uint256) = TMP_6266 (c)+ duration_1
			lockedTill_1(uint256) := TMP_6267(uint256)
		Expression: lockLeft = lockedTill - block.timestamp
		IRs:
			TMP_6268(uint256) = lockedTill_1 (c)- block.timestamp
			lockLeft_1(uint256) := TMP_6268(uint256)
		Expression: lockLeft < MIN_LOCK_PERIOD
		IRs:
			TMP_6269(bool) = lockLeft_1 < MIN_LOCK_PERIOD_1
			CONDITION TMP_6269
		Expression: revert LockTimeLessMinLock()()
		IRs:
			TMP_6270(None) = SOLIDITY_CALL revert LockTimeLessMinLock()()
		Expression: lockLeft > MAX_LOCK_PERIOD
		IRs:
			TMP_6271(bool) = lockLeft_1 > MAX_LOCK_PERIOD_7
			CONDITION TMP_6271
		Expression: revert LockTimeMoreMaxLock()()
		IRs:
			TMP_6272(None) = SOLIDITY_CALL revert LockTimeMoreMaxLock()()
		Expression: balanceDiff = _balanceAt(depositor.amount + amount,lockedTill) / _VOTING_POWER_DIVIDER - balanceOf(account)
		IRs:
			REF_1303(uint176) -> depositor_1.amount
			TMP_6273(uint176) = REF_1303 (c)+ amount_1
			TMP_6274(uint256) = INTERNAL_CALL, VotingPowerCalculator._balanceAt(uint256,uint256)(TMP_6273,lockedTill_1)
			TMP_6275(uint256) = TMP_6274 (c)/ _VOTING_POWER_DIVIDER_8
			TMP_6276(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			TMP_6277(uint256) = TMP_6275 (c)- TMP_6276
			balanceDiff_1(uint256) := TMP_6277(uint256)
		Expression: depositor.unlockTime = uint40(lockedTill)
		IRs:
			REF_1304(uint40) -> depositor_4.unlockTime
			TMP_6278 = CONVERT lockedTill_1 to uint40
			depositor_5(St1inch.Depositor) := ϕ(['depositor_4'])
			REF_1304(uint40) (->depositor_5) := TMP_6278(uint40)
		Expression: depositor.amount += uint176(amount)
		IRs:
			REF_1305(uint176) -> depositor_5.amount
			TMP_6279 = CONVERT amount_1 to uint176
			depositor_6(St1inch.Depositor) := ϕ(['depositor_5'])
			REF_1305(-> depositor_6) = REF_1305 (c)+ TMP_6279
		Expression: depositors[account] = depositor
		IRs:
			REF_1306(St1inch.Depositor) -> depositors_1[account_1]
			depositors_2(mapping(address => St1inch.Depositor)) := ϕ(['depositors_1'])
			REF_1306(St1inch.Depositor) (->depositors_2) := depositor_6(St1inch.Depositor)
		Expression: totalDeposits += amount
		IRs:
			totalDeposits_4(uint256) = totalDeposits_3 (c)+ amount_1
		Expression: _mint(account,balanceDiff)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account_1,balanceDiff_1)
		Expression: amount > 0
		IRs:
			TMP_6281(bool) = amount_1 > 0
			CONDITION TMP_6281
		Expression: oneInch.safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_6282 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['oneInch_7', 'msg.sender', 'TMP_6282', 'amount_1'] 
		Expression: defaultFarm != address(0) && ! hasPod(account,defaultFarm)
		IRs:
			TMP_6284 = CONVERT 0 to address
			TMP_6285(bool) = defaultFarm_5 != TMP_6284
			TMP_6286(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,defaultFarm_5)
			TMP_6287 = UnaryType.BANG TMP_6286 
			TMP_6288(bool) = TMP_6285 && TMP_6287
			CONDITION TMP_6288
		Expression: _addPod(account,defaultFarm)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(account_1,defaultFarm_6)
		Expression: duration == 0
		IRs:
			TMP_6290(bool) = duration_1 == 0
			CONDITION TMP_6290
		Expression: depositor.lockTime = uint40(depositor.lockTime)
		IRs:
			REF_1308(uint40) -> depositor_1.lockTime
			REF_1309(uint40) -> depositor_1.lockTime
			TMP_6291 = CONVERT REF_1309 to uint40
			depositor_2(St1inch.Depositor) := ϕ(['depositor_1'])
			REF_1308(uint40) (->depositor_2) := TMP_6291(uint40)
		Expression: depositor.lockTime = uint40(block.timestamp)
		IRs:
			REF_1310(uint40) -> depositor_1.lockTime
			TMP_6292 = CONVERT block.timestamp to uint40
			depositor_3(St1inch.Depositor) := ϕ(['depositor_1'])
			REF_1310(uint40) (->depositor_3) := TMP_6292(uint40)
		IRs:
			depositor_4(St1inch.Depositor) := ϕ(['depositor_2', 'depositor_3'])
	Function St1inch.earlyWithdraw(uint256,uint256)
		Expression: earlyWithdrawTo(msg.sender,minReturn,maxLoss)
		IRs:
			INTERNAL_CALL, St1inch.earlyWithdrawTo(address,uint256,uint256)(msg.sender,minReturn_1,maxLoss_1)
	Function St1inch.earlyWithdrawTo(address,uint256,uint256)
		IRs:
			to_1(address) := ϕ(['msg.sender'])
			minReturn_1(uint256) := ϕ(['minReturn_1'])
			maxLoss_1(uint256) := ϕ(['maxLoss_1'])
			_ONE_E9_5(uint256) := ϕ(['_ONE_E9_7', '_ONE_E9_10', '_ONE_E9_2', '_ONE_E9_4', '_ONE_E9_0'])
			oneInch_8(IERC20) := ϕ(['oneInch_14', 'oneInch_0', 'oneInch_16', 'oneInch_7', 'oneInch_1', 'oneInch_11'])
			depositors_3(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5', 'depositors_3', 'depositors_4', 'depositors_6', 'depositors_2', 'depositors_0'])
			emergencyExit_3(bool) := ϕ(['emergencyExit_0', 'emergencyExit_1'])
			maxLossRatio_2(uint256) := ϕ(['maxLossRatio_0', 'maxLossRatio_1', 'maxLossRatio_7', 'maxLossRatio_4'])
			minLockPeriodRatio_2(uint256) := ϕ(['minLockPeriodRatio_1', 'minLockPeriodRatio_0'])
			feeReceiver_2(address) := ϕ(['feeReceiver_5', 'feeReceiver_1', 'feeReceiver_0'])
		Expression: depositor = depositors[msg.sender]
		IRs:
			REF_1311(St1inch.Depositor) -> depositors_3[msg.sender]
			depositor_1(St1inch.Depositor) := REF_1311(St1inch.Depositor)
		Expression: emergencyExit || block.timestamp >= depositor.unlockTime
		IRs:
			REF_1312(uint40) -> depositor_1.unlockTime
			TMP_6294(bool) = block.timestamp >= REF_1312
			TMP_6295(bool) = emergencyExit_3 || TMP_6294
			CONDITION TMP_6295
		Expression: revert StakeUnlocked()()
		IRs:
			TMP_6296(None) = SOLIDITY_CALL revert StakeUnlocked()()
		Expression: allowedExitTime = depositor.lockTime + (depositor.unlockTime - depositor.lockTime) * minLockPeriodRatio / _ONE_E9
		IRs:
			REF_1313(uint40) -> depositor_1.lockTime
			REF_1314(uint40) -> depositor_1.unlockTime
			REF_1315(uint40) -> depositor_1.lockTime
			TMP_6297(uint40) = REF_1314 (c)- REF_1315
			TMP_6298(uint40) = TMP_6297 (c)* minLockPeriodRatio_2
			TMP_6299(uint40) = TMP_6298 (c)/ _ONE_E9_5
			TMP_6300(uint40) = REF_1313 (c)+ TMP_6299
			allowedExitTime_1(uint256) := TMP_6300(uint40)
		Expression: block.timestamp < allowedExitTime
		IRs:
			TMP_6301(bool) = block.timestamp < allowedExitTime_1
			CONDITION TMP_6301
		Expression: revert MinLockPeriodRatioNotReached()()
		IRs:
			TMP_6302(None) = SOLIDITY_CALL revert MinLockPeriodRatioNotReached()()
		Expression: amount = depositor.amount
		IRs:
			REF_1316(uint176) -> depositor_1.amount
			amount_1(uint256) := REF_1316(uint176)
		Expression: amount > 0
		IRs:
			TMP_6303(bool) = amount_1 > 0
			CONDITION TMP_6303
		Expression: balance = balanceOf(msg.sender)
		IRs:
			TMP_6304(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(msg.sender)
			balance_1(uint256) := TMP_6304(uint256)
		Expression: (loss,ret) = _earlyWithdrawLoss(amount,balance)
		IRs:
			TUPLE_78(uint256,uint256) = INTERNAL_CALL, St1inch._earlyWithdrawLoss(uint256,uint256)(amount_1,balance_1)
			loss_1(uint256)= UNPACK TUPLE_78 index: 0 
			ret_1(uint256)= UNPACK TUPLE_78 index: 1 
		Expression: ret < minReturn
		IRs:
			TMP_6305(bool) = ret_1 < minReturn_1
			CONDITION TMP_6305
		Expression: revert MinReturnIsNotMet()()
		IRs:
			TMP_6306(None) = SOLIDITY_CALL revert MinReturnIsNotMet()()
		Expression: loss > maxLoss
		IRs:
			TMP_6307(bool) = loss_1 > maxLoss_1
			CONDITION TMP_6307
		Expression: revert MaxLossIsNotMet()()
		IRs:
			TMP_6308(None) = SOLIDITY_CALL revert MaxLossIsNotMet()()
		Expression: loss > amount * maxLossRatio / _ONE_E9
		IRs:
			TMP_6309(uint256) = amount_1 (c)* maxLossRatio_4
			TMP_6310(uint256) = TMP_6309 (c)/ _ONE_E9_7
			TMP_6311(bool) = loss_1 > TMP_6310
			CONDITION TMP_6311
		Expression: revert LossIsTooBig()()
		IRs:
			TMP_6312(None) = SOLIDITY_CALL revert LossIsTooBig()()
		Expression: _withdraw(depositor,balance)
		IRs:
			INTERNAL_CALL, St1inch._withdraw(St1inch.Depositor,uint256)(depositor_1,balance_1)
		Expression: oneInch.safeTransfer(to,ret)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['oneInch_11', 'to_1', 'ret_1'] 
		Expression: oneInch.safeTransfer(feeReceiver,loss)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['oneInch_11', 'feeReceiver_5', 'loss_1'] 
	Function St1inch.earlyWithdrawLoss(address)
		IRs:
			_ONE_E9_8(uint256) := ϕ(['_ONE_E9_7', '_ONE_E9_10', '_ONE_E9_2', '_ONE_E9_4', '_ONE_E9_0'])
			depositors_4(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5', 'depositors_3', 'depositors_4', 'depositors_6', 'depositors_2', 'depositors_0'])
			maxLossRatio_5(uint256) := ϕ(['maxLossRatio_0', 'maxLossRatio_1', 'maxLossRatio_7', 'maxLossRatio_4'])
		Expression: amount = depositors[account].amount
		IRs:
			REF_1319(St1inch.Depositor) -> depositors_4[account_1]
			REF_1320(uint176) -> REF_1319.amount
			amount_1(uint256) := REF_1320(uint176)
		Expression: (loss,ret) = _earlyWithdrawLoss(amount,balanceOf(account))
		IRs:
			TMP_6316(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			TUPLE_79(uint256,uint256) = INTERNAL_CALL, St1inch._earlyWithdrawLoss(uint256,uint256)(amount_1,TMP_6316)
			loss_1(uint256)= UNPACK TUPLE_79 index: 0 
			ret_1(uint256)= UNPACK TUPLE_79 index: 1 
		Expression: canWithdraw = loss <= amount * maxLossRatio / _ONE_E9
		IRs:
			TMP_6317(uint256) = amount_1 (c)* maxLossRatio_7
			TMP_6318(uint256) = TMP_6317 (c)/ _ONE_E9_10
			TMP_6319(bool) = loss_1 <= TMP_6318
			canWithdraw_1(bool) := TMP_6319(bool)
		Expression: (loss,ret,canWithdraw)
		IRs:
			RETURN loss_1,ret_1,canWithdraw_1
	Function St1inch._earlyWithdrawLoss(uint256,uint256)
		IRs:
			depAmount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			stBalance_1(uint256) := ϕ(['balance_1', 'TMP_6316'])
			_VOTING_POWER_DIVIDER_10(uint256) := ϕ(['_VOTING_POWER_DIVIDER_0', '_VOTING_POWER_DIVIDER_9', '_VOTING_POWER_DIVIDER_11', '_VOTING_POWER_DIVIDER_6'])
		Expression: ret = (depAmount - _votingPowerAt(stBalance,block.timestamp)) * _VOTING_POWER_DIVIDER / (_VOTING_POWER_DIVIDER - 1)
		IRs:
			TMP_6320(uint256) = INTERNAL_CALL, VotingPowerCalculator._votingPowerAt(uint256,uint256)(stBalance_1,block.timestamp)
			TMP_6321(uint256) = depAmount_1 (c)- TMP_6320
			TMP_6322(uint256) = TMP_6321 (c)* _VOTING_POWER_DIVIDER_11
			TMP_6323(uint256) = _VOTING_POWER_DIVIDER_11 (c)- 1
			TMP_6324(uint256) = TMP_6322 (c)/ TMP_6323
			ret_1(uint256) := TMP_6324(uint256)
		Expression: loss = depAmount - ret
		IRs:
			TMP_6325(uint256) = depAmount_1 (c)- ret_1
			loss_1(uint256) := TMP_6325(uint256)
		Expression: (loss,ret)
		IRs:
			RETURN loss_1,ret_1
	Function St1inch.withdraw()
		Expression: withdrawTo(msg.sender)
		IRs:
			INTERNAL_CALL, St1inch.withdrawTo(address)(msg.sender)
	Function St1inch.withdrawTo(address)
		IRs:
			to_1(address) := ϕ(['msg.sender'])
			oneInch_12(IERC20) := ϕ(['oneInch_14', 'oneInch_0', 'oneInch_16', 'oneInch_7', 'oneInch_1', 'oneInch_11'])
			depositors_5(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5', 'depositors_3', 'depositors_4', 'depositors_6', 'depositors_2', 'depositors_0'])
			emergencyExit_4(bool) := ϕ(['emergencyExit_0', 'emergencyExit_1'])
		Expression: depositor = depositors[msg.sender]
		IRs:
			REF_1321(St1inch.Depositor) -> depositors_5[msg.sender]
			depositor_1(St1inch.Depositor) := REF_1321(St1inch.Depositor)
		Expression: ! emergencyExit && block.timestamp < depositor.unlockTime
		IRs:
			TMP_6327 = UnaryType.BANG emergencyExit_4 
			REF_1322(uint40) -> depositor_1.unlockTime
			TMP_6328(bool) = block.timestamp < REF_1322
			TMP_6329(bool) = TMP_6327 && TMP_6328
			CONDITION TMP_6329
		Expression: revert UnlockTimeHasNotCome()()
		IRs:
			TMP_6330(None) = SOLIDITY_CALL revert UnlockTimeHasNotCome()()
		Expression: amount = depositor.amount
		IRs:
			REF_1323(uint176) -> depositor_1.amount
			amount_1(uint256) := REF_1323(uint176)
		Expression: amount > 0
		IRs:
			TMP_6331(bool) = amount_1 > 0
			CONDITION TMP_6331
		Expression: _withdraw(depositor,balanceOf(msg.sender))
		IRs:
			TMP_6332(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(msg.sender)
			INTERNAL_CALL, St1inch._withdraw(St1inch.Depositor,uint256)(depositor_1,TMP_6332)
		Expression: oneInch.safeTransfer(to,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['oneInch_14', 'to_1', 'amount_1'] 
	Function St1inch._withdraw(St1inch.Depositor,uint256)
		IRs:
			depositor_1(St1inch.Depositor) := ϕ(['depositor_1', 'depositor_1'])
			balance_1(uint256) := ϕ(['balance_1', 'TMP_6332'])
			totalDeposits_5(uint256) := ϕ(['totalDeposits_8', 'totalDeposits_0', 'totalDeposits_4', 'totalDeposits_6'])
		Expression: totalDeposits -= depositor.amount
		IRs:
			REF_1325(uint176) -> depositor_1.amount
			totalDeposits_6(uint256) = totalDeposits_5 (c)- REF_1325
		Expression: depositor.amount = 0
		IRs:
			REF_1326(uint176) -> depositor_1.amount
			depositor_2(St1inch.Depositor) := ϕ(['depositor_1'])
			REF_1326(uint176) (->depositor_2) := 0(uint256)
		Expression: depositor.unlockTime = uint40(block.timestamp)
		IRs:
			REF_1327(uint40) -> depositor_2.unlockTime
			TMP_6335 = CONVERT block.timestamp to uint40
			depositor_3(St1inch.Depositor) := ϕ(['depositor_2'])
			REF_1327(uint40) (->depositor_3) := TMP_6335(uint40)
		Expression: depositors[msg.sender] = depositor
		IRs:
			REF_1328(St1inch.Depositor) -> depositors_5[msg.sender]
			depositors_6(mapping(address => St1inch.Depositor)) := ϕ(['depositors_5'])
			REF_1328(St1inch.Depositor) (->depositors_6) := depositor_3(St1inch.Depositor)
		Expression: _burn(msg.sender,balance)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(msg.sender,balance_1)
	Function St1inch.rescueFunds(IERC20,uint256)
		IRs:
			oneInch_15(IERC20) := ϕ(['oneInch_14', 'oneInch_0', 'oneInch_16', 'oneInch_7', 'oneInch_1', 'oneInch_11'])
			totalDeposits_7(uint256) := ϕ(['totalDeposits_8', 'totalDeposits_0', 'totalDeposits_4', 'totalDeposits_6'])
		Expression: address(token) == address(0)
		IRs:
			TMP_6337 = CONVERT token_1 to address
			TMP_6338 = CONVERT 0 to address
			TMP_6339(bool) = TMP_6337 == TMP_6338
			CONDITION TMP_6339
		Expression: Address.sendValue(address(msg.sender),amount)
		IRs:
			TMP_6340 = CONVERT msg.sender to address
			LIBRARY_CALL, dest:Address, function:Address.sendValue(address,uint256), arguments:['TMP_6340', 'amount_1'] 
		Expression: token == oneInch
		IRs:
			TMP_6342(bool) = token_1 == oneInch_16
			CONDITION TMP_6342
		Expression: amount > oneInch.balanceOf(address(this)) - totalDeposits
		IRs:
			TMP_6343 = CONVERT this to address
			TMP_6344(uint256) = HIGH_LEVEL_CALL, dest:oneInch_16(IERC20), function:balanceOf, arguments:['TMP_6343']  
			oneInch_17(IERC20) := ϕ(['oneInch_14', 'oneInch_16', 'oneInch_7', 'oneInch_1', 'oneInch_11'])
			totalDeposits_9(uint256) := ϕ(['totalDeposits_8', 'totalDeposits_4', 'totalDeposits_6'])
			TMP_6345(uint256) = TMP_6344 (c)- totalDeposits_9
			TMP_6346(bool) = amount_1 > TMP_6345
			CONDITION TMP_6346
		Expression: revert RescueAmountIsTooLarge()()
		IRs:
			TMP_6347(None) = SOLIDITY_CALL revert RescueAmountIsTooLarge()()
		Expression: token.safeTransfer(msg.sender,amount)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['token_1', 'msg.sender', 'amount_1'] 
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function St1inch.approve(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_6350(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function St1inch.transfer(address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_6351(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function St1inch.transferFrom(address,address,uint256)
		Expression: revert TransferDisabled()()
		IRs:
			TMP_6352(None) = SOLIDITY_CALL revert TransferDisabled()()
	Function St1inch.increaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_6353(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function St1inch.decreaseAllowance(address,uint256)
		Expression: revert ApproveDisabled()()
		IRs:
			TMP_6354(None) = SOLIDITY_CALL revert ApproveDisabled()()
	Function IVotable.votingPowerOf(address)
	Function IERC20.totalSupply()
	Function IERC20.balanceOf(address)
	Function IERC20.transfer(address,uint256)
	Function IERC20.allowance(address,address)
	Function IERC20.approve(address,uint256)
	Function IERC20.transferFrom(address,address,uint256)
	Function VotingPowerCalculator.constructor(uint256,uint256)
		IRs:
			_ONE_E18_1(uint256) := ϕ(['_ONE_E18_0'])
		Expression: origin_ > block.timestamp
		IRs:
			TMP_6355(bool) = origin__1 > block.timestamp
			CONDITION TMP_6355
		Expression: revert OriginInTheFuture()()
		IRs:
			TMP_6356(None) = SOLIDITY_CALL revert OriginInTheFuture()()
		Expression: origin = origin_
		IRs:
			origin_1(uint256) := origin__1(uint256)
		Expression: expBase = expBase_
		IRs:
			expBase_1(uint256) := expBase__1(uint256)
		Expression: _expTable0 = expBase_
		IRs:
			_expTable0_1(uint256) := expBase__1(uint256)
		Expression: _expTable1 = (_expTable0 * _expTable0) / _ONE_E18
		IRs:
			TMP_6357(uint256) = _expTable0_1 (c)* _expTable0_1
			TMP_6358(uint256) = TMP_6357 (c)/ _ONE_E18_1
			_expTable1_1(uint256) := TMP_6358(uint256)
		Expression: _expTable2 = (_expTable1 * _expTable1) / _ONE_E18
		IRs:
			TMP_6359(uint256) = _expTable1_1 (c)* _expTable1_1
			TMP_6360(uint256) = TMP_6359 (c)/ _ONE_E18_1
			_expTable2_1(uint256) := TMP_6360(uint256)
		Expression: _expTable3 = (_expTable2 * _expTable2) / _ONE_E18
		IRs:
			TMP_6361(uint256) = _expTable2_1 (c)* _expTable2_1
			TMP_6362(uint256) = TMP_6361 (c)/ _ONE_E18_1
			_expTable3_1(uint256) := TMP_6362(uint256)
		Expression: _expTable4 = (_expTable3 * _expTable3) / _ONE_E18
		IRs:
			TMP_6363(uint256) = _expTable3_1 (c)* _expTable3_1
			TMP_6364(uint256) = TMP_6363 (c)/ _ONE_E18_1
			_expTable4_1(uint256) := TMP_6364(uint256)
		Expression: _expTable5 = (_expTable4 * _expTable4) / _ONE_E18
		IRs:
			TMP_6365(uint256) = _expTable4_1 (c)* _expTable4_1
			TMP_6366(uint256) = TMP_6365 (c)/ _ONE_E18_1
			_expTable5_1(uint256) := TMP_6366(uint256)
		Expression: _expTable6 = (_expTable5 * _expTable5) / _ONE_E18
		IRs:
			TMP_6367(uint256) = _expTable5_1 (c)* _expTable5_1
			TMP_6368(uint256) = TMP_6367 (c)/ _ONE_E18_1
			_expTable6_1(uint256) := TMP_6368(uint256)
		Expression: _expTable7 = (_expTable6 * _expTable6) / _ONE_E18
		IRs:
			TMP_6369(uint256) = _expTable6_1 (c)* _expTable6_1
			TMP_6370(uint256) = TMP_6369 (c)/ _ONE_E18_1
			_expTable7_1(uint256) := TMP_6370(uint256)
		Expression: _expTable8 = (_expTable7 * _expTable7) / _ONE_E18
		IRs:
			TMP_6371(uint256) = _expTable7_1 (c)* _expTable7_1
			TMP_6372(uint256) = TMP_6371 (c)/ _ONE_E18_1
			_expTable8_1(uint256) := TMP_6372(uint256)
		Expression: _expTable9 = (_expTable8 * _expTable8) / _ONE_E18
		IRs:
			TMP_6373(uint256) = _expTable8_1 (c)* _expTable8_1
			TMP_6374(uint256) = TMP_6373 (c)/ _ONE_E18_1
			_expTable9_1(uint256) := TMP_6374(uint256)
		Expression: _expTable10 = (_expTable9 * _expTable9) / _ONE_E18
		IRs:
			TMP_6375(uint256) = _expTable9_1 (c)* _expTable9_1
			TMP_6376(uint256) = TMP_6375 (c)/ _ONE_E18_1
			_expTable10_1(uint256) := TMP_6376(uint256)
		Expression: _expTable11 = (_expTable10 * _expTable10) / _ONE_E18
		IRs:
			TMP_6377(uint256) = _expTable10_1 (c)* _expTable10_1
			TMP_6378(uint256) = TMP_6377 (c)/ _ONE_E18_1
			_expTable11_1(uint256) := TMP_6378(uint256)
		Expression: _expTable12 = (_expTable11 * _expTable11) / _ONE_E18
		IRs:
			TMP_6379(uint256) = _expTable11_1 (c)* _expTable11_1
			TMP_6380(uint256) = TMP_6379 (c)/ _ONE_E18_1
			_expTable12_1(uint256) := TMP_6380(uint256)
		Expression: _expTable13 = (_expTable12 * _expTable12) / _ONE_E18
		IRs:
			TMP_6381(uint256) = _expTable12_1 (c)* _expTable12_1
			TMP_6382(uint256) = TMP_6381 (c)/ _ONE_E18_1
			_expTable13_1(uint256) := TMP_6382(uint256)
		Expression: _expTable14 = (_expTable13 * _expTable13) / _ONE_E18
		IRs:
			TMP_6383(uint256) = _expTable13_1 (c)* _expTable13_1
			TMP_6384(uint256) = TMP_6383 (c)/ _ONE_E18_1
			_expTable14_1(uint256) := TMP_6384(uint256)
		Expression: _expTable15 = (_expTable14 * _expTable14) / _ONE_E18
		IRs:
			TMP_6385(uint256) = _expTable14_1 (c)* _expTable14_1
			TMP_6386(uint256) = TMP_6385 (c)/ _ONE_E18_1
			_expTable15_1(uint256) := TMP_6386(uint256)
		Expression: _expTable16 = (_expTable15 * _expTable15) / _ONE_E18
		IRs:
			TMP_6387(uint256) = _expTable15_1 (c)* _expTable15_1
			TMP_6388(uint256) = TMP_6387 (c)/ _ONE_E18_1
			_expTable16_1(uint256) := TMP_6388(uint256)
		Expression: _expTable17 = (_expTable16 * _expTable16) / _ONE_E18
		IRs:
			TMP_6389(uint256) = _expTable16_1 (c)* _expTable16_1
			TMP_6390(uint256) = TMP_6389 (c)/ _ONE_E18_1
			_expTable17_1(uint256) := TMP_6390(uint256)
		Expression: _expTable18 = (_expTable17 * _expTable17) / _ONE_E18
		IRs:
			TMP_6391(uint256) = _expTable17_1 (c)* _expTable17_1
			TMP_6392(uint256) = TMP_6391 (c)/ _ONE_E18_1
			_expTable18_1(uint256) := TMP_6392(uint256)
		Expression: _expTable19 = (_expTable18 * _expTable18) / _ONE_E18
		IRs:
			TMP_6393(uint256) = _expTable18_1 (c)* _expTable18_1
			TMP_6394(uint256) = TMP_6393 (c)/ _ONE_E18_1
			_expTable19_1(uint256) := TMP_6394(uint256)
		Expression: _expTable20 = (_expTable19 * _expTable19) / _ONE_E18
		IRs:
			TMP_6395(uint256) = _expTable19_1 (c)* _expTable19_1
			TMP_6396(uint256) = TMP_6395 (c)/ _ONE_E18_1
			_expTable20_1(uint256) := TMP_6396(uint256)
		Expression: _expTable21 = (_expTable20 * _expTable20) / _ONE_E18
		IRs:
			TMP_6397(uint256) = _expTable20_1 (c)* _expTable20_1
			TMP_6398(uint256) = TMP_6397 (c)/ _ONE_E18_1
			_expTable21_1(uint256) := TMP_6398(uint256)
		Expression: _expTable22 = (_expTable21 * _expTable21) / _ONE_E18
		IRs:
			TMP_6399(uint256) = _expTable21_1 (c)* _expTable21_1
			TMP_6400(uint256) = TMP_6399 (c)/ _ONE_E18_1
			_expTable22_1(uint256) := TMP_6400(uint256)
		Expression: _expTable23 = (_expTable22 * _expTable22) / _ONE_E18
		IRs:
			TMP_6401(uint256) = _expTable22_1 (c)* _expTable22_1
			TMP_6402(uint256) = TMP_6401 (c)/ _ONE_E18_1
			_expTable23_1(uint256) := TMP_6402(uint256)
		Expression: _expTable24 = (_expTable23 * _expTable23) / _ONE_E18
		IRs:
			TMP_6403(uint256) = _expTable23_1 (c)* _expTable23_1
			TMP_6404(uint256) = TMP_6403 (c)/ _ONE_E18_1
			_expTable24_1(uint256) := TMP_6404(uint256)
		Expression: _expTable25 = (_expTable24 * _expTable24) / _ONE_E18
		IRs:
			TMP_6405(uint256) = _expTable24_1 (c)* _expTable24_1
			TMP_6406(uint256) = TMP_6405 (c)/ _ONE_E18_1
			_expTable25_1(uint256) := TMP_6406(uint256)
		Expression: _expTable26 = (_expTable25 * _expTable25) / _ONE_E18
		IRs:
			TMP_6407(uint256) = _expTable25_1 (c)* _expTable25_1
			TMP_6408(uint256) = TMP_6407 (c)/ _ONE_E18_1
			_expTable26_1(uint256) := TMP_6408(uint256)
		Expression: _expTable27 = (_expTable26 * _expTable26) / _ONE_E18
		IRs:
			TMP_6409(uint256) = _expTable26_1 (c)* _expTable26_1
			TMP_6410(uint256) = TMP_6409 (c)/ _ONE_E18_1
			_expTable27_1(uint256) := TMP_6410(uint256)
		Expression: _expTable28 = (_expTable27 * _expTable27) / _ONE_E18
		IRs:
			TMP_6411(uint256) = _expTable27_1 (c)* _expTable27_1
			TMP_6412(uint256) = TMP_6411 (c)/ _ONE_E18_1
			_expTable28_1(uint256) := TMP_6412(uint256)
		Expression: _expTable29 = (_expTable28 * _expTable28) / _ONE_E18
		IRs:
			TMP_6413(uint256) = _expTable28_1 (c)* _expTable28_1
			TMP_6414(uint256) = TMP_6413 (c)/ _ONE_E18_1
			_expTable29_1(uint256) := TMP_6414(uint256)
	Function VotingPowerCalculator._votingPowerAt(uint256,uint256)
		IRs:
			balance_1(uint256) := ϕ(['TMP_6253', 'TMP_6255', 'stBalance_1', 'balance_1', 'balance_1'])
			timestamp_1(uint256) := ϕ(['timestamp_1', 'block.timestamp', 'TMP_6214', 'timestamp_1', 'TMP_6220'])
			_ONE_E18_2(uint256) := ϕ(['_ONE_E18_0'])
			origin_2(uint256) := ϕ(['origin_0', 'origin_1'])
			_expTable0_2(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_2(uint256) := ϕ(['_expTable1_0', '_expTable1_1'])
			_expTable2_2(uint256) := ϕ(['_expTable2_1', '_expTable2_0'])
			_expTable3_2(uint256) := ϕ(['_expTable3_1', '_expTable3_0'])
			_expTable4_2(uint256) := ϕ(['_expTable4_1', '_expTable4_0'])
			_expTable5_2(uint256) := ϕ(['_expTable5_1', '_expTable5_0'])
			_expTable6_2(uint256) := ϕ(['_expTable6_1', '_expTable6_0'])
			_expTable7_2(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_2(uint256) := ϕ(['_expTable8_0', '_expTable8_1'])
			_expTable9_2(uint256) := ϕ(['_expTable9_0', '_expTable9_1'])
			_expTable10_2(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_2(uint256) := ϕ(['_expTable11_1', '_expTable11_0'])
			_expTable12_2(uint256) := ϕ(['_expTable12_1', '_expTable12_0'])
			_expTable13_2(uint256) := ϕ(['_expTable13_1', '_expTable13_0'])
			_expTable14_2(uint256) := ϕ(['_expTable14_1', '_expTable14_0'])
			_expTable15_2(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_2(uint256) := ϕ(['_expTable16_0', '_expTable16_1'])
			_expTable17_2(uint256) := ϕ(['_expTable17_0', '_expTable17_1'])
			_expTable18_2(uint256) := ϕ(['_expTable18_0', '_expTable18_1'])
			_expTable19_2(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_2(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_2(uint256) := ϕ(['_expTable21_0', '_expTable21_1'])
			_expTable22_2(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_2(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_2(uint256) := ϕ(['_expTable24_0', '_expTable24_1'])
			_expTable25_2(uint256) := ϕ(['_expTable25_0', '_expTable25_1'])
			_expTable26_2(uint256) := ϕ(['_expTable26_0', '_expTable26_1'])
			_expTable27_2(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_2(uint256) := ϕ(['_expTable28_0', '_expTable28_1'])
			_expTable29_2(uint256) := ϕ(['_expTable29_0', '_expTable29_1'])
		Expression: t = timestamp - origin
		IRs:
			TMP_6415(uint256) = timestamp_4 - origin_2
			t_1(uint256) := TMP_6415(uint256)
		Expression: votingPower = balance
		IRs:
			votingPower_1(uint256) := balance_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_6416(uint256) = t_1 & 1
			TMP_6417(bool) = TMP_6416 != 0
			CONDITION TMP_6417
		Expression: votingPower = (votingPower * _expTable0) / _ONE_E18
		IRs:
			TMP_6418(uint256) = votingPower_1 * _expTable0_2
			TMP_6419(uint256) = TMP_6418 / _ONE_E18_2
			votingPower_2(uint256) := TMP_6419(uint256)
		IRs:
			votingPower_3(uint256) := ϕ(['votingPower_1', 'votingPower_2'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_6420(uint256) = t_1 & 2
			TMP_6421(bool) = TMP_6420 != 0
			CONDITION TMP_6421
		Expression: votingPower = (votingPower * _expTable1) / _ONE_E18
		IRs:
			TMP_6422(uint256) = votingPower_3 * _expTable1_2
			TMP_6423(uint256) = TMP_6422 / _ONE_E18_2
			votingPower_4(uint256) := TMP_6423(uint256)
		IRs:
			votingPower_5(uint256) := ϕ(['votingPower_1', 'votingPower_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_6424(uint256) = t_1 & 4
			TMP_6425(bool) = TMP_6424 != 0
			CONDITION TMP_6425
		Expression: votingPower = (votingPower * _expTable2) / _ONE_E18
		IRs:
			TMP_6426(uint256) = votingPower_5 * _expTable2_2
			TMP_6427(uint256) = TMP_6426 / _ONE_E18_2
			votingPower_6(uint256) := TMP_6427(uint256)
		IRs:
			votingPower_7(uint256) := ϕ(['votingPower_1', 'votingPower_6'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_6428(uint256) = t_1 & 8
			TMP_6429(bool) = TMP_6428 != 0
			CONDITION TMP_6429
		Expression: votingPower = (votingPower * _expTable3) / _ONE_E18
		IRs:
			TMP_6430(uint256) = votingPower_7 * _expTable3_2
			TMP_6431(uint256) = TMP_6430 / _ONE_E18_2
			votingPower_8(uint256) := TMP_6431(uint256)
		IRs:
			votingPower_9(uint256) := ϕ(['votingPower_8', 'votingPower_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_6432(uint256) = t_1 & 16
			TMP_6433(bool) = TMP_6432 != 0
			CONDITION TMP_6433
		Expression: votingPower = (votingPower * _expTable4) / _ONE_E18
		IRs:
			TMP_6434(uint256) = votingPower_9 * _expTable4_2
			TMP_6435(uint256) = TMP_6434 / _ONE_E18_2
			votingPower_10(uint256) := TMP_6435(uint256)
		IRs:
			votingPower_11(uint256) := ϕ(['votingPower_10', 'votingPower_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_6436(uint256) = t_1 & 32
			TMP_6437(bool) = TMP_6436 != 0
			CONDITION TMP_6437
		Expression: votingPower = (votingPower * _expTable5) / _ONE_E18
		IRs:
			TMP_6438(uint256) = votingPower_11 * _expTable5_2
			TMP_6439(uint256) = TMP_6438 / _ONE_E18_2
			votingPower_12(uint256) := TMP_6439(uint256)
		IRs:
			votingPower_13(uint256) := ϕ(['votingPower_12', 'votingPower_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_6440(uint256) = t_1 & 64
			TMP_6441(bool) = TMP_6440 != 0
			CONDITION TMP_6441
		Expression: votingPower = (votingPower * _expTable6) / _ONE_E18
		IRs:
			TMP_6442(uint256) = votingPower_13 * _expTable6_2
			TMP_6443(uint256) = TMP_6442 / _ONE_E18_2
			votingPower_14(uint256) := TMP_6443(uint256)
		IRs:
			votingPower_15(uint256) := ϕ(['votingPower_14', 'votingPower_1'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_6444(uint256) = t_1 & 128
			TMP_6445(bool) = TMP_6444 != 0
			CONDITION TMP_6445
		Expression: votingPower = (votingPower * _expTable7) / _ONE_E18
		IRs:
			TMP_6446(uint256) = votingPower_15 * _expTable7_2
			TMP_6447(uint256) = TMP_6446 / _ONE_E18_2
			votingPower_16(uint256) := TMP_6447(uint256)
		IRs:
			votingPower_17(uint256) := ϕ(['votingPower_16', 'votingPower_1'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_6448(uint256) = t_1 & 256
			TMP_6449(bool) = TMP_6448 != 0
			CONDITION TMP_6449
		Expression: votingPower = (votingPower * _expTable8) / _ONE_E18
		IRs:
			TMP_6450(uint256) = votingPower_17 * _expTable8_2
			TMP_6451(uint256) = TMP_6450 / _ONE_E18_2
			votingPower_18(uint256) := TMP_6451(uint256)
		IRs:
			votingPower_19(uint256) := ϕ(['votingPower_1', 'votingPower_18'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_6452(uint256) = t_1 & 512
			TMP_6453(bool) = TMP_6452 != 0
			CONDITION TMP_6453
		Expression: votingPower = (votingPower * _expTable9) / _ONE_E18
		IRs:
			TMP_6454(uint256) = votingPower_19 * _expTable9_2
			TMP_6455(uint256) = TMP_6454 / _ONE_E18_2
			votingPower_20(uint256) := TMP_6455(uint256)
		IRs:
			votingPower_21(uint256) := ϕ(['votingPower_1', 'votingPower_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_6456(uint256) = t_1 & 1024
			TMP_6457(bool) = TMP_6456 != 0
			CONDITION TMP_6457
		Expression: votingPower = (votingPower * _expTable10) / _ONE_E18
		IRs:
			TMP_6458(uint256) = votingPower_21 * _expTable10_2
			TMP_6459(uint256) = TMP_6458 / _ONE_E18_2
			votingPower_22(uint256) := TMP_6459(uint256)
		IRs:
			votingPower_23(uint256) := ϕ(['votingPower_1', 'votingPower_22'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_6460(uint256) = t_1 & 2048
			TMP_6461(bool) = TMP_6460 != 0
			CONDITION TMP_6461
		Expression: votingPower = (votingPower * _expTable11) / _ONE_E18
		IRs:
			TMP_6462(uint256) = votingPower_23 * _expTable11_2
			TMP_6463(uint256) = TMP_6462 / _ONE_E18_2
			votingPower_24(uint256) := TMP_6463(uint256)
		IRs:
			votingPower_25(uint256) := ϕ(['votingPower_24', 'votingPower_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_6464(uint256) = t_1 & 4096
			TMP_6465(bool) = TMP_6464 != 0
			CONDITION TMP_6465
		Expression: votingPower = (votingPower * _expTable12) / _ONE_E18
		IRs:
			TMP_6466(uint256) = votingPower_25 * _expTable12_2
			TMP_6467(uint256) = TMP_6466 / _ONE_E18_2
			votingPower_26(uint256) := TMP_6467(uint256)
		IRs:
			votingPower_27(uint256) := ϕ(['votingPower_26', 'votingPower_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_6468(uint256) = t_1 & 8192
			TMP_6469(bool) = TMP_6468 != 0
			CONDITION TMP_6469
		Expression: votingPower = (votingPower * _expTable13) / _ONE_E18
		IRs:
			TMP_6470(uint256) = votingPower_27 * _expTable13_2
			TMP_6471(uint256) = TMP_6470 / _ONE_E18_2
			votingPower_28(uint256) := TMP_6471(uint256)
		IRs:
			votingPower_29(uint256) := ϕ(['votingPower_28', 'votingPower_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_6472(uint256) = t_1 & 16384
			TMP_6473(bool) = TMP_6472 != 0
			CONDITION TMP_6473
		Expression: votingPower = (votingPower * _expTable14) / _ONE_E18
		IRs:
			TMP_6474(uint256) = votingPower_29 * _expTable14_2
			TMP_6475(uint256) = TMP_6474 / _ONE_E18_2
			votingPower_30(uint256) := TMP_6475(uint256)
		IRs:
			votingPower_31(uint256) := ϕ(['votingPower_30', 'votingPower_1'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_6476(uint256) = t_1 & 32768
			TMP_6477(bool) = TMP_6476 != 0
			CONDITION TMP_6477
		Expression: votingPower = (votingPower * _expTable15) / _ONE_E18
		IRs:
			TMP_6478(uint256) = votingPower_31 * _expTable15_2
			TMP_6479(uint256) = TMP_6478 / _ONE_E18_2
			votingPower_32(uint256) := TMP_6479(uint256)
		IRs:
			votingPower_33(uint256) := ϕ(['votingPower_32', 'votingPower_1'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_6480(uint256) = t_1 & 65536
			TMP_6481(bool) = TMP_6480 != 0
			CONDITION TMP_6481
		Expression: votingPower = (votingPower * _expTable16) / _ONE_E18
		IRs:
			TMP_6482(uint256) = votingPower_33 * _expTable16_2
			TMP_6483(uint256) = TMP_6482 / _ONE_E18_2
			votingPower_34(uint256) := TMP_6483(uint256)
		IRs:
			votingPower_35(uint256) := ϕ(['votingPower_1', 'votingPower_34'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_6484(uint256) = t_1 & 131072
			TMP_6485(bool) = TMP_6484 != 0
			CONDITION TMP_6485
		Expression: votingPower = (votingPower * _expTable17) / _ONE_E18
		IRs:
			TMP_6486(uint256) = votingPower_35 * _expTable17_2
			TMP_6487(uint256) = TMP_6486 / _ONE_E18_2
			votingPower_36(uint256) := TMP_6487(uint256)
		IRs:
			votingPower_37(uint256) := ϕ(['votingPower_1', 'votingPower_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_6488(uint256) = t_1 & 262144
			TMP_6489(bool) = TMP_6488 != 0
			CONDITION TMP_6489
		Expression: votingPower = (votingPower * _expTable18) / _ONE_E18
		IRs:
			TMP_6490(uint256) = votingPower_37 * _expTable18_2
			TMP_6491(uint256) = TMP_6490 / _ONE_E18_2
			votingPower_38(uint256) := TMP_6491(uint256)
		IRs:
			votingPower_39(uint256) := ϕ(['votingPower_1', 'votingPower_38'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_6492(uint256) = t_1 & 524288
			TMP_6493(bool) = TMP_6492 != 0
			CONDITION TMP_6493
		Expression: votingPower = (votingPower * _expTable19) / _ONE_E18
		IRs:
			TMP_6494(uint256) = votingPower_39 * _expTable19_2
			TMP_6495(uint256) = TMP_6494 / _ONE_E18_2
			votingPower_40(uint256) := TMP_6495(uint256)
		IRs:
			votingPower_41(uint256) := ϕ(['votingPower_40', 'votingPower_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_6496(uint256) = t_1 & 1048576
			TMP_6497(bool) = TMP_6496 != 0
			CONDITION TMP_6497
		Expression: votingPower = (votingPower * _expTable20) / _ONE_E18
		IRs:
			TMP_6498(uint256) = votingPower_41 * _expTable20_2
			TMP_6499(uint256) = TMP_6498 / _ONE_E18_2
			votingPower_42(uint256) := TMP_6499(uint256)
		IRs:
			votingPower_43(uint256) := ϕ(['votingPower_42', 'votingPower_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_6500(uint256) = t_1 & 2097152
			TMP_6501(bool) = TMP_6500 != 0
			CONDITION TMP_6501
		Expression: votingPower = (votingPower * _expTable21) / _ONE_E18
		IRs:
			TMP_6502(uint256) = votingPower_43 * _expTable21_2
			TMP_6503(uint256) = TMP_6502 / _ONE_E18_2
			votingPower_44(uint256) := TMP_6503(uint256)
		IRs:
			votingPower_45(uint256) := ϕ(['votingPower_44', 'votingPower_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_6504(uint256) = t_1 & 4194304
			TMP_6505(bool) = TMP_6504 != 0
			CONDITION TMP_6505
		Expression: votingPower = (votingPower * _expTable22) / _ONE_E18
		IRs:
			TMP_6506(uint256) = votingPower_45 * _expTable22_2
			TMP_6507(uint256) = TMP_6506 / _ONE_E18_2
			votingPower_46(uint256) := TMP_6507(uint256)
		IRs:
			votingPower_47(uint256) := ϕ(['votingPower_46', 'votingPower_1'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_6508(uint256) = t_1 & 8388608
			TMP_6509(bool) = TMP_6508 != 0
			CONDITION TMP_6509
		Expression: votingPower = (votingPower * _expTable23) / _ONE_E18
		IRs:
			TMP_6510(uint256) = votingPower_47 * _expTable23_2
			TMP_6511(uint256) = TMP_6510 / _ONE_E18_2
			votingPower_48(uint256) := TMP_6511(uint256)
		IRs:
			votingPower_49(uint256) := ϕ(['votingPower_48', 'votingPower_1'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_6512(uint256) = t_1 & 16777216
			TMP_6513(bool) = TMP_6512 != 0
			CONDITION TMP_6513
		Expression: votingPower = (votingPower * _expTable24) / _ONE_E18
		IRs:
			TMP_6514(uint256) = votingPower_49 * _expTable24_2
			TMP_6515(uint256) = TMP_6514 / _ONE_E18_2
			votingPower_50(uint256) := TMP_6515(uint256)
		IRs:
			votingPower_51(uint256) := ϕ(['votingPower_1', 'votingPower_50'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_6516(uint256) = t_1 & 33554432
			TMP_6517(bool) = TMP_6516 != 0
			CONDITION TMP_6517
		Expression: votingPower = (votingPower * _expTable25) / _ONE_E18
		IRs:
			TMP_6518(uint256) = votingPower_51 * _expTable25_2
			TMP_6519(uint256) = TMP_6518 / _ONE_E18_2
			votingPower_52(uint256) := TMP_6519(uint256)
		IRs:
			votingPower_53(uint256) := ϕ(['votingPower_1', 'votingPower_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_6520(uint256) = t_1 & 67108864
			TMP_6521(bool) = TMP_6520 != 0
			CONDITION TMP_6521
		Expression: votingPower = (votingPower * _expTable26) / _ONE_E18
		IRs:
			TMP_6522(uint256) = votingPower_53 * _expTable26_2
			TMP_6523(uint256) = TMP_6522 / _ONE_E18_2
			votingPower_54(uint256) := TMP_6523(uint256)
		IRs:
			votingPower_55(uint256) := ϕ(['votingPower_1', 'votingPower_54'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_6524(uint256) = t_1 & 134217728
			TMP_6525(bool) = TMP_6524 != 0
			CONDITION TMP_6525
		Expression: votingPower = (votingPower * _expTable27) / _ONE_E18
		IRs:
			TMP_6526(uint256) = votingPower_55 * _expTable27_2
			TMP_6527(uint256) = TMP_6526 / _ONE_E18_2
			votingPower_56(uint256) := TMP_6527(uint256)
		IRs:
			votingPower_57(uint256) := ϕ(['votingPower_56', 'votingPower_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_6528(uint256) = t_1 & 268435456
			TMP_6529(bool) = TMP_6528 != 0
			CONDITION TMP_6529
		Expression: votingPower = (votingPower * _expTable28) / _ONE_E18
		IRs:
			TMP_6530(uint256) = votingPower_57 * _expTable28_2
			TMP_6531(uint256) = TMP_6530 / _ONE_E18_2
			votingPower_58(uint256) := TMP_6531(uint256)
		IRs:
			votingPower_59(uint256) := ϕ(['votingPower_58', 'votingPower_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_6532(uint256) = t_1 & 536870912
			TMP_6533(bool) = TMP_6532 != 0
			CONDITION TMP_6533
		Expression: votingPower = (votingPower * _expTable29) / _ONE_E18
		IRs:
			TMP_6534(uint256) = votingPower_59 * _expTable29_2
			TMP_6535(uint256) = TMP_6534 / _ONE_E18_2
			votingPower_60(uint256) := TMP_6535(uint256)
		IRs:
			votingPower_61(uint256) := ϕ(['votingPower_60', 'votingPower_1'])
		Expression: votingPower
		IRs:
			RETURN votingPower_61
		Expression: timestamp < origin
		IRs:
			TMP_6536(bool) = timestamp_1 < origin_2
			CONDITION TMP_6536
		Expression: timestamp = origin
		IRs:
			timestamp_3(uint256) := origin_2(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_2(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: votingPower
	Function VotingPowerCalculator._balanceAt(uint256,uint256)
		IRs:
			votingPower_1(uint256) := ϕ(['TMP_6273'])
			timestamp_1(uint256) := ϕ(['lockedTill_1'])
			_ONE_E18_3(uint256) := ϕ(['_ONE_E18_0'])
			origin_3(uint256) := ϕ(['origin_0', 'origin_1'])
			_expTable0_3(uint256) := ϕ(['_expTable0_0', '_expTable0_1'])
			_expTable1_3(uint256) := ϕ(['_expTable1_0', '_expTable1_1'])
			_expTable2_3(uint256) := ϕ(['_expTable2_1', '_expTable2_0'])
			_expTable3_3(uint256) := ϕ(['_expTable3_1', '_expTable3_0'])
			_expTable4_3(uint256) := ϕ(['_expTable4_1', '_expTable4_0'])
			_expTable5_3(uint256) := ϕ(['_expTable5_1', '_expTable5_0'])
			_expTable6_3(uint256) := ϕ(['_expTable6_1', '_expTable6_0'])
			_expTable7_3(uint256) := ϕ(['_expTable7_1', '_expTable7_0'])
			_expTable8_3(uint256) := ϕ(['_expTable8_0', '_expTable8_1'])
			_expTable9_3(uint256) := ϕ(['_expTable9_0', '_expTable9_1'])
			_expTable10_3(uint256) := ϕ(['_expTable10_1', '_expTable10_0'])
			_expTable11_3(uint256) := ϕ(['_expTable11_1', '_expTable11_0'])
			_expTable12_3(uint256) := ϕ(['_expTable12_1', '_expTable12_0'])
			_expTable13_3(uint256) := ϕ(['_expTable13_1', '_expTable13_0'])
			_expTable14_3(uint256) := ϕ(['_expTable14_1', '_expTable14_0'])
			_expTable15_3(uint256) := ϕ(['_expTable15_1', '_expTable15_0'])
			_expTable16_3(uint256) := ϕ(['_expTable16_0', '_expTable16_1'])
			_expTable17_3(uint256) := ϕ(['_expTable17_0', '_expTable17_1'])
			_expTable18_3(uint256) := ϕ(['_expTable18_0', '_expTable18_1'])
			_expTable19_3(uint256) := ϕ(['_expTable19_0', '_expTable19_1'])
			_expTable20_3(uint256) := ϕ(['_expTable20_0', '_expTable20_1'])
			_expTable21_3(uint256) := ϕ(['_expTable21_0', '_expTable21_1'])
			_expTable22_3(uint256) := ϕ(['_expTable22_1', '_expTable22_0'])
			_expTable23_3(uint256) := ϕ(['_expTable23_1', '_expTable23_0'])
			_expTable24_3(uint256) := ϕ(['_expTable24_0', '_expTable24_1'])
			_expTable25_3(uint256) := ϕ(['_expTable25_0', '_expTable25_1'])
			_expTable26_3(uint256) := ϕ(['_expTable26_0', '_expTable26_1'])
			_expTable27_3(uint256) := ϕ(['_expTable27_0', '_expTable27_1'])
			_expTable28_3(uint256) := ϕ(['_expTable28_0', '_expTable28_1'])
			_expTable29_3(uint256) := ϕ(['_expTable29_0', '_expTable29_1'])
		Expression: t = timestamp - origin
		IRs:
			TMP_6537(uint256) = timestamp_4 - origin_3
			t_1(uint256) := TMP_6537(uint256)
		Expression: balance = votingPower
		IRs:
			balance_1(uint256) := votingPower_1(uint256)
		Expression: t & 0x01 != 0
		IRs:
			TMP_6538(uint256) = t_1 & 1
			TMP_6539(bool) = TMP_6538 != 0
			CONDITION TMP_6539
		Expression: balance = (balance * _ONE_E18) / _expTable0
		IRs:
			TMP_6540(uint256) = balance_1 * _ONE_E18_3
			TMP_6541(uint256) = TMP_6540 / _expTable0_3
			balance_2(uint256) := TMP_6541(uint256)
		IRs:
			balance_3(uint256) := ϕ(['balance_1', 'balance_2'])
		Expression: t & 0x02 != 0
		IRs:
			TMP_6542(uint256) = t_1 & 2
			TMP_6543(bool) = TMP_6542 != 0
			CONDITION TMP_6543
		Expression: balance = (balance * _ONE_E18) / _expTable1
		IRs:
			TMP_6544(uint256) = balance_3 * _ONE_E18_3
			TMP_6545(uint256) = TMP_6544 / _expTable1_3
			balance_4(uint256) := TMP_6545(uint256)
		IRs:
			balance_5(uint256) := ϕ(['balance_1', 'balance_4'])
		Expression: t & 0x04 != 0
		IRs:
			TMP_6546(uint256) = t_1 & 4
			TMP_6547(bool) = TMP_6546 != 0
			CONDITION TMP_6547
		Expression: balance = (balance * _ONE_E18) / _expTable2
		IRs:
			TMP_6548(uint256) = balance_5 * _ONE_E18_3
			TMP_6549(uint256) = TMP_6548 / _expTable2_3
			balance_6(uint256) := TMP_6549(uint256)
		IRs:
			balance_7(uint256) := ϕ(['balance_1', 'balance_6'])
		Expression: t & 0x08 != 0
		IRs:
			TMP_6550(uint256) = t_1 & 8
			TMP_6551(bool) = TMP_6550 != 0
			CONDITION TMP_6551
		Expression: balance = (balance * _ONE_E18) / _expTable3
		IRs:
			TMP_6552(uint256) = balance_7 * _ONE_E18_3
			TMP_6553(uint256) = TMP_6552 / _expTable3_3
			balance_8(uint256) := TMP_6553(uint256)
		IRs:
			balance_9(uint256) := ϕ(['balance_8', 'balance_1'])
		Expression: t & 0x10 != 0
		IRs:
			TMP_6554(uint256) = t_1 & 16
			TMP_6555(bool) = TMP_6554 != 0
			CONDITION TMP_6555
		Expression: balance = (balance * _ONE_E18) / _expTable4
		IRs:
			TMP_6556(uint256) = balance_9 * _ONE_E18_3
			TMP_6557(uint256) = TMP_6556 / _expTable4_3
			balance_10(uint256) := TMP_6557(uint256)
		IRs:
			balance_11(uint256) := ϕ(['balance_10', 'balance_1'])
		Expression: t & 0x20 != 0
		IRs:
			TMP_6558(uint256) = t_1 & 32
			TMP_6559(bool) = TMP_6558 != 0
			CONDITION TMP_6559
		Expression: balance = (balance * _ONE_E18) / _expTable5
		IRs:
			TMP_6560(uint256) = balance_11 * _ONE_E18_3
			TMP_6561(uint256) = TMP_6560 / _expTable5_3
			balance_12(uint256) := TMP_6561(uint256)
		IRs:
			balance_13(uint256) := ϕ(['balance_12', 'balance_1'])
		Expression: t & 0x40 != 0
		IRs:
			TMP_6562(uint256) = t_1 & 64
			TMP_6563(bool) = TMP_6562 != 0
			CONDITION TMP_6563
		Expression: balance = (balance * _ONE_E18) / _expTable6
		IRs:
			TMP_6564(uint256) = balance_13 * _ONE_E18_3
			TMP_6565(uint256) = TMP_6564 / _expTable6_3
			balance_14(uint256) := TMP_6565(uint256)
		IRs:
			balance_15(uint256) := ϕ(['balance_14', 'balance_1'])
		Expression: t & 0x80 != 0
		IRs:
			TMP_6566(uint256) = t_1 & 128
			TMP_6567(bool) = TMP_6566 != 0
			CONDITION TMP_6567
		Expression: balance = (balance * _ONE_E18) / _expTable7
		IRs:
			TMP_6568(uint256) = balance_15 * _ONE_E18_3
			TMP_6569(uint256) = TMP_6568 / _expTable7_3
			balance_16(uint256) := TMP_6569(uint256)
		IRs:
			balance_17(uint256) := ϕ(['balance_1', 'balance_16'])
		Expression: t & 0x100 != 0
		IRs:
			TMP_6570(uint256) = t_1 & 256
			TMP_6571(bool) = TMP_6570 != 0
			CONDITION TMP_6571
		Expression: balance = (balance * _ONE_E18) / _expTable8
		IRs:
			TMP_6572(uint256) = balance_17 * _ONE_E18_3
			TMP_6573(uint256) = TMP_6572 / _expTable8_3
			balance_18(uint256) := TMP_6573(uint256)
		IRs:
			balance_19(uint256) := ϕ(['balance_1', 'balance_18'])
		Expression: t & 0x200 != 0
		IRs:
			TMP_6574(uint256) = t_1 & 512
			TMP_6575(bool) = TMP_6574 != 0
			CONDITION TMP_6575
		Expression: balance = (balance * _ONE_E18) / _expTable9
		IRs:
			TMP_6576(uint256) = balance_19 * _ONE_E18_3
			TMP_6577(uint256) = TMP_6576 / _expTable9_3
			balance_20(uint256) := TMP_6577(uint256)
		IRs:
			balance_21(uint256) := ϕ(['balance_1', 'balance_20'])
		Expression: t & 0x400 != 0
		IRs:
			TMP_6578(uint256) = t_1 & 1024
			TMP_6579(bool) = TMP_6578 != 0
			CONDITION TMP_6579
		Expression: balance = (balance * _ONE_E18) / _expTable10
		IRs:
			TMP_6580(uint256) = balance_21 * _ONE_E18_3
			TMP_6581(uint256) = TMP_6580 / _expTable10_3
			balance_22(uint256) := TMP_6581(uint256)
		IRs:
			balance_23(uint256) := ϕ(['balance_22', 'balance_1'])
		Expression: t & 0x800 != 0
		IRs:
			TMP_6582(uint256) = t_1 & 2048
			TMP_6583(bool) = TMP_6582 != 0
			CONDITION TMP_6583
		Expression: balance = (balance * _ONE_E18) / _expTable11
		IRs:
			TMP_6584(uint256) = balance_23 * _ONE_E18_3
			TMP_6585(uint256) = TMP_6584 / _expTable11_3
			balance_24(uint256) := TMP_6585(uint256)
		IRs:
			balance_25(uint256) := ϕ(['balance_24', 'balance_1'])
		Expression: t & 0x1000 != 0
		IRs:
			TMP_6586(uint256) = t_1 & 4096
			TMP_6587(bool) = TMP_6586 != 0
			CONDITION TMP_6587
		Expression: balance = (balance * _ONE_E18) / _expTable12
		IRs:
			TMP_6588(uint256) = balance_25 * _ONE_E18_3
			TMP_6589(uint256) = TMP_6588 / _expTable12_3
			balance_26(uint256) := TMP_6589(uint256)
		IRs:
			balance_27(uint256) := ϕ(['balance_26', 'balance_1'])
		Expression: t & 0x2000 != 0
		IRs:
			TMP_6590(uint256) = t_1 & 8192
			TMP_6591(bool) = TMP_6590 != 0
			CONDITION TMP_6591
		Expression: balance = (balance * _ONE_E18) / _expTable13
		IRs:
			TMP_6592(uint256) = balance_27 * _ONE_E18_3
			TMP_6593(uint256) = TMP_6592 / _expTable13_3
			balance_28(uint256) := TMP_6593(uint256)
		IRs:
			balance_29(uint256) := ϕ(['balance_28', 'balance_1'])
		Expression: t & 0x4000 != 0
		IRs:
			TMP_6594(uint256) = t_1 & 16384
			TMP_6595(bool) = TMP_6594 != 0
			CONDITION TMP_6595
		Expression: balance = (balance * _ONE_E18) / _expTable14
		IRs:
			TMP_6596(uint256) = balance_29 * _ONE_E18_3
			TMP_6597(uint256) = TMP_6596 / _expTable14_3
			balance_30(uint256) := TMP_6597(uint256)
		IRs:
			balance_31(uint256) := ϕ(['balance_30', 'balance_1'])
		Expression: t & 0x8000 != 0
		IRs:
			TMP_6598(uint256) = t_1 & 32768
			TMP_6599(bool) = TMP_6598 != 0
			CONDITION TMP_6599
		Expression: balance = (balance * _ONE_E18) / _expTable15
		IRs:
			TMP_6600(uint256) = balance_31 * _ONE_E18_3
			TMP_6601(uint256) = TMP_6600 / _expTable15_3
			balance_32(uint256) := TMP_6601(uint256)
		IRs:
			balance_33(uint256) := ϕ(['balance_1', 'balance_32'])
		Expression: t & 0x10000 != 0
		IRs:
			TMP_6602(uint256) = t_1 & 65536
			TMP_6603(bool) = TMP_6602 != 0
			CONDITION TMP_6603
		Expression: balance = (balance * _ONE_E18) / _expTable16
		IRs:
			TMP_6604(uint256) = balance_33 * _ONE_E18_3
			TMP_6605(uint256) = TMP_6604 / _expTable16_3
			balance_34(uint256) := TMP_6605(uint256)
		IRs:
			balance_35(uint256) := ϕ(['balance_1', 'balance_34'])
		Expression: t & 0x20000 != 0
		IRs:
			TMP_6606(uint256) = t_1 & 131072
			TMP_6607(bool) = TMP_6606 != 0
			CONDITION TMP_6607
		Expression: balance = (balance * _ONE_E18) / _expTable17
		IRs:
			TMP_6608(uint256) = balance_35 * _ONE_E18_3
			TMP_6609(uint256) = TMP_6608 / _expTable17_3
			balance_36(uint256) := TMP_6609(uint256)
		IRs:
			balance_37(uint256) := ϕ(['balance_1', 'balance_36'])
		Expression: t & 0x40000 != 0
		IRs:
			TMP_6610(uint256) = t_1 & 262144
			TMP_6611(bool) = TMP_6610 != 0
			CONDITION TMP_6611
		Expression: balance = (balance * _ONE_E18) / _expTable18
		IRs:
			TMP_6612(uint256) = balance_37 * _ONE_E18_3
			TMP_6613(uint256) = TMP_6612 / _expTable18_3
			balance_38(uint256) := TMP_6613(uint256)
		IRs:
			balance_39(uint256) := ϕ(['balance_38', 'balance_1'])
		Expression: t & 0x80000 != 0
		IRs:
			TMP_6614(uint256) = t_1 & 524288
			TMP_6615(bool) = TMP_6614 != 0
			CONDITION TMP_6615
		Expression: balance = (balance * _ONE_E18) / _expTable19
		IRs:
			TMP_6616(uint256) = balance_39 * _ONE_E18_3
			TMP_6617(uint256) = TMP_6616 / _expTable19_3
			balance_40(uint256) := TMP_6617(uint256)
		IRs:
			balance_41(uint256) := ϕ(['balance_40', 'balance_1'])
		Expression: t & 0x100000 != 0
		IRs:
			TMP_6618(uint256) = t_1 & 1048576
			TMP_6619(bool) = TMP_6618 != 0
			CONDITION TMP_6619
		Expression: balance = (balance * _ONE_E18) / _expTable20
		IRs:
			TMP_6620(uint256) = balance_41 * _ONE_E18_3
			TMP_6621(uint256) = TMP_6620 / _expTable20_3
			balance_42(uint256) := TMP_6621(uint256)
		IRs:
			balance_43(uint256) := ϕ(['balance_42', 'balance_1'])
		Expression: t & 0x200000 != 0
		IRs:
			TMP_6622(uint256) = t_1 & 2097152
			TMP_6623(bool) = TMP_6622 != 0
			CONDITION TMP_6623
		Expression: balance = (balance * _ONE_E18) / _expTable21
		IRs:
			TMP_6624(uint256) = balance_43 * _ONE_E18_3
			TMP_6625(uint256) = TMP_6624 / _expTable21_3
			balance_44(uint256) := TMP_6625(uint256)
		IRs:
			balance_45(uint256) := ϕ(['balance_44', 'balance_1'])
		Expression: t & 0x400000 != 0
		IRs:
			TMP_6626(uint256) = t_1 & 4194304
			TMP_6627(bool) = TMP_6626 != 0
			CONDITION TMP_6627
		Expression: balance = (balance * _ONE_E18) / _expTable22
		IRs:
			TMP_6628(uint256) = balance_45 * _ONE_E18_3
			TMP_6629(uint256) = TMP_6628 / _expTable22_3
			balance_46(uint256) := TMP_6629(uint256)
		IRs:
			balance_47(uint256) := ϕ(['balance_46', 'balance_1'])
		Expression: t & 0x800000 != 0
		IRs:
			TMP_6630(uint256) = t_1 & 8388608
			TMP_6631(bool) = TMP_6630 != 0
			CONDITION TMP_6631
		Expression: balance = (balance * _ONE_E18) / _expTable23
		IRs:
			TMP_6632(uint256) = balance_47 * _ONE_E18_3
			TMP_6633(uint256) = TMP_6632 / _expTable23_3
			balance_48(uint256) := TMP_6633(uint256)
		IRs:
			balance_49(uint256) := ϕ(['balance_1', 'balance_48'])
		Expression: t & 0x1000000 != 0
		IRs:
			TMP_6634(uint256) = t_1 & 16777216
			TMP_6635(bool) = TMP_6634 != 0
			CONDITION TMP_6635
		Expression: balance = (balance * _ONE_E18) / _expTable24
		IRs:
			TMP_6636(uint256) = balance_49 * _ONE_E18_3
			TMP_6637(uint256) = TMP_6636 / _expTable24_3
			balance_50(uint256) := TMP_6637(uint256)
		IRs:
			balance_51(uint256) := ϕ(['balance_1', 'balance_50'])
		Expression: t & 0x2000000 != 0
		IRs:
			TMP_6638(uint256) = t_1 & 33554432
			TMP_6639(bool) = TMP_6638 != 0
			CONDITION TMP_6639
		Expression: balance = (balance * _ONE_E18) / _expTable25
		IRs:
			TMP_6640(uint256) = balance_51 * _ONE_E18_3
			TMP_6641(uint256) = TMP_6640 / _expTable25_3
			balance_52(uint256) := TMP_6641(uint256)
		IRs:
			balance_53(uint256) := ϕ(['balance_1', 'balance_52'])
		Expression: t & 0x4000000 != 0
		IRs:
			TMP_6642(uint256) = t_1 & 67108864
			TMP_6643(bool) = TMP_6642 != 0
			CONDITION TMP_6643
		Expression: balance = (balance * _ONE_E18) / _expTable26
		IRs:
			TMP_6644(uint256) = balance_53 * _ONE_E18_3
			TMP_6645(uint256) = TMP_6644 / _expTable26_3
			balance_54(uint256) := TMP_6645(uint256)
		IRs:
			balance_55(uint256) := ϕ(['balance_1', 'balance_54'])
		Expression: t & 0x8000000 != 0
		IRs:
			TMP_6646(uint256) = t_1 & 134217728
			TMP_6647(bool) = TMP_6646 != 0
			CONDITION TMP_6647
		Expression: balance = (balance * _ONE_E18) / _expTable27
		IRs:
			TMP_6648(uint256) = balance_55 * _ONE_E18_3
			TMP_6649(uint256) = TMP_6648 / _expTable27_3
			balance_56(uint256) := TMP_6649(uint256)
		IRs:
			balance_57(uint256) := ϕ(['balance_56', 'balance_1'])
		Expression: t & 0x10000000 != 0
		IRs:
			TMP_6650(uint256) = t_1 & 268435456
			TMP_6651(bool) = TMP_6650 != 0
			CONDITION TMP_6651
		Expression: balance = (balance * _ONE_E18) / _expTable28
		IRs:
			TMP_6652(uint256) = balance_57 * _ONE_E18_3
			TMP_6653(uint256) = TMP_6652 / _expTable28_3
			balance_58(uint256) := TMP_6653(uint256)
		IRs:
			balance_59(uint256) := ϕ(['balance_58', 'balance_1'])
		Expression: t & 0x20000000 != 0
		IRs:
			TMP_6654(uint256) = t_1 & 536870912
			TMP_6655(bool) = TMP_6654 != 0
			CONDITION TMP_6655
		Expression: balance = (balance * _ONE_E18) / _expTable29
		IRs:
			TMP_6656(uint256) = balance_59 * _ONE_E18_3
			TMP_6657(uint256) = TMP_6656 / _expTable29_3
			balance_60(uint256) := TMP_6657(uint256)
		IRs:
			balance_61(uint256) := ϕ(['balance_60', 'balance_1'])
		Expression: balance
		IRs:
			RETURN balance_61
		Expression: timestamp < origin
		IRs:
			TMP_6658(bool) = timestamp_1 < origin_3
			CONDITION TMP_6658
		Expression: timestamp = origin
		IRs:
			timestamp_3(uint256) := origin_3(uint256)
		Expression: timestamp = timestamp
		IRs:
			timestamp_2(uint256) := timestamp_1(uint256)
		IRs:
			timestamp_4(uint256) := ϕ(['timestamp_2', 'timestamp_3'])
		Expression: balance
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_6659(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_6659)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_6661(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_6662(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_6663(bool) = TMP_6661 == TMP_6662
			TMP_6664(None) = SOLIDITY_CALL require(bool,string)(TMP_6663,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_6665 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_6665)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_6668 = CONVERT 0 to address
			TMP_6669(bool) = newOwner_1 != TMP_6668
			TMP_6670(None) = SOLIDITY_CALL require(bool,string)(TMP_6669,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['newOwner_1', 'TMP_6665', 'TMP_6659'])
			_owner_2(address) := ϕ(['_owner_3', '_owner_0'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ERC20Pods.constructor(uint256,uint256)
		IRs:
			_guard_1(ReentrancyGuardLib.Data) := ϕ(['_guard_3', '_guard_0', '_guard_5', '_guard_7'])
		Expression: podsLimit_ == 0
		IRs:
			TMP_6674(bool) = podsLimit__1 == 0
			CONDITION TMP_6674
		Expression: revert ZeroPodsLimit()()
		IRs:
			TMP_6675(None) = SOLIDITY_CALL revert ZeroPodsLimit()()
		Expression: podsLimit = podsLimit_
		IRs:
			podsLimit_1(uint256) := podsLimit__1(uint256)
		Expression: podCallGasLimit = podCallGasLimit_
		IRs:
			podCallGasLimit_1(uint256) := podCallGasLimit__1(uint256)
		Expression: _guard.init()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.init(ReentrancyGuardLib.Data), arguments:['_guard_1'] 
	Function ERC20Pods.hasPod(address,address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			pod_1(address) := ϕ(['pod_1', 'defaultFarm_5'])
			_pods_1(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_0', '_pods_3', '_pods_7'])
		Expression: _pods[account].contains(pod)
		IRs:
			REF_1333(AddressSet.Data) -> _pods_1[account_1]
			TMP_6677(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.contains(AddressSet.Data,address), arguments:['REF_1333', 'pod_1'] 
			RETURN TMP_6677
	Function ERC20Pods.podsCount(address)
		IRs:
			_pods_2(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_0', '_pods_3', '_pods_7'])
		Expression: _pods[account].length()
		IRs:
			REF_1335(AddressSet.Data) -> _pods_2[account_1]
			TMP_6678(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_1335'] 
			RETURN TMP_6678
	Function ERC20Pods.podAt(address,uint256)
		IRs:
			_pods_3(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_0', '_pods_3', '_pods_7'])
		Expression: _pods[account].at(index)
		IRs:
			REF_1337(AddressSet.Data) -> _pods_3[account_1]
			TMP_6679(address) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.at(AddressSet.Data,uint256), arguments:['REF_1337', 'index_1'] 
			RETURN TMP_6679
	Function ERC20Pods.pods(address)
		IRs:
			_pods_4(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_0', '_pods_3', '_pods_7'])
		Expression: _pods[account].items.get()
		IRs:
			REF_1339(AddressSet.Data) -> _pods_4[account_1]
			REF_1340(AddressArray.Data) -> REF_1339.items
			TMP_6680(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1340'] 
			RETURN TMP_6680
	Function ERC20Pods.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1', 'account_1', 'account_1', 'account_1', 'account_1', 'account_1', 'msg.sender'])
			_guard_2(ReentrancyGuardLib.Data) := ϕ(['_guard_3', '_guard_0', '_guard_5', '_guard_7'])
		Expression: super.balanceOf(account)
		IRs:
			TMP_6681(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_6681
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_2)
	Function ERC20Pods.podBalanceOf(address,address)
		IRs:
			_guard_4(ReentrancyGuardLib.Data) := ϕ(['_guard_3', '_guard_0', '_guard_5', '_guard_7'])
		Expression: hasPod(account,pod)
		IRs:
			TMP_6683(bool) = INTERNAL_CALL, ERC20Pods.hasPod(address,address)(account_1,pod_1)
			CONDITION TMP_6683
		Expression: super.balanceOf(account)
		IRs:
			TMP_6684(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(account_1)
			RETURN TMP_6684
		Expression: 0
		IRs:
			RETURN 0
		Expression: nonReentrantView(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)(_guard_4)
	Function ERC20Pods.addPod(address)
		Expression: _addPod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._addPod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removePod(address)
		Expression: _removePod(msg.sender,pod)
		IRs:
			INTERNAL_CALL, ERC20Pods._removePod(address,address)(msg.sender,pod_1)
	Function ERC20Pods.removeAllPods()
		Expression: _removeAllPods(msg.sender)
		IRs:
			INTERNAL_CALL, ERC20Pods._removeAllPods(address)(msg.sender)
	Function ERC20Pods._addPod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender', 'account_1'])
			pod_1(address) := ϕ(['defaultFarm_6', 'pod_1'])
			podsLimit_2(uint256) := ϕ(['podsLimit_1', 'podsLimit_3', 'podsLimit_0'])
			_pods_5(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_0', '_pods_3', '_pods_7'])
		Expression: pod == address(0)
		IRs:
			TMP_6689 = CONVERT 0 to address
			TMP_6690(bool) = pod_1 == TMP_6689
			CONDITION TMP_6690
		Expression: revert InvalidPodAddress()()
		IRs:
			TMP_6691(None) = SOLIDITY_CALL revert InvalidPodAddress()()
		Expression: IPod(pod).token() != IERC20Pods(address(this))
		IRs:
			TMP_6692 = CONVERT pod_1 to IPod
			TMP_6693(IERC20Pods) = HIGH_LEVEL_CALL, dest:TMP_6692(IPod), function:token, arguments:[]  
			podsLimit_3(uint256) := ϕ(['podsLimit_1', 'podsLimit_3', 'podsLimit_2'])
			_pods_6(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_5', '_pods_3', '_pods_7'])
			TMP_6694 = CONVERT this to address
			TMP_6695 = CONVERT TMP_6694 to IERC20Pods
			TMP_6696(bool) = TMP_6693 != TMP_6695
			CONDITION TMP_6696
		Expression: revert InvalidTokenInPod()()
		IRs:
			TMP_6697(None) = SOLIDITY_CALL revert InvalidTokenInPod()()
		Expression: ! _pods[account].add(pod)
		IRs:
			REF_1343(AddressSet.Data) -> _pods_6[account_1]
			TMP_6698(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.add(AddressSet.Data,address), arguments:['REF_1343', 'pod_1'] 
			TMP_6699 = UnaryType.BANG TMP_6698 
			CONDITION TMP_6699
		Expression: revert PodAlreadyAdded()()
		IRs:
			TMP_6700(None) = SOLIDITY_CALL revert PodAlreadyAdded()()
		Expression: _pods[account].length() > podsLimit
		IRs:
			REF_1345(AddressSet.Data) -> _pods_6[account_1]
			TMP_6701(uint256) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.length(AddressSet.Data), arguments:['REF_1345'] 
			TMP_6702(bool) = TMP_6701 > podsLimit_3
			CONDITION TMP_6702
		Expression: revert PodsLimitReachedForAccount()()
		IRs:
			TMP_6703(None) = SOLIDITY_CALL revert PodsLimitReachedForAccount()()
		Expression: PodAdded(account,pod)
		IRs:
			Emit PodAdded(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_6705(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_6705(uint256)
		Expression: balance > 0
		IRs:
			TMP_6706(bool) = balance_1 > 0
			CONDITION TMP_6706
		Expression: _updateBalances(pod,address(0),account,balance)
		IRs:
			TMP_6707 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,TMP_6707,account_1,balance_1)
	Function ERC20Pods._removePod(address,address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			pod_1(address) := ϕ(['pod_1'])
			_pods_7(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_0', '_pods_3', '_pods_7'])
		Expression: ! _pods[account].remove(pod)
		IRs:
			REF_1347(AddressSet.Data) -> _pods_7[account_1]
			TMP_6709(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_1347', 'pod_1'] 
			TMP_6710 = UnaryType.BANG TMP_6709 
			CONDITION TMP_6710
		Expression: revert PodNotFound()()
		IRs:
			TMP_6711(None) = SOLIDITY_CALL revert PodNotFound()()
		Expression: PodRemoved(account,pod)
		IRs:
			Emit PodRemoved(account_1,pod_1)
		Expression: balance = balanceOf(account)
		IRs:
			TMP_6713(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_6713(uint256)
		Expression: balance > 0
		IRs:
			TMP_6714(bool) = balance_1 > 0
			CONDITION TMP_6714
		Expression: _updateBalances(pod,account,address(0),balance)
		IRs:
			TMP_6715 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,account_1,TMP_6715,balance_1)
	Function ERC20Pods._removeAllPods(address)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			_pods_8(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_0', '_pods_3', '_pods_7'])
		Expression: items = _pods[account].items.get()
		IRs:
			REF_1349(AddressSet.Data) -> _pods_8[account_1]
			REF_1350(AddressArray.Data) -> REF_1349.items
			TMP_6717(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1350'] 
			items_1(address[]) = ['TMP_6717(address[])']
		Expression: balance = balanceOf(account)
		IRs:
			TMP_6718(uint256) = INTERNAL_CALL, ERC20Pods.balanceOf(address)(account_1)
			balance_1(uint256) := TMP_6718(uint256)
		Expression: i = items.length
		IRs:
			REF_1352 -> LENGTH items_1
			i_1(uint256) := REF_1352(uint256)
		Expression: i > 0
		IRs:
			i_2(uint256) := ϕ(['i_1', 'i_3'])
			TMP_6719(bool) = i_2 > 0
			CONDITION TMP_6719
		Expression: _pods[account].remove(items[i - 1])
		IRs:
			REF_1353(AddressSet.Data) -> _pods_9[account_1]
			TMP_6720(uint256) = i_2 - 1
			REF_1355(address) -> items_1[TMP_6720]
			TMP_6721(bool) = LIBRARY_CALL, dest:AddressSet, function:AddressSet.remove(AddressSet.Data,address), arguments:['REF_1353', 'REF_1355'] 
		Expression: PodRemoved(account,items[i - 1])
		IRs:
			TMP_6722(uint256) = i_2 - 1
			REF_1356(address) -> items_1[TMP_6722]
			Emit PodRemoved(account_1,REF_1356)
		Expression: balance > 0
		IRs:
			TMP_6724(bool) = balance_1 > 0
			CONDITION TMP_6724
		Expression: _updateBalances(items[i - 1],account,address(0),balance)
		IRs:
			TMP_6725(uint256) = i_2 - 1
			REF_1357(address) -> items_1[TMP_6725]
			TMP_6726 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(REF_1357,account_1,TMP_6726,balance_1)
		Expression: i --
		IRs:
			TMP_6728(uint256) := i_2(uint256)
			i_3(uint256) = i_2 - 1
	Function ERC20Pods._updateBalances(address,address,address,uint256)
		IRs:
			pod_1(address) := ϕ(['pod_scope_1_1', 'REF_1357', 'pod_1', 'pod_1', 'pod_1'])
			from_1(address) := ϕ(['account_1', 'account_1', 'from_1', 'TMP_6707', 'TMP_6764'])
			to_1(address) := ϕ(['TMP_6758', 'to_1', 'TMP_6726', 'TMP_6715', 'account_1'])
			amount_1(uint256) := ϕ(['balance_1', 'amount_1', 'balance_1', 'balance_1'])
			podCallGasLimit_2(uint256) := ϕ(['podCallGasLimit_1', 'podCallGasLimit_0'])
		Expression: selector = IPod.updateBalances.selector
		IRs:
			REF_1359(bytes4) (->None) := 2048858793(bytes4)
			selector_1(bytes4) := REF_1359(bytes4)
		Expression: exception = revert InsufficientGas().selector
		IRs:
			REF_1360(bytes4) (->None) := 472281420(bytes4)
			exception_1(bytes4) := REF_1360(bytes4)
		Expression: gasLimit = podCallGasLimit
		IRs:
			gasLimit_1(uint256) := podCallGasLimit_2(uint256)
		Expression: ptr__updateBalances_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_6729(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr__updateBalances_asm_0_1(uint256) := TMP_6729(uint256)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0,selector)
		IRs:
			TMP_6730(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr__updateBalances_asm_0_1,selector_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x04,from)
		IRs:
			TMP_6731(uint256) = ptr__updateBalances_asm_0_1 + 4
			TMP_6732(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6731,from_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x24,to)
		IRs:
			TMP_6733(uint256) = ptr__updateBalances_asm_0_1 + 36
			TMP_6734(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6733,to_1)
		Expression: mstore(uint256,uint256)(ptr__updateBalances_asm_0 + 0x44,amount)
		IRs:
			TMP_6735(uint256) = ptr__updateBalances_asm_0_1 + 68
			TMP_6736(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_6735,amount_1)
		Expression: gas()() * 63 / 64 < gasLimit
		IRs:
			TMP_6737(uint256) = SOLIDITY_CALL gas()()
			TMP_6738(uint256) = TMP_6737 * 63
			TMP_6739(uint256) = TMP_6738 / 64
			TMP_6740(bool) = TMP_6739 < gasLimit_1
			CONDITION TMP_6740
		Expression: mstore(uint256,uint256)(0,exception)
		IRs:
			TMP_6741(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,exception_1)
		Expression: revert(uint256,uint256)(0,4)
		IRs:
			TMP_6742(None) = SOLIDITY_CALL revert(uint256,uint256)(0,4)
		Expression: pop(uint256)(call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit,pod,0,ptr__updateBalances_asm_0,0x64,0,0))
		IRs:
			TMP_6743(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gasLimit_1,pod_1,0,ptr__updateBalances_asm_0_1,100,0,0)
			TMP_6744(None) = SOLIDITY_CALL pop(uint256)(TMP_6743)
	Function ERC20Pods._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_6804'])
			to_1(address) := ϕ(['to_1', 'TMP_6816', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
			_guard_6(ReentrancyGuardLib.Data) := ϕ(['_guard_3', '_guard_0', '_guard_5', '_guard_7'])
			_pods_11(mapping(address => AddressSet.Data)) := ϕ(['_pods_1', '_pods_13', '_pods_4', '_pods_6', '_pods_9', '_pods_2', '_pods_0', '_pods_3', '_pods_7'])
		Expression: super._afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: amount > 0 && from != to
		IRs:
			TMP_6746(bool) = amount_1 > 0
			TMP_6747(bool) = from_1 != to_1
			TMP_6748(bool) = TMP_6746 && TMP_6747
			CONDITION TMP_6748
		Expression: a = _pods[from].items.get()
		IRs:
			REF_1361(AddressSet.Data) -> _pods_13[from_1]
			REF_1362(AddressArray.Data) -> REF_1361.items
			TMP_6749(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1362'] 
			a_1(address[]) = ['TMP_6749(address[])']
		Expression: b = _pods[to].items.get()
		IRs:
			REF_1364(AddressSet.Data) -> _pods_13[to_1]
			REF_1365(AddressArray.Data) -> REF_1364.items
			TMP_6750(address[]) = LIBRARY_CALL, dest:AddressArray, function:AddressArray.get(AddressArray.Data), arguments:['REF_1365'] 
			b_1(address[]) = ['TMP_6750(address[])']
		Expression: aLength = a.length
		IRs:
			REF_1367 -> LENGTH a_1
			aLength_1(uint256) := REF_1367(uint256)
		Expression: bLength = b.length
		IRs:
			REF_1368 -> LENGTH b_1
			bLength_1(uint256) := REF_1368(uint256)
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < aLength
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_6751(bool) = i_2 < aLength_1
			CONDITION TMP_6751
		Expression: pod = a[i]
		IRs:
			REF_1369(address) -> a_1[i_2]
			pod_1(address) := REF_1369(address)
		IRs:
			b_3(address[]) := ϕ(['b_1', 'b_2'])
		Expression: j = 0
		IRs:
			j_1(uint256) := 0(uint256)
		Expression: j < bLength
		IRs:
			j_2(uint256) := ϕ(['j_1', 'j_3'])
			TMP_6752(bool) = j_2 < bLength_1
			CONDITION TMP_6752
		Expression: pod == b[j]
		IRs:
			REF_1370(address) -> b_1[j_2]
			TMP_6753(bool) = pod_1 == REF_1370
			CONDITION TMP_6753
		Expression: _updateBalances(pod,from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,to_1,amount_1)
		Expression: b[j] = address(0)
		IRs:
			REF_1371(address) -> b_1[j_2]
			TMP_6755 = CONVERT 0 to address
			b_2(address[]) := ϕ(['b_1'])
			REF_1371(address) (->b_2) := TMP_6755(address)
		Expression: j ++
		IRs:
			TMP_6756(uint256) := j_2(uint256)
			j_3(uint256) = j_2 + 1
		Expression: j == bLength
		IRs:
			TMP_6757(bool) = j_2 == bLength_1
			CONDITION TMP_6757
		Expression: _updateBalances(pod,from,address(0),amount)
		IRs:
			TMP_6758 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_1,from_1,TMP_6758,amount_1)
		Expression: i ++
		IRs:
			TMP_6760(uint256) := i_2(uint256)
			i_3(uint256) = i_2 + 1
		Expression: j_scope_0 = 0
		IRs:
			j_scope_0_1(uint256) := 0(uint256)
		Expression: j_scope_0 < bLength
		IRs:
			j_scope_0_2(uint256) := ϕ(['j_scope_0_1', 'j_scope_0_3'])
			TMP_6761(bool) = j_scope_0_2 < bLength_1
			CONDITION TMP_6761
		Expression: pod_scope_1 = b[j_scope_0]
		IRs:
			REF_1372(address) -> b_1[j_scope_0_2]
			pod_scope_1_1(address) := REF_1372(address)
		Expression: pod_scope_1 != address(0)
		IRs:
			TMP_6762 = CONVERT 0 to address
			TMP_6763(bool) = pod_scope_1_1 != TMP_6762
			CONDITION TMP_6763
		Expression: _updateBalances(pod_scope_1,address(0),to,amount)
		IRs:
			TMP_6764 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._updateBalances(address,address,address,uint256)(pod_scope_1_1,TMP_6764,to_1,amount_1)
		Expression: j_scope_0 ++
		IRs:
			TMP_6766(uint256) := j_scope_0_2(uint256)
			j_scope_0_3(uint256) = j_scope_0_2 + 1
		Expression: nonReentrant(_guard)
		IRs:
			MODIFIER_CALL, ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)(_guard_6)
	Function IERC20Pods.podsLimit()
	Function IERC20Pods.podCallGasLimit()
	Function IERC20Pods.hasPod(address,address)
	Function IERC20Pods.podsCount(address)
	Function IERC20Pods.podAt(address,uint256)
	Function IERC20Pods.pods(address)
	Function IERC20Pods.podBalanceOf(address,address)
	Function IERC20Pods.addPod(address)
	Function IERC20Pods.removePod(address)
	Function IERC20Pods.removeAllPods()
	Function ERC20.constructor(string,string)
		Expression: _name = name_
		IRs:
			_name_1(string) := name__1(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol_1(string) := symbol__1(string)
	Function ERC20.name()
		IRs:
			_name_2(string) := ϕ(['_name_1', '_name_0'])
		Expression: _name
		IRs:
			RETURN _name_2
	Function ERC20.symbol()
		IRs:
			_symbol_2(string) := ϕ(['_symbol_1', '_symbol_0'])
		Expression: _symbol
		IRs:
			RETURN _symbol_2
	Function ERC20.decimals()
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply()
		IRs:
			_totalSupply_1(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply_1
	Function ERC20.balanceOf(address)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			_balances_1(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
		Expression: _balances[account]
		IRs:
			REF_1373(uint256) -> _balances_1[account_1]
			RETURN REF_1373
	Function ERC20.transfer(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_6768(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_6768(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1'])
			_allowances_1(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_0', '_allowances_1', '_allowances_2'])
		Expression: _allowances[owner][spender]
		IRs:
			REF_1374(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_1375(uint256) -> REF_1374[spender_1]
			RETURN REF_1375
	Function ERC20.approve(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_6770(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_6770(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256)
		Expression: spender = _msgSender()
		IRs:
			TMP_6772(address) = INTERNAL_CALL, Context._msgSender()()
			spender_1(address) := TMP_6772(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from_1,spender_1,amount_1)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_6775(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_6775(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_6776(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			TMP_6777(uint256) = TMP_6776 (c)+ addedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_6777)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256)
		Expression: owner = _msgSender()
		IRs:
			TMP_6779(address) = INTERNAL_CALL, Context._msgSender()()
			owner_1(address) := TMP_6779(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_6780(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_6780(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_6781(bool) = currentAllowance_1 >= subtractedValue_1
			TMP_6782(None) = SOLIDITY_CALL require(bool,string)(TMP_6781,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_6783(uint256) = currentAllowance_1 - subtractedValue_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_6783)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1', 'owner_1'])
			to_1(address) := ϕ(['to_1', 'to_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1'])
			_balances_2(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_6785 = CONVERT 0 to address
			TMP_6786(bool) = from_1 != TMP_6785
			TMP_6787(None) = SOLIDITY_CALL require(bool,string)(TMP_6786,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_6788 = CONVERT 0 to address
			TMP_6789(bool) = to_1 != TMP_6788
			TMP_6790(None) = SOLIDITY_CALL require(bool,string)(TMP_6789,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_1376(uint256) -> _balances_3[from_1]
			fromBalance_1(uint256) := REF_1376(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_6792(bool) = fromBalance_1 >= amount_1
			TMP_6793(None) = SOLIDITY_CALL require(bool,string)(TMP_6792,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_1377(uint256) -> _balances_3[from_1]
			TMP_6794(uint256) = fromBalance_1 - amount_1
			_balances_4(mapping(address => uint256)) := ϕ(['_balances_3'])
			REF_1377(uint256) (->_balances_4) := TMP_6794(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_1378(uint256) -> _balances_4[to_1]
			_balances_5(mapping(address => uint256)) := ϕ(['_balances_4'])
			REF_1378(-> _balances_5) = REF_1378 + amount_1
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from_1,to_1,amount_1)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(from_1,to_1,amount_1)
	Function ERC20._mint(address,uint256)
		IRs:
			account_1(address) := ϕ(['account_1', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'balanceDiff_1'])
			_balances_6(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
			_totalSupply_2(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_6797 = CONVERT 0 to address
			TMP_6798(bool) = account_1 != TMP_6797
			TMP_6799(None) = SOLIDITY_CALL require(bool,string)(TMP_6798,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_6800 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_6800,account_1,amount_1)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply_4(uint256) = _totalSupply_3 (c)+ amount_1
		Expression: _balances[account] += amount
		IRs:
			REF_1379(uint256) -> _balances_7[account_1]
			_balances_8(mapping(address => uint256)) := ϕ(['_balances_7'])
			REF_1379(-> _balances_8) = REF_1379 + amount_1
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_6802 = CONVERT 0 to address
			Emit Transfer(TMP_6802,account_1,amount_1)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_6804 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(TMP_6804,account_1,amount_1)
	Function ERC20._burn(address,uint256)
		IRs:
			account_1(address) := ϕ(['msg.sender'])
			amount_1(uint256) := ϕ(['balance_1'])
			_balances_9(mapping(address => uint256)) := ϕ(['_balances_0', '_balances_1', '_balances_8', '_balances_11', '_balances_5'])
			_totalSupply_5(uint256) := ϕ(['_totalSupply_0', '_totalSupply_7', '_totalSupply_4'])
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_6806 = CONVERT 0 to address
			TMP_6807(bool) = account_1 != TMP_6806
			TMP_6808(None) = SOLIDITY_CALL require(bool,string)(TMP_6807,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_6809 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account_1,TMP_6809,amount_1)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_1380(uint256) -> _balances_10[account_1]
			accountBalance_1(uint256) := REF_1380(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_6811(bool) = accountBalance_1 >= amount_1
			TMP_6812(None) = SOLIDITY_CALL require(bool,string)(TMP_6811,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_1381(uint256) -> _balances_10[account_1]
			TMP_6813(uint256) = accountBalance_1 - amount_1
			_balances_11(mapping(address => uint256)) := ϕ(['_balances_10'])
			REF_1381(uint256) (->_balances_11) := TMP_6813(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply_7(uint256) = _totalSupply_6 - amount_1
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_6814 = CONVERT 0 to address
			Emit Transfer(account_1,TMP_6814,amount_1)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_6816 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Pods._afterTokenTransfer(address,address,uint256)(account_1,TMP_6816,amount_1)
	Function ERC20._approve(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['owner_1', 'owner_1', 'owner_1', 'owner_1'])
			spender_1(address) := ϕ(['spender_1', 'spender_1', 'spender_1', 'spender_1'])
			amount_1(uint256) := ϕ(['amount_1', 'TMP_6783', 'TMP_6777', 'TMP_6831'])
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_6818 = CONVERT 0 to address
			TMP_6819(bool) = owner_1 != TMP_6818
			TMP_6820(None) = SOLIDITY_CALL require(bool,string)(TMP_6819,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_6821 = CONVERT 0 to address
			TMP_6822(bool) = spender_1 != TMP_6821
			TMP_6823(None) = SOLIDITY_CALL require(bool,string)(TMP_6822,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_1382(mapping(address => uint256)) -> _allowances_1[owner_1]
			REF_1383(uint256) -> REF_1382[spender_1]
			_allowances_2(mapping(address => mapping(address => uint256))) := ϕ(['_allowances_1'])
			REF_1383(uint256) (->_allowances_2) := amount_1(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner_1,spender_1,amount_1)
	Function ERC20._spendAllowance(address,address,uint256)
		IRs:
			owner_1(address) := ϕ(['from_1'])
			spender_1(address) := ϕ(['spender_1'])
			amount_1(uint256) := ϕ(['amount_1'])
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_6825(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner_1,spender_1)
			currentAllowance_1(uint256) := TMP_6825(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_6827(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_6828(bool) = currentAllowance_1 != TMP_6827
			CONDITION TMP_6828
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_6829(bool) = currentAllowance_1 >= amount_1
			TMP_6830(None) = SOLIDITY_CALL require(bool,string)(TMP_6829,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_6831(uint256) = currentAllowance_1 - amount_1
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner_1,spender_1,TMP_6831)
	Function ERC20._beforeTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['account_1', 'from_1', 'TMP_6800'])
			to_1(address) := ϕ(['to_1', 'TMP_6809', 'account_1'])
			amount_1(uint256) := ϕ(['amount_1', 'amount_1', 'amount_1'])
	Function ERC20._afterTokenTransfer(address,address,uint256)
		IRs:
			from_1(address) := ϕ(['from_1'])
			to_1(address) := ϕ(['to_1'])
			amount_1(uint256) := ϕ(['amount_1'])
	Function IERC20Metadata.name()
	Function IERC20Metadata.symbol()
	Function IERC20Metadata.decimals()
	Function St1inchMock.constructor(IERC20,uint256,address)
		Expression: St1inch(oneInch_,expBase_,feeReceiver_)
		IRs:
			INTERNAL_CALL, St1inch.constructor(IERC20,uint256,address)(oneInch__1,expBase__1,feeReceiver__1)
	Function St1inchMock.mint(address,uint256)
		Expression: _mint(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account_1,amount_1)
	Function St1inchMock.slitherConstructorConstantVariables()
		Expression: MIN_LOCK_PERIOD = 2592000
		Expression: MAX_LOCK_PERIOD = 2 * 31536000
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_
	Modifier ReentrancyGuardExt.nonReentrant(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_6'])
EXPRESSION self.enter()
		Expression: self.enter()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.enter(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
_
EXPRESSION self.exit()
		Expression: self.exit()
		IRs:
			LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.exit(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard'])"] 
	Modifier ReentrancyGuardExt.nonReentrantView(ReentrancyGuardLib.Data)
ENTRY_POINT
		IRs:
			self_1 (-> ['_guard', '_guard'])(ReentrancyGuardLib.Data) := ϕ(['_guard_2', '_guard_4'])
IF self.check()
		Expression: self.check()
		IRs:
			TMP_6839(bool) = LIBRARY_CALL, dest:ReentrancyGuardLib, function:ReentrancyGuardLib.check(ReentrancyGuardLib.Data), arguments:["self_1 (-> ['_guard', '_guard'])"] 
			CONDITION TMP_6839
EXPRESSION ReentrancyGuardLib.ReentrantCall()
		Expression: ReentrancyGuardLib.ReentrantCall()
		IRs:
			TMP_6840(None) = SOLIDITY_CALL revert ReentrantCall()()
END_IF
_
Contract WhitelistRegistrySimple
	Function Ownable.constructor()
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_6841(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_6841)
	Function Ownable.owner()
		IRs:
			_owner_1(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: _owner
		IRs:
			RETURN _owner_1
	Function Ownable._checkOwner()
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_6843(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_6844(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_6845(bool) = TMP_6843 == TMP_6844
			TMP_6846(None) = SOLIDITY_CALL require(bool,string)(TMP_6845,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership()
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_6847 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_6847)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_6850 = CONVERT 0 to address
			TMP_6851(bool) = newOwner_1 != TMP_6850
			TMP_6852(None) = SOLIDITY_CALL require(bool,string)(TMP_6851,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address)
		IRs:
			newOwner_1(address) := ϕ(['TMP_6847', 'newOwner_1', 'TMP_6841'])
			_owner_2(address) := ϕ(['_owner_0', '_owner_3'])
		Expression: oldOwner = _owner
		IRs:
			oldOwner_1(address) := _owner_2(address)
		Expression: _owner = newOwner
		IRs:
			_owner_3(address) := newOwner_1(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner_1,newOwner_1)
	Function Context._msgSender()
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData()
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function WhitelistRegistrySimple.batchSetStatus(address[],bool[])
		Expression: length = addresses.length
		IRs:
			REF_1387 -> LENGTH addresses_1
			length_1(uint256) := REF_1387(uint256)
		Expression: length != statuses.length
		IRs:
			REF_1388 -> LENGTH statuses_1
			TMP_6856(bool) = length_1 != REF_1388
			CONDITION TMP_6856
		Expression: revert ArraysLengthsDoNotMatch()()
		IRs:
			TMP_6857(None) = SOLIDITY_CALL revert ArraysLengthsDoNotMatch()()
		Expression: i = 0
		IRs:
			i_1(uint256) := 0(uint256)
		Expression: i < length
		IRs:
			i_2(uint256) := ϕ(['i_3', 'i_1'])
			TMP_6858(bool) = i_2 < length_1
			CONDITION TMP_6858
		Expression: _setStatus(addresses[i],statuses[i])
		IRs:
			REF_1389(address) -> addresses_1[i_2]
			REF_1390(bool) -> statuses_1[i_2]
			INTERNAL_CALL, WhitelistRegistrySimple._setStatus(address,bool)(REF_1389,REF_1390)
		Expression: ++ i
		IRs:
			i_3(uint256) = i_2 (c)+ 1
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function WhitelistRegistrySimple.setStatus(address,bool)
		Expression: _setStatus(_address,_status)
		IRs:
			INTERNAL_CALL, WhitelistRegistrySimple._setStatus(address,bool)(_address_1,_status_1)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function WhitelistRegistrySimple._setStatus(address,bool)
		IRs:
			_address_1(address) := ϕ(['_address_1', 'REF_1389'])
			_status_1(bool) := ϕ(['REF_1390', '_status_1'])
			isWhitelisted_1(mapping(address => bool)) := ϕ(['isWhitelisted_2', 'isWhitelisted_0'])
		Expression: isWhitelisted[_address] == _status
		IRs:
			REF_1391(bool) -> isWhitelisted_1[_address_1]
			TMP_6863(bool) = REF_1391 == _status_1
			CONDITION TMP_6863
		Expression: revert SameStatus()()
		IRs:
			TMP_6864(None) = SOLIDITY_CALL revert SameStatus()()
		Expression: isWhitelisted[_address] = _status
		IRs:
			REF_1392(bool) -> isWhitelisted_1[_address_1]
			isWhitelisted_2(mapping(address => bool)) := ϕ(['isWhitelisted_1'])
			REF_1392(bool) (->isWhitelisted_2) := _status_1(bool)
		Expression: StatusUpdate(_address,_status)
		IRs:
			Emit StatusUpdate(_address_1,_status_1)
	Function WhitelistRegistrySimple.rescueFunds(IERC20,uint256)
		Expression: token.uniTransfer(address(msg.sender),amount)
		IRs:
			TMP_6866 = CONVERT msg.sender to address
			LIBRARY_CALL, dest:UniERC20, function:UniERC20.uniTransfer(IERC20,address,uint256), arguments:['token_1', 'TMP_6866', 'amount_1'] 
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Modifier Ownable.onlyOwner()
ENTRY_POINT
EXPRESSION _checkOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
_

INFO:Slither:../protocols/fusion-protocol/ analyzed (132 contracts)
